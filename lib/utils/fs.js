// Generated by CoffeeScript 1.4.0
var RE_IGNORE, cp, exists, existsSync, fs, mkdir, mkdirp, mv, path, readdir, rimraf, rm;

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

rimraf = require('rimraf');

exports.existsSync = existsSync = fs.existsSync || path.existsSync;

exports.exists = exists = fs.exists || path.exists;

RE_IGNORE = /^[\.~]|~$/;

exports.ignoredHidden = /^[\.~]|~$/;

exports.ignored = /^[\.~]|[-\.]min[-\.]|svn|~$/;

exports.indir = function(dir, filepath) {
  dir = path.resolve(dir);
  filepath = path.resolve(filepath);
  if (filepath.indexOf(dir) !== -1) {
    if (path.relative(dir, filepath).indexOf('..') !== -1) {
      return false;
    } else {
      return true;
    }
  } else {
    return false;
  }
};

exports.readdir = readdir = function(dir, ignore, fn) {
  var _files, _outstanding, _readdir;
  ignore = ignore ? new RegExp(exports.ignoredHidden.source + '|' + ignore.source) : exports.ignoredHidden;
  _outstanding = 0;
  _files = [];
  _readdir = function(dir) {
    _outstanding++;
    return fs.readdir(dir, function(err, files) {
      _outstanding--;
      if (err) {
        if (err.code === 'ENOENT') {

        } else {
          return fn(err);
        }
      } else {
        files.forEach(function(file) {
          var filepath;
          if (!ignore.test(path.basename(file))) {
            filepath = path.resolve(dir, file);
            _outstanding++;
            return fs.stat(filepath, function(err, stats) {
              _outstanding--;
              if (err) {
                if (err.code === 'ENOENT') {

                } else {
                  return fn(err);
                }
              } else {
                if (stats.isDirectory()) {
                  return _readdir(filepath);
                } else {
                  _files.push(filepath);
                  if (!_outstanding) {
                    return fn(null, _files);
                  }
                }
              }
            });
          }
        });
        if (!_outstanding) {
          return fn(null, _files);
        }
      }
    });
  };
  return _readdir(dir);
};

exports.mkdir = mkdir = function(filepath, fn) {
  var dir;
  dir = path.extname(filepath) ? path.dirname(filepath) : filepath;
  if (!existsSync(dir)) {
    return mkdirp(dir, function(err) {
      if (err) {
        return fn(err);
      } else {
        return fn();
      }
    });
  } else {
    return fn();
  }
};

exports.mv = mv = function(source, destination, fn) {
  return mkdir(destination, function(err) {
    var filepath;
    if (err) {
      return fn(err);
    } else {
      filepath = path.resolve(destination, path.basename(source));
      if (existsSync(filepath)) {
        return fn(null, filepath);
      } else {
        return fs.rename(source, filepath, function(err) {
          if (err) {
            return fn(err);
          } else {
            return fn(null, filepath);
          }
        });
      }
    }
  });
};

exports.cp = cp = function(source, destination, fn) {
  var _base, _cp, _filepath, _first, _outstanding;
  _outstanding = 0;
  _base = '';
  _filepath = '';
  _first = true;
  _cp = function(source, destination) {
    _outstanding++;
    fs.stat(source, function(err, stats) {
      var contentsOnly, dest, destDir, destName, file, filepath, isDestFile;
      _outstanding--;
      if (err) {
        if (err.code === 'ENOENT') {

        } else {
          return fn(err);
        }
      } else {
        isDestFile = path.extname(destination).length;
        if (stats.isFile()) {
          destDir = isDestFile ? path.dirname(destination) : destination;
          destName = isDestFile ? path.basename(destination) : path.basename(source);
          filepath = path.resolve(destDir, destName);
          if (existsSync(filepath)) {
            if (!_outstanding) {
              return fn(null, _filepath);
            }
          } else {
            _outstanding++;
            if (_first) {
              _filepath = filepath;
              _first = false;
            }
            fs.createReadStream(source).pipe(file = fs.createWriteStream(filepath));
            file.on('error', function(err) {
              return fn(err);
            });
            return file.on('close', function() {
              _outstanding--;
              if (!_outstanding) {
                return fn(null, _filepath);
              }
            });
          }
        } else {
          if (isDestFile) {
            return fn(new Error('invalid destination for copy: ' + destination));
          } else {
            contentsOnly = _first && /\\$|\/$/.test(source);
            dest = contentsOnly ? destination : path.resolve(destination, path.basename(source));
            _outstanding++;
            return mkdir(dest, function(err) {
              _outstanding--;
              if (err) {
                return fn(err);
              } else {
                _outstanding++;
                return fs.readdir(source, function(err, files) {
                  _outstanding--;
                  if (err) {
                    if (err.code === 'ENOENT') {

                    } else {
                      return fn(err);
                    }
                  } else {
                    if (_first) {
                      _filepath = dest;
                      _first = false;
                    }
                    files.forEach(function(file) {
                      return _cp(path.resolve(source, file), dest);
                    });
                    if (!_outstanding) {
                      return fn(null, _filepath);
                    }
                  }
                });
              }
            });
          }
        }
      }
    });
    if (!_outstanding) {
      return fn(null, _filepath);
    }
  };
  return _cp(source, destination);
};

exports.rm = rm = function(source, fn) {
  if (existsSync(source)) {
    if (source.indexOf(process.cwd()) !== -1) {
      return rimraf(source, function(err) {
        if (err) {
          return fn(err);
        } else {
          return fn();
        }
      });
    } else {
      return fn(new Error('cannot rm source outside of project path: ' + source));
    }
  } else {
    return fn(new Error('cannot rm non-existant source: ' + source));
  }
};
