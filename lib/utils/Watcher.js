// Generated by CoffeeScript 1.4.0
var THROTTLE_TIMEOUT, Watcher, events, existsSync, fs, path, readdir, wait, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

fs = require('fs');

path = require('path');

events = require('events');

_ref = require('./fs'), readdir = _ref.readdir, wait = _ref.wait, existsSync = _ref.existsSync;

THROTTLE_TIMEOUT = 100;

module.exports = Watcher = (function(_super) {

  __extends(Watcher, _super);

  function Watcher(ignore) {
    this.ignore = ignore != null ? ignore : /^\./;
    this.watchers = {};
    this._throttling = {
      create: false,
      'delete': false,
      change: false
    };
  }

  Watcher.prototype.watch = function(source) {
    var _this = this;
    if (!this.ignore.test(path.basename(source))) {
      return fs.stat(source, function(err, stats) {
        var lastChange;
        if (err) {
          return _this.emit('error', err);
        } else {
          lastChange = stats.mtime.getTime();
          if (stats.isDirectory()) {
            fs.readdir(source, function(err, files) {
              if (err) {
                return _this.emit('error', err);
              } else {
                return files.forEach(function(file) {
                  return _this.watch(path.resolve(source, file));
                });
              }
            });
          }
          return _this.watchers[source] = fs.watch(source, function(evt, filename) {
            if (existsSync(source)) {
              return fs.stat(source, function(err, stats) {
                if (err) {
                  return _this._throttleEvent('error', err);
                } else {
                  if (stats.isFile()) {
                    if (stats.mtime.getTime() !== lastChange) {
                      _this._throttleEvent('change', source, stats);
                    }
                    return lastChange = stats.mtime.getTime();
                  } else if (stats.isDirectory()) {
                    if (!_this.watchers[source]) {
                      _this._throttleEvent('create', source, stats);
                    }
                    return fs.readdir(source, function(err, files) {
                      if (err) {
                        return _this._throttleEvent('error', err);
                      } else {
                        return files.forEach(function(file) {
                          var item;
                          item = path.resolve(source, file);
                          if (!_this.ignore.test(path.basename(item)) && !_this.watchers[item]) {
                            return fs.stat(item, function(err, stats) {
                              _this._throttleEvent('create', item, stats);
                              return _this.watch(item);
                            });
                          }
                        });
                      }
                    });
                  }
                }
              });
            } else {
              _this.unwatch(source);
              return _this._throttleEvent('delete', source);
            }
          });
        }
      });
    }
  };

  Watcher.prototype.unwatch = function(source) {
    var watcher;
    if (watcher = this.watchers[source]) {
      delete this.watchers[source];
      try {
        return watcher.close();
      } catch (err) {

      }
    }
  };

  Watcher.prototype.clean = function() {
    var source, _results;
    _results = [];
    for (source in this.watchers) {
      _results.push(this.unwatch(source));
    }
    return _results;
  };

  Watcher.prototype._throttleEvent = function() {
    var props, type,
      _this = this;
    type = arguments[0], props = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!this._throttling[type]) {
      this._throttling[type] = true;
      this.emit.apply(this, [type].concat(props));
      return setTimeout((function() {
        return _this._throttling[type] = false;
      }), THROTTLE_TIMEOUT);
    }
  };

  return Watcher;

})(events.EventEmitter);
