// Generated by CoffeeScript 1.4.0
var Dependencies, RE_ID, bower, cat, cp, existsSync, fs, mkdir, mv, notify, path, rimraf, _ref;

path = require('path');

fs = require('fs');

bower = require('bower');

rimraf = require('rimraf');

_ref = require('./utils'), mv = _ref.mv, cp = _ref.cp, mkdir = _ref.mkdir, cat = _ref.cat, notify = _ref.notify;

existsSync = fs.existsSync || path.existsSync;

RE_ID = /\D\[\d{2}m([\w-_]+)\D\[\d{2}m$/;

module.exports = Dependencies = (function() {

  function Dependencies(options, compressor) {
    var data, destination, _ref1,
      _this = this;
    this.options = options;
    this.compressor = compressor;
    this.installIdx = 0;
    this.dependencies = [];
    _ref1 = this.options;
    for (destination in _ref1) {
      data = _ref1[destination];
      data.sources.forEach(function(source) {
        var id, items, local, sourcePath;
        if (/^[\.\/~]/.test(source)) {
          id = source;
          source = path.resolve(source);
          local = true;
        }
        if (/@/.test(source)) {
          items = source.split('@');
          source = items[0];
          sourcePath = items[1];
        }
        return _this.dependencies.push({
          destination: destination,
          source: source,
          sourcePath: sourcePath || '',
          output: data.output && path.resolve(data.output),
          local: local || false,
          id: id,
          filepath: ''
        });
      });
    }
  }

  Dependencies.prototype.install = function(fn) {
    var dependency, next,
      _this = this;
    next = function(dependency) {
      _this.installIdx++;
      _this._moveSource(dependency);
      return _this.install(fn);
    };
    if (dependency = this.dependencies[this.installIdx]) {
      if (dependency.local) {
        return next(dependency);
      } else {
        return bower.commands.install([dependency.source]).on('data', function(data) {
          var _ref1;
          if (/fetching/.test(data)) {
            return (_ref1 = dependency.id) != null ? _ref1 : dependency.id = RE_ID.exec(data)[1];
          }
        }).on('end', function() {
          return next(dependency);
        }).on('error', function(err) {
          return fn(err);
        });
      }
    } else {
      this.installIdx = 0;
      return this._resolveDependants(fn);
    }
  };

  Dependencies.prototype._moveSource = function(dependency) {
    var component, filepath;
    mkdir(path.resolve(dependency.destination));
    if (dependency.local) {
      filepath = dependency.source;
      cp(filepath, path.resolve(dependency.destination));
    } else {
      filepath = path.resolve(process.cwd(), 'components', dependency.id);
      component = JSON.parse(fs.readFileSync(path.resolve(filepath, 'component.json'), 'utf8'));
      filepath = path.resolve(filepath, dependency.sourcePath || component.main || '');
      dependency.filepath = path.resolve(process.cwd(), dependency.destination, path.basename(filepath));
      mv(filepath, path.resolve(dependency.destination));
    }
    return notify.print("" + (notify.colour('installed', notify.GREEN)) + " " + (notify.strong(dependency.id)) + " to " + (notify.strong(dependency.destination)), 3);
  };

  Dependencies.prototype._resolveDependants = function(fn) {
    var _this = this;
    return bower.commands.list({
      map: true
    }).on('data', function(data) {
      var depItem, dependant, dependency, item, props;
      for (item in data) {
        props = data[item];
        dependency = _this.dependencies.filter(function(d) {
          return d.id === item;
        })[0];
        if (props.dependencies) {
          for (depItem in props.dependencies) {
            dependant = {
              destination: dependency.destination,
              output: dependency.output,
              id: depItem
            };
            _this._moveSource(dependant);
            _this.dependencies.splice(_this.dependencies.indexOf(dependency), 0, dependant);
          }
        }
      }
      _this._clearCache();
      return _this._pack(fn);
    }).on('error', function(err) {
      return fn(err);
    });
  };

  Dependencies.prototype._clearCache = function() {
    return rimraf.sync(path.resolve('components'));
  };

  Dependencies.prototype._pack = function(fn) {
    var content, contents, files, output, outputable, outputs, _results;
    outputs = {};
    outputable = this.dependencies.filter(function(dependency) {
      return dependency.output;
    });
    if (outputable.length) {
      outputable.forEach(function(dependency) {
        var _name, _ref1;
        if ((_ref1 = outputs[_name = dependency.output]) == null) {
          outputs[_name] = [];
        }
        return outputs[dependency.output].push(dependency.filepath);
      });
      _results = [];
      for (output in outputs) {
        files = outputs[output];
        contents = [];
        files.forEach(function(file) {
          return contents.push(fs.readFileSync(file));
        });
        content = contents.join('\n');
        mkdir(output);
        _results.push(this.compressor.compress(content, function(err, content) {
          if (err) {
            return fn(err);
          } else {
            notify.print("" + (notify.colour('compressed', notify.GREEN)) + " " + (notify.strong(path.basename(output))), 3);
            fs.writeFileSync(output, content);
            return fn(null);
          }
        }));
      }
      return _results;
    } else {
      return fn(null);
    }
  };

  return Dependencies;

})();
