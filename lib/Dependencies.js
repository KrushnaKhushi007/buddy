// Generated by CoffeeScript 1.4.0
var Dependencies, Dependency, RE_FETCHING, RE_GITHUB_PROJECT, RE_GITHUB_URL, RE_ID, RE_LOCAL, RE_PACKAGE_NOT_FOUND, RE_SOURCE_OVERRIDE, RE_VERSION, cp, existsSync, fs, mkdir, mv, notify, path, rm, _ref;

path = require('path');

fs = require('fs');

Dependency = require('./dependency');

_ref = require('./utils'), rm = _ref.rm, mv = _ref.mv, cp = _ref.cp, mkdir = _ref.mkdir, notify = _ref.notify;

existsSync = fs.existsSync || path.existsSync;

RE_GITHUB_PROJECT = /\w+\/\w+/;

RE_GITHUB_URL = /git:\/\/(.*)\.git/;

RE_PACKAGE_NOT_FOUND = /was not found/;

RE_VERSION = /@/;

RE_SOURCE_OVERRIDE = /#/;

RE_ID = /\D\[\d{2}m([\w-_\.]+)\D\[\d{2}m$/;

RE_LOCAL = /^[\.\/~]/;

RE_FETCHING = /fetching/;

module.exports = Dependencies = (function() {

  function Dependencies(options, compressor) {
    var data, destination, _ref1,
      _this = this;
    this.options = options;
    this.compressor = compressor;
    this.installIdx = 0;
    this.dependencies = [];
    this.files = [];
    this.temp = path.resolve('.tmp');
    _ref1 = this.options;
    for (destination in _ref1) {
      data = _ref1[destination];
      data.sources.forEach(function(source) {
        return _this.dependencies.push(new Dependency(source, destination, data.output));
      });
    }
  }

  Dependencies.prototype.install = function(fn) {
    var _this = this;
    mkdir(this.temp);
    return this.dependencies.forEach(function(dependency) {
      if (dependency.local) {
        return _this._move(dependency);
      } else {
        if (!dependency.url) {
          return _this._lookupPackage(dependency, function(err) {
            if (err) {
              return fn(err);
            } else {
              return _this._fetch(dependency, temp, function(err) {
                if (err) {
                  return fn(err);
                } else {
                  return _this._parseSources(dependency, function(err) {});
                }
              });
            }
          });
        } else {
          return _this._fetch(dependency, temp, function(err) {
            if (err) {
              return fn(err);
            } else {
              return _this._parseSources(dependency, function(err) {});
            }
          });
        }
      }
    });
  };

  Dependencies.prototype.clean = function(fn) {
    return bower.commands['cache-clean']().on('end', function() {
      return fn();
    }).on('error', function(err) {
      return fn(err);
    });
  };

  Dependencies.prototype._moveSource = function(dependency) {
    var component, filepath;
    mkdir(path.resolve(dependency.destination));
    if (dependency.local) {
      dependency.filepath = path.resolve(dependency.destination, path.basename(dependency.source));
      cp(dependency.source, path.resolve(dependency.destination));
    } else {
      filepath = path.resolve('components', dependency.id);
      component = JSON.parse(fs.readFileSync(path.resolve(filepath, 'component.json'), 'utf8'));
      filepath = path.resolve(filepath, dependency.sourcePath || component.main || '');
      dependency.filepath = path.resolve(dependency.destination, path.basename(filepath));
      mv(filepath, path.resolve(dependency.destination));
    }
    if (!dependency.keep) {
      this.files.push(dependency.filepath);
    }
    return notify.print("" + (notify.colour('installed', notify.GREEN)) + " " + (notify.strong(dependency.id)) + " to " + (notify.strong(dependency.destination)), 3);
  };

  Dependencies.prototype._resolveDependants = function(fn) {
    var _this = this;
    return bower.commands.list({
      map: true
    }).on('data', function(data) {
      var depItem, dependant, dependency, item, props;
      for (item in data) {
        props = data[item];
        if (dependency = _this.dependencies.filter(function(d) {
          return d.id === item;
        })[0]) {
          if (props.dependencies) {
            for (depItem in props.dependencies) {
              dependant = {
                destination: dependency.destination,
                output: dependency.output,
                id: depItem
              };
              _this._moveSource(dependant);
              _this.dependencies.splice(_this.dependencies.indexOf(dependency), 0, dependant);
            }
          }
        }
      }
      _this._clearCache();
      return _this._pack(fn);
    }).on('error', function(err) {
      return fn(err);
    });
  };

  Dependencies.prototype._clearCache = function() {
    return rm(path.resolve('components'));
  };

  Dependencies.prototype._pack = function(fn) {
    var content, contents, files, i, n, output, outputable, outputs, _results,
      _this = this;
    outputs = {};
    outputable = this.dependencies.filter(function(dependency) {
      return dependency.output;
    });
    if (outputable.length) {
      outputable.forEach(function(dependency) {
        var _name, _ref1;
        if ((_ref1 = outputs[_name = dependency.output]) == null) {
          outputs[_name] = [];
        }
        return outputs[dependency.output].push(dependency.filepath);
      });
      n = Object.keys(outputs).length;
      i = 0;
      _results = [];
      for (output in outputs) {
        files = outputs[output];
        contents = files.map(function(file) {
          return fs.readFileSync(file);
        });
        content = contents.join('\n');
        mkdir(output);
        _results.push(this.compressor.compress(content, function(err, content) {
          if (err) {
            return fn(err, _this.files);
          } else {
            notify.print("" + (notify.colour('compressed', notify.GREEN)) + " " + (notify.strong(path.relative(output))), 3);
            fs.writeFileSync(output, content);
            _this.files.push(output);
            if (++i === n) {
              return fn(null, _this.files);
            }
          }
        }));
      }
      return _results;
    } else {
      return fn(null, this.files);
    }
  };

  return Dependencies;

})();
