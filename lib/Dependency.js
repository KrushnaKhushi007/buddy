// Generated by CoffeeScript 1.4.0
var Dependency, RE_GITHUB_PROJECT, RE_GITHUB_URL, RE_INDEX, RE_PACKAGE_NOT_FOUND, RE_VALID_VERSION, bower, cp, events, existsSync, fs, http, mkdir, mv, notify, path, request, rm, semver, unzip, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

path = require('path');

fs = require('fs');

events = require('events');

bower = require('bower');

request = require('superagent');

http = require('http');

unzip = require('unzip');

semver = require('semver');

_ref = require('./utils'), rm = _ref.rm, mv = _ref.mv, cp = _ref.cp, mkdir = _ref.mkdir, notify = _ref.notify, existsSync = _ref.existsSync;

RE_GITHUB_PROJECT = /\w+\/\w+/;

RE_GITHUB_URL = /git:\/\/(.*)\.git/;

RE_PACKAGE_NOT_FOUND = /was not found/;

RE_INDEX = /^index(?:\.js$)?/;

RE_VALID_VERSION = /^\d+\.\d+\.\d+$|^master$/;

module.exports = Dependency = (function(_super) {

  __extends(Dependency, _super);

  function Dependency(source, destination, output) {
    var _ref1;
    this.local = false;
    this.keep = false;
    this.id = source;
    this.name = source;
    this.url = null;
    this.version = 'master';
    this.location = null;
    this.resources = null;
    this.files = [];
    this.destination = path.resolve(destination);
    this.output = output && path.resolve(output);
    source = source.split('#');
    if (source[1]) {
      this.resources = source[1].split('|');
    }
    if (existsSync(path.resolve(source[0]))) {
      this.local = true;
      this.location = path.resolve(source[0]);
      if ((_ref1 = this.resources) == null) {
        this.resources = [this.location];
      }
      this.keep = this.location.indexOf(path.resolve(this.destination)) !== -1;
    } else {
      source = source[0].split('@');
      if (source[1]) {
        this.version = source[1];
      }
      this.id = this.name = source[0];
      if (RE_GITHUB_PROJECT.test(this.name)) {
        this.url = "https://github.com/" + this.name + "/archive/" + this.version + ".zip";
        this.id = this.name.split('/')[1];
      }
    }
  }

  Dependency.prototype.install = function(temp) {
    if (this.local) {
      return this.move();
    } else {
      return this.lookupPackage().once('end:lookup', function() {
        return this.validateVersion().once('end:validate', function() {
          return this.fetch(temp).once('end:fetch', function() {
            return this.resolveResources().once('end:resolve', function() {
              return this.move();
            });
          });
        });
      });
    }
  };

  Dependency.prototype.lookupPackage = function() {
    var _this = this;
    if (!this.url) {
      bower.commands.lookup(this.id).on('error', function() {
        return _this.emit('error', 'no package found for:' + _this.id);
      }).on('data', function(data) {
        var url;
        if (RE_PACKAGE_NOT_FOUND.test(data)) {
          return _this.emit('error', 'no package found for:' + _this.id);
        } else {
          url = RE_GITHUB_URL.exec(data)[1];
          _this.name = url.replace('github.com/', '');
          _this.url = "https://" + url + "/archive/" + _this.version + ".zip";
          return _this.emit('end:lookup', _this);
        }
      });
    } else {
      process.nextTick(function() {
        return _this.emit('end:lookup', _this);
      });
    }
    return this;
  };

  Dependency.prototype.validateVersion = function() {
    var req,
      _this = this;
    if (!RE_VALID_VERSION.test(this.version)) {
      req = request.get("https://api.github.com/repos/" + this.name + "/tags");
      req.end(function(err, res) {
        var json, version, _i, _len;
        if (err || res.error) {
          return _this.emit('error', 'fetching tags for: ' + _this.name + ' failed with error code: ' + http.STATUS_CODES[res.status]);
        } else {
          try {
            json = JSON.parse(res.text);
          } catch (err) {
            _this.emit('error', 'parsing tag information for: ' + _this.name);
          }
          json.sort(function(a, b) {
            return semver.rcompare(a.name, b.name);
          });
          if (_this.version === '*' || _this.version === 'latest') {
            _this.version = json[0].name;
            _this.url = json[0].zipball_url;
          } else {
            for (_i = 0, _len = json.length; _i < _len; _i++) {
              version = json[_i];
              if (semver.satisfies(version.name, _this.version)) {
                _this.version = version.name;
                _this.url = version.zipball_url;
                break;
              }
            }
          }
          return _this.emit('end:validate', _this);
        }
      });
    } else {
      process.nextTick(function() {
        return _this.emit('end:validate', _this);
      });
    }
    return this;
  };

  Dependency.prototype.fetch = function(temp) {
    var filename, req,
      _this = this;
    filename = temp + path.sep + this.id + '-' + this.version + '.zip';
    req = request.get(this.url).buffer(false);
    req.end(function(err, res) {
      if (err || res.error) {
        return _this.emit('error', 'fetching ' + _this.url + ' failed with error code: ' + http.STATUS_CODES[res.status]);
      } else {
        res.pipe(fs.createWriteStream(filename));
        return res.on('end', function() {
          return fs.createReadStream(filename).pipe(unzip.Extract({
            path: temp
          })).on('error', function() {
            return _this.emit('error', 'unzipping archive: ' + filename);
          }).on('close', function() {
            _this.location = filename.replace(path.extname(filename), '');
            return _this.emit('end:fetch', _this);
          });
        });
      }
    });
    return this;
  };

  Dependency.prototype.resolveResources = function() {
    var add, config, dependency, json, temp, version, _ref1,
      _this = this;
    add = function(filename) {
      var filepath, newname;
      if (RE_INDEX.test(filename)) {
        if (!path.extname(filename)) {
          filename += '.js';
        }
        newname = _this.id + '.js';
        cp(path.resolve(_this.location, filename), path.resolve(_this.location, newname));
        filename = newname;
      }
      filepath = path.resolve(_this.location, filename);
      if (existsSync(filepath)) {
        return _this.resources.push(filepath);
      }
    };
    if (this.resources) {
      temp = this.resources.concat();
      this.resources = [];
      temp.forEach(function(filename) {
        return add(filename);
      });
    } else {
      this.resources = [];
      if (existsSync(path.resolve(this.location, 'component.json'))) {
        config = 'component.json';
      } else if (existsSync(path.resolve(this.location, 'package.json'))) {
        config = 'package.json';
      } else {
        return this.emit('error', 'no config (component/package).json file found for: ' + this.id);
      }
      try {
        json = JSON.parse(fs.readFileSync(path.resolve(this.location, config), 'utf8'));
      } catch (err) {
        return this.emit('error', 'parsing: ' + this.id + config);
      }
      if (json.dependencies) {
        _ref1 = json.dependencies;
        for (dependency in _ref1) {
          version = _ref1[dependency];
          process.nextTick(function() {
            return _this.emit('dependency', "" + dependency + "@" + version);
          });
        }
      }
      if (json.scripts) {
        json.scripts.forEach(function(filename) {
          return add(filename);
        });
      } else if (json.main) {
        add(json.main);
      } else {
        return this.emit('error', 'unable to resolve resources for: ' + this.id);
      }
    }
    process.nextTick(function() {
      return _this.emit('end:resolve', _this);
    });
    return this;
  };

  Dependency.prototype.move = function() {
    var _this = this;
    if (!this.keep) {
      this.resources.forEach(function(resource, idx) {
        var filename;
        filename = _this.local ? cp(resource, _this.destination) : mv(resource, _this.destination);
        _this.files.push(path.relative(process.cwd(), filename));
        return _this.resources[idx] = filename;
      });
    }
    process.nextTick(function() {
      return _this.emit('end', _this);
    });
    return this;
  };

  Dependency.prototype.destroy = function() {
    return this.removeAllListeners();
  };

  return Dependency;

})(events.EventEmitter);
