// Generated by CoffeeScript 1.4.0
var Target, existsSync, fs, notify, path,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

notify = require('./utils').notify;

existsSync = fs.existsSync || path.existsSync;

module.exports = Target = (function() {

  function Target(type, input, output, fileCache, options) {
    this.type = type;
    this.input = input;
    this.output = output;
    this.fileCache = fileCache;
    this.options = options;
    this.sources = [];
    this.files = [];
    this.concat = false;
    this.watching = false;
    if (!path.extname(this.output).length && fs.statSync(this.input).isFile()) {
      this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), "." + this.type);
    }
  }

  Target.prototype.run = function(compress, lint, fn) {
    this.sources = [];
    this.files = [];
    this._parseSources(this.input);
    if (this.sources.length) {
      if (!this.watching) {
        notify.print("building " + (notify.strong(path.basename(this.input))) + " to " + (notify.strong(path.basename(this.output))), 2);
      }
      return this._build(compress, lint, fn);
    } else {
      notify.warn("no sources to build in " + (notify.strong(this.input)), 2);
      return fn();
    }
  };

  Target.prototype.hasSource = function(file) {
    return __indexOf.call(this.sources, file) >= 0;
  };

  Target.prototype._parseSources = function(input) {
    var file,
      _this = this;
    if (fs.statSync(input).isFile()) {
      if (file = this.fileCache.byPath[input]) {
        file.parseContents(this.options.modular);
        return this._addSource(file);
      }
    } else {
      return fs.readdirSync(input).forEach(function(item) {
        return _this._parseSources(path.join(input, item));
      });
    }
  };

  Target.prototype._addSource = function(file) {
    if (__indexOf.call(this.sources, file) < 0) {
      return this.sources.push(file);
    }
  };

  Target.prototype._lint = function(content, filepath) {
    var _this = this;
    if (this.options.linter != null) {
      return this.options.linter.lint(content, function(err) {
        if (err) {
          notify.warn('failed linting', 4);
          return err.items.forEach(function(item) {
            return notify.print("[" + item.line + ":" + item.col + "] " + item.reason, 5);
          });
        } else {
          return notify.print("" + (notify.colour('passed linting', notify.GREEN)) + " " + (notify.strong(path.basename(filepath))), 4);
        }
      });
    }
  };

  Target.prototype._compress = function(content, filepath, fn) {
    var _this = this;
    if (this.options.compressor != null) {
      return this.options.compressor.compress(content, function(err, content) {
        if (err) {
          return fn(err);
        } else {
          notify.print("" + (notify.colour('compressed', notify.GREEN)) + " " + (notify.strong(path.basename(filepath))), 3);
          return fn(null, content);
        }
      });
    }
  };

  return Target;

})();
