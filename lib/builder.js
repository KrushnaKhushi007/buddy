// Generated by CoffeeScript 1.4.0
var Builder, CSS, CSSFile, CSSTarget, Configuration, Depedencies, Filelog, HTML, JS, JSFile, JSTarget, RE_IGNORE_FILE, Watcher, existsSync, fs, notify, path, plugins, readdir, rimraf, _ref;

fs = require('fs');

path = require('path');

Configuration = require('./configuration');

plugins = require('./plugins');

Depedencies = require('./dependencies');

Filelog = require('./filelog');

Watcher = require('./watcher');

JSFile = require('./jsfile');

CSSFile = require('./cssfile');

JSTarget = require('./jstarget');

CSSTarget = require('./csstarget');

rimraf = require('rimraf');

_ref = require('./utils'), notify = _ref.notify, readdir = _ref.readdir;

existsSync = fs.existsSync || path.existsSync;

RE_IGNORE_FILE = /^[\._~]|[-\.]min[-\.]|svn$/;

JS = 'js';

CSS = 'css';

HTML = 'html';

module.exports = Builder = (function() {

  function Builder() {
    this.config = null;
    this.plugins = null;
    this.dependencies = null;
    this.filelog = null;
    this.watchers = [];
    this.jsSources = {
      locations: [],
      byPath: {},
      byModule: {},
      count: 0
    };
    this.cssSources = {
      locations: [],
      byPath: {},
      count: 0
    };
    this.htmlSources = {
      locations: [],
      byPath: {},
      count: 0
    };
    this.jsTargets = [];
    this.cssTargets = [];
    this.htmlTargets = [];
  }

  Builder.prototype.initialize = function(configpath) {
    if (!this.initialized) {
      this.config = new Configuration(configpath);
      this.config.locate().load();
      this.plugins = plugins.load(this.config.settings && this.config.settings.plugins);
      if (this.config.dependencies) {
        this.dependencies = new Depedencies(this.config.dependencies, this.plugins.js.compressor);
      }
      this.filelog = new Filelog;
      this.initialized = true;
    }
    return this;
  };

  Builder.prototype.install = function() {
    var _this = this;
    if (this.dependencies) {
      notify.print('installing dependencies...', 2);
      return this.dependencies.install(function(err, files) {
        files && _this.filelog.add(files);
        return err && notify.error(err, 2);
      });
    } else {
      return notify.error('no dependencies specified in configuration file');
    }
  };

  Builder.prototype.build = function(compress, lint) {
    var _this = this;
    return [JS, CSS].forEach(function(type) {
      if (_this._validBuildType(type)) {
        _this.config.build[type].sources.forEach(function(source) {
          return _this._parseSourceDirectory(path.resolve(process.cwd(), source), null, _this[type + 'Sources']);
        });
        _this._parseTargets(_this.config.build[type].targets, type);
        return _this[type + 'Targets'].forEach(function(target) {
          return target.run(compress, lint, function(err, files) {
            files && _this.filelog.add(files);
            return err && notify.error(err, 2);
          });
        });
      }
    });
  };

  Builder.prototype.watch = function(compress, lint) {
    var _this = this;
    this.build(compress, lint);
    return [JS, CSS].forEach(function(type) {
      notify.print("watching [" + (notify.strong(_this.config.build[type].sources.join(', '))) + "]...", 2);
      return _this[type + 'Sources'].locations.forEach(function(source) {
        return _this.watchers.push(new Watcher(source, RE_IGNORE_FILE, _this._changed));
      });
    });
  };

  Builder.prototype._changed = function(err, data) {};

  Builder.prototype.deploy = function() {
    return this.build(true, false);
  };

  Builder.prototype.clean = function() {
    var _ref1,
      _this = this;
    notify.print('cleaning files...', 2);
    this.filelog.files.forEach(function(file) {
      notify.print("" + (notify.colour('deleted', notify.GREEN)) + " " + (notify.strong(path.relative(process.cwd(), file))), 3);
      return rimraf.sync(file);
    });
    this.filelog.clean();
    return (_ref1 = this.dependencies) != null ? _ref1.clean(function(err) {
      return err && notify.error(err, 2);
    }) : void 0;
  };

  Builder.prototype._validSource = function(type, filename) {
    var compiler, extension, name, _ref1;
    extension = path.extname(filename).slice(1);
    if (extension === type) {
      return true;
    }
    _ref1 = this.plugins[type].compilers;
    for (name in _ref1) {
      compiler = _ref1[name];
      if (extension === compiler.extension) {
        return true;
      }
    }
    return false;
  };

  Builder.prototype._validBuildType = function(type) {
    var _ref1;
    return (((_ref1 = this.config.build[type]) != null ? _ref1.sources : void 0) != null) && this.config.build[type].sources.length >= 1 && (this.config.build[type].targets != null) && this.config.build[type].targets.length >= 1;
  };

  Builder.prototype._parseSourceDirectory = function(dir, root, cache) {
    var _this = this;
    if (!root) {
      cache.locations.push(root = dir);
    }
    return readdir(dir, RE_IGNORE_FILE).forEach(function(item) {
      var f;
      if (f = _this._fileFactory(path.resolve(dir, item), root)) {
        cache.count++;
        if (f.moduleId != null) {
          cache.byModule[f.moduleId] = f;
        }
        return cache.byPath[f.filepath] = f;
      }
    });
  };

  Builder.prototype._fileFactory = function(filepath, base) {
    if (this._validSource(JS, filepath)) {
      return new JSFile(filepath, base, this.plugins[JS].compilers, this.plugins[JS].module);
    } else if (this._validSource(CSS, filepath)) {
      return new CSSFile(filepath, base, this.plugins[CSS].compilers);
    } else {
      return null;
    }
  };

  Builder.prototype._parseTargets = function(targets, type, parentTarget) {
    var _this = this;
    if (parentTarget == null) {
      parentTarget = null;
    }
    return targets.forEach(function(item) {
      var target;
      item.parent = parentTarget;
      if (target = _this._targetFactory(type, item)) {
        _this[type + 'Targets'].push(target);
        if (item.targets) {
          return _this._parseTargets(item.targets, type, target);
        }
      }
    });
  };

  Builder.prototype._targetFactory = function(type, props) {
    var dir, inSources, inputpath, location, options, outputpath, _i, _len, _ref1;
    inputpath = path.resolve(props.input);
    outputpath = path.resolve(props.output);
    if (!existsSync(inputpath)) {
      notify.error("" + (notify.strong(props.input)) + " not found in project path", 2);
      return null;
    }
    _ref1 = this[type + 'Sources'].locations;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      location = _ref1[_i];
      dir = fs.statSync(inputpath).isDirectory() ? inputpath : path.dirname(inputpath);
      inSources = dir.indexOf(location) >= 0;
      if (inSources) {
        break;
      }
    }
    if (!inSources) {
      notify.error("" + (notify.strong(props.input)) + " not found in source path", 2);
      return null;
    }
    if (fs.statSync(inputpath).isDirectory() && path.extname(outputpath).length) {
      notify.error("a file (" + (notify.strong(props.output)) + ") is not a valid output target for a directory (" + (notify.strong(props.input)) + ") input target", 2);
      return null;
    }
    options = {
      compressor: this.plugins[type].compressor,
      linter: this.plugins[type].linter
    };
    if (type === JS) {
      options.modular = props.modular != null ? props.modular : true;
      options.module = this.plugins.js.module;
      options.parent = props.parent;
      return new JSTarget(inputpath, outputpath, this[type + 'Sources'], options);
    } else if (type === CSS) {
      return new CSSTarget(inputpath, outputpath, this[type + 'Sources'], options);
    }
  };

  return Builder;

})();

/*
	watch: (compress, lint) ->
		# @build(compress, lint)
		# console.log(@jsSources.count, @cssSources.count)

		# for type in [@JS, @CSS]
		# 	notify.print("watching for changes in #{notify.strong('['+@config.build[type].sources.join(', ')+']')}...", 2)
		# 	for s in @[type + 'Sources'].locations
		# 		watcher = chokidar.watch(s, {ignored: @RE_IGNORE_FILE, persistent: true})
		# 		watcher.on('add', @_onWatchAdd)
		# 		watcher.on('change', @_onWatchChange)
		# 		watcher.on('unlink', @_onWatchUnlink)
		# 		@watchers.push(watcher)

	_onWatchAdd: (filepath) =>
		unless (@jsSources.byPath[filepath] or @cssSources.byPath[filepath]) and not path.basename(filepath).match(RE_IGNORE_FILE)
			# Find base source directory
			for loc in @jsSources.locations.concat(@cssSources.locations)
				# Create file instance and store
				if filepath.indexOf(loc) is 0 and f = @_fileFactory(filepath, loc)
					cache = @[f.type + 'Sources']
					cache.count++
					cache.byModule[f.moduleId] = f if f.moduleId?
					cache.byPath[f.filepath] = f
					console.log('add', filepath, cache.count, path.basename(filepath).match(RE_IGNORE_FILE))
					return
		# notify.print("[#{new Date().toLocaleTimeString()}] change detected in #{notify.strong(path)}", 0)

	_onWatchChange: (filepath) =>
		# notify.print("[#{new Date().toLocaleTimeString()}] change detected in #{notify.strong(path)}", 0)

	_onWatchUnlink: (filepath) =>
		# notify.print("[#{new Date().toLocaleTimeString()}] change detected in #{notify.strong(path)}", 0)

	_watchFile: (file, compress) ->
		# Store initial time and size
		stat = fs.statSync(file.filepath)
		file.lastChange = +stat.mtime
		file.lastSize = stat.size
		watcher = fs.watch file.filepath, callback = (event) =>
			# Clear old and create new on rename
			if event is 'rename'
				watcher.close()
				try	 # if source no longer exists, never mind
					watcher = fs.watch(file.filepath, callback)
			if event is 'change'
				# Compare time to the last second
				# This should prevent double watch execusion bug
				nstat = fs.statSync(file.filepath)
				last = +nstat.mtime / 1000
				if last isnt file.lastChange
					# Store new time
					file.lastChange = last
					term.out("[#{new Date().toLocaleTimeString()}] change detected in #{term.colour(file.filename, term.GREY)}", 0)
					# Update contents
					file.updateContents(fs.readFileSync(file.filepath, 'utf8'))
					# TODO: re-initialize targets
					@compile(compress, [file.type])
*/

