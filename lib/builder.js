// Generated by CoffeeScript 1.4.0
var Builder, CSS, CSSFile, CSSTarget, Configuration, Depedencies, Filelog, HTML, JS, JSFile, JSTarget, RE_IGNORE_FILE, RE_WATCH_IGNORE_FILE, Watcher, existsSync, fs, notify, path, plugins, readdir, rm, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

Configuration = require('./configuration');

plugins = require('./plugins');

Depedencies = require('./dependencies');

Watcher = require('./watcher');

Filelog = require('./filelog');

JSFile = require('./jsfile');

CSSFile = require('./cssfile');

JSTarget = require('./jstarget');

CSSTarget = require('./csstarget');

_ref = require('./utils'), notify = _ref.notify, readdir = _ref.readdir, rm = _ref.rm, existsSync = _ref.existsSync;

RE_IGNORE_FILE = /^[\._~]|[-\.]min[-\.]|svn|~$/;

RE_WATCH_IGNORE_FILE = /^[\.~]|[-\.]min[-\.]|svn|~$/;

JS = 'js';

CSS = 'css';

HTML = 'html';

module.exports = Builder = (function() {

  function Builder() {
    this._onWatchDelete = __bind(this._onWatchDelete, this);

    this._onWatchChange = __bind(this._onWatchChange, this);

    this._onWatchCreate = __bind(this._onWatchCreate, this);
    this.config = null;
    this.plugins = null;
    this.dependencies = null;
    this.filelog = null;
    this.compress = false;
    this.lint = false;
    this.watching = false;
    this.watchers = [];
    this.jsSources = {
      locations: [],
      byPath: {},
      byModule: {},
      count: 0
    };
    this.cssSources = {
      locations: [],
      byPath: {},
      count: 0
    };
    this.htmlSources = {
      locations: [],
      byPath: {},
      count: 0
    };
    this.jsTargets = [];
    this.cssTargets = [];
    this.htmlTargets = [];
  }

  Builder.prototype.initialize = function(configpath) {
    if (!this.initialized) {
      this.config = new Configuration(configpath);
      this.config.locate().load();
      this.plugins = plugins.load(this.config.settings && this.config.settings.plugins);
      if (this.config.dependencies) {
        this.dependencies = new Depedencies(this.config.dependencies, this.plugins.js.compressor);
      }
      this.filelog = new Filelog;
      this.initialized = true;
    }
    return this;
  };

  Builder.prototype.install = function() {
    var _this = this;
    if (this.dependencies) {
      notify.print('installing dependencies...', 2);
      return this.dependencies.install(function(err, files) {
        files && _this.filelog.add(files);
        return err && notify.error(err, 2);
      });
    } else {
      return notify.error('no dependencies specified in configuration file');
    }
  };

  Builder.prototype.build = function(compress, lint) {
    var _this = this;
    return [JS, CSS].forEach(function(type) {
      if (_this._validBuildType(type)) {
        _this.config.build[type].sources.forEach(function(source) {
          return _this._parseSourceDirectory(path.resolve(source), null, _this[type + 'Sources']);
        });
        _this._parseTargets(_this.config.build[type].targets, type);
        return _this[type + 'Targets'].forEach(function(target) {
          return _this._runTarget(target, compress, lint);
        });
      }
    });
  };

  Builder.prototype.watch = function(compress) {
    var _this = this;
    this.compress = compress;
    this.build(this.compress, false);
    this.watching = true;
    return [JS, CSS].forEach(function(type) {
      if (_this[type + 'Sources'].count) {
        notify.print("watching [" + (notify.strong(_this.config.build[type].sources.join(', '))) + "]...", 2);
        return _this[type + 'Sources'].locations.forEach(function(source) {
          var watcher;
          _this.watchers.push(watcher = new Watcher(RE_WATCH_IGNORE_FILE));
          watcher.on('create', _this._onWatchCreate);
          watcher.on('change', _this._onWatchChange);
          watcher.on('delete', _this._onWatchDelete);
          return watcher.watch(source);
        });
      }
    });
  };

  Builder.prototype.deploy = function() {
    return this.build(true, false);
  };

  Builder.prototype.clean = function() {
    if (this.filelog.files.length) {
      notify.print('cleaning files...', 2);
      this.filelog.files.forEach(function(file) {
        notify.print("" + (notify.colour('deleted', notify.RED)) + " " + (notify.strong(file)), 3);
        return rm(path.resolve(file));
      });
      return this.filelog.clean();
    } else {
      return notify.print('no files to clean', 2);
    }
  };

  Builder.prototype._validFileType = function(type, filename) {
    var compiler, extension, name, _ref1;
    extension = path.extname(filename).slice(1);
    if (extension === type) {
      return true;
    }
    _ref1 = this.plugins[type].compilers;
    for (name in _ref1) {
      compiler = _ref1[name];
      if (extension === compiler.extension) {
        return true;
      }
    }
    return false;
  };

  Builder.prototype._validBuildType = function(type) {
    var _ref1;
    return (((_ref1 = this.config.build[type]) != null ? _ref1.sources : void 0) != null) && this.config.build[type].sources.length >= 1 && (this.config.build[type].targets != null) && this.config.build[type].targets.length >= 1;
  };

  Builder.prototype._getFileType = function(filename) {
    var compiler, extension, name, type, _i, _len, _ref1, _ref2;
    extension = path.extname(filename).slice(1);
    _ref1 = [JS, CSS];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      type = _ref1[_i];
      if (extension === type) {
        return type;
      }
      _ref2 = this.plugins[type].compilers;
      for (name in _ref2) {
        compiler = _ref2[name];
        if (extension === compiler.extension) {
          return type;
        }
      }
    }
    return '';
  };

  Builder.prototype._getSourceLocation = function(filename, type) {
    var source, _i, _len, _ref1;
    _ref1 = this[type + 'Sources'].locations;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      source = _ref1[_i];
      if (filename.indexOf(source) !== -1) {
        return source;
      }
    }
    return '';
  };

  Builder.prototype._parseSourceDirectory = function(dir, root, cache) {
    var _this = this;
    if (!root) {
      cache.locations.push(root = dir);
    }
    return readdir(dir, RE_IGNORE_FILE).forEach(function(item) {
      var file;
      if (file = _this._fileFactory(path.resolve(dir, item), root)) {
        return _this._cacheFile(file, cache);
      }
    });
  };

  Builder.prototype._fileFactory = function(filepath, base) {
    if (this._validFileType(JS, filepath)) {
      return new JSFile(filepath, base, this.plugins[JS].compilers, this.plugins[JS].module);
    } else if (this._validFileType(CSS, filepath)) {
      return new CSSFile(filepath, base, this.plugins[CSS].compilers);
    } else {
      return null;
    }
  };

  Builder.prototype._cacheFile = function(file, cache) {
    if (!cache.byPath[file.filepath]) {
      cache.count++;
      if (cache.byModule) {
        cache.byModule[file.moduleId] = file;
      }
      return cache.byPath[file.filepath] = file;
    }
  };

  Builder.prototype._uncacheFile = function(file, cache) {
    cache.count--;
    if (file.moduleId) {
      delete cache.byModule[file.moduleId];
    }
    delete cache.byPath[file.filepath];
    return file.destroy();
  };

  Builder.prototype._parseTargets = function(targets, type, parentTarget) {
    var _this = this;
    if (parentTarget == null) {
      parentTarget = null;
    }
    return targets.forEach(function(item) {
      var target;
      item.parent = parentTarget;
      if (target = _this._targetFactory(type, item)) {
        _this[type + 'Targets'].push(target);
        if (item.targets) {
          return _this._parseTargets(item.targets, type, target);
        }
      }
    });
  };

  Builder.prototype._targetFactory = function(type, props) {
    var dir, inSources, inputpath, isDir, location, options, outputpath, _i, _len, _ref1;
    inputpath = path.resolve(props.input);
    outputpath = path.resolve(props.output);
    if (!existsSync(inputpath)) {
      notify.error("" + (notify.strong(props.input)) + " not found in project path", 2);
      return null;
    }
    isDir = fs.statSync(inputpath).isDirectory();
    _ref1 = this[type + 'Sources'].locations;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      location = _ref1[_i];
      dir = isDir ? inputpath : path.dirname(inputpath);
      inSources = dir.indexOf(location) >= 0;
      if (inSources) {
        break;
      }
    }
    if (!inSources) {
      notify.error("" + (notify.strong(props.input)) + " not found in source path", 2);
      return null;
    }
    if (isDir && path.extname(outputpath).length) {
      notify.error("a file (" + (notify.strong(props.output)) + ") is not a valid output target for a directory (" + (notify.strong(props.input)) + ") input target", 2);
      return null;
    }
    options = {
      compressor: this.plugins[type].compressor,
      linter: this.plugins[type].linter
    };
    if (type === JS) {
      options.modular = props.modular != null ? props.modular : true;
      options.module = this.plugins.js.module;
      options.parent = props.parent;
      return new JSTarget(inputpath, outputpath, this[type + 'Sources'], options);
    } else if (type === CSS) {
      return new CSSTarget(inputpath, outputpath, this[type + 'Sources'], options);
    }
  };

  Builder.prototype._runTarget = function(target, compress, lint, fn) {
    var _this = this;
    return target.run(compress, lint, function(err, files) {
      files && _this.filelog.add(files);
      fn && fn(files);
      return err && notify.error(err, 2);
    });
  };

  Builder.prototype._onWatchCreate = function(filename, stats) {
    var file, type;
    type = this._getFileType(filename);
    if (type && (file = this._fileFactory(filename, this._getSourceLocation(filename, type)))) {
      notify.print("[" + (new Date().toLocaleTimeString()) + "] " + (notify.colour('added', notify.GREEN)) + " " + (notify.strong(path.basename(filename))), 3);
      return this._cacheFile(file, this[type + 'Sources']);
    }
  };

  Builder.prototype._onWatchChange = function(filename, stats) {
    var type,
      _this = this;
    notify.print("[" + (new Date().toLocaleTimeString()) + "] " + (notify.colour('changed', notify.YELLOW)) + " " + (notify.strong(path.basename(filename))), 3);
    type = this._getFileType(filename);
    return this[type + 'Targets'].forEach(function(target) {
      target.watching = true;
      return _this._runTarget(target, _this.compress, false);
    });
  };

  Builder.prototype._onWatchDelete = function(filename) {
    var file, type;
    type = this._getFileType(filename);
    if (type && (file = this[type + 'Sources'].byPath[filename])) {
      notify.print("[" + (new Date().toLocaleTimeString()) + "] " + (notify.colour('removed', notify.RED)) + " " + (notify.strong(path.basename(filename))), 3);
      return this._uncacheFile(file, this[type + 'Sources']);
    }
  };

  return Builder;

})();
