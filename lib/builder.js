// Generated by CoffeeScript 1.4.0
var Builder, CSS, HTML, JS, Source, async, colour, configuration, debug, dependencies, error, exec, existsSync, filelog, fs, notify, object, path, print, processors, readdir, rm, start, strong, target, warn, _ref, _ref1,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

exec = require('child_process').exec;

async = require('async');

target = require('./core/target');

configuration = require('./core/configuration');

processors = require('./processors');

dependencies = require('./core/dependencies');

Source = require('./core/source');

filelog = require('./utils/filelog');

notify = require('./utils/notify');

object = require('./utils/object');

_ref = require('./utils/notify'), debug = _ref.debug, warn = _ref.warn, error = _ref.error, print = _ref.print, colour = _ref.colour, strong = _ref.strong;

_ref1 = require('./utils/fs'), readdir = _ref1.readdir, rm = _ref1.rm, existsSync = _ref1.existsSync;

JS = 'js';

CSS = 'css';

HTML = 'html';

start = notify.start = +(new Date);

module.exports = Builder = (function() {

  function Builder() {
    this._executeScript = __bind(this._executeScript, this);

    this._buildTargets = __bind(this._buildTargets, this);

    this._parseTargets = __bind(this._parseTargets, this);

    this._validBuildType = __bind(this._validBuildType, this);
    this.config = null;
    this.options = {
      compress: false,
      compile: false,
      lint: false,
      test: false,
      lazy: false,
      reload: false,
      verbose: false,
      watching: false,
      processors: null
    };
    this.sources = {
      js: null,
      css: null,
      html: null
    };
    this.targets = {
      js: [],
      css: [],
      html: []
    };
  }

  Builder.prototype.install = function(configpath, verbose) {
    var _this = this;
    this._extend(this.options, {
      verbose: verbose
    });
    return this._initialize(configpath, function(err) {
      if (err) {
        error(err, 0);
      }
      if (_this.config.dependencies) {
        debug('INSTALL', 1);
        print('installing dependencies...', 2);
        return dependencies.install(_this.config.dependencies, function(err, files) {
          files && filelog.add(files);
          err && error(err, 0);
          return print("completed install in " + (colour((+(new Date) - start) / 1000 + 's', notify.CYAN)), 2);
        });
      } else {
        return error('no dependencies specified in configuration file', 2);
      }
    });
  };

  Builder.prototype.build = function(configpath, compress, lint, test, lazy, verbose, fn) {
    var _this = this;
    object.extend(this.options, {
      compress: compress,
      lint: lint,
      test: test,
      lazy: lazy,
      verbose: verbose
    });
    return this._initialize(configpath, function(err) {
      if (err) {
        error(err, 2);
      }
      return async.forEachSeries([JS, CSS], (function(type, cb) {
        var build, opts;
        if (build = _this.config.build[type]) {
          if (_this._validBuildType(build)) {
            debug('SOURCE', 1);
            opts = object.clone(_this.options);
            opts.processors = _this.options.processors[type];
            _this.sources[type] = new Source(type, build.sources, opts);
            return _this.sources[type].parse(function(err) {
              if (err) {
                return cb("failed parsing sources " + (strong(build)));
              }
              debug('TARGET', 1);
              return _this._parseTargets(type, build.targets, function(err, instances) {
                if (instances) {
                  _this.targets[type] = instances;
                  return _this._buildTargets(type, function(err) {
                    if (err) {
                      return cb(err);
                    }
                    return cb();
                  });
                } else {
                  return cb();
                }
              });
            });
          } else {
            return cb('invalid build configuration');
          }
        } else {
          return cb();
        }
      }), function(err) {
        var script;
        if (err) {
          fn && fn(err);
          error(err, 2);
        }
        print("completed build in " + (colour((+(new Date) - start) / 1000 + 's', notify.CYAN)), 2);
        fn && fn();
        if (_this.options.test && (script = _this.config.settings.test)) {
          return _this._executeScript(function(script, err) {
            if (err) {
              return error(err, 2);
            }
          });
        }
      });
    });
  };

  Builder.prototype.watch = function(configpath, compress, reload, test, lazy, verbose) {
    var _this = this;
    return this.build(configpath, compress, false, test, lazy, verbose, function(err) {
      if (err) {
        error(err, 2);
      }
      debug('WATCH', 1);
      print('watching sources:', 2);
      return [_this.sources.js, _this.sources.css].forEach(function(source) {
        if (source) {
          object.extend(source.options, {
            watching: true,
            reload: reload
          });
          return source.watch(function(err, file) {
            if (err) {
              return error(err, 2, false);
            } else {
              start = new Date();
              file.clearContent();
              return _this._buildTargets(source.type, function(err) {
                var script;
                if (err) {
                  return error(err, 2, false);
                } else {
                  print("completed build in " + (colour((+(new Date) - start) / 1000 + 's', notify.CYAN)), 3);
                  if (_this.options.test && (script = _this.config.settings.test)) {
                    return _this._executeScript(function(script, err) {
                      if (err) {
                        return error(err, 2);
                      }
                    });
                  }
                }
              });
            }
          });
        }
      });
    });
  };

  Builder.prototype.deploy = function(configpath, test, lazy, verbose) {
    return this.build(configpath, true, false, test, lazy, verbose);
  };

  Builder.prototype.list = function(verbose) {
    var _this = this;
    notify.verbose = verbose;
    return filelog.load(function(err) {
      debug('LIST', 1);
      print('listing generated files...', 2);
      return filelog.files.forEach(function(file) {
        return print("" + (strong(file)), 3);
      });
    });
  };

  Builder.prototype.clean = function(verbose) {
    var _this = this;
    notify.verbose = verbose;
    return filelog.load(function(err) {
      debug('CLEAN', 1);
      print('cleaning generated files...', 2);
      filelog.files.forEach(function(file) {
        print("" + (colour('deleted', notify.RED)) + " " + (strong(file)), 3);
        return rm(path.resolve(file), function() {});
      });
      return filelog.clean();
    });
  };

  Builder.prototype._initialize = function(configpath, fn) {
    var _this = this;
    notify.verbose = this.options.verbose;
    start = new Date();
    if (!this.initialized) {
      return configuration.load(configpath, function(err, data) {
        if (err) {
          return fn(err);
        }
        _this.config = data;
        print("loaded config " + (strong(configuration.url)), 2);
        filelog.load(function() {});
        processors.load(_this.config.settings && _this.config.settings.processors, function(err, installed) {
          if (err) {
            return fn(err);
          }
          _this.options.processors = installed;
          _this.initialized = true;
          return fn();
        });
        return process.on('uncaughtException', function(err) {
          dependencies.clean();
          return [_this.sources.js, _this.sources.css].forEach(function(source) {
            if (source) {
              return source.clean();
            }
          });
        });
      });
    } else {
      return fn();
    }
  };

  Builder.prototype._validBuildType = function(build) {
    return !!(build && build.sources && build.sources.length >= 1 && build.targets && build.targets.length >= 1);
  };

  Builder.prototype._parseTargets = function(type, targets, fn) {
    var instances, outstanding, parse,
      _this = this;
    instances = [];
    outstanding = 0;
    parse = function(tgts, parent) {
      return tgts.forEach(function(tgt) {
        var opts;
        opts = object.extend(object.clone(_this.options), tgt);
        opts.parent = parent;
        opts.hasParent = !!parent;
        opts.hasChildren = !!opts.targets;
        opts.source = _this.sources[type];
        opts.processors = opts.processors[type];
        opts.compile = type === CSS;
        outstanding++;
        return target(type, opts, function(err, instance) {
          outstanding--;
          if (err) {
            warn(err, 2);
          }
          if (instance) {
            if (opts.parent) {
              instances.splice(instances.indexOf(opts.parent) + 1, 0, instance);
            } else {
              instances.push(instance);
            }
            if (opts.targets) {
              parse(opts.targets, instance);
            }
          }
          if (!outstanding) {
            return fn(null, instances);
          }
        });
      });
    };
    return parse(targets);
  };

  Builder.prototype._buildTargets = function(type, fn) {
    var _this = this;
    debug('BUILD', 1);
    return async.forEachSeries(this.targets[type], (function(tgt, cb) {
      return tgt.build(function(err, files) {
        files && filelog.add(files);
        if (!tgt.options.hasChildren) {
          tgt.reset();
        }
        if (err) {
          return cb(err);
        }
        tgt.options.source.refresh(path.basename(files[0]));
        return cb();
      });
    }), function(err) {
      if (err) {
        return fn(err);
      }
      return fn();
    });
  };

  Builder.prototype._executeScript = function(script, fn) {
    print('executing test script...', 2);
    debug("execute: " + (strong(this.config.settings.test)), 3);
    return exec(script, function(err, stdout, stderr) {
      if (err) {
        return fn(err);
      }
      stdout && console.log(stdout);
      stderr && console.log(stderr);
      return fn();
    });
  };

  return Builder;

})();
