'use strict';

const async = require('async');
const chalk = require('chalk');
const cnsl = require('./utils/cnsl');
const compiler = require('./helpers/compile');
const fileCache = require('./utils/fileCache');
const filetype = require('./utils/filetype');
const fs = require('fs');
const idResource = require('./identify-resource');
const md5 = require('md5');
const path = require('path');
const truncate = require('./utils/truncate');

const RE_BUDDY_BUILT = /\/\* generated by Buddy \/\*/;
// Test to determine if file has already been generated by buddy/browserify/component
const RE_BUILT = /function\((?:\w+,)?\s?module,\s?exports\)\s?{/;

const debug = cnsl.debug;
const ensureAsync = async.ensureAsync;
const error = cnsl.error;
const hasMultipleVersions = idResource.hasMultipleVersions;
const helpers = {
  write: require('./helpers/write'),
  compile: compiler.compile,
  compress: require('./helpers/compress'),
  concat: require('./helpers/concat'),
  inline: require('./helpers/inline'),
  parse: require('./helpers/parse'),
  replace: require('./helpers/replace'),
  transpile: require('./helpers/transpile'),
  wrap: require('./helpers/wrap')
};
const identify = idResource.identify;
const print = cnsl.print;
const resolve = idResource.resolve;
const strong = cnsl.strong;
const series = async.series;
const warn = cnsl.warn;

/**
 * File instance factory
 * @param {String} filepath
 * @param {Object} options
 * @returns {File}
 */
const factory = module.exports = function factory (filepath, options) {
  let file;

  // Retrieve cached
  if (factory.cache.hasFile(filepath)) {
    file = factory.cache.getFile(filepath);

  // Create new if valid id
  } else {
    const type = filetype(filepath, options.fileExtensions);
    const opts = {
      fileExtensions: options.fileExtensions,
      sources: options.sources,
      type: type
    };
    const id = identify(filepath, opts);

    if (id) {
      file = new File(id, filepath, type, options);
      factory.cache.addFile(file);
      // Warn of multiple versions
      if (hasMultipleVersions(id)) {
        warn('more than one version of '
          + strong(id.split('#')[0])
          + ' exists ('
          + strong(file.relpath)
          + ')', 3);
      }
    } else {
      throw Error('unable to create file for: ' + filepath);
    }
  }

  return file;
};

/*
 * Default file cache
 */
module.exports.cache = fileCache();

class File {
  /**
   * Constructor
   * @param {String} id
   * @param {String} filepath
   * @param {String} type
   * @param {Object} options
   *   - {Object} compilers
   *   - {Object} compressors
   *   - {Object} fileExtensions
   *   - {Object} runtimeOptions
   *   - {Array} sources
   */
  constructor (id, filepath, type, options) {
    this.content = '';
    this.compiledContent = '';
    this.compressPass = 0;
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.fileContent = '';
    this.filepath = filepath;
    this.hash = '';
    this.id = id;
    this.isBuddyBuilt = false;
    this.isBuilt = false;
    this.isDependency = false;
    this.isInline = false;
    this.isLocked = false;
    this.options = options;
    this.type = type;

    this.extension = path.extname(this.filepath).slice(1);
    this.relpath = truncate(path.relative(process.cwd(), filepath));
    this.name = path.basename(this.filepath);

    // Force generation of hash
    this.load();

    debug('created File instance ' + strong(this.relpath), 3);
  }

  /**
   * Retrieve writeable state
   * @param {Boolean} isBatch
   * @returns {Boolean}
   */
  isWriteable (isBatch) {
    return isBatch
      // Only writeable if not node_module in batch mode
      ? !~this.filepath.indexOf('node_modules')
      : !this.isDependency;
  }

  /**
   * Retrieve inlineable state
   * @returns {Boolean}
   */
  isInlineable () {
    return this.isInline;
  }

  /**
   * Retrieve flattened dependency tree
   * @param {Boolean} asReferences
   * @returns {Array}
   */
  getAllDependencies (asReferences) {
    const key = asReferences ? 'dependencyReferences' : 'dependencies';
    const root = this;
    let deps = [];
    let depsUnique = [];

    function add (dependency, dependant) {
      const instance = dependency.instance || dependency;

      if (instance !== root) {
        deps.push(dependency);
        // Add children
        if (key in instance) {
          instance[key].forEach(function (dep) {
            // Protect against circular references
            if ((dep.instance || dep) != dependant) add(dep, dependency);
          });
        }
      }
    }

    this[key].forEach(add);

    // Reverse and filter unique
    // Prefer deeply nested duplicates
    for (let i = deps.length - 1; i >= 0; i--) {
      if (!~depsUnique.indexOf(deps[i])) depsUnique.push(deps[i]);
    }

    return depsUnique;
  }

  /**
   * Run 'workflows' tasks in sequence
   * @param {Array} workflow
   * @param {Object} options
   *   - {Boolean} bootstrap
   *   - {Boolean} boilerplate
   *   - {Array} ignoredFiles
   *   - {Boolean} includeHeader
   *   - {Boolean} includeHelpers
   *   - {Boolean} watching
   * @param {Function} fn(err, dependencies)
   * @returns {null}
   */
  run (workflow, options, fn) {
    if (!workflow.length) return fn(null, []);

    series(workflow.map((task) => {
      // Memoize & prevent long stacks
      return ensureAsync(this[task].bind(this, options));
    }), (err) => {
      // Return dependencies if parsed
      fn(err, (~workflow.indexOf('parse') || ~workflow.indexOf('parseInline'))
        ? this.dependencies
        : []
      );
    });
  }

  /**
   * Read and store file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  load (options, fn) {
    if (!this.fileContent) {
      const content = fs.readFileSync(this.filepath, (this.type == 'image' && this.extension != 'svg') ? null : 'utf8');

      this.content = this.fileContent = content;
      this.hash = md5(content);
      // Determine if file has already been processed
      if (this.type == 'js') {
        this.isBuddyBuilt = RE_BUDDY_BUILT.test(content);
        this.isBuilt = RE_BUILT.test(content);
      }
      debug('load: ' + strong(this.relpath), 4);
    } else {
      this.content = this.fileContent;
    }

    if (fn) fn();
  }

  transpile (options, fn) {
    helpers.transpile(this.id, this.content, options, (err, content) => {
      console.log(content)
      fn();
    });
  }

  /**
   * Compile file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  compile (options, fn) {
    // Only compile if not already
    if (!this.compiledContent) {
      // Expose properties for compilers
      let options = {
        id: this.id,
        type: this.type
      };

      if (this.type == 'html') {
        // Gather all dependencies
        options.includes = [];
        this.getAllDependencies()
          .forEach((dependency) => {
            if (dependency.type != 'json') {
              const id = dependency.id;
              const idx = id.indexOf('#');

              // Strip version
              if (idx != -1) id = id.slice(0, idx);
              options.includes.push({
                id: id,
                content: dependency.content,
                filepath: dependency.filepath
              });
            // Sidecar data file
            } else {
              try {
                options.data = JSON.parse(dependency.content);
              } catch (err) {
                warn('malformed json file: ' + strong(dependency.filepath));
              }
            }
          });
      } else if (this.type == 'css') {
        // Gather all directories
        options.paths = factory.cache.getDirs();
      }

      helpers.compile(this.filepath, this.content, this.options.compilers, options, (err, content) => {
        if (err) {
          // Don't quit on error
          error(err, 2, false);
          return fn();
        }
        debug('compile: ' + strong(this.relpath), 4);
        this.content = this.compiledContent = content;
        fn();
      });
    } else {
      this.content = this.compiledContent;
      fn();
    }
  }

  /**
   * Parse file contents for dependency references
   * @param {Object} options
   * @param {Function} fn(err)
   */
  parse (options, fn) {
    this._parse(false, options, fn);
  }

  /**
   * Parse file contents for inline dependency references
   * @param {Object} options
   * @param {Function} fn(err)
   */
  parseInline (options, fn) {
    this._parse(true, options, fn);
  }

  /**
   * Parse file contents
   * @param {Boolean} isInline
   * @param {Object} options
   * @param {Function} fn(err)
   */
  _parse (isInline, options, fn) {
    const helper = isInline ? helpers.parse.inline : helpers.parse;
    const ignoredFiles = options.ignoredFiles || [];

    // Only parse unbuilt files
    if (!this.isBuddyBuilt || !this.isBuilt) {
      helper(this.filepath, this.type, this.content, (err, deps) => {
        if (err) return fn(err);

        debug('parse: ' + strong(this.relpath), 4);

        const resolveOptions = {
          fileExtensions: this.options.fileExtensions,
          type: this.type,
          sources: this.options.sources
        };

        deps.forEach((dep) => {
          const filepath = resolve(this.filepath, dep.filepath, resolveOptions);
          let instance;

          if (filepath !== '') {
            // Save context for future inlining
            this.dependencyReferences.push(dep);
            // Handle disabled (ignore node_modules when watching)
            if (filepath === false || (options.watching == 2 && ~filepath.indexOf('node_modules'))) {
              dep.isDisabled = true;
            } else if (instance = factory(filepath, this.options)) {
              // Store instance
              dep.instance = instance;
              // Parent target file...
              if (instance.isLocked
                // circular dependency...
                || ~instance.dependencies.indexOf(this)
                // ignored child target file
                || ~ignoredFiles.indexOf(filepath)) {
                  dep.isIgnored = true;
              // Store if not already stored
              } else if (!~this.dependencies.indexOf(instance)) {
                instance.isDependency = true;
                instance.isInline = 'stack' in dep;
                this.dependencies.push(instance);
              }
            }
          }

          if (!instance) {
            // Unable to resolve filepath
            if (!dep.isDisabled) {
              warn('dependency '
                + strong(dep.filepath)
                + ' for '
                + strong(this.id)
                + ' not found', 3);
            }
          }
        });

        fn();
      });
    }
  }

  /**
   * Inline dependency content
   * @param {Object} options
   * @param {Function} fn(err)
   */
  inline (options, fn) {
    const deps = (this.type == 'html')
      ? this.getAllDependencies(true)
      : this.dependencyReferences;

    helpers.inline(this.type, this.content, deps, this.options.runtimeOptions.compress, (err, content) => {
      if (err) return fn(err);
      debug('inline: ' + strong(this.relpath), 4);
      this.content = content;
      fn();
    });
  }

  /**
   * Replace relative dependency references with fully resolved
   * @param {Object} options
   * @param {Function} fn(err)
   */
  replaceReferences (options, fn) {
    this.content = helpers.replace.references(this.content, this.type, this.dependencyReferences);
    debug('replace dependency references: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Replace process.env references with values
   * @param {Object} options
   * @param {Function} fn(err)
   */
  replaceEnvironment (options, fn) {
    this.content = helpers.replace.environment(this.content, this.dependencyReferences);
    debug('replace environment vars: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Compress file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  compress (options, fn) {
    const compressorOptions = {
      // Ignore special strings on first compression pass
      except: (this.type == 'js' && !this.compressPass++) ? ['require', 'module', 'exports'] : null
    };

    helpers.compress(this.type, this.content, this.options.compressors, compressorOptions, (err, content) => {
      if (err) return fn(err);
      this.content = content;
      debug('compressed: ' + strong(this.relpath), 4);
      fn();
    });
  }

  /**
   * Wrap JS file contents in a module definition
   * @param {Object} options
   * @param {Function} fn(err)
   */
  wrap (options, fn) {
    // Allow wrapping of browserified bundles
    if (!this.isBuddyBuilt) {
      this.content = helpers.wrap(this.id, this.content);
      debug('wrap: ' + strong(this.relpath), 4);
    }
    fn();
  }

  /**
   * Concatenate file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  concat (options, fn) {
    this.content = helpers.concat(this.type, this.content, this.id, this.getAllDependencies(), options);
    debug('concat: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Write file contents to disk
   * @param {String} filepath
   * @returns {String}
   */
  write (filepath) {
    helpers.write(filepath, this.content);

    print(chalk.green('built'
      + (this.options.runtimeOptions.compress ? ' and compressed ' : ' '))
      + strong(truncate(path.relative(process.cwd(), filepath))), 2);

    return [filepath, md5(this.content), Date.now()];
  }

  /**
   * Reset content
   * @param {Boolean} hard
   */
  reset (hard) {
    this.isLocked = false;
    this.isDependency = false;
    this.isInline = false;
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.compressPass = 0;
    if (this.type != 'js') {
      this.content = this.fileContent;
      this.compiledContent = '';
    } else {
      this.content = this.compiledContent || this.fileContent;
    }
    if (hard) {
      this.content = this.fileContent = this.compiledContent = '';
      // Following are set on load
      // Can't delete this.hash
      this.isBuddyBuilt = false;
      this.isBuilt = false;
      RE_BUDDY_BUILT.lastIndex = 0;
      RE_BUILT.lastIndex = 0;
    }
    debug('reset' + (hard ? ' (hard)' : '') + ': ' + strong(this.relpath), 4);
  }

  /**
   * Destroy instance
   */
  destroy () {
    this.reset(true);
    this.options = null;
  }
}