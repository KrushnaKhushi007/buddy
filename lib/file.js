'use strict';

const chalk = require('chalk')
  , cnsl = require('./utils/cnsl')
  , compact = require('lodash/compact')
  , compiler = require('./helpers/compile')
  , fileCache = require('./utils/fileCache')
  , filetype = require('./utils/filetype')
  , flatten = require('lodash/flatten')
  , fs = require('fs')
  , idResource = require('identify-resource')
  , isEqual = require('lodash/isEqual')
  , path = require('path')
  , series = require('async').series
  , truncate = require('./utils/truncate')

  , RE_BUDDY_BUILT = /\/\* generated by Buddy/
    // Test to determine if file has already been generated by buddy/browserify/component
  , RE_BUILT = /(?:\[function\(require,\s?module,\s?exports\))/

  , debug = cnsl.debug
  , error = cnsl.error
  , hasMultipleVersions = idResource.hasMultipleVersions
  , helpers = {
      write: require('./helpers/write'),
      compile: compiler.compile,
      compress: require('./helpers/compress'),
      concat: require('./helpers/concat'),
      inline: require('./helpers/inline'),
      lint: require('./helpers/lint'),
      escape: require('./helpers/escape'),
      parse: require('./helpers/parse'),
      replace: require('./helpers/replace'),
      wrap: require('./helpers/wrap')
    }
  , identify = idResource.identify
  , print = cnsl.print
  , resolve = idResource.resolve
  , strong = cnsl.strong
  , warn = cnsl.warn;

/**
 * File instance factory
 * @param {String} filepath
 * @param {Object} options
 * @returns {File}
 */
var factory = module.exports = function factory (filepath, options) {
  let file;

  // Retrieve cached
  if (factory.cache.hasFile(filepath)) {
    file = factory.cache.getFile(filepath);

  // Create new if valid id
  } else {
    const type = filetype(filepath, options.fileExtensions)
      , opts = {
          fileExtensions: options.fileExtensions,
          sources: options.sources,
          type: type
        }
      , id = identify(filepath, opts);

    if (id) {
      file = new File(id, filepath, type, options);
      factory.cache.addFile(file);
      // Warn of multiple versions
      if (hasMultipleVersions(id)) {
        warn('more than one version of '
          + strong(id.split('#')[0])
          + ' exists ('
          + strong(file.relpath)
          + ')', 3);
      }
    } else {
      throw new Error('unable to create file for: ' + filepath);
    }
  }

  return file;
};

/*
 * Default file cache
 */
module.exports.cache = fileCache();

class File {
  /**
   * Constructor
   * @param {String} id
   * @param {String} filepath
   * @param {String} type
   * @param {Object} options
   */
  constructor (id, filepath, type, options) {
    this.content = '';
    this.compiledContent = '';
    this.dependencies = [];
    this.dependencyReferences = [];
    this.fileContent = '';
    this.filepath = filepath;
    this.headerHelpers = '';
    this.id = id;
    this.isBuddyBuilt = false;
    this.isBuilt = false;
    this.isDependency = false;
    this.isLocked = false;
    this.options = options;
    this.type = type;
    this.workflow = [];

    this.extension = path.extname(this.filepath).slice(1);
    this.relpath = truncate(path.relative(process.cwd(), filepath));
    this.name = path.basename(this.filepath);

    debug('created File instance ' + strong(this.relpath), 3);
  }

  /**
   * Retrieve writeable state
   * @param {Boolean} isBatch
   * @returns {Boolean}
   */
  getIsWriteable (isBatch) {
    return isBatch
      // Only writeable if not node_module in batch mode
      ? !~this.filepath.indexOf('node_modules')
      : !this.isDependency;
  }

  /**
   * Retrieve flattened dependency tree
   * @param {Boolean} asReferences
   * @returns {Array}
   */
  getAllDependencies (asReferences) {
    const key = asReferences ? 'dependencyReferences' : 'dependencies'
      , self = this;

    let deps = [];

    function add (dependency, dependant) {
      const instance = dependency.instance || dependency;

      if (instance !== self && !~deps.indexOf(dependency)) {
        deps.push(dependency);
        // Add children
        if (key in instance) {
          instance[key].forEach((dep) => {
            // Protect against circular references
            if ((dep.instance || dep) != dependant) add(dep, dependency);
          });
        }
      }
    }

    this[key].forEach(add);

    return deps;
  }

  /**
   * Run 'workflows' tasks in sequence
   * @param {Array} workflow
   * @param {Object} options
   * @param {Function} fn(err, dependencies)
   */
  run (workflow, options, fn) {
    if (workflow && workflow.length && !isEqual(workflow, this.workflow)) {
      this.workflow = workflow;

      series(workflow.map((task) => {
        return this[task].bind(this, options);
      }), (err, dependencies) => {
        // Return dependencies
        fn(err, flatten(compact(dependencies)));
      });
    } else {
      fn();
    }
  }

  /**
   * Read and store file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  load (options, fn) {
    if (!this.fileContent) {
      const content = fs.readFileSync(this.filepath, (this.type == 'image' && this.extension != 'svg') ? null : 'utf8');

      this.content = this.fileContent = content;
      // Determine if file has already been processed
      this.isBuddyBuilt = (this.type == 'js') && RE_BUDDY_BUILT.test(content);
      this.isBuilt = (this.type == 'js') && RE_BUILT.test(content);
      debug('load: ' + strong(this.relpath), 4);
    } else {
      this.content = this.fileContent;
    }

    fn();
  }

  /**
   * Compile file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  compile (options, fn) {
    // Only compile if not already
    if (!this.compiledContent) {
      // Expose properties for compilers
      let options = {
        id: this.id,
        type: this.type
      };

      if (this.type == 'html') {
        let dataUrl;

        // Gather all dependencies
        options.includes = [];
        this.getAllDependencies()
          .forEach((dependency) => {
            if (dependency.type != 'json') {
              const id = dependency.id
                , idx = id.indexOf('#');

              // Strip version
              if (idx != -1) id = id.slice(0, idx);
              options.includes.push({
                id: id,
                content: dependency.content,
                filepath: dependency.filepath
              });
            // Sidecar data file
            } else {
              try {
                options.data = JSON.parse(dependency.content);
              } catch (err) {
                warn('malformed json file: ' + strong(dependency.filepath));
              }
            }
          });
      } else if (this.type == 'css') {
        // Gather all directories
        options.paths = factory.cache.getDirs();
      }

      helpers.compile(this.filepath, this.content, this.options.compilers, options, (err, content) => {
        if (err) {
          // Don't quit on error
          error(err, 2, false);
          return fn();
        }
        debug('compile: ' + strong(this.relpath), 4);
        this.content = this.compiledContent = content;
        fn();
      });
    } else {
      this.content = this.compiledContent;
      fn();
    }
  }

  /**
   * Parse file contents for dependency references
   * @param {Object} options
   * @param {Function} fn(err, dependencies)
   */
  parse (options, fn) {
    // Only parse unbuilt files
    if (!this.isBuddyBuilt || !this.isBuilt) {
      helpers.parse(this.filepath, this.type, this.content, (err, deps) => {
        if (err) return fn(err);

        debug('parse: ' + strong(this.relpath), 4);

        const options = {
          fileExtensions: this.options.fileExtensions,
          type: this.type,
          sources: this.options.sources
        };

        deps.forEach((dep) => {
          const filepath = resolve(this.filepath, dep.filepath, options);

          let instance;

          if (filepath !== '') {
            // Save context for future inlining
            this.dependencyReferences.push(dep);
            // Handle disabled/ignored
            // Ignore node_modules when watching
            if (filepath === false || (options.watching == 2 && ~filepath.indexOf('node_modules'))) {
              dep.isDisabled = true;
            } else if (instance = factory(filepath, this.options)) {
              // Store instance
              dep.instance = instance;
              // Process if not locked (parent target files are locked)
              if (!instance.isLocked) {
                // Store if not already stored
                if (!~this.dependencies.indexOf(instance)) {
                  instance.isDependency = true;
                  this.dependencies.push(instance);
                }
              }
            }
          }

          if (!instance) {
            // Unable to resolve filepath
            if (!dep.isDisabled) {
              warn('dependency '
                + strong(dep.filepath)
                + ' for '
                + strong(this.id)
                + ' not found', 3);
            }
          }
        });

        fn(null, this.dependencies);
      });
    }
  }

  /**
   * Inline dependency content
   * @param {Object} options
   * @param {Function} fn(err)
   */
  inline (options, fn) {
    const deps = (this.type != 'css')
      ? this.getAllDependencies(true)
      : this.dependencyReferences;

    helpers.inline(this.type, this.content, deps, (err, content) => {
      if (err) return fn(err);
      debug('inline: ' + strong(this.relpath), 4);
      this.content = content;
      fn();
    });
  }

  /**
   * Replace relative dependency references with fully resolved
   * @param {Object} options
   * @param {Function} fn(err)
   */
  replaceReferences (options, fn) {
    this.content = helpers.replace.references(this.content, this.type, this.dependencyReferences);
    debug('replace dependency references: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Replace process.env references with values
   * @param {Object} options
   * @param {Function} fn(err)
   */
  replaceEnvironment (options, fn) {
    this.content = helpers.replace.environment(this.content, this.dependencyReferences);
    debug('replace environment vars: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Lint file contents
   * @param {Object} options
   * @param {Function} fn(err, warnings)
   * @returns {Array}
   */
  lint (options, fn) {
    let warnings;

    // Don't lint compiled files, 3rd party modules, or built files
    if (this.extension == this.type
      && !~this.filepath.indexOf('node_modules')
      && !this.isBuddyBuilt
      && !this.isBuilt) {
        if (warnings = helpers.lint(this.type, this.content)) {
          warn('linting ' + strong(this.relpath), 3);
          warnings.forEach((item) => {
            if (item) {
              print('[line '
                + chalk.cyan(item.line)
                + ':'
                + chalk.cyan(item.col)
                + '] '
                + item.reason
                + ':', 3);
              if (item.evidence) print(strong(item.evidence), 4);
            }
          });
        } else {
          debug('lint: ' + strong(this.relpath), 4);
        }
    }

    if (fn) return fn();
    // Smelly test hook
    return warnings;
  }

  /**
   * Escape file contents for lazy js modules
   * @param {Object} options
   * @param {Function} fn(err)
   */
  escape (options, fn) {
    this.content = helpers.escape(this.content);
    debug('escape: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Compress file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  compress (options, fn) {
    helpers.compress(this.type, this.content, this.options.compressors, (err, content) => {
      if (err) return fn(err);
      this.content = content;
      debug('compressed: ' + strong(this.relpath), 4);
      fn();
    });
  }

  /**
   * Wrap JS file contents in a module definition
   * @param {Object} options
   * @param {Function} fn(err)
   */
  wrap (options, fn) {
    // Allow wrapping of browserified bundles
    if (!this.isBuddyBuilt) {
      const lazy = this.options.runtimeOptions
        ? this.options.runtimeOptions.lazy
        : false;

      this.content = helpers.wrap(this.id, this.content, lazy);
      debug('wrap: ' + strong(this.relpath), 4);
    }
    fn();
  }

  /**
   * Concatenate file contents
   * @param {Object} options
   * @param {Function} fn(err)
   */
  concat (options, fn) {
    this.content = helpers.concat(this.type, this.content, this.id, this.getAllDependencies().reverse(), options);
    debug('concat: ' + strong(this.relpath), 4);
    fn();
  }

  /**
   * Write file contents to disk
   * @param {String} filepath
   * @returns {String}
   */
  write (filepath) {
    helpers.write(filepath, this.content);

    print(chalk.green('built'
      + (this.options.runtimeOptions.compress ? ' and compressed ' : ' '))
      + strong(truncate(path.relative(process.cwd(), filepath))), 2);

    return filepath;
  }

  /**
   * Reset content
   * @param {Boolean} hard
   */
  reset (hard) {
    this.workflow = [];
    this.isLocked = false;
    this.isDependency = false;
    this.dependencies = [];
    this.dependencyReferences = [];
    if (this.type != 'js') {
      this.content = this.fileContent;
      this.compiledContent = '';
    } else {
      this.content = this.compiledContent || this.fileContent;
    }
    if (hard) {
      this.content = this.fileContent = this.compiledContent = '';
      // Following are set on load
      this.isBuddyBuilt = false;
      this.isBuilt = false;
    }
    debug('reset' + (hard ? ' (hard)' : '') + ': ' + strong(this.relpath), 4);
  }

  /**
   * Destroy instance
   */
  destroy () {
    this.reset(true);
    this.options = null;
  }
}