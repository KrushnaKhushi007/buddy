// Generated by CoffeeScript 1.4.0
var cp, exists, existsSync, fs, mkdir, mkdirp, mv, notify, path, readdir, rimraf, rm;

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

rimraf = require('rimraf');

exports.existsSync = existsSync = fs.existsSync || path.existsSync;

exports.exists = exists = fs.exists || path.exists;

exports.notify = notify = {
  RED: '0;31',
  YELLOW: '1;33',
  GREEN: '0;32',
  GREY: '0;90',
  silent: false,
  nocolor: !process.stdout.isTTY,
  colour: function(string, colourCode) {
    if (this.nocolor) {
      return string;
    } else {
      return '\033[' + colourCode + 'm' + string + '\033[0m';
    }
  },
  print: function(msg, ind) {
    if (ind == null) {
      ind = 1;
    }
    if (!this.silent) {
      return console.log(exports.indent(msg, ind));
    }
  },
  error: function(err, ind) {
    if (ind == null) {
      ind = 1;
    }
    if ('string' === typeof err) {
      err = new Error(err);
    }
    this.print("" + (this.colour('error', this.RED)) + ": " + err.message, ind);
    throw err;
  },
  warn: function(msg, indent) {
    if (indent == null) {
      indent = 1;
    }
    return this.print("" + (this.colour('warning', this.YELLOW)) + " " + msg, indent);
  },
  strong: function(string) {
    return this.colour(string, this.GREY);
  }
};

exports.readdir = readdir = function(dir, ignore, files) {
  var _this = this;
  if (ignore == null) {
    ignore = /^\./;
  }
  if (files == null) {
    files = [];
  }
  fs.readdirSync(dir).forEach(function(item) {
    var itempath;
    if (!ignore.test(path.basename(item))) {
      itempath = path.resolve(dir, item);
      if (fs.statSync(itempath).isDirectory()) {
        return readdir(itempath, ignore, files);
      } else {
        return files.push(itempath);
      }
    }
  });
  return files;
};

exports.mkdir = mkdir = function(filepath) {
  var dir;
  dir = path.extname(filepath) ? path.dirname(filepath) : filepath;
  if (!existsSync(dir)) {
    return mkdirp.sync(dir);
  }
};

exports.mv = mv = function(source, destination) {
  var filename;
  mkdir(destination);
  try {
    fs.rename(source, filename = path.resolve(destination, path.basename(source)));
    return filename;
  } catch (err) {

  }
};

exports.cp = cp = function(source, destination, base) {
  var contentsOnly, dir, filename,
    _this = this;
  if (base == null) {
    base = null;
  }
  if (fs.statSync(source).isFile()) {
    if (path.dirname(source) === path.dirname(destination)) {
      if (path.basename(destination) && path.basename(destination) !== path.basename(source)) {
        filename = destination;
      } else {
        filename = source.replace('.', ' copy.');
      }
    } else {
      filename = path.resolve(destination, path.basename(source));
    }
    if (!existsSync(filename)) {
      fs.writeFileSync(filename, fs.readFileSync(source));
    }
    return filename;
  } else {
    contentsOnly = source.charAt(source.length - 1) === '/' && !base ? true : false;
    base = contentsOnly ? path.resolve(source) : path.dirname(path.resolve(source));
    dir = path.resolve(destination, source.replace(base, destination));
    mkdir(dir);
    fs.readdirSync(source).forEach(function(item) {
      return cp(path.resolve(source, item), dir, base);
    });
    return dir;
  }
};

exports.rm = rm = function(source) {
  if (existsSync(source) && source.indexOf(process.cwd()) !== -1) {
    return rimraf(source, function(err) {
      return err && notify.error(err, 2);
    });
  }
};

exports.indent = function(string, level) {
  var re;
  re = /^/gm;
  string = string.replace(re, (new Array(level)).join('  '));
  return string;
};

exports.wait = function(time, fn) {
  if (time == null) {
    time = 25;
  }
  return setTimeout(fn, time);
};
