'use strict';

const comment = require('../utils/comment');
const compiler = require('./compile');
const fs = require('fs');
const replace = require('./replace');

const BOILERPLATE = fs.readFileSync(require.resolve('../utils/require.js'), 'utf8');
const HEADER = 'generated by Buddy';

/**
 * Concatenate all 'dependencies' for 'file'
 * @param {File} file
 * @param {Array} dependencies
 * @param {Object} options
 * @returns {String}
 */
module.exports = function (file, dependencies, options) {
  switch (file.type) {
    case 'js':
      return concatJS(file.content, file.id, dependencies, options);
    case 'css':
      return concatCSS(file.content, options);
    default:
      return file.content;
  }
};

/**
 * Get concatenated JS 'content'
 * @param {String} content
 * @param {String} id
 * @param {Array} dependencies
 * @param {Object} options
 * @returns {String}
 */
function concatJS (content, id, dependencies, options) {
  const contents = [];

  // Add header comment
  if (options.includeHeader) contents.push(comment(HEADER, 'js'));

  // Add require boilerplate (replace process.env.NODE_ENV)
  contents.push(replace.environment(BOILERPLATE));

  // Add helpers
  if (options.includeHelpers) {
    const helpers = compiler.getHelpers('js');

    if (helpers) contents.push(helpers);
  }

  if (!options.bootstrap) contents.push(`_m_['${id}']=function () {`);

  // Add dependencies
  dependencies.filter((dependency) => {
    return dependency.type != 'json';
  }).forEach((dependency) => {
    contents.push(dependency.content);
  });

  contents.push(content);

  if (!options.bootstrap) contents.push(`return _m_['${id}'];\n}\n_m_['${id}'].boot = 1;`);

  return contents.join('\n');
}

/**
 * Get concatenated CSS 'content'
 * @param {String} content
 * @param {Object} options
 * @returns {String}
 */
function concatCSS (content, options) {
  // Add comment
  if (options.includeHeader) content = `${comment(HEADER, 'css')}\n${content}`;

  return content;
}