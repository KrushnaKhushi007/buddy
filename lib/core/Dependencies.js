// Generated by CoffeeScript 1.4.0
var Dependency, async, childDependencies, cp, dependencies, existsSync, fs, mkdir, mv, notify, outputFiles, path, processors, rm, temp, _installDependency, _pack, _ref,
  _this = this;

path = require('path');

fs = require('fs');

async = require('async');

Dependency = require('./dependency');

processors = require('../processors');

notify = require('../utils/notify');

_ref = require('../utils/fs'), rm = _ref.rm, mv = _ref.mv, cp = _ref.cp, mkdir = _ref.mkdir, existsSync = _ref.existsSync;

dependencies = [];

childDependencies = [];

outputFiles = [];

temp = path.resolve('.tmp');

exports.install = function(options, fn) {
  var data, destination,
    _this = this;
  dependencies = [];
  childDependencies = [];
  outputFiles = [];
  for (destination in options) {
    data = options[destination];
    data.sources.forEach(function(source) {
      return dependencies.push(new Dependency(source, destination, data.output, temp));
    });
  }
  return mkdir(temp, function(err) {
    if (err) {
      return fn(err);
    }
    return async.forEach(dependencies, _installDependency, function(err) {
      if (childDependencies.length) {
        return async.forEach(childDependencies, _installDependency, function(err) {
          dependencies = childDependencies.concat(dependencies);
          return _pack(function(err) {
            return fn(err, outputFiles);
          });
        });
      } else {
        return _pack(function(err) {
          return fn(err, outputFiles);
        });
      }
    });
  });
};

_installDependency = function(dependency, fn) {
  return dependency.install(function(err, dependencies) {
    if (err) {
      notify.warn(err);
      dependencies.splice(dependencies.indexOf(dependency), 1);
      return dependency.destroy();
    } else {
      if (dependencies.length) {
        dependencies.forEach(function(source) {
          return childDependencies.push(new Dependency(source, dependency.destination, dependency.output, temp));
        });
      }
      notify.print("" + (notify.colour('installed', notify.GREEN)) + " " + (notify.strong(dependency.id)) + " to " + (notify.strong(path.relative(process.cwd(), dependency.destination))), 3);
      outputFiles = outputFiles.concat(dependency.files);
      return fn();
    }
  });
};

_pack = function(fn) {
  return rm(temp, function(err) {
    var files, output, outputable, outputs, _results;
    if (err) {
      notify.warn(err);
    }
    outputs = {};
    outputable = dependencies.filter(function(dependency) {
      return dependency.output;
    });
    if (outputable.length) {
      outputable.forEach(function(dependency) {
        var _name, _ref1;
        if ((_ref1 = outputs[_name = dependency.output]) == null) {
          outputs[_name] = [];
        }
        return outputs[dependency.output] = outputs[dependency.output].concat(dependency.resources);
      });
      _results = [];
      for (output in outputs) {
        files = outputs[output];
        _results.push(async.map(files, fs.readFile, function(err, contents) {
          var content;
          if (err) {
            return err;
          }
          content = contents.join('\n');
          return async.waterfall([
            (function(cb) {
              return mkdir(output, cb);
            }), (function(cb) {
              return processors.installed.js.compressor.compress(content, cb);
            }), (function(content, cb) {
              return fs.writeFile(output, content, 'utf8', cb);
            }), (function(cb) {
              notify.print("" + (notify.colour('compressed', notify.GREEN)) + " " + (notify.strong(path.relative(process.cwd(), output))), 3);
              outputFiles.push(output);
              return cb();
            })
          ], fn);
        }));
      }
      return _results;
    } else {
      return fn();
    }
  });
};
