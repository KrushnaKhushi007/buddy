// Generated by CoffeeScript 1.4.0
var Dependency, async, childDependencies, colour, cp, debug, dependencies, existsSync, fs, mkdir, mv, notify, outputFiles, path, processors, rimraf, strong, temp, _clear, _installDependency, _pack, _ref, _ref1,
  _this = this;

path = require('path');

fs = require('fs');

async = require('async');

rimraf = require('rimraf');

Dependency = require('./dependency');

processors = require('../processors');

notify = require('../utils/notify');

_ref = require('../utils/notify'), debug = _ref.debug, strong = _ref.strong, colour = _ref.colour;

_ref1 = require('../utils/fs'), mv = _ref1.mv, cp = _ref1.cp, mkdir = _ref1.mkdir, existsSync = _ref1.existsSync;

dependencies = [];

childDependencies = [];

outputFiles = [];

temp = null;

exports.install = function(options, fn) {
  var data, destination,
    _this = this;
  temp = path.resolve('.tmp');
  dependencies = [];
  childDependencies = [];
  outputFiles = [];
  for (destination in options) {
    data = options[destination];
    data.sources.forEach(function(source) {
      return dependencies.push(new Dependency(source, destination, data.output, temp));
    });
  }
  return mkdir(temp, function(err) {
    if (err) {
      return fn(err);
    }
    debug("created temp directory: " + (strong(path.relative(process.cwd(), temp))), 3);
    return async.forEach(dependencies, _installDependency, function(err) {
      if (childDependencies.length) {
        return async.forEach(childDependencies, _installDependency, function(err) {
          dependencies = childDependencies.concat(dependencies);
          return _pack(function(err) {
            return fn(err, outputFiles);
          });
        });
      } else {
        return _pack(function(err) {
          return fn(err, outputFiles);
        });
      }
    });
  });
};

exports.clean = function() {
  return _clear();
};

_installDependency = function(dependency, fn) {
  return dependency.install(function(err, dependencies) {
    if (err) {
      notify.warn(err);
      dependencies.splice(dependencies.indexOf(dependency), 1);
      return dependency.destroy();
    } else {
      if (dependencies.length) {
        dependencies.forEach(function(source) {
          return childDependencies.push(new Dependency(source, dependency.destination, dependency.output, temp));
        });
      }
      notify.print("" + (colour('installed', notify.GREEN)) + " " + (strong(dependency.id)) + " to " + (strong(path.relative(process.cwd(), dependency.destination))), 3);
      outputFiles = outputFiles.concat(dependency.files);
      return fn();
    }
  });
};

_pack = function(fn) {
  var files, output, outputable, outputs, _results;
  _clear();
  outputs = {};
  outputable = dependencies.filter(function(dependency) {
    return dependency.output;
  });
  if (outputable.length) {
    outputable.forEach(function(dependency) {
      var _name, _ref2;
      if ((_ref2 = outputs[_name = dependency.output]) == null) {
        outputs[_name] = [];
      }
      return outputs[dependency.output] = outputs[dependency.output].concat(dependency.resources);
    });
    _results = [];
    for (output in outputs) {
      files = outputs[output];
      _results.push(async.map(files, fs.readFile, function(err, contents) {
        var content;
        if (err) {
          return fn(err);
        }
        content = contents.join('\n');
        return async.waterfall([
          (function(cb) {
            return mkdir(output, cb);
          }), (function(cb) {
            return processors.installed.js.compressor.compress(content, cb);
          }), (function(content, cb) {
            return fs.writeFile(output, content, 'utf8', cb);
          }), (function(cb) {
            notify.print("" + (colour('compressed', notify.GREEN)) + " " + (strong(path.relative(process.cwd(), output))), 3);
            outputFiles.push(output);
            return cb();
          })
        ], fn);
      }));
    }
    return _results;
  } else {
    return fn();
  }
};

_clear = function() {
  return rimraf.sync(temp);
};
