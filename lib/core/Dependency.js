// Generated by CoffeeScript 1.4.0
var Dependency, RE_GITHUB_PROJECT, RE_GITHUB_URL, RE_INDEX, RE_PACKAGE_NOT_FOUND, RE_VALID_VERSION, async, bower, cp, debug, existsSync, fs, fsutils, http, mkdir, mv, path, request, rm, semver, strong, unzip, _ref, _ref1,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

path = require('path');

fs = require('fs');

bower = require('bower');

request = require('superagent');

http = require('http');

unzip = require('unzip');

semver = require('semver');

async = require('async');

fsutils = require('../utils/fs');

_ref = require('../utils/notify'), debug = _ref.debug, strong = _ref.strong;

_ref1 = require('../utils/fs'), rm = _ref1.rm, mv = _ref1.mv, cp = _ref1.cp, mkdir = _ref1.mkdir, existsSync = _ref1.existsSync;

RE_GITHUB_PROJECT = /\w+\/\w+/;

RE_GITHUB_URL = /git:\/\/(.*)\.git/;

RE_PACKAGE_NOT_FOUND = /was not found/;

RE_INDEX = /^index(?:\.js$)?/;

RE_VALID_VERSION = /^\d+\.\d+\.\d+$|^master$/;

module.exports = Dependency = (function() {

  function Dependency(source, destination, output, temp) {
    var _ref2;
    this.temp = temp;
    this.move = __bind(this.move, this);

    this.resolveResources = __bind(this.resolveResources, this);

    this.fetch = __bind(this.fetch, this);

    this.validateVersion = __bind(this.validateVersion, this);

    this.lookupPackage = __bind(this.lookupPackage, this);

    debug("created Source instance for: " + source, 2);
    this.local = false;
    this.keep = false;
    this.id = source;
    this.name = source;
    this.url = null;
    this.version = 'master';
    this.packageFiles = ['component.json', 'package.json'];
    this.location = null;
    this.resources = null;
    this.files = [];
    this.dependencies = [];
    this.destination = path.resolve(destination);
    this.output = output && path.resolve(output);
    source = source.split('#');
    if (source[1]) {
      this.resources = source[1].split('|');
    }
    if (existsSync(path.resolve(source[0]))) {
      this.local = true;
      this.location = path.resolve(source[0]);
      if ((_ref2 = this.resources) == null) {
        this.resources = [this.location];
      }
      this.keep = this.location.indexOf(path.resolve(this.destination)) !== -1;
    } else {
      source = source[0].split('@');
      if (source[1]) {
        this.version = source[1];
      }
      this.id = this.name = source[0];
      if (RE_GITHUB_PROJECT.test(this.name)) {
        this.url = "https://github.com/" + this.name + "/archive/" + this.version + ".zip";
        this.id = this.name.split('/')[1];
      }
    }
  }

  Dependency.prototype.install = function(fn) {
    var _this = this;
    if (this.local) {
      return this.move(function(err) {
        if (err) {
          return fn(err);
        } else {
          return fn(null, _this.dependencies);
        }
      });
    } else {
      return async.series([this.lookupPackage, this.validateVersion, this.fetch, this.resolveResources, this.move], function(err) {
        if (err) {
          return fn(err);
        } else {
          return fn(null, _this.dependencies);
        }
      });
    }
  };

  Dependency.prototype.lookupPackage = function(fn) {
    var _this = this;
    if (!this.url) {
      debug("looking up package: " + (strong(this.id)), 3);
      return bower.commands.lookup(this.id).on('error', function() {
        return fn('no package found for:' + _this.id);
      }).on('data', function(data) {
        var url;
        if (RE_PACKAGE_NOT_FOUND.test(data)) {
          return fn('no package found for:' + _this.id);
        } else {
          url = RE_GITHUB_URL.exec(data)[1];
          _this.name = url.replace('github.com/', '');
          _this.url = "https://" + url + "/archive/" + _this.version + ".zip";
          return fn();
        }
      });
    } else {
      return process.nextTick(function() {
        return fn();
      });
    }
  };

  Dependency.prototype.validateVersion = function(fn) {
    var req,
      _this = this;
    if (!RE_VALID_VERSION.test(this.version)) {
      debug("validating version: " + (strong(this.name + '@' + this.version)), 3);
      req = request.get("https://api.github.com/repos/" + this.name + "/tags");
      return req.end(function(err, res) {
        var json, version, _i, _len;
        if (err || res.error) {
          return fn('fetching tags for: ' + _this.name + ' failed with error code: ' + http.STATUS_CODES[res.status]);
        } else {
          try {
            json = JSON.parse(res.text);
          } catch (err) {
            fn('parsing tag information for: ' + _this.name);
          }
          json.sort(function(a, b) {
            return semver.rcompare(a.name, b.name);
          });
          if (_this.version === '*' || _this.version === 'latest') {
            _this.version = json[0].name;
            _this.url = json[0].zipball_url;
          } else {
            for (_i = 0, _len = json.length; _i < _len; _i++) {
              version = json[_i];
              if (semver.satisfies(version.name, _this.version)) {
                _this.version = version.name;
                _this.url = version.zipball_url;
                break;
              }
            }
          }
          return fn();
        }
      });
    } else {
      return process.nextTick(function() {
        return fn();
      });
    }
  };

  Dependency.prototype.fetch = function(fn) {
    var filename, req,
      _this = this;
    filename = this.temp + path.sep + this.id + '-' + this.version + '.zip';
    debug("downloading zipball to temp: " + (strong(this.url)), 3);
    req = request.get(this.url).buffer(false);
    return req.end(function(err, res) {
      if (err || res.error) {
        return fn('fetching ' + _this.url + ' failed with error code: ' + http.STATUS_CODES[res.status]);
      } else {
        res.pipe(fs.createWriteStream(filename));
        return res.on('end', function() {
          var extractor;
          extractor = unzip.Extract({
            path: _this.temp
          });
          fs.createReadStream(filename).pipe(extractor);
          extractor.on('error', function() {
            return fn('unzipping archive: ' + filename);
          });
          return extractor.on('close', function() {
            _this.location = filename.replace(path.extname(filename), '');
            return fn();
          });
        });
      }
    });
  };

  Dependency.prototype.resolveResources = function(fn) {
    var add, callback, find, temp,
      _this = this;
    find = function(packageFile, cb) {
      var filename;
      if (existsSync(filename = path.resolve(_this.location, packageFile))) {
        return fs.readFile(filename, 'utf8', function(err, data) {
          var json;
          if (err) {
            return cb('reading: ' + _this.id + ' ' + packageFile);
          }
          try {
            json = JSON.parse(data);
          } catch (err) {
            return cb('parsing: ' + _this.id + ' ' + packageFile);
          }
          return cb(null, json);
        });
      } else {
        return cb(null);
      }
    };
    add = function(filename) {
      var filepath, newname;
      if (RE_INDEX.test(filename)) {
        if (!path.extname(filename)) {
          filename += '.js';
        }
        newname = _this.id + '.js';
        fs.renameSync(path.resolve(_this.location, filename), path.resolve(_this.location, newname));
        filename = newname;
      }
      filepath = path.resolve(_this.location, filename);
      debug("added resource: " + (strong(path.basename(filepath))), 3);
      if (existsSync(filepath)) {
        return _this.resources.push(filepath);
      }
    };
    if (this.resources) {
      temp = this.resources.concat();
      this.resources = [];
      temp.forEach(function(filename) {
        return add(filename);
      });
      return process.nextTick(function() {
        return fn();
      });
    } else {
      this.resources = [];
      return find(this.packageFiles.pop(), callback = function(err, json) {
        var dependency, version, _ref2;
        if (err) {
          return fn(err);
        }
        if (json && json.main) {
          add(json.main);
          if (json.dependencies) {
            _ref2 = json.dependencies;
            for (dependency in _ref2) {
              version = _ref2[dependency];
              _this.dependencies.push("" + dependency + "@" + version);
            }
          }
          return fn();
        } else if (_this.packageFiles.length) {
          return find(_this.packageFiles.pop(), callback);
        } else {
          return fn('unable to resolve resources for: ' + _this.id);
        }
      });
    }
  };

  Dependency.prototype.move = function(fn) {
    var idx,
      _this = this;
    if (!this.keep) {
      idx = -1;
      return async.forEachSeries(this.resources, (function(resource, cb) {
        return fsutils[_this.local ? 'cp' : 'mv'](resource, _this.destination, true, function(err, filepath) {
          if (err) {
            return cb(err);
          }
          idx++;
          _this.files.push(path.relative(process.cwd(), filepath));
          debug("moved resource " + (strong(path.basename(resource))) + " to destination " + (strong(path.relative(process.cwd(), _this.destination))), 3);
          _this.resources[idx] = filepath;
          return cb();
        });
      }), function(err) {
        if (err) {
          return fn(err);
        } else {
          return fn();
        }
      });
    } else {
      return process.nextTick(function() {
        return fn();
      });
    }
  };

  Dependency.prototype.destroy = function() {};

  return Dependency;

})();
