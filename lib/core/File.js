// Generated by CoffeeScript 1.4.0
var File, RE_BUILT_HEADER, async, existsSync, fs, path;

fs = require('fs');

path = require('path');

async = require('async');

existsSync = require('./utils').existsSync;

RE_BUILT_HEADER = /^\/\*BUILT/g;

module.exports = File = (function() {

  function File(type, filepath, options) {
    var compiler, id, source, _i, _len, _ref, _ref1, _ref2;
    this.type = type;
    this.filepath = filepath;
    this.options = options;
    this.dependencies = [];
    this.name = path.basename(this.filepath);
    _ref = this.options.sources;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source.indexOf(this.filepath) !== -1) {
        this.base = source;
        this.qualifiedName = path.relative(this.base, this.filepath).replace(path.extname(this.name), '');
        break;
      }
    }
    this.extension = path.extname(this.name).slice(1);
    this.needsCompile = extension !== this.type;
    if (this.needsCompile) {
      _ref1 = this.options.processors.compilers;
      for (id in _ref1) {
        compiler = _ref1[id];
        if (this.extension === compiler.extension) {
          this.compiler = compiler;
          break;
        }
      }
    }
    this.linter = this.options.processors.linter;
    this.compressor = this.options.processors.compressor;
    this.module = this.options.processors.module;
    this.moduleId = (_ref2 = this.module) != null ? _ref2.getModuleId(this.qualifiedName) : void 0;
  }

  File.prototype.getContent = function(fn) {
    return fs.readfile(this.filepath, 'utf8', function(err, content) {
      var _this = this;
      if (err) {
        return fn(err);
      }
      if (this.options.modular) {
        this.dependencies = this.module.getModuleDependencies(content, this.moduleId);
        this.dependencies.forEach(function(dependency, idx) {});
      }
      if (this.needsCompile) {
        if (this.compiler != null) {
          return this.compiler.compile(content, function(err, compiled) {
            if (err) {
              return fn(err, '');
            }
            if (_this.options.modular) {
              return fn(null, _this.module.wrapModuleContents(compiled, _this.moduleId), _this.dependencies);
            } else {
              return fn(null, compiled);
            }
          });
        } else {
          return fn(null, '');
        }
      }
    });
  };

  File.prototype.destroy = function() {};

  return File;

})();

/*

	# Read file contents
	# @param {Function} fn(err, data)
	parseContents: (fn) ->
		# Clear existing
		@_contents = ''
		# TODO: read stream and abort on header match
		# Read file
		fs.readFile @filepath, 'utf8', (err, data) =>
			return fn(err) if err
			# Skip compiled files
			return if data.match(RE_BUILT_HEADER)
			@_contents = data
			return fn(null, @_contents)

	# Return contents, compiled if necessary
	# @param {Object} options
	# @param {Function} fn(err, data)
	getContents: (options, fn) ->
		# Compile if necessary
		if @needsCompile then @_compile(options, fn) else fn(null, @_contents)

	destroy: ->
		@dependencies = null
		@compiler = null

	# Use the supplied compiler to compile file contents
	# @param {Object} options
	# @param {Function} fn(err, data)
	_compile: (options, fn) ->
		if @compiler?
			@compiler.compile @_contents, options.sources, (err, compiled) =>
				if err then fn(err, '') else fn(null, compiled)
		else
			fn("no compiler plugin available for #{nofify.strong(@filename)}", '')
*/

