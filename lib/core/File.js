// Generated by CoffeeScript 1.4.0
var File, RE_BUILT_HEADER, async, existsSync, fs, notify, path;

fs = require('fs');

path = require('path');

async = require('async');

notify = require('../utils/notify');

existsSync = require('../utils/fs').existsSync;

RE_BUILT_HEADER = /^\/\*BUILT/g;

module.exports = function(type, filepath, basepath, processors, fn) {
  var compiler, extension, name, valid, _ref;
  filepath = path.resolve(filepath);
  if (!existsSync(filepath)) {
    return fn("" + (notify.strong(filepath)) + " not found in project path");
  }
  extension = path.extname(filepath).slice(1);
  if (extension === type) {
    valid = true;
  } else {
    _ref = processors.compilers;
    for (name in _ref) {
      compiler = _ref[name];
      if (extension === compiler.extension) {
        valid = true;
        break;
      }
    }
  }
  if (!valid) {
    return fn("invalid file type " + (notify.strong(path.relative(process.cwd(), filepath))));
  } else {
    return fn(null, new File(type, filepath, basepath, compiler, processors.module));
  }
};

File = (function() {

  function File(type, filepath, basepath, compiler, module) {
    this.type = type;
    this.filepath = filepath;
    this.basepath = basepath;
    this.compiler = compiler;
    this.module = module;
    this.name = path.basename(this.filepath);
    this.qualifiedName = path.relative(this.basepath, this.filepath).replace(path.extname(this.name), '');
    this.needsCompile = this.compiler != null;
    this.moduleID = this.module.getModuleID(this.qualifiedName);
    this.dependencies = [];
    this.content = '';
    this.dependant = null;
  }

  File.prototype.parseContent = function(fn) {
    var _this = this;
    if (this.content) {
      return process.nextTick(function() {
        return fn(null);
      });
    } else {
      return fs.readFile(this.filepath, 'utf8', function(err, content) {
        if (err) {
          return fn(err);
        }
        _this.content = content;
        return fn(null);
        _this.dependencies = _this.module.getModuleDependencies(content, _this.moduleID);
      });
    }
  };

  File.prototype.destroy = function() {};

  return File;

})();

/*

	# Read file contents
	# @param {Function} fn(err, data)
	parseContents: (fn) ->
		# Clear existing
		@_contents = ''
		# TODO: read stream and abort on header match
		# Read file
		fs.readFile @filepath, 'utf8', (err, data) =>
			return fn(err) if err
			# Skip compiled files
			return if data.match(RE_BUILT_HEADER)
			@_contents = data
			return fn(null, @_contents)

	# Return contents, compiled if necessary
	# @param {Object} options
	# @param {Function} fn(err, data)
	getContents: (options, fn) ->
		# Compile if necessary
		if @needsCompile then @_compile(options, fn) else fn(null, @_contents)

	destroy: ->
		@dependencies = null
		@compiler = null

	# Use the supplied compiler to compile file contents
	# @param {Object} options
	# @param {Function} fn(err, data)
	_compile: (options, fn) ->
		if @compiler?
			@compiler.compile @_contents, options.sources, (err, compiled) =>
				if err then fn(err, '') else fn(null, compiled)
		else
			fn("no compiler plugin available for #{nofify.strong(@filename)}", '')
*/

