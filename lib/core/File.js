// Generated by CoffeeScript 1.4.0
var ESCAPE_MAP, File, RE_BUILT_HEADER, RE_ESCAPE, async, debug, existsSync, fs, path, strong, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

async = require('async');

_ref = require('../utils/notify'), debug = _ref.debug, strong = _ref.strong;

existsSync = require('../utils/fs').existsSync;

RE_BUILT_HEADER = /^\/\*BUILT/g;

RE_ESCAPE = /\\|\r?\n|"/g;

ESCAPE_MAP = {
  '\\': '\\\\',
  '\n': '\\n',
  '\r\n': '\\n',
  '"': '\\"'
};

module.exports = function(type, filepath, basepath, options, fn) {
  var compiler, extension, name, valid, _ref1;
  filepath = path.resolve(filepath);
  if (!existsSync(filepath)) {
    return fn("" + (strong(filepath)) + " not found in project path");
  }
  extension = path.extname(filepath).slice(1);
  if (extension === type) {
    options.compile = false;
    valid = true;
  } else {
    _ref1 = options.processors.compilers;
    for (name in _ref1) {
      compiler = _ref1[name];
      if (extension === compiler.extension) {
        options.compile = type === 'js';
        options.compiler = compiler;
        valid = true;
        break;
      }
    }
  }
  if (!valid) {
    return fn("invalid file type " + (strong(path.relative(process.cwd(), filepath))));
  } else {
    if (type === 'css') {
      options.lazy = false;
    }
    options.compress = options.lazy && options.compress;
    options.module = options.processors.module;
    if (options.compress) {
      options.compressor = options.processors.compressor;
    }
    return fn(null, new File(type, filepath, basepath, options));
  }
};

File = (function() {

  function File(type, filepath, basepath, options) {
    this.type = type;
    this.filepath = filepath;
    this.basepath = basepath;
    this.options = options;
    this._escape = __bind(this._escape, this);

    this._compress = __bind(this._compress, this);

    this._compile = __bind(this._compile, this);

    this.name = path.basename(this.filepath);
    this.qualifiedName = path.relative(this.basepath, this.filepath).replace(path.extname(this.name), '');
    this.moduleID = this.options.module.getModuleID(this.qualifiedName);
    this.dependencies = [];
    this.isDependency = false;
    this._content = '';
    debug("created " + this.type + " File instance " + (strong(path.relative(process.cwd(), this.filepath))) + " with moduleID: " + (strong(this.moduleID)), 3);
  }

  File.prototype.parseContent = function(fn) {
    var _this = this;
    if (this._content) {
      return process.nextTick(function() {
        return fn();
      });
    } else {
      return fs.readFile(this.filepath, 'utf8', function(err, content) {
        if (err) {
          return fn(err);
        }
        if (content.match(RE_BUILT_HEADER)) {
          return fn();
        }
        _this._content = content;
        _this.dependencies = _this.options.module.getModuleDependencies(_this._content, _this.moduleID);
        return async.series([_this._compile, _this._compress, _this._escape], fn);
      });
    }
  };

  File.prototype.getContent = function(wrapped) {
    if (wrapped) {
      return this.options.module.wrapModuleContents(this._content, this.moduleID, this.options.lazy);
    } else {
      return this._content;
    }
  };

  File.prototype.clearContent = function() {
    return this._content = '';
  };

  File.prototype.reset = function() {
    this.dependencies = this._content ? this.options.module.getModuleDependencies(this._content, this.moduleID) : [];
    return this.isDependency = false;
  };

  File.prototype.destroy = function() {
    this.reset();
    this.clearContent();
    return this.options = null;
  };

  File.prototype._compile = function(fn) {
    var _this = this;
    if (this.options.compile) {
      return this.options.compiler.compile(this._content, function(err, compiled) {
        if (err) {
          return fn(err);
        }
        debug("compiled: " + (strong(path.relative(process.cwd(), _this.filepath))), 3);
        _this._content = compiled;
        return fn();
      });
    } else {
      return fn();
    }
  };

  File.prototype._compress = function(fn) {
    var _this = this;
    if (this.options.compress) {
      return this.options.compressor.compress(this._content, function(err, compressed) {
        if (err) {
          return fn(err);
        }
        debug("compressed: " + (strong(path.relative(process.cwd(), _this.filepath))), 3);
        _this._content = compressed;
        return fn();
      });
    } else {
      return fn();
    }
  };

  File.prototype._escape = function(fn) {
    if (this.options.lazy) {
      debug("escaped: " + (strong(path.relative(process.cwd(), this.filepath))), 3);
      this._content = '"' + this._content.replace(RE_ESCAPE, function(m) {
        return ESCAPE_MAP[m];
      }) + '"';
    }
    return fn();
  };

  return File;

})();
