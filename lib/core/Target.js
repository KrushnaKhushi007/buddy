// Generated by CoffeeScript 1.4.0
var BUILT_HEADER, Target, async, colour, debug, existsSync, fs, ignored, indir, mkdir, notify, path, print, readdir, strong, warn, _ref, _ref1,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

async = require('async');

notify = require('../utils/notify');

_ref = require('../utils/notify'), debug = _ref.debug, strong = _ref.strong, colour = _ref.colour, print = _ref.print, warn = _ref.warn;

_ref1 = require('../utils/fs'), indir = _ref1.indir, readdir = _ref1.readdir, mkdir = _ref1.mkdir, existsSync = _ref1.existsSync, ignored = _ref1.ignored;

BUILT_HEADER = '/*BUILT ';

module.exports = function(type, options, fn) {
  var inputpath, outputpath;
  inputpath = path.resolve(options.input);
  outputpath = path.resolve(options.output);
  if (!existsSync(inputpath)) {
    return fn("" + (strong(options.input)) + " doesn\'t exist");
  }
  return fs.stat(inputpath, function(err, stats) {
    var isDir, location, valid, _i, _len, _ref2, _ref3;
    if (err) {
      return fn(err);
    }
    isDir = stats.isDirectory();
    _ref2 = options.source.locations;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      location = _ref2[_i];
      valid = indir(location, inputpath);
      if (valid) {
        break;
      }
    }
    if (!valid) {
      return fn("" + (strong(options.input)) + " not found in source path");
    }
    if (isDir && path.extname(outputpath).length) {
      return fn("a file (" + (strong(options.output)) + ") is not a valid output target for a directory (" + (strong(options.input)) + ") input target");
    }
    if ((_ref3 = options.modular) == null) {
      options.modular = true;
    }
    if (options.compress) {
      options.compressor = options.processors.compressor;
    }
    if (options.lint) {
      options.linter = options.processors.linter;
    }
    return fn(null, new Target(type, isDir, options));
  });
};

Target = (function() {

  function Target(type, isDir, options) {
    this.type = type;
    this.isDir = isDir;
    this.options = options;
    this._write = __bind(this._write, this);

    this._compress = __bind(this._compress, this);

    this._lint = __bind(this._lint, this);

    this._compile = __bind(this._compile, this);

    this._outputFile = __bind(this._outputFile, this);

    this._parse = __bind(this._parse, this);

    debug("created " + this.type + " Target instance with input: " + (strong(this.options.input)) + " and output: " + (strong(this.options.output)), 2);
    this.input = path.resolve(this.options.input);
    this.output = path.resolve(this.options.output);
    this.sources = [];
    this.files = [];
    this._modified = [];
    if (!this.isDir) {
      this.concat = this.options.modular;
      if (!path.extname(this.output).length) {
        this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), "." + this.type);
      }
    } else {
      this.concat = this.type === 'css';
    }
  }

  Target.prototype.build = function(fn) {
    var _this = this;
    this.sources = [];
    this.files = [];
    if (!this.options.watching) {
      print("building " + (strong(path.basename(this.input))) + " to " + (strong(path.basename(this.output))), 2);
    }
    return this._parse(function(err) {
      if (err) {
        return fn(err);
      }
      if (_this.sources.length) {
        return async.forEach(_this.sources, _this._outputFile, function(err) {
          if (err) {
            return fn(err, _this.files);
          }
          return fn(null, _this.files);
        });
      } else {
        warn("no sources to build in " + (strong(_this.input)), 3);
        return fn(null, _this.files);
      }
    });
  };

  Target.prototype.hasSource = function(file) {
    return __indexOf.call(this.sources, file) >= 0 || this.options.hasParent && this.options.parent.hasSource(file);
  };

  Target.prototype.reset = function() {
    this._modified.map(function(file) {
      return file.reset();
    });
    this._modified = [];
    if (this.options.hasParent) {
      return this.options.parent.reset();
    }
  };

  Target.prototype._parse = function(fn) {
    var file, outstanding, parse,
      _this = this;
    outstanding = 0;
    parse = function(file, fn) {
      outstanding++;
      return file.parseContent(function(err) {
        if (err) {
          return fn(err);
        }
        if (_this.concat && file.dependencies.length) {
          file.dependencies.forEach(function(dependency, idx) {
            var dep;
            if (dep = _this.options.source.byModule[dependency] || _this.options.source.byModule["" + dependency + "/index"]) {
              if (!dep.isDependency) {
                _this._modified.push(dep);
                dep.isDependency = true;
                file.dependencies[idx] = dep;
                debug("added dependency " + (strong(dep.moduleID)) + " to " + (strong(file.moduleID)), 3);
                return parse(dep, fn);
              }
            } else {
              return warn("dependency " + (strong(dependency)) + " for " + (strong(file.moduleID)) + " not found", 4);
            }
          });
        }
        outstanding--;
        if (!outstanding) {
          return fn();
        }
      });
    };
    if (this.isDir) {
      return readdir(this.input, ignored, function(err, files) {
        return files.forEach(function(filepath) {
          var file;
          if (file = _this.options.source.byPath[filepath]) {
            if (!_this.hasSource(file)) {
              _this.sources.push(file);
              _this._modified.push(file);
              return parse(file, function(err) {
                if (err) {
                  return fn(err);
                }
                _this.sources = _this.sources.filter(function(file) {
                  return !file.isDependency;
                });
                if (!outstanding) {
                  return fn();
                }
              });
            } else {
              if (!outstanding) {
                return fn();
              }
            }
          }
        });
      });
    } else {
      if (file = this.options.source.byPath[this.input]) {
        if (!this.hasSource(file)) {
          this.sources.push(file);
          this._modified.push(file);
          return parse(file, fn);
        } else {
          return fn();
        }
      }
    }
  };

  Target.prototype._outputFile = function(file, fn) {
    var content, filepath,
      _this = this;
    if (this.concat) {
      content = file.options.module.concat(file);
      debug("concatenated: " + (strong(path.relative(process.cwd(), file.filepath))), 3);
    } else {
      content = file.getContent(this.options.modular);
    }
    filepath = path.extname(this.output).length ? this.output : path.join(this.output, file.qualifiedName) + '.' + this.type;
    return async.waterfall([
      (function(cb) {
        return _this._compile(content, filepath, file.options.compiler, cb);
      }), this._lint, this._compress, this._write
    ], function(err) {
      if (err) {
        return fn(err);
      }
      return fn();
    });
  };

  Target.prototype._compile = function(content, filepath, compiler, fn) {
    var _this = this;
    if (this.options.compile && compiler) {
      return compiler.compile(content, function(err, content) {
        if (err) {
          return fn(err);
        }
        debug("compiled: " + (strong(path.relative(process.cwd(), filepath))), 3);
        return fn(null, content, filepath);
      });
    } else {
      return fn(null, content, filepath);
    }
  };

  Target.prototype._lint = function(content, filepath, fn) {
    var _this = this;
    if (this.options.lint) {
      return this.options.linter.lint(content, function(err) {
        if (err) {
          warn('failed linting', 3);
          err.items.forEach(function(item) {
            if (item) {
              print("[" + (colour(item.line, notify.CYAN)) + ":" + (colour(item.col, notify.CYAN)) + "] " + item.reason + ":", 4);
              if (item.evidence) {
                return print("" + (strong(item.evidence)), 5);
              }
            }
          });
        } else {
          print("" + (colour('linted', GREEN)) + " " + (strong(path.relative(process.cwd(), filepath))), 3);
        }
        return fn(null, content, filepath);
      });
    } else {
      return fn(null, content, filepath);
    }
  };

  Target.prototype._compress = function(content, filepath, fn) {
    var _this = this;
    if (this.options.compress) {
      return this.options.compressor.compress(content, function(err, content) {
        if (err) {
          return fn(err);
        }
        print("" + (colour('compressed', notify.GREEN)) + " " + (strong(path.relative(process.cwd(), filepath))), 3);
        return fn(null, content, filepath);
      });
    } else {
      return fn(null, content, filepath);
    }
  };

  Target.prototype._write = function(content, filepath, fn) {
    var _this = this;
    return mkdir(filepath, function(err) {
      if (err) {
        return fn(err);
      }
      if (_this.concat) {
        content = "" + BUILT_HEADER + (new Date().toString()) + "*/\n" + content;
      }
      return fs.writeFile(filepath, content, 'utf8', function(err) {
        if (err) {
          return fn(err);
        }
        _this.files.push(filepath);
        print("" + (colour('built', notify.GREEN)) + " " + (strong(path.relative(process.cwd(), filepath))), _this.options.watching ? 4 : 3);
        return fn();
      });
    });
  };

  return Target;

})();
