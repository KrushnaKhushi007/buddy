// Generated by CoffeeScript 1.4.0
var RE_IGNORE_FILE, Target, async, existsSync, fs, notify, path, readdir, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

async = require('async');

_ref = require('./utils'), notify = _ref.notify, readdir = _ref.readdir, existsSync = _ref.existsSync;

RE_IGNORE_FILE = /^[\._~]|[-\.]min[-\.]|svn|~$/;

module.exports = Target = (function() {

  function Target(type, input, output, options) {
    this.type = type;
    this.input = input;
    this.output = output;
    this.options = options;
    this._readfile = __bind(this._readfile, this);

    this.sources = {};
    if (path.extname(this.input).length) {
      this.batch = !this.options.modular;
      if (!path.extname(this.output).length) {
        this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), "." + this.type);
      }
    } else {
      this.batch = true;
    }
  }

  Target.prototype.build = function(compress, lint, fn) {
    return this.sources = {};
  };

  Target.prototype._parse = function(fn) {
    var _this = this;
    if (this.batch) {
      if (path.extname(this.input).length) {
        return this._readfile(this.input, function(err, content) {
          if (err) {
            return fn(err);
          }
          this.sources[this.input] = content;
          return fn();
        });
      } else {
        return readdir(this.input, RE_IGNORE_FILE, function(err, files) {
          if (err) {
            return fn(err);
          }
          return async.map(files, _this._readfile, function(err, contents) {
            if (err) {
              return fn(err);
            }
            files.forEach(function(file, idx) {
              return _this.sources[file] = contents[idx];
            });
            return fn();
          });
        });
      }
    } else {

    }
  };

  Target.prototype._readfile = function(filepath, fn) {
    return fs.readfile(filepath, 'utf8', function(err, content) {
      if (err) {
        return fn(err);
      } else {
        return fn(null, content);
      }
    });
  };

  return Target;

})();

/*
	# Constructor
	# @param {String} type
	# @param {String} input
	# @param {String} output
	# @param {Object} fileCache
	# @param {Object} options
	constructor: (@type, @input, @output, @fileCache, @options) ->
		@sources = []
		@files = []
		@concat = false
		@watching = false
		# Resolve output file name for file>directory target
		if not path.extname(@output).length and fs.statSync(@input).isFile()
			@output = path.join(@output, path.basename(@input)).replace(path.extname(@input), ".#{@type}")

	# Process the target, optionally compressing and linting output
	# @param {Boolean} compress
	# @param {Boolean} lint
	# @param {Function} fn(err, files)
	run: (compress, lint, fn) ->
		# Clear existing sources
		@sources = []
		@files = []
		# Parse sources and build
		@_parseSources(@input)
		if @sources.length
			notify.print("building #{notify.strong(path.basename(@input))} to #{notify.strong(path.basename(@output))}", 2) unless @watching
			@_build(compress, lint, fn)
		else
			notify.warn("no sources to build in #{notify.strong(@input)}", 2)
			fn()

	# Determine if a File is included in a target's sources
	# @param {File} file
	# @return	{Boolean}
	hasSource: (file) ->
		file in @sources

	# Recursively add File objects from file cache based on 'input' path
	# @param {String} input
	# @param {Function} fn(err)
	_parseSources: (input, fn) ->
		# Add files from source cache
		fs.stat input, (err, stats) =>
			if err
				fn(err)
			else
				if stats.isFile()
					if file = @fileCache.byPath[input]
						file.parseContents(@options.modular)
						@_addSource(file)
				else
					# Recurse child directories
					fs.readdir input, (err, files) =>
						if err
							fn(err)
						else
							files.forEach (file) =>
								@_parseSources(path.join(input, file))

	# Add a File object to the source store if not already added
	# @param {File} file
	_addSource: (file) ->
		@sources.push(file) if file not in @sources

	_lint: (content, filepath) ->
		if @options.linter?
			@options.linter.lint content, (err) =>
				if err
					notify.warn('failed linting', 4)
					err.items.forEach (item) =>
						notify.print("[#{item.line}:#{item.col}] #{item.reason}", 5)
				else
					notify.print("#{notify.colour('passed linting', notify.GREEN)} #{notify.strong(path.basename(filepath))}", 4)

	_compress: (content, filepath, fn) ->
		if @options.compressor?
			@options.compressor.compress content, (err, content) =>
				if err
					fn(err)
				else
					notify.print("#{notify.colour('compressed', notify.GREEN)} #{notify.strong(path.basename(filepath))}", 3)
					fn(null, content)
*/

