// Generated by CoffeeScript 1.4.0
var Target, async, existsSync, fs, ignored, indir, notify, path, readdir, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

async = require('async');

notify = require('../utils/notify');

_ref = require('../utils/fs'), indir = _ref.indir, readdir = _ref.readdir, existsSync = _ref.existsSync, ignored = _ref.ignored;

module.exports = function(type, options, processors, fn) {
  var inputpath, outputpath;
  inputpath = path.resolve(options.input);
  outputpath = path.resolve(options.output);
  if (!existsSync(inputpath)) {
    return fn("" + (notify.strong(options.input)) + " not found in project path");
  }
  return fs.stat(inputpath, function(err, stats) {
    var isDir, location, valid, _i, _len, _ref1;
    if (err) {
      return fn(err);
    }
    isDir = stats.isDirectory();
    _ref1 = options.source.locations;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      location = _ref1[_i];
      valid = indir(location, inputpath);
      if (valid) {
        break;
      }
    }
    if (!valid) {
      return fn("" + (notify.strong(options.input)) + " not found in source path");
    }
    if (isDir && path.extname(outputpath).length) {
      return fn("a file (" + (notify.strong(options.output)) + ") is not a valid output target for a directory (" + (notify.strong(options.input)) + ") input target");
    }
    return fn(null, new Target(type, isDir, options, processors));
  });
};

Target = (function() {

  function Target(type, isDir, options, processors) {
    this.type = type;
    this.isDir = isDir;
    this.options = options;
    this.processors = processors;
    this.input = path.resolve(this.options.input);
    this.output = path.resolve(this.options.output);
    this.sources = [];
    this.files = [];
    if (!this.isDir) {
      this.concat = this.options.modular;
      if (!path.extname(this.output).length) {
        this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), "." + this.type);
      }
    } else {
      this.concat = this.type === 'css';
    }
  }

  Target.prototype.build = function(compress, lint, fn) {
    var _this = this;
    this.sources = [];
    this.files = [];
    return this._parse(function() {
      if (_this.sources.length) {
        return notify.print("building " + (notify.strong(path.basename(_this.input))) + " to " + (notify.strong(path.basename(_this.output))), 2);
      } else {
        notify.warn("no sources to build in " + (notify.strong(_this.input)), 2);
        return fn(null, _this.files);
      }
    });
  };

  Target.prototype.hasSource = function(file) {
    return __indexOf.call(this.sources, file) >= 0 || this.options.parent && this.options.parent.hasSource(file);
  };

  Target.prototype._parse = function(fn) {
    var file, outstanding, parse,
      _this = this;
    outstanding = 0;
    parse = function(file, fn) {
      outstanding++;
      return file.parseContent(function(err) {
        outstanding--;
        if (err) {
          notify.warn("failed parsing contents of " + (notify.strong(path.relative(process.cwd(), file.filepath))), 4);
        }
        if (_this.concat && file.dependencies.length) {
          file.dependencies.forEach(function(dependency, idx) {
            var dep;
            if (dep = _this.options.source.byModule[dependency] || _this.options.source.byModule["" + dependency + "/index"]) {
              dep.dependant = file;
              file.dependencies[idx] = dep;
              if (dep.dependencies.length) {
                return parse(dep);
              }
            } else {
              return notify.warn("dependency " + (notify.strong(dependency)) + " for " + (notify.strong(file.moduleId)) + " not found", 4);
            }
          });
        }
        if (!outstanding) {
          return fn();
        }
      });
    };
    if (this.isDir) {
      return readdir(this.input, ignored, function(err, files) {
        return files.forEach(function(filepath) {
          var file;
          if (file = _this.options.source.byPath[filepath]) {
            _this.sources.push(file);
            return parse(file, function() {
              _this.sources = _this.sources.filter(function(file) {
                return !file.dependant;
              });
              return fn();
            });
          }
        });
      });
    } else {
      if (file = this.options.source.byPath[this.input]) {
        this.sources.push(file);
        return parse(file, fn);
      }
    }
  };

  Target.prototype._add = function(file, fn) {
    var add, outstanding,
      _this = this;
    outstanding = 0;
    add = function(file) {
      if (!file.dependant) {
        _this.sources.push(file);
      }
      outstanding++;
      return file.parseContent(function(err) {
        outstanding--;
        if (err) {
          return fn(err);
        }
        if (_this.concat && file.dependencies.length) {
          file.dependencies.forEach(function(dependency, idx) {
            var dep;
            if (dep = _this.options.source.byModule[dependency] || _this.options.source.byModule["" + dependency + "/index"]) {
              dep.dependant = true;
              file.dependencies[idx] = dep;
              if (dep.dependencies.length) {
                return add(dep);
              }
            } else {
              return notify.warn("dependency " + (notify.strong(dependency)) + " for " + (notify.strong(file.moduleId)) + " not found", 4);
            }
          });
        }
        if (!outstanding) {
          return fn();
        }
      });
    };
    if (this.hasSource(file)) {
      return fn();
    } else {
      file.dependant = false;
      return add(file);
    }
  };

  Target.prototype._concat = function(fn) {
    var contents;
    return contents = this.sources.map(function(file) {
      return file.content;
    });
  };

  return Target;

})();

/*
	# Recursively add File objects from file cache based on 'input' path
	# @param {String} input
	# @param {Function} fn(err)
	_parseSources: (input, fn) ->
		# Add files from source cache
		fs.stat input, (err, stats) =>
			if err
				fn(err)
			else
				if stats.isFile()
					if file = @fileCache.byPath[input]
						file.parseContents(@options.modular)
						@_addSource(file)
				else
					# Recurse child directories
					fs.readdir input, (err, files) =>
						if err
							fn(err)
						else
							files.forEach (file) =>
								@_parseSources(path.join(input, file))

	# Add a File object to the source store if not already added
	# @param {File} file
	_addSource: (file) ->
		@sources.push(file) if file not in @sources

	_lint: (content, filepath) ->
		if @options.linter?
			@options.linter.lint content, (err) =>
				if err
					notify.warn('failed linting', 4)
					err.items.forEach (item) =>
						notify.print("[#{item.line}:#{item.col}] #{item.reason}", 5)
				else
					notify.print("#{notify.colour('passed linting', notify.GREEN)} #{notify.strong(path.basename(filepath))}", 4)

	_compress: (content, filepath, fn) ->
		if @options.compressor?
			@options.compressor.compress content, (err, content) =>
				if err
					fn(err)
				else
					notify.print("#{notify.colour('compressed', notify.GREEN)} #{notify.strong(path.basename(filepath))}", 3)
					fn(null, content)
*/

