// Generated by CoffeeScript 1.4.0
var BUILT_HEADER, Target, async, existsSync, fs, ignored, indir, mkdir, notify, path, readdir, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

async = require('async');

notify = require('../utils/notify');

_ref = require('../utils/fs'), indir = _ref.indir, readdir = _ref.readdir, mkdir = _ref.mkdir, existsSync = _ref.existsSync, ignored = _ref.ignored;

BUILT_HEADER = '/*BUILT ';

module.exports = function(type, options, processors, fn) {
  var inputpath, outputpath;
  inputpath = path.resolve(options.input);
  outputpath = path.resolve(options.output);
  if (!existsSync(inputpath)) {
    return fn("" + (notify.strong(options.input)) + " not found in project path");
  }
  return fs.stat(inputpath, function(err, stats) {
    var isDir, location, valid, _i, _len, _ref1;
    if (err) {
      return fn(err);
    }
    isDir = stats.isDirectory();
    _ref1 = options.source.locations;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      location = _ref1[_i];
      valid = indir(location, inputpath);
      if (valid) {
        break;
      }
    }
    if (!valid) {
      return fn("" + (notify.strong(options.input)) + " not found in source path");
    }
    if (isDir && path.extname(outputpath).length) {
      return fn("a file (" + (notify.strong(options.output)) + ") is not a valid output target for a directory (" + (notify.strong(options.input)) + ") input target");
    }
    return fn(null, new Target(type, isDir, options, processors));
  });
};

Target = (function() {

  function Target(type, isDir, options, processors) {
    this.type = type;
    this.isDir = isDir;
    this.options = options;
    this.processors = processors;
    this._write = __bind(this._write, this);

    this._compress = __bind(this._compress, this);

    this._lint = __bind(this._lint, this);

    this._compile = __bind(this._compile, this);

    this.input = path.resolve(this.options.input);
    this.output = path.resolve(this.options.output);
    this.sources = [];
    this.files = [];
    this.compress = false;
    this.lint = false;
    this.compile = this.type === 'css';
    if (!this.isDir) {
      this.concat = this.options.modular;
      if (!path.extname(this.output).length) {
        this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), "." + this.type);
      }
    } else {
      this.concat = this.type === 'css';
    }
  }

  Target.prototype.build = function(compress, lint, fn) {
    var _this = this;
    this.compress = compress;
    this.lint = lint;
    this.sources = [];
    this.files = [];
    return this._parse(function(err) {
      if (err) {
        return fn(err);
      }
      if (_this.sources.length) {
        if (!_this.watching) {
          notify.print("building " + (notify.strong(path.basename(_this.input))) + " to " + (notify.strong(path.basename(_this.output))), 2);
        }
        return async.forEach(_this.sources, _this._outputFile, function(err, content) {});
      } else {
        notify.warn("no sources to build in " + (notify.strong(_this.input)), 2);
        return fn(null, _this.files);
      }
    });
  };

  Target.prototype.hasSource = function(file) {
    return __indexOf.call(this.sources, file) >= 0 || this.options.parent && this.options.parent.hasSource(file);
  };

  Target.prototype._parse = function(fn) {
    var file, outstanding, parse,
      _this = this;
    outstanding = 0;
    parse = function(file, fn) {
      outstanding++;
      if (!file.content) {
        return file.parseContent(!_this.compile, function(err) {
          if (err) {
            return fn(err);
          }
          if (_this.concat && file.dependencies.length) {
            file.dependencies.forEach(function(dependency, idx) {
              var dep;
              if (dep = _this.options.source.byModule[dependency] || _this.options.source.byModule["" + dependency + "/index"]) {
                if (!dep.isDependency) {
                  dep.isDependency = true;
                  file.dependencies[idx] = dep;
                  return parse(dep, fn);
                }
              } else {
                return notify.warn("dependency " + (notify.strong(dependency)) + " for " + (notify.strong(file.moduleID)) + " not found", 4);
              }
            });
          }
          outstanding--;
          if (!outstanding) {
            return fn();
          }
        });
      } else {
        outstanding--;
        if (!outstanding) {
          return fn();
        }
      }
    };
    if (this.isDir) {
      return readdir(this.input, ignored, function(err, files) {
        return files.forEach(function(filepath) {
          var file;
          if (file = _this.options.source.byPath[filepath]) {
            if (!_this.hasSource(file)) {
              _this.sources.push(file);
              return parse(file, function(err) {
                if (err) {
                  return fn(err);
                }
                _this.sources = _this.sources.filter(function(file) {
                  return !file.isDependency;
                });
                return fn();
              });
            } else {
              if (!outstanding) {
                return fn();
              }
            }
          }
        });
      });
    } else {
      if (file = this.options.source.byPath[this.input]) {
        if (!this.hasSource(file)) {
          this.sources.push(file);
          return parse(file, fn);
        } else {
          return fn();
        }
      }
    }
  };

  Target.prototype._outputFile = function(file, fn) {
    var content, filepath,
      _this = this;
    content = file.module.concat(file);
    filepath = path.extname(this.output).length ? this.output : path.join(this.output, file.qualifiedName) + '.' + this.type;
    return async.waterfall([
      (function(cb) {
        return _this._compile(content, filepath, file.compiler, cb);
      }), this._lint, this._compress, this._write
    ], function(err) {
      if (err) {
        return fn(err);
      }
      return fn();
    });
  };

  Target.prototype._compile = function(content, filepath, compiler, fn) {
    var _this = this;
    if (this.compile && compiler) {
      return compiler.compile(content, function(err, content) {
        if (err) {
          return fn(err);
        }
        return fn(null, content, filepath);
      });
    } else {
      return fn(null, content, filepath);
    }
  };

  Target.prototype._lint = function(content, filepath, fn) {
    return fn(null, content, filepath);
  };

  Target.prototype._compress = function(content, filepath, fn) {
    var _this = this;
    if (this.compress) {
      return this.processors.compressor.compress(content, function(err, content) {
        if (err) {
          return fn(err);
        }
        notify.print("" + (notify.colour('compressed', notify.GREEN)) + " " + (notify.strong(path.relative(process.cwd(), filepath))), 3);
        return fn(null, content, filepath);
      });
    } else {
      return fn(null, content, filepath);
    }
  };

  Target.prototype._write = function(content, filepath, fn) {
    var _this = this;
    return mkdir(filepath, function(err) {
      if (err) {
        return fn(err);
      }
      if (_this.concat) {
        content = "" + BUILT_HEADER + (new Date().toString()) + "*/\n" + content;
      }
      return fs.writeFile(filepath, content, 'utf8', function(err) {
        if (err) {
          return fn(err);
        }
        _this.files.push(filepath);
        notify.print("" + (notify.colour('built', notify.GREEN)) + " " + (notify.strong(path.relative(process.cwd(), filepath))), _this.watching ? 4 : 3);
        return fn();
      });
    });
  };

  return Target;

})();

/*
	_lint: (content, filepath) ->
		if @options.linter?
			@options.linter.lint content, (err) =>
				if err
					notify.warn('failed linting', 4)
					err.items.forEach (item) =>
						notify.print("[#{item.line}:#{item.col}] #{item.reason}", 5)
				else
					notify.print("#{notify.colour('passed linting', notify.GREEN)} #{notify.strong(path.basename(filepath))}", 4)
*/

