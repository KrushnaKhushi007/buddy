/** BUDDY BUILT **/
var $m = {};
var originalRequire = require;
require = function buddyRequire (id) {
  if (!$m[id]) return originalRequire(id);
  if ('function' == typeof $m[id]) $m[id]();
  return $m[id].exports;
};
/*== node_modules/babel-runtime/cor...ct/get-own-property-symbols.js ==*/
$m['babel-runtime/core-js/object/get-own-property-symbols.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/object/get-own-property-symbols.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/cor...ct/get-own-property-symbols.js ≠≠*/

/*== node_modules/babel-runtime/core-js/get-iterator.js ==*/
$m['babel-runtime/core-js/get-iterator.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/get-iterator.js ≠≠*/

/*== node_modules/babel-runtime/core-js/object/keys.js ==*/
$m['babel-runtime/core-js/object/keys.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/object/keys.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/object/keys.js ≠≠*/

/*== node_modules/babel-runtime/core-js/json/stringify.js ==*/
$m['babel-runtime/core-js/json/stringify.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/json/stringify.js ≠≠*/

/*== node_modules/babel-types/lib/constants.js ==*/
$m['babel-types/lib/constants.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/constants.js#6.16.0'].exports.__esModule = true;
$m['babel-types/lib/constants.js#6.16.0'].exports.NOT_LOCAL_BINDING = $m['babel-types/lib/constants.js#6.16.0'].exports.BLOCK_SCOPED_SYMBOL = $m['babel-types/lib/constants.js#6.16.0'].exports.INHERIT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.STRING_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.NUMBER_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.NUMBER_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.COMPARISON_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.EQUALITY_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_NUMBER_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.UPDATE_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.LOGICAL_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.COMMENT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.FOR_INIT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.FLATTENABLE_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _babeltypeslibconstantsjs6160__for = $m['babel-runtime/core-js/symbol/for.js#6.11.6'].exports;

var _babeltypeslibconstantsjs6160__for2 = _babeltypeslibconstantsjs6160__interopRequireDefault(_babeltypeslibconstantsjs6160__for);

function _babeltypeslibconstantsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltypeslibconstantsjs6160_STATEMENT_OR_BLOCK_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
var _babeltypeslibconstantsjs6160_FLATTENABLE_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.FLATTENABLE_KEYS = ["body", "expressions"];
var _babeltypeslibconstantsjs6160_FOR_INIT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.FOR_INIT_KEYS = ["left", "init"];
var _babeltypeslibconstantsjs6160_COMMENT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];

var _babeltypeslibconstantsjs6160_LOGICAL_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.LOGICAL_OPERATORS = ["||", "&&"];
var _babeltypeslibconstantsjs6160_UPDATE_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.UPDATE_OPERATORS = ["++", "--"];

var _babeltypeslibconstantsjs6160_BOOLEAN_NUMBER_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
var _babeltypeslibconstantsjs6160_EQUALITY_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
var _babeltypeslibconstantsjs6160_COMPARISON_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.COMPARISON_BINARY_OPERATORS = [].concat(_babeltypeslibconstantsjs6160_EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
var _babeltypeslibconstantsjs6160_BOOLEAN_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_BINARY_OPERATORS = [].concat(_babeltypeslibconstantsjs6160_COMPARISON_BINARY_OPERATORS, _babeltypeslibconstantsjs6160_BOOLEAN_NUMBER_BINARY_OPERATORS);
var _babeltypeslibconstantsjs6160_NUMBER_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
var _babeltypeslibconstantsjs6160_BINARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BINARY_OPERATORS = ["+"].concat(_babeltypeslibconstantsjs6160_NUMBER_BINARY_OPERATORS, _babeltypeslibconstantsjs6160_BOOLEAN_BINARY_OPERATORS);

var _babeltypeslibconstantsjs6160_BOOLEAN_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
var _babeltypeslibconstantsjs6160_NUMBER_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.NUMBER_UNARY_OPERATORS = ["+", "-", "++", "--", "~"];
var _babeltypeslibconstantsjs6160_STRING_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.STRING_UNARY_OPERATORS = ["typeof"];
var _babeltypeslibconstantsjs6160_UNARY_OPERATORS = $m['babel-types/lib/constants.js#6.16.0'].exports.UNARY_OPERATORS = ["void"].concat(_babeltypeslibconstantsjs6160_BOOLEAN_UNARY_OPERATORS, _babeltypeslibconstantsjs6160_NUMBER_UNARY_OPERATORS, _babeltypeslibconstantsjs6160_STRING_UNARY_OPERATORS);

var _babeltypeslibconstantsjs6160_INHERIT_KEYS = $m['babel-types/lib/constants.js#6.16.0'].exports.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};

var _babeltypeslibconstantsjs6160_BLOCK_SCOPED_SYMBOL = $m['babel-types/lib/constants.js#6.16.0'].exports.BLOCK_SCOPED_SYMBOL = (0, _babeltypeslibconstantsjs6160__for2.default)("var used to be block scoped");
var _babeltypeslibconstantsjs6160_NOT_LOCAL_BINDING = $m['babel-types/lib/constants.js#6.16.0'].exports.NOT_LOCAL_BINDING = (0, _babeltypeslibconstantsjs6160__for2.default)("should not be considered a local binding");
/*≠≠ node_modules/babel-types/lib/constants.js ≠≠*/

/*== node_modules/babel-types/lib/retrievers.js ==*/
$m['babel-types/lib/retrievers.js#6.16.0'] = function () {
$m['babel-types/lib/retrievers.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/retrievers.js#6.16.0'].exports.__esModule = true;

var _babeltypeslibretrieversjs6160__create = $m['babel-runtime/core-js/object/create.js#6.11.6'].exports;

var _babeltypeslibretrieversjs6160__create2 = _babeltypeslibretrieversjs6160__interopRequireDefault(_babeltypeslibretrieversjs6160__create);

$m['babel-types/lib/retrievers.js#6.16.0'].exports.getBindingIdentifiers = _babeltypeslibretrieversjs6160_getBindingIdentifiers;
$m['babel-types/lib/retrievers.js#6.16.0'].exports.getOuterBindingIdentifiers = _babeltypeslibretrieversjs6160_getOuterBindingIdentifiers;

var _babeltypeslibretrieversjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibretrieversjs6160_t = _babeltypeslibretrieversjs6160__interopRequireWildcard(_babeltypeslibretrieversjs6160__index);

function _babeltypeslibretrieversjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibretrieversjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltypeslibretrieversjs6160_getBindingIdentifiers(node, duplicates, outerOnly) {
  var search = [].concat(node);
  var ids = (0, _babeltypeslibretrieversjs6160__create2.default)(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;

    var keys = _babeltypeslibretrieversjs6160_t.getBindingIdentifiers.keys[id.type];

    if (_babeltypeslibretrieversjs6160_t.isIdentifier(id)) {
      if (duplicates) {
        var _ids = ids[id.name] = ids[id.name] || [];
        _ids.push(id);
      } else {
        ids[id.name] = id;
      }
      continue;
    }

    if (_babeltypeslibretrieversjs6160_t.isExportDeclaration(id)) {
      if (_babeltypeslibretrieversjs6160_t.isDeclaration(node.declaration)) {
        search.push(node.declaration);
      }
      continue;
    }

    if (outerOnly) {
      if (_babeltypeslibretrieversjs6160_t.isFunctionDeclaration(id)) {
        search.push(id.id);
        continue;
      }

      if (_babeltypeslibretrieversjs6160_t.isFunctionExpression(id)) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

_babeltypeslibretrieversjs6160_getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],

  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],

  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],

  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],

  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],

  ClassDeclaration: ["id"],
  ClassExpression: ["id"],

  RestElement: ["argument"],
  UpdateExpression: ["argument"],

  RestProperty: ["argument"],
  ObjectProperty: ["value"],

  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],

  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

function _babeltypeslibretrieversjs6160_getOuterBindingIdentifiers(node, duplicates) {
  return _babeltypeslibretrieversjs6160_getBindingIdentifiers(node, duplicates, true);
}
};
/*≠≠ node_modules/babel-types/lib/retrievers.js ≠≠*/

/*== node_modules/babel-types/lib/validators.js ==*/
$m['babel-types/lib/validators.js#6.16.0'] = function () {
$m['babel-types/lib/validators.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/validators.js#6.16.0'].exports.__esModule = true;

var _babeltypeslibvalidatorsjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltypeslibvalidatorsjs6160__getIterator3 = _babeltypeslibvalidatorsjs6160__interopRequireDefault(_babeltypeslibvalidatorsjs6160__getIterator2);

$m['babel-types/lib/validators.js#6.16.0'].exports.isBinding = _babeltypeslibvalidatorsjs6160_isBinding;
$m['babel-types/lib/validators.js#6.16.0'].exports.isReferenced = _babeltypeslibvalidatorsjs6160_isReferenced;
$m['babel-types/lib/validators.js#6.16.0'].exports.isValidIdentifier = _babeltypeslibvalidatorsjs6160_isValidIdentifier;
$m['babel-types/lib/validators.js#6.16.0'].exports.isLet = _babeltypeslibvalidatorsjs6160_isLet;
$m['babel-types/lib/validators.js#6.16.0'].exports.isBlockScoped = _babeltypeslibvalidatorsjs6160_isBlockScoped;
$m['babel-types/lib/validators.js#6.16.0'].exports.isVar = _babeltypeslibvalidatorsjs6160_isVar;
$m['babel-types/lib/validators.js#6.16.0'].exports.isSpecifierDefault = _babeltypeslibvalidatorsjs6160_isSpecifierDefault;
$m['babel-types/lib/validators.js#6.16.0'].exports.isScope = _babeltypeslibvalidatorsjs6160_isScope;
$m['babel-types/lib/validators.js#6.16.0'].exports.isImmutable = _babeltypeslibvalidatorsjs6160_isImmutable;

var _babeltypeslibvalidatorsjs6160__retrievers = require("babel-types/lib/retrievers.js#6.16.0");

var _babeltypeslibvalidatorsjs6160__esutils = $m['esutils/lib/utils.js#2.0.2'].exports;

var _babeltypeslibvalidatorsjs6160__esutils2 = _babeltypeslibvalidatorsjs6160__interopRequireDefault(_babeltypeslibvalidatorsjs6160__esutils);

var _babeltypeslibvalidatorsjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibvalidatorsjs6160_t = _babeltypeslibvalidatorsjs6160__interopRequireWildcard(_babeltypeslibvalidatorsjs6160__index);

var _babeltypeslibvalidatorsjs6160__constants = $m['babel-types/lib/constants.js#6.16.0'].exports;

function _babeltypeslibvalidatorsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibvalidatorsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltypeslibvalidatorsjs6160_isBinding(node, parent) {
  var keys = _babeltypeslibvalidatorsjs6160__retrievers.getBindingIdentifiers.keys[parent.type];
  if (keys) {
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

function _babeltypeslibvalidatorsjs6160_isReferenced(node, parent) {
  switch (parent.type) {
    case "BindExpression":
      return parent.object === node || parent.callee === node;

    case "MemberExpression":
    case "JSXMemberExpression":
      if (parent.property === node && parent.computed) {
        return true;
      } else if (parent.object === node) {
        return true;
      } else {
        return false;
      }

    case "MetaProperty":
      return false;

    case "ObjectProperty":
      if (parent.key === node) {
        return parent.computed;
      }

    case "VariableDeclarator":
      return parent.id !== node;

    case "ArrowFunctionExpression":
    case "FunctionDeclaration":
    case "FunctionExpression":
      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltypeslibvalidatorsjs6160__getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var param = _ref;

        if (param === node) return false;
      }

      return parent.id !== node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      } else {
        return parent.local === node;
      }

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "JSXAttribute":
      return parent.name !== node;

    case "ClassProperty":
      if (parent.key === node) {
        return parent.computed;
      } else {
        return parent.value === node;
      }

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.id !== node;

    case "ClassMethod":
    case "ObjectMethod":
      return parent.key === node && parent.computed;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return parent.param !== node;

    case "RestElement":
      return false;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;
  }

  return true;
}

function _babeltypeslibvalidatorsjs6160_isValidIdentifier(name) {
  if (typeof name !== "string" || _babeltypeslibvalidatorsjs6160__esutils2.default.keyword.isReservedWordES6(name, true)) {
    return false;
  } else {
    return _babeltypeslibvalidatorsjs6160__esutils2.default.keyword.isIdentifierNameES6(name);
  }
}

function _babeltypeslibvalidatorsjs6160_isLet(node) {
  return _babeltypeslibvalidatorsjs6160_t.isVariableDeclaration(node) && (node.kind !== "var" || node[_babeltypeslibvalidatorsjs6160__constants.BLOCK_SCOPED_SYMBOL]);
}

function _babeltypeslibvalidatorsjs6160_isBlockScoped(node) {
  return _babeltypeslibvalidatorsjs6160_t.isFunctionDeclaration(node) || _babeltypeslibvalidatorsjs6160_t.isClassDeclaration(node) || _babeltypeslibvalidatorsjs6160_t.isLet(node);
}

function _babeltypeslibvalidatorsjs6160_isVar(node) {
  return _babeltypeslibvalidatorsjs6160_t.isVariableDeclaration(node, { kind: "var" }) && !node[_babeltypeslibvalidatorsjs6160__constants.BLOCK_SCOPED_SYMBOL];
}

function _babeltypeslibvalidatorsjs6160_isSpecifierDefault(specifier) {
  return _babeltypeslibvalidatorsjs6160_t.isImportDefaultSpecifier(specifier) || _babeltypeslibvalidatorsjs6160_t.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
}

function _babeltypeslibvalidatorsjs6160_isScope(node, parent) {
  if (_babeltypeslibvalidatorsjs6160_t.isBlockStatement(node) && _babeltypeslibvalidatorsjs6160_t.isFunction(parent, { body: node })) {
    return false;
  }

  return _babeltypeslibvalidatorsjs6160_t.isScopable(node);
}

function _babeltypeslibvalidatorsjs6160_isImmutable(node) {
  if (_babeltypeslibvalidatorsjs6160_t.isType(node.type, "Immutable")) return true;

  if (_babeltypeslibvalidatorsjs6160_t.isIdentifier(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}
};
/*≠≠ node_modules/babel-types/lib/validators.js ≠≠*/

/*== node_modules/babel-types/lib/converters.js ==*/
$m['babel-types/lib/converters.js#6.16.0'] = function () {
$m['babel-types/lib/converters.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/converters.js#6.16.0'].exports.__esModule = true;

var _babeltypeslibconvertersjs6160__maxSafeInteger = $m['babel-runtime/core-js/number/max-safe-integer.js#6.11.6'].exports;

var _babeltypeslibconvertersjs6160__maxSafeInteger2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__maxSafeInteger);

var _babeltypeslibconvertersjs6160__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babeltypeslibconvertersjs6160__stringify2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__stringify);

var _babeltypeslibconvertersjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltypeslibconvertersjs6160__getIterator3 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__getIterator2);

$m['babel-types/lib/converters.js#6.16.0'].exports.toComputedKey = _babeltypeslibconvertersjs6160_toComputedKey;
$m['babel-types/lib/converters.js#6.16.0'].exports.toSequenceExpression = _babeltypeslibconvertersjs6160_toSequenceExpression;
$m['babel-types/lib/converters.js#6.16.0'].exports.toKeyAlias = _babeltypeslibconvertersjs6160_toKeyAlias;
$m['babel-types/lib/converters.js#6.16.0'].exports.toIdentifier = _babeltypeslibconvertersjs6160_toIdentifier;
$m['babel-types/lib/converters.js#6.16.0'].exports.toBindingIdentifierName = _babeltypeslibconvertersjs6160_toBindingIdentifierName;
$m['babel-types/lib/converters.js#6.16.0'].exports.toStatement = _babeltypeslibconvertersjs6160_toStatement;
$m['babel-types/lib/converters.js#6.16.0'].exports.toExpression = _babeltypeslibconvertersjs6160_toExpression;
$m['babel-types/lib/converters.js#6.16.0'].exports.toBlock = _babeltypeslibconvertersjs6160_toBlock;
$m['babel-types/lib/converters.js#6.16.0'].exports.valueToNode = _babeltypeslibconvertersjs6160_valueToNode;

var _babeltypeslibconvertersjs6160__isPlainObject = $m['lodash/isPlainObject.js#4.16.2'].exports;

var _babeltypeslibconvertersjs6160__isPlainObject2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__isPlainObject);

var _babeltypeslibconvertersjs6160__isNumber = $m['lodash/isNumber.js#4.16.2'].exports;

var _babeltypeslibconvertersjs6160__isNumber2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__isNumber);

var _babeltypeslibconvertersjs6160__isRegExp = $m['lodash/isRegExp.js#4.16.2'].exports;

var _babeltypeslibconvertersjs6160__isRegExp2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__isRegExp);

var _babeltypeslibconvertersjs6160__isString = $m['lodash/isString.js#4.16.2'].exports;

var _babeltypeslibconvertersjs6160__isString2 = _babeltypeslibconvertersjs6160__interopRequireDefault(_babeltypeslibconvertersjs6160__isString);

var _babeltypeslibconvertersjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibconvertersjs6160_t = _babeltypeslibconvertersjs6160__interopRequireWildcard(_babeltypeslibconvertersjs6160__index);

function _babeltypeslibconvertersjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibconvertersjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltypeslibconvertersjs6160_toComputedKey(node) {
  var key = arguments.length <= 1 || arguments[1] === undefined ? node.key || node.property : arguments[1];

  if (!node.computed) {
    if (_babeltypeslibconvertersjs6160_t.isIdentifier(key)) key = _babeltypeslibconvertersjs6160_t.stringLiteral(key.name);
  }
  return key;
}

function _babeltypeslibconvertersjs6160_toSequenceExpression(nodes, scope) {
  if (!nodes || !nodes.length) return;

  var declars = [];
  var bailed = false;

  var result = convert(nodes);
  if (bailed) return;

  for (var i = 0; i < declars.length; i++) {
    scope.push(declars[i]);
  }

  return result;

  function convert(nodes) {
    var ensureLastUndefined = false;
    var exprs = [];

    for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltypeslibconvertersjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;

      if (_babeltypeslibconvertersjs6160_t.isExpression(node)) {
        exprs.push(node);
      } else if (_babeltypeslibconvertersjs6160_t.isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (_babeltypeslibconvertersjs6160_t.isVariableDeclaration(node)) {
        if (node.kind !== "var") return bailed = true;

        for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltypeslibconvertersjs6160__getIterator3.default)(_iterator2);;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var declar = _ref2;

          var bindings = _babeltypeslibconvertersjs6160_t.getBindingIdentifiers(declar);
          for (var key in bindings) {
            declars.push({
              kind: node.kind,
              id: bindings[key]
            });
          }

          if (declar.init) {
            exprs.push(_babeltypeslibconvertersjs6160_t.assignmentExpression("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
        continue;
      } else if (_babeltypeslibconvertersjs6160_t.isIfStatement(node)) {
        var consequent = node.consequent ? convert([node.consequent]) : scope.buildUndefinedNode();
        var alternate = node.alternate ? convert([node.alternate]) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return bailed = true;

        exprs.push(_babeltypeslibconvertersjs6160_t.conditionalExpression(node.test, consequent, alternate));
      } else if (_babeltypeslibconvertersjs6160_t.isBlockStatement(node)) {
        exprs.push(convert(node.body));
      } else if (_babeltypeslibconvertersjs6160_t.isEmptyStatement(node)) {
        ensureLastUndefined = true;
        continue;
      } else {
        return bailed = true;
      }

      ensureLastUndefined = false;
    }

    if (ensureLastUndefined || exprs.length === 0) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return _babeltypeslibconvertersjs6160_t.sequenceExpression(exprs);
    }
  }
}

function _babeltypeslibconvertersjs6160_toKeyAlias(node) {
  var key = arguments.length <= 1 || arguments[1] === undefined ? node.key : arguments[1];

  var alias = void 0;

  if (node.kind === "method") {
    return _babeltypeslibconvertersjs6160_toKeyAlias.increment() + "";
  } else if (_babeltypeslibconvertersjs6160_t.isIdentifier(key)) {
    alias = key.name;
  } else if (_babeltypeslibconvertersjs6160_t.isStringLiteral(key)) {
    alias = (0, _babeltypeslibconvertersjs6160__stringify2.default)(key.value);
  } else {
    alias = (0, _babeltypeslibconvertersjs6160__stringify2.default)(_babeltypeslibconvertersjs6160_t.removePropertiesDeep(_babeltypeslibconvertersjs6160_t.cloneDeep(key)));
  }

  if (node.computed) {
    alias = "[" + alias + "]";
  }

  if (node.static) {
    alias = "static:" + alias;
  }

  return alias;
}

_babeltypeslibconvertersjs6160_toKeyAlias.uid = 0;

_babeltypeslibconvertersjs6160_toKeyAlias.increment = function () {
  if (_babeltypeslibconvertersjs6160_toKeyAlias.uid >= _babeltypeslibconvertersjs6160__maxSafeInteger2.default) {
    return _babeltypeslibconvertersjs6160_toKeyAlias.uid = 0;
  } else {
    return _babeltypeslibconvertersjs6160_toKeyAlias.uid++;
  }
};

function _babeltypeslibconvertersjs6160_toIdentifier(name) {
  name = name + "";

  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");

  name = name.replace(/^[-0-9]+/, "");

  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!_babeltypeslibconvertersjs6160_t.isValidIdentifier(name)) {
    name = "_" + name;
  }

  return name || "_";
}

function _babeltypeslibconvertersjs6160_toBindingIdentifierName(name) {
  name = _babeltypeslibconvertersjs6160_toIdentifier(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

function _babeltypeslibconvertersjs6160_toStatement(node, ignore) {
  if (_babeltypeslibconvertersjs6160_t.isStatement(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType = void 0;

  if (_babeltypeslibconvertersjs6160_t.isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (_babeltypeslibconvertersjs6160_t.isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (_babeltypeslibconvertersjs6160_t.isAssignmentExpression(node)) {
    return _babeltypeslibconvertersjs6160_t.expressionStatement(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn " + node.type + " to a statement");
    }
  }

  node.type = newType;

  return node;
}

function _babeltypeslibconvertersjs6160_toExpression(node) {
  if (_babeltypeslibconvertersjs6160_t.isExpressionStatement(node)) {
    node = node.expression;
  }

  if (_babeltypeslibconvertersjs6160_t.isExpression(node)) {
    return node;
  }

  if (_babeltypeslibconvertersjs6160_t.isClass(node)) {
    node.type = "ClassExpression";
  } else if (_babeltypeslibconvertersjs6160_t.isFunction(node)) {
    node.type = "FunctionExpression";
  }

  if (!_babeltypeslibconvertersjs6160_t.isExpression(node)) {
    throw new Error("cannot turn " + node.type + " to an expression");
  }

  return node;
}

function _babeltypeslibconvertersjs6160_toBlock(node, parent) {
  if (_babeltypeslibconvertersjs6160_t.isBlockStatement(node)) {
    return node;
  }

  if (_babeltypeslibconvertersjs6160_t.isEmptyStatement(node)) {
    node = [];
  }

  if (!Array.isArray(node)) {
    if (!_babeltypeslibconvertersjs6160_t.isStatement(node)) {
      if (_babeltypeslibconvertersjs6160_t.isFunction(parent)) {
        node = _babeltypeslibconvertersjs6160_t.returnStatement(node);
      } else {
        node = _babeltypeslibconvertersjs6160_t.expressionStatement(node);
      }
    }

    node = [node];
  }

  return _babeltypeslibconvertersjs6160_t.blockStatement(node);
}

function _babeltypeslibconvertersjs6160_valueToNode(value) {
  if (value === undefined) {
    return _babeltypeslibconvertersjs6160_t.identifier("undefined");
  }

  if (value === true || value === false) {
    return _babeltypeslibconvertersjs6160_t.booleanLiteral(value);
  }

  if (value === null) {
    return _babeltypeslibconvertersjs6160_t.nullLiteral();
  }

  if ((0, _babeltypeslibconvertersjs6160__isString2.default)(value)) {
    return _babeltypeslibconvertersjs6160_t.stringLiteral(value);
  }

  if ((0, _babeltypeslibconvertersjs6160__isNumber2.default)(value)) {
    return _babeltypeslibconvertersjs6160_t.numericLiteral(value);
  }

  if ((0, _babeltypeslibconvertersjs6160__isRegExp2.default)(value)) {
    var pattern = value.source;
    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return _babeltypeslibconvertersjs6160_t.regExpLiteral(pattern, flags);
  }

  if (Array.isArray(value)) {
    return _babeltypeslibconvertersjs6160_t.arrayExpression(value.map(_babeltypeslibconvertersjs6160_t.valueToNode));
  }

  if ((0, _babeltypeslibconvertersjs6160__isPlainObject2.default)(value)) {
    var props = [];
    for (var key in value) {
      var nodeKey = void 0;
      if (_babeltypeslibconvertersjs6160_t.isValidIdentifier(key)) {
        nodeKey = _babeltypeslibconvertersjs6160_t.identifier(key);
      } else {
        nodeKey = _babeltypeslibconvertersjs6160_t.stringLiteral(key);
      }
      props.push(_babeltypeslibconvertersjs6160_t.objectProperty(nodeKey, _babeltypeslibconvertersjs6160_t.valueToNode(value[key])));
    }
    return _babeltypeslibconvertersjs6160_t.objectExpression(props);
  }

  throw new Error("don't know how to turn this value into a node");
}
};
/*≠≠ node_modules/babel-types/lib/converters.js ≠≠*/

/*== node_modules/babel-types/lib/flow.js ==*/
$m['babel-types/lib/flow.js#6.16.0'] = function () {
$m['babel-types/lib/flow.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/flow.js#6.16.0'].exports.__esModule = true;
$m['babel-types/lib/flow.js#6.16.0'].exports.createUnionTypeAnnotation = _babeltypeslibflowjs6160_createUnionTypeAnnotation;
$m['babel-types/lib/flow.js#6.16.0'].exports.removeTypeDuplicates = _babeltypeslibflowjs6160_removeTypeDuplicates;
$m['babel-types/lib/flow.js#6.16.0'].exports.createTypeAnnotationBasedOnTypeof = _babeltypeslibflowjs6160_createTypeAnnotationBasedOnTypeof;

var _babeltypeslibflowjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibflowjs6160_t = _babeltypeslibflowjs6160__interopRequireWildcard(_babeltypeslibflowjs6160__index);

function _babeltypeslibflowjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibflowjs6160_createUnionTypeAnnotation(types) {
  var flattened = _babeltypeslibflowjs6160_removeTypeDuplicates(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return _babeltypeslibflowjs6160_t.unionTypeAnnotation(flattened);
  }
}

function _babeltypeslibflowjs6160_removeTypeDuplicates(nodes) {
  var generics = {};
  var bases = {};

  var typeGroups = [];

  var types = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if (_babeltypeslibflowjs6160_t.isAnyTypeAnnotation(node)) {
      return [node];
    }

    if (_babeltypeslibflowjs6160_t.isFlowBaseAnnotation(node)) {
      bases[node.type] = node;
      continue;
    }

    if (_babeltypeslibflowjs6160_t.isUnionTypeAnnotation(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }
      continue;
    }

    if (_babeltypeslibflowjs6160_t.isGenericTypeAnnotation(node)) {
      var name = node.id.name;

      if (generics[name]) {
        var existing = generics[name];
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = _babeltypeslibflowjs6160_removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (var type in bases) {
    types.push(bases[type]);
  }

  for (var _name in generics) {
    types.push(generics[_name]);
  }

  return types;
}

function _babeltypeslibflowjs6160_createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return _babeltypeslibflowjs6160_t.stringTypeAnnotation();
  } else if (type === "number") {
    return _babeltypeslibflowjs6160_t.numberTypeAnnotation();
  } else if (type === "undefined") {
    return _babeltypeslibflowjs6160_t.voidTypeAnnotation();
  } else if (type === "boolean") {
    return _babeltypeslibflowjs6160_t.booleanTypeAnnotation();
  } else if (type === "function") {
    return _babeltypeslibflowjs6160_t.genericTypeAnnotation(_babeltypeslibflowjs6160_t.identifier("Function"));
  } else if (type === "object") {
    return _babeltypeslibflowjs6160_t.genericTypeAnnotation(_babeltypeslibflowjs6160_t.identifier("Object"));
  } else if (type === "symbol") {
    return _babeltypeslibflowjs6160_t.genericTypeAnnotation(_babeltypeslibflowjs6160_t.identifier("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}
};
/*≠≠ node_modules/babel-types/lib/flow.js ≠≠*/

/*== node_modules/to-fast-properties/index.js ==*/
$m['to-fast-properties/index.js#1.0.2'] = { exports: {} };
'use strict';

$m['to-fast-properties/index.js#1.0.2'].exports = function toFastProperties(obj) {
	function f() {}
	f.prototype = obj;
	new f();
	return;
	eval(obj);
};
/*≠≠ node_modules/to-fast-properties/index.js ≠≠*/

/*== node_modules/lodash/compact.js ==*/
$m['lodash/compact.js#4.16.2'] = { exports: {} };
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function _lodashcompactjs4162_compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

$m['lodash/compact.js#4.16.2'].exports = _lodashcompactjs4162_compact;
/*≠≠ node_modules/lodash/compact.js ≠≠*/

/*== node_modules/lodash/clone.js ==*/
$m['lodash/clone.js#4.16.2'] = { exports: {} };
var _lodashclonejs4162_baseClone = $m['lodash/_baseClone.js#4.16.2'].exports;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function _lodashclonejs4162_clone(value) {
  return _lodashclonejs4162_baseClone(value, false, true);
}

$m['lodash/clone.js#4.16.2'].exports = _lodashclonejs4162_clone;
/*≠≠ node_modules/lodash/clone.js ≠≠*/

/*== node_modules/lodash/each.js ==*/
$m['lodash/each.js#4.16.2'] = { exports: {} };
$m['lodash/each.js#4.16.2'].exports = $m['lodash/forEach.js#4.16.2'].exports;
/*≠≠ node_modules/lodash/each.js ≠≠*/

/*== node_modules/lodash/uniq.js ==*/
$m['lodash/uniq.js#4.16.2'] = { exports: {} };
var _lodashuniqjs4162_baseUniq = $m['lodash/_baseUniq.js#4.16.2'].exports;

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function _lodashuniqjs4162_uniq(array) {
  return array && array.length ? _lodashuniqjs4162_baseUniq(array) : [];
}

$m['lodash/uniq.js#4.16.2'].exports = _lodashuniqjs4162_uniq;
/*≠≠ node_modules/lodash/uniq.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/init.js ==*/
$m['babel-types/lib/definitions/init.js#6.16.0'] = function () {
$m['babel-types/lib/definitions/init.js#6.16.0'] = { exports: {} };
"use strict";

require("babel-types/lib/definitions/index.js#6.16.0");

require("babel-types/lib/definitions/core.js#6.16.0");

$m['babel-types/lib/definitions/es2015.js#6.16.0'].exports;

$m['babel-types/lib/definitions/flow.js#6.16.0'].exports;

$m['babel-types/lib/definitions/jsx.js#6.16.0'].exports;

$m['babel-types/lib/definitions/misc.js#6.16.0'].exports;

$m['babel-types/lib/definitions/experimental.js#6.16.0'].exports;
};
/*≠≠ node_modules/babel-types/lib/definitions/init.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/index.js ==*/
$m['babel-types/lib/definitions/index.js#6.16.0'] = function () {
$m['babel-types/lib/definitions/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/definitions/index.js#6.16.0'].exports.__esModule = true;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.DEPRECATED_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.BUILDER_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.NODE_FIELDS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.ALIAS_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.VISITOR_KEYS = undefined;

var _babeltypeslibdefinitionsindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltypeslibdefinitionsindexjs6160__getIterator3 = _babeltypeslibdefinitionsindexjs6160__interopRequireDefault(_babeltypeslibdefinitionsindexjs6160__getIterator2);

var _babeltypeslibdefinitionsindexjs6160__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babeltypeslibdefinitionsindexjs6160__stringify2 = _babeltypeslibdefinitionsindexjs6160__interopRequireDefault(_babeltypeslibdefinitionsindexjs6160__stringify);

var _babeltypeslibdefinitionsindexjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babeltypeslibdefinitionsindexjs6160__typeof3 = _babeltypeslibdefinitionsindexjs6160__interopRequireDefault(_babeltypeslibdefinitionsindexjs6160__typeof2);

$m['babel-types/lib/definitions/index.js#6.16.0'].exports.assertEach = _babeltypeslibdefinitionsindexjs6160_assertEach;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.assertOneOf = _babeltypeslibdefinitionsindexjs6160_assertOneOf;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.assertNodeType = _babeltypeslibdefinitionsindexjs6160_assertNodeType;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.assertNodeOrValueType = _babeltypeslibdefinitionsindexjs6160_assertNodeOrValueType;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.assertValueType = _babeltypeslibdefinitionsindexjs6160_assertValueType;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.chain = _babeltypeslibdefinitionsindexjs6160_chain;
$m['babel-types/lib/definitions/index.js#6.16.0'].exports.default = _babeltypeslibdefinitionsindexjs6160_defineType;

var _babeltypeslibdefinitionsindexjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibdefinitionsindexjs6160_t = _babeltypeslibdefinitionsindexjs6160__interopRequireWildcard(_babeltypeslibdefinitionsindexjs6160__index);

function _babeltypeslibdefinitionsindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibdefinitionsindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltypeslibdefinitionsindexjs6160_VISITOR_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.VISITOR_KEYS = {};
var _babeltypeslibdefinitionsindexjs6160_ALIAS_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.ALIAS_KEYS = {};
var _babeltypeslibdefinitionsindexjs6160_NODE_FIELDS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.NODE_FIELDS = {};
var _babeltypeslibdefinitionsindexjs6160_BUILDER_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.BUILDER_KEYS = {};
var _babeltypeslibdefinitionsindexjs6160_DEPRECATED_KEYS = $m['babel-types/lib/definitions/index.js#6.16.0'].exports.DEPRECATED_KEYS = {};

function _babeltypeslibdefinitionsindexjs6160_getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return typeof val === "undefined" ? "undefined" : (0, _babeltypeslibdefinitionsindexjs6160__typeof3.default)(val);
  }
}

function _babeltypeslibdefinitionsindexjs6160_assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (var i = 0; i < val.length; i++) {
      callback(node, key + "[" + i + "]", val[i]);
    }
  }
  validator.each = callback;
  return validator;
}

function _babeltypeslibdefinitionsindexjs6160_assertOneOf() {
  for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {
    vals[_key] = arguments[_key];
  }

  function validate(node, key, val) {
    if (vals.indexOf(val) < 0) {
      throw new TypeError("Property " + key + " expected value to be one of " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(vals) + " but got " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(val));
    }
  }

  validate.oneOf = vals;

  return validate;
}

function _babeltypeslibdefinitionsindexjs6160_assertNodeType() {
  for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    types[_key2] = arguments[_key2];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltypeslibdefinitionsindexjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type = _ref;

      if (_babeltypeslibdefinitionsindexjs6160_t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(types) + " " + ("but instead got " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeTypes = types;

  return validate;
}

function _babeltypeslibdefinitionsindexjs6160_assertNodeOrValueType() {
  for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    types[_key3] = arguments[_key3];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltypeslibdefinitionsindexjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var type = _ref2;

      if (_babeltypeslibdefinitionsindexjs6160_getType(val) === type || _babeltypeslibdefinitionsindexjs6160_t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(types) + " " + ("but instead got " + (0, _babeltypeslibdefinitionsindexjs6160__stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeOrValueTypes = types;

  return validate;
}

function _babeltypeslibdefinitionsindexjs6160_assertValueType(type) {
  function validate(node, key, val) {
    var valid = _babeltypeslibdefinitionsindexjs6160_getType(val) === type;

    if (!valid) {
      throw new TypeError("Property " + key + " expected type of " + type + " but got " + _babeltypeslibdefinitionsindexjs6160_getType(val));
    }
  }

  validate.type = type;

  return validate;
}

function _babeltypeslibdefinitionsindexjs6160_chain() {
  for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    fns[_key4] = arguments[_key4];
  }

  function validate() {
    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltypeslibdefinitionsindexjs6160__getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var fn = _ref3;

      fn.apply(undefined, arguments);
    }
  }
  validate.chainOf = fns;
  return validate;
}

function _babeltypeslibdefinitionsindexjs6160_defineType(type) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var inherits = opts.inherits && _babeltypeslibdefinitionsindexjs6160_store[opts.inherits] || {};

  opts.fields = opts.fields || inherits.fields || {};
  opts.visitor = opts.visitor || inherits.visitor || [];
  opts.aliases = opts.aliases || inherits.aliases || [];
  opts.builder = opts.builder || inherits.builder || opts.visitor || [];

  if (opts.deprecatedAlias) {
    _babeltypeslibdefinitionsindexjs6160_DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _babeltypeslibdefinitionsindexjs6160__getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var _key5 = _ref4;

    opts.fields[_key5] = opts.fields[_key5] || {};
  }

  for (var key in opts.fields) {
    var field = opts.fields[key];

    if (opts.builder.indexOf(key) === -1) {
      field.optional = true;
    }
    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = _babeltypeslibdefinitionsindexjs6160_assertValueType(_babeltypeslibdefinitionsindexjs6160_getType(field.default));
    }
  }

  _babeltypeslibdefinitionsindexjs6160_VISITOR_KEYS[type] = opts.visitor;
  _babeltypeslibdefinitionsindexjs6160_BUILDER_KEYS[type] = opts.builder;
  _babeltypeslibdefinitionsindexjs6160_NODE_FIELDS[type] = opts.fields;
  _babeltypeslibdefinitionsindexjs6160_ALIAS_KEYS[type] = opts.aliases;

  _babeltypeslibdefinitionsindexjs6160_store[type] = opts;
}

var _babeltypeslibdefinitionsindexjs6160_store = {};
};
/*≠≠ node_modules/babel-types/lib/definitions/index.js ≠≠*/

/*== node_modules/babel-types/lib/react.js ==*/
$m['babel-types/lib/react.js#6.16.0'] = function () {
$m['babel-types/lib/react.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/react.js#6.16.0'].exports.__esModule = true;
$m['babel-types/lib/react.js#6.16.0'].exports.isReactComponent = undefined;
$m['babel-types/lib/react.js#6.16.0'].exports.isCompatTag = _babeltypeslibreactjs6160_isCompatTag;
$m['babel-types/lib/react.js#6.16.0'].exports.buildChildren = _babeltypeslibreactjs6160_buildChildren;

var _babeltypeslibreactjs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibreactjs6160_t = _babeltypeslibreactjs6160__interopRequireWildcard(_babeltypeslibreactjs6160__index);

function _babeltypeslibreactjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

var _babeltypeslibreactjs6160_isReactComponent = $m['babel-types/lib/react.js#6.16.0'].exports.isReactComponent = _babeltypeslibreactjs6160_t.buildMatchMemberExpression("React.Component");

function _babeltypeslibreactjs6160_isCompatTag(tagName) {
  return !!tagName && /^[a-z]|\-/.test(tagName);
}

function _babeltypeslibreactjs6160_cleanJSXElementLiteralChild(child, args) {
  var lines = child.value.split(/\r\n|\n|\r/);

  var lastNonEmptyLine = 0;

  for (var i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  var str = "";

  for (var _i = 0; _i < lines.length; _i++) {
    var line = lines[_i];

    var isFirstLine = _i === 0;
    var isLastLine = _i === lines.length - 1;
    var isLastNonEmptyLine = _i === lastNonEmptyLine;

    var trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push(_babeltypeslibreactjs6160_t.stringLiteral(str));
}

function _babeltypeslibreactjs6160_buildChildren(node) {
  var elems = [];

  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if (_babeltypeslibreactjs6160_t.isJSXText(child)) {
      _babeltypeslibreactjs6160_cleanJSXElementLiteralChild(child, elems);
      continue;
    }

    if (_babeltypeslibreactjs6160_t.isJSXExpressionContainer(child)) child = child.expression;
    if (_babeltypeslibreactjs6160_t.isJSXEmptyExpression(child)) continue;

    elems.push(child);
  }

  return elems;
}
};
/*≠≠ node_modules/babel-types/lib/react.js ≠≠*/

/*== node_modules/babel-types/lib/index.js ==*/
$m['babel-types/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-types/lib/index.js#6.16.0'].exports.__esModule = true;
$m['babel-types/lib/index.js#6.16.0'].exports.createTypeAnnotationBasedOnTypeof = $m['babel-types/lib/index.js#6.16.0'].exports.removeTypeDuplicates = $m['babel-types/lib/index.js#6.16.0'].exports.createUnionTypeAnnotation = $m['babel-types/lib/index.js#6.16.0'].exports.valueToNode = $m['babel-types/lib/index.js#6.16.0'].exports.toBlock = $m['babel-types/lib/index.js#6.16.0'].exports.toExpression = $m['babel-types/lib/index.js#6.16.0'].exports.toStatement = $m['babel-types/lib/index.js#6.16.0'].exports.toBindingIdentifierName = $m['babel-types/lib/index.js#6.16.0'].exports.toIdentifier = $m['babel-types/lib/index.js#6.16.0'].exports.toKeyAlias = $m['babel-types/lib/index.js#6.16.0'].exports.toSequenceExpression = $m['babel-types/lib/index.js#6.16.0'].exports.toComputedKey = $m['babel-types/lib/index.js#6.16.0'].exports.isImmutable = $m['babel-types/lib/index.js#6.16.0'].exports.isScope = $m['babel-types/lib/index.js#6.16.0'].exports.isSpecifierDefault = $m['babel-types/lib/index.js#6.16.0'].exports.isVar = $m['babel-types/lib/index.js#6.16.0'].exports.isBlockScoped = $m['babel-types/lib/index.js#6.16.0'].exports.isLet = $m['babel-types/lib/index.js#6.16.0'].exports.isValidIdentifier = $m['babel-types/lib/index.js#6.16.0'].exports.isReferenced = $m['babel-types/lib/index.js#6.16.0'].exports.isBinding = $m['babel-types/lib/index.js#6.16.0'].exports.getOuterBindingIdentifiers = $m['babel-types/lib/index.js#6.16.0'].exports.getBindingIdentifiers = $m['babel-types/lib/index.js#6.16.0'].exports.TYPES = $m['babel-types/lib/index.js#6.16.0'].exports.react = $m['babel-types/lib/index.js#6.16.0'].exports.DEPRECATED_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.BUILDER_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.NODE_FIELDS = $m['babel-types/lib/index.js#6.16.0'].exports.ALIAS_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.VISITOR_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.NOT_LOCAL_BINDING = $m['babel-types/lib/index.js#6.16.0'].exports.BLOCK_SCOPED_SYMBOL = $m['babel-types/lib/index.js#6.16.0'].exports.INHERIT_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.UNARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.STRING_UNARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.NUMBER_UNARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.BOOLEAN_UNARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.NUMBER_BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.BOOLEAN_BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.COMPARISON_BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.EQUALITY_BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.BOOLEAN_NUMBER_BINARY_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.UPDATE_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.LOGICAL_OPERATORS = $m['babel-types/lib/index.js#6.16.0'].exports.COMMENT_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.FOR_INIT_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.FLATTENABLE_KEYS = $m['babel-types/lib/index.js#6.16.0'].exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _babeltypeslibindexjs6160__getOwnPropertySymbols = $m['babel-runtime/core-js/object/get-own-property-symbols.js#6.11.6'].exports;

var _babeltypeslibindexjs6160__getOwnPropertySymbols2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__getOwnPropertySymbols);

var _babeltypeslibindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltypeslibindexjs6160__getIterator3 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__getIterator2);

var _babeltypeslibindexjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babeltypeslibindexjs6160__keys2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__keys);

var _babeltypeslibindexjs6160__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babeltypeslibindexjs6160__stringify2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__stringify);

var _babeltypeslibindexjs6160__constants = $m['babel-types/lib/constants.js#6.16.0'].exports;

Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "STATEMENT_OR_BLOCK_KEYS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.STATEMENT_OR_BLOCK_KEYS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "FLATTENABLE_KEYS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.FLATTENABLE_KEYS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "FOR_INIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.FOR_INIT_KEYS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "COMMENT_KEYS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.COMMENT_KEYS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "LOGICAL_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.LOGICAL_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "UPDATE_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.UPDATE_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "BOOLEAN_NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.BOOLEAN_NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "EQUALITY_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.EQUALITY_BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "COMPARISON_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.COMPARISON_BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "BOOLEAN_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.BOOLEAN_BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.BINARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "BOOLEAN_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.BOOLEAN_UNARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "NUMBER_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.NUMBER_UNARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "STRING_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.STRING_UNARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.UNARY_OPERATORS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "INHERIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.INHERIT_KEYS;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "BLOCK_SCOPED_SYMBOL", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.BLOCK_SCOPED_SYMBOL;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "NOT_LOCAL_BINDING", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__constants.NOT_LOCAL_BINDING;
  }
});
$m['babel-types/lib/index.js#6.16.0'].exports.is = _babeltypeslibindexjs6160_is;
$m['babel-types/lib/index.js#6.16.0'].exports.isType = _babeltypeslibindexjs6160_isType;
$m['babel-types/lib/index.js#6.16.0'].exports.validate = _babeltypeslibindexjs6160_validate;
$m['babel-types/lib/index.js#6.16.0'].exports.shallowEqual = _babeltypeslibindexjs6160_shallowEqual;
$m['babel-types/lib/index.js#6.16.0'].exports.appendToMemberExpression = _babeltypeslibindexjs6160_appendToMemberExpression;
$m['babel-types/lib/index.js#6.16.0'].exports.prependToMemberExpression = _babeltypeslibindexjs6160_prependToMemberExpression;
$m['babel-types/lib/index.js#6.16.0'].exports.ensureBlock = _babeltypeslibindexjs6160_ensureBlock;
$m['babel-types/lib/index.js#6.16.0'].exports.clone = _babeltypeslibindexjs6160_clone;
$m['babel-types/lib/index.js#6.16.0'].exports.cloneWithoutLoc = _babeltypeslibindexjs6160_cloneWithoutLoc;
$m['babel-types/lib/index.js#6.16.0'].exports.cloneDeep = _babeltypeslibindexjs6160_cloneDeep;
$m['babel-types/lib/index.js#6.16.0'].exports.buildMatchMemberExpression = _babeltypeslibindexjs6160_buildMatchMemberExpression;
$m['babel-types/lib/index.js#6.16.0'].exports.removeComments = _babeltypeslibindexjs6160_removeComments;
$m['babel-types/lib/index.js#6.16.0'].exports.inheritsComments = _babeltypeslibindexjs6160_inheritsComments;
$m['babel-types/lib/index.js#6.16.0'].exports.inheritTrailingComments = _babeltypeslibindexjs6160_inheritTrailingComments;
$m['babel-types/lib/index.js#6.16.0'].exports.inheritLeadingComments = _babeltypeslibindexjs6160_inheritLeadingComments;
$m['babel-types/lib/index.js#6.16.0'].exports.inheritInnerComments = _babeltypeslibindexjs6160_inheritInnerComments;
$m['babel-types/lib/index.js#6.16.0'].exports.inherits = _babeltypeslibindexjs6160_inherits;
$m['babel-types/lib/index.js#6.16.0'].exports.assertNode = _babeltypeslibindexjs6160_assertNode;
$m['babel-types/lib/index.js#6.16.0'].exports.isNode = _babeltypeslibindexjs6160_isNode;
$m['babel-types/lib/index.js#6.16.0'].exports.traverseFast = _babeltypeslibindexjs6160_traverseFast;
$m['babel-types/lib/index.js#6.16.0'].exports.removeProperties = _babeltypeslibindexjs6160_removeProperties;
$m['babel-types/lib/index.js#6.16.0'].exports.removePropertiesDeep = _babeltypeslibindexjs6160_removePropertiesDeep;

var _babeltypeslibindexjs6160__retrievers = require("babel-types/lib/retrievers.js#6.16.0");

Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__retrievers.getBindingIdentifiers;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__retrievers.getOuterBindingIdentifiers;
  }
});

var _babeltypeslibindexjs6160__validators = require("babel-types/lib/validators.js#6.16.0");

Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isBinding", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isBinding;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isReferenced", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isReferenced;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isValidIdentifier", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isValidIdentifier;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isLet", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isLet;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isBlockScoped", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isBlockScoped;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isVar", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isVar;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isSpecifierDefault", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isSpecifierDefault;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isScope", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isScope;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "isImmutable", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__validators.isImmutable;
  }
});

var _babeltypeslibindexjs6160__converters = require("babel-types/lib/converters.js#6.16.0");

Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toComputedKey", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toComputedKey;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toSequenceExpression", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toSequenceExpression;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toKeyAlias", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toKeyAlias;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toIdentifier", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toIdentifier;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toBindingIdentifierName;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toStatement", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toStatement;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toExpression", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toExpression;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "toBlock", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.toBlock;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "valueToNode", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__converters.valueToNode;
  }
});

var _babeltypeslibindexjs6160__flow = require("babel-types/lib/flow.js#6.16.0");

Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__flow.createUnionTypeAnnotation;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__flow.removeTypeDuplicates;
  }
});
Object.defineProperty($m['babel-types/lib/index.js#6.16.0'].exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function get() {
    return _babeltypeslibindexjs6160__flow.createTypeAnnotationBasedOnTypeof;
  }
});

var _babeltypeslibindexjs6160__toFastProperties = $m['to-fast-properties/index.js#1.0.2'].exports;

var _babeltypeslibindexjs6160__toFastProperties2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__toFastProperties);

var _babeltypeslibindexjs6160__compact = $m['lodash/compact.js#4.16.2'].exports;

var _babeltypeslibindexjs6160__compact2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__compact);

var _babeltypeslibindexjs6160__clone = $m['lodash/clone.js#4.16.2'].exports;

var _babeltypeslibindexjs6160__clone2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__clone);

var _babeltypeslibindexjs6160__each = $m['lodash/each.js#4.16.2'].exports;

var _babeltypeslibindexjs6160__each2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__each);

var _babeltypeslibindexjs6160__uniq = $m['lodash/uniq.js#4.16.2'].exports;

var _babeltypeslibindexjs6160__uniq2 = _babeltypeslibindexjs6160__interopRequireDefault(_babeltypeslibindexjs6160__uniq);

require("babel-types/lib/definitions/init.js#6.16.0");

var _babeltypeslibindexjs6160__definitions = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibindexjs6160__react2 = require("babel-types/lib/react.js#6.16.0");

var _babeltypeslibindexjs6160__react = _babeltypeslibindexjs6160__interopRequireWildcard(_babeltypeslibindexjs6160__react2);

function _babeltypeslibindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltypeslibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltypeslibindexjs6160_t = $m['babel-types/lib/index.js#6.16.0'].exports;

function _babeltypeslibindexjs6160_registerType(type) {
  var is = _babeltypeslibindexjs6160_t["is" + type];
  if (!is) {
    is = _babeltypeslibindexjs6160_t["is" + type] = function (node, opts) {
      return _babeltypeslibindexjs6160_t.is(type, node, opts);
    };
  }

  _babeltypeslibindexjs6160_t["assert" + type] = function (node, opts) {
    opts = opts || {};
    if (!is(node, opts)) {
      throw new Error("Expected type " + (0, _babeltypeslibindexjs6160__stringify2.default)(type) + " with option " + (0, _babeltypeslibindexjs6160__stringify2.default)(opts));
    }
  };
}

$m['babel-types/lib/index.js#6.16.0'].exports.VISITOR_KEYS = _babeltypeslibindexjs6160__definitions.VISITOR_KEYS;
$m['babel-types/lib/index.js#6.16.0'].exports.ALIAS_KEYS = _babeltypeslibindexjs6160__definitions.ALIAS_KEYS;
$m['babel-types/lib/index.js#6.16.0'].exports.NODE_FIELDS = _babeltypeslibindexjs6160__definitions.NODE_FIELDS;
$m['babel-types/lib/index.js#6.16.0'].exports.BUILDER_KEYS = _babeltypeslibindexjs6160__definitions.BUILDER_KEYS;
$m['babel-types/lib/index.js#6.16.0'].exports.DEPRECATED_KEYS = _babeltypeslibindexjs6160__definitions.DEPRECATED_KEYS;
$m['babel-types/lib/index.js#6.16.0'].exports.react = _babeltypeslibindexjs6160__react;

for (var _babeltypeslibindexjs6160_type in _babeltypeslibindexjs6160_t.VISITOR_KEYS) {
  _babeltypeslibindexjs6160_registerType(_babeltypeslibindexjs6160_type);
}

_babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS = {};

(0, _babeltypeslibindexjs6160__each2.default)(_babeltypeslibindexjs6160_t.ALIAS_KEYS, function (aliases, type) {
  (0, _babeltypeslibindexjs6160__each2.default)(aliases, function (alias) {
    var types = _babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS[alias] = _babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS[alias] || [];
    types.push(type);
  });
});

(0, _babeltypeslibindexjs6160__each2.default)(_babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS, function (types, type) {
  _babeltypeslibindexjs6160_t[type.toUpperCase() + "_TYPES"] = types;
  _babeltypeslibindexjs6160_registerType(type);
});

var _babeltypeslibindexjs6160_TYPES = $m['babel-types/lib/index.js#6.16.0'].exports.TYPES = (0, _babeltypeslibindexjs6160__keys2.default)(_babeltypeslibindexjs6160_t.VISITOR_KEYS).concat((0, _babeltypeslibindexjs6160__keys2.default)(_babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS)).concat((0, _babeltypeslibindexjs6160__keys2.default)(_babeltypeslibindexjs6160_t.DEPRECATED_KEYS));

function _babeltypeslibindexjs6160_is(type, node, opts) {
  if (!node) return false;

  var matches = _babeltypeslibindexjs6160_isType(node.type, type);
  if (!matches) return false;

  if (typeof opts === "undefined") {
    return true;
  } else {
    return _babeltypeslibindexjs6160_t.shallowEqual(node, opts);
  }
}

function _babeltypeslibindexjs6160_isType(nodeType, targetType) {
  if (nodeType === targetType) return true;

  if (_babeltypeslibindexjs6160_t.ALIAS_KEYS[targetType]) return false;

  var aliases = _babeltypeslibindexjs6160_t.FLIPPED_ALIAS_KEYS[targetType];
  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var alias = _ref;

      if (nodeType === alias) return true;
    }
  }

  return false;
}

(0, _babeltypeslibindexjs6160__each2.default)(_babeltypeslibindexjs6160_t.BUILDER_KEYS, function (keys, type) {
  function builder() {
    if (arguments.length > keys.length) {
      throw new Error("t." + type + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length));
    }

    var node = {};
    node.type = type;

    var i = 0;

    for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _key = _ref2;

      var field = _babeltypeslibindexjs6160_t.NODE_FIELDS[type][_key];

      var arg = arguments[i++];
      if (arg === undefined) arg = (0, _babeltypeslibindexjs6160__clone2.default)(field.default);

      node[_key] = arg;
    }

    for (var key in node) {
      _babeltypeslibindexjs6160_validate(node, key, node[key]);
    }

    return node;
  }

  _babeltypeslibindexjs6160_t[type] = builder;
  _babeltypeslibindexjs6160_t[type[0].toLowerCase() + type.slice(1)] = builder;
});

var _babeltypeslibindexjs6160__loop = function _loop(_type) {
  var newType = _babeltypeslibindexjs6160_t.DEPRECATED_KEYS[_type];

  function proxy(fn) {
    return function () {
      console.trace("The node type " + _type + " has been renamed to " + newType);
      return fn.apply(this, arguments);
    };
  }

  _babeltypeslibindexjs6160_t[_type] = _babeltypeslibindexjs6160_t[_type[0].toLowerCase() + _type.slice(1)] = proxy(_babeltypeslibindexjs6160_t[newType]);
  _babeltypeslibindexjs6160_t["is" + _type] = proxy(_babeltypeslibindexjs6160_t["is" + newType]);
  _babeltypeslibindexjs6160_t["assert" + _type] = proxy(_babeltypeslibindexjs6160_t["assert" + newType]);
};

for (var _babeltypeslibindexjs6160__type in _babeltypeslibindexjs6160_t.DEPRECATED_KEYS) {
  _babeltypeslibindexjs6160__loop(_babeltypeslibindexjs6160__type);
}

function _babeltypeslibindexjs6160_validate(node, key, val) {
  if (!node) return;

  var fields = _babeltypeslibindexjs6160_t.NODE_FIELDS[node.type];
  if (!fields) return;

  var field = fields[key];
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;

  field.validate(node, key, val);
}

function _babeltypeslibindexjs6160_shallowEqual(actual, expected) {
  var keys = (0, _babeltypeslibindexjs6160__keys2.default)(expected);

  for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator3);;) {
    var _ref3;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref3 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref3 = _i3.value;
    }

    var key = _ref3;

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

function _babeltypeslibindexjs6160_appendToMemberExpression(member, append, computed) {
  member.object = _babeltypeslibindexjs6160_t.memberExpression(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

function _babeltypeslibindexjs6160_prependToMemberExpression(member, prepend) {
  member.object = _babeltypeslibindexjs6160_t.memberExpression(prepend, member.object);
  return member;
}

function _babeltypeslibindexjs6160_ensureBlock(node) {
  var key = arguments.length <= 1 || arguments[1] === undefined ? "body" : arguments[1];

  return node[key] = _babeltypeslibindexjs6160_t.toBlock(node[key], node);
}

function _babeltypeslibindexjs6160_clone(node) {
  var newNode = {};
  for (var key in node) {
    if (key[0] === "_") continue;
    newNode[key] = node[key];
  }
  return newNode;
}

function _babeltypeslibindexjs6160_cloneWithoutLoc(node) {
  var newNode = _babeltypeslibindexjs6160_clone(node);
  delete newNode.loc;
  return newNode;
}

function _babeltypeslibindexjs6160_cloneDeep(node) {
  var newNode = {};

  for (var key in node) {
    if (key[0] === "_") continue;

    var val = node[key];

    if (val) {
      if (val.type) {
        val = _babeltypeslibindexjs6160_t.cloneDeep(val);
      } else if (Array.isArray(val)) {
        val = val.map(_babeltypeslibindexjs6160_t.cloneDeep);
      }
    }

    newNode[key] = val;
  }

  return newNode;
}

function _babeltypeslibindexjs6160_buildMatchMemberExpression(match, allowPartial) {
  var parts = match.split(".");

  return function (member) {
    if (!_babeltypeslibindexjs6160_t.isMemberExpression(member)) return false;

    var search = [member];
    var i = 0;

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (_babeltypeslibindexjs6160_t.isIdentifier(node)) {
        if (parts[i] !== node.name) return false;
      } else if (_babeltypeslibindexjs6160_t.isStringLiteral(node)) {
        if (parts[i] !== node.value) return false;
      } else if (_babeltypeslibindexjs6160_t.isMemberExpression(node)) {
        if (node.computed && !_babeltypeslibindexjs6160_t.isStringLiteral(node.property)) {
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        return false;
      }

      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  };
}

function _babeltypeslibindexjs6160_removeComments(node) {
  for (var _iterator4 = _babeltypeslibindexjs6160_t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var key = _ref4;

    delete node[key];
  }
  return node;
}

function _babeltypeslibindexjs6160_inheritsComments(child, parent) {
  _babeltypeslibindexjs6160_inheritTrailingComments(child, parent);
  _babeltypeslibindexjs6160_inheritLeadingComments(child, parent);
  _babeltypeslibindexjs6160_inheritInnerComments(child, parent);
  return child;
}

function _babeltypeslibindexjs6160_inheritTrailingComments(child, parent) {
  _babeltypeslibindexjs6160__inheritComments("trailingComments", child, parent);
}

function _babeltypeslibindexjs6160_inheritLeadingComments(child, parent) {
  _babeltypeslibindexjs6160__inheritComments("leadingComments", child, parent);
}

function _babeltypeslibindexjs6160_inheritInnerComments(child, parent) {
  _babeltypeslibindexjs6160__inheritComments("innerComments", child, parent);
}

function _babeltypeslibindexjs6160__inheritComments(key, child, parent) {
  if (child && parent) {
    child[key] = (0, _babeltypeslibindexjs6160__uniq2.default)((0, _babeltypeslibindexjs6160__compact2.default)([].concat(child[key], parent[key])));
  }
}

function _babeltypeslibindexjs6160_inherits(child, parent) {
  if (!child || !parent) return child;

  for (var _iterator5 = _babeltypeslibindexjs6160_t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var _key2 = _ref5;

    if (child[_key2] == null) {
      child[_key2] = parent[_key2];
    }
  }

  for (var key in parent) {
    if (key[0] === "_") child[key] = parent[key];
  }

  for (var _iterator6 = _babeltypeslibindexjs6160_t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator6);;) {
    var _ref6;

    if (_isArray6) {
      if (_i6 >= _iterator6.length) break;
      _ref6 = _iterator6[_i6++];
    } else {
      _i6 = _iterator6.next();
      if (_i6.done) break;
      _ref6 = _i6.value;
    }

    var _key3 = _ref6;

    child[_key3] = parent[_key3];
  }

  _babeltypeslibindexjs6160_t.inheritsComments(child, parent);

  return child;
}

function _babeltypeslibindexjs6160_assertNode(node) {
  if (!_babeltypeslibindexjs6160_isNode(node)) {
    throw new TypeError("Not a valid node " + (node && node.type));
  }
}

function _babeltypeslibindexjs6160_isNode(node) {
  return !!(node && _babeltypeslibindexjs6160__definitions.VISITOR_KEYS[node.type]);
}

(0, _babeltypeslibindexjs6160__toFastProperties2.default)(_babeltypeslibindexjs6160_t);
(0, _babeltypeslibindexjs6160__toFastProperties2.default)(_babeltypeslibindexjs6160_t.VISITOR_KEYS);

function _babeltypeslibindexjs6160_traverseFast(node, enter, opts) {
  if (!node) return;

  var keys = _babeltypeslibindexjs6160_t.VISITOR_KEYS[node.type];
  if (!keys) return;

  opts = opts || {};
  enter(node, opts);

  for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator7);;) {
    var _ref7;

    if (_isArray7) {
      if (_i7 >= _iterator7.length) break;
      _ref7 = _iterator7[_i7++];
    } else {
      _i7 = _iterator7.next();
      if (_i7.done) break;
      _ref7 = _i7.value;
    }

    var key = _ref7;

    var subNode = node[key];

    if (Array.isArray(subNode)) {
      for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var _node = _ref8;

        _babeltypeslibindexjs6160_traverseFast(_node, enter, opts);
      }
    } else {
      _babeltypeslibindexjs6160_traverseFast(subNode, enter, opts);
    }
  }
}

var _babeltypeslibindexjs6160_CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

var _babeltypeslibindexjs6160_CLEAR_KEYS_PLUS_COMMENTS = _babeltypeslibindexjs6160_t.COMMENT_KEYS.concat(["comments"]).concat(_babeltypeslibindexjs6160_CLEAR_KEYS);

function _babeltypeslibindexjs6160_removeProperties(node, opts) {
  opts = opts || {};
  var map = opts.preserveComments ? _babeltypeslibindexjs6160_CLEAR_KEYS : _babeltypeslibindexjs6160_CLEAR_KEYS_PLUS_COMMENTS;
  for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator9);;) {
    var _ref9;

    if (_isArray9) {
      if (_i9 >= _iterator9.length) break;
      _ref9 = _iterator9[_i9++];
    } else {
      _i9 = _iterator9.next();
      if (_i9.done) break;
      _ref9 = _i9.value;
    }

    var _key4 = _ref9;

    if (node[_key4] != null) node[_key4] = undefined;
  }

  for (var key in node) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  var syms = (0, _babeltypeslibindexjs6160__getOwnPropertySymbols2.default)(node);
  for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _babeltypeslibindexjs6160__getIterator3.default)(_iterator10);;) {
    var _ref10;

    if (_isArray10) {
      if (_i10 >= _iterator10.length) break;
      _ref10 = _iterator10[_i10++];
    } else {
      _i10 = _iterator10.next();
      if (_i10.done) break;
      _ref10 = _i10.value;
    }

    var sym = _ref10;

    node[sym] = null;
  }
}

function _babeltypeslibindexjs6160_removePropertiesDeep(tree, opts) {
  _babeltypeslibindexjs6160_traverseFast(tree, _babeltypeslibindexjs6160_removeProperties, opts);
  return tree;
}
/*≠≠ node_modules/babel-types/lib/index.js ≠≠*/

/*== node_modules/babel-runtime/helpers/classCallCheck.js ==*/
$m['babel-runtime/helpers/classCallCheck.js#6.11.6'] = { exports: {} };
"use strict";

$m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports.__esModule = true;

$m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
/*≠≠ node_modules/babel-runtime/helpers/classCallCheck.js ≠≠*/

/*== node_modules/babel-runtime/core-js/weak-map.js ==*/
$m['babel-runtime/core-js/weak-map.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/weak-map.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/weak-map.js ≠≠*/

/*== node_modules/babel-traverse/lib/scope/binding.js ==*/
$m['babel-traverse/lib/scope/binding.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/scope/binding.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibscopebindingjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibscopebindingjs6160__classCallCheck3 = _babeltraverselibscopebindingjs6160__interopRequireDefault(_babeltraverselibscopebindingjs6160__classCallCheck2);

function _babeltraverselibscopebindingjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibscopebindingjs6160_Binding = function () {
  function Binding(_ref) {
    var existing = _ref.existing;
    var identifier = _ref.identifier;
    var scope = _ref.scope;
    var path = _ref.path;
    var kind = _ref.kind;
    (0, _babeltraverselibscopebindingjs6160__classCallCheck3.default)(this, Binding);

    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;

    this.constantViolations = [];
    this.constant = true;

    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;

    this.clearValue();

    if (existing) {
      this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
    }
  }

  Binding.prototype.deoptValue = function deoptValue() {
    this.clearValue();
    this.hasDeoptedValue = true;
  };

  Binding.prototype.setValue = function setValue(value) {
    if (this.hasDeoptedValue) return;
    this.hasValue = true;
    this.value = value;
  };

  Binding.prototype.clearValue = function clearValue() {
    this.hasDeoptedValue = false;
    this.hasValue = false;
    this.value = null;
  };

  Binding.prototype.reassign = function reassign(path) {
    this.constant = false;
    if (this.constantViolations.indexOf(path) !== -1) {
      return;
    }
    this.constantViolations.push(path);
  };

  Binding.prototype.reference = function reference(path) {
    if (this.referencePaths.indexOf(path) !== -1) {
      return;
    }
    this.referenced = true;
    this.references++;
    this.referencePaths.push(path);
  };

  Binding.prototype.dereference = function dereference() {
    this.references--;
    this.referenced = !!this.references;
  };

  return Binding;
}();

$m['babel-traverse/lib/scope/binding.js#6.16.0'].exports.default = _babeltraverselibscopebindingjs6160_Binding;
$m['babel-traverse/lib/scope/binding.js#6.16.0'].exports = $m['babel-traverse/lib/scope/binding.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/lib/scope/binding.js ≠≠*/

/*== node_modules/babel-traverse/li...inference/inferer-reference.js ==*/
$m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathinferenceinfererreferencejs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathinferenceinfererreferencejs6160__getIterator3 = _babeltraverselibpathinferenceinfererreferencejs6160__interopRequireDefault(_babeltraverselibpathinferenceinfererreferencejs6160__getIterator2);

$m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'].exports.default = function (node) {
  if (!this.isReferenced()) return;

  var binding = this.scope.getBinding(node.name);
  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return _babeltraverselibpathinferenceinfererreferencejs6160_getTypeAnnotationBindingConstantViolations(this, node.name);
    }
  }

  if (node.name === "undefined") {
    return _babeltraverselibpathinferenceinfererreferencejs6160_t.voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return _babeltraverselibpathinferenceinfererreferencejs6160_t.numberTypeAnnotation();
  } else if (node.name === "arguments") {}
};

var _babeltraverselibpathinferenceinfererreferencejs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathinferenceinfererreferencejs6160_t = _babeltraverselibpathinferenceinfererreferencejs6160__interopRequireWildcard(_babeltraverselibpathinferenceinfererreferencejs6160__babelTypes);

function _babeltraverselibpathinferenceinfererreferencejs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathinferenceinfererreferencejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathinferenceinfererreferencejs6160_getTypeAnnotationBindingConstantViolations(path, name) {
  var binding = path.scope.getBinding(name);

  var types = [];
  path.typeAnnotation = _babeltraverselibpathinferenceinfererreferencejs6160_t.unionTypeAnnotation(types);

  var functionConstantViolations = [];
  var constantViolations = _babeltraverselibpathinferenceinfererreferencejs6160_getConstantViolationsBefore(binding, path, functionConstantViolations);

  var testType = _babeltraverselibpathinferenceinfererreferencejs6160_getConditionalAnnotation(path, name);
  if (testType) {
    (function () {
      var testConstantViolations = _babeltraverselibpathinferenceinfererreferencejs6160_getConstantViolationsBefore(binding, testType.ifStatement);

      constantViolations = constantViolations.filter(function (path) {
        return testConstantViolations.indexOf(path) < 0;
      });

      types.push(testType.typeAnnotation);
    })();
  }

  if (constantViolations.length) {
    constantViolations = constantViolations.concat(functionConstantViolations);

    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathinferenceinfererreferencejs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var violation = _ref;

      types.push(violation.getTypeAnnotation());
    }
  }

  if (types.length) {
    return _babeltraverselibpathinferenceinfererreferencejs6160_t.createUnionTypeAnnotation(types);
  }
}

function _babeltraverselibpathinferenceinfererreferencejs6160_getConstantViolationsBefore(binding, path, functions) {
  var violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(function (violation) {
    violation = violation.resolve();
    var status = violation._guessExecutionStatusRelativeTo(path);
    if (functions && status === "function") functions.push(violation);
    return status === "before";
  });
}

function _babeltraverselibpathinferenceinfererreferencejs6160_inferAnnotationFromBinaryExpression(name, path) {
  var operator = path.node.operator;

  var right = path.get("right").resolve();
  var left = path.get("left").resolve();

  var target = void 0;
  if (left.isIdentifier({ name: name })) {
    target = right;
  } else if (right.isIdentifier({ name: name })) {
    target = left;
  }
  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    } else if (_babeltraverselibpathinferenceinfererreferencejs6160_t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return _babeltraverselibpathinferenceinfererreferencejs6160_t.numberTypeAnnotation();
    } else {
      return;
    }
  } else {
    if (operator !== "===") return;
  }

  var typeofPath = void 0;
  var typePath = void 0;
  if (left.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = right;
    typePath = left;
  }
  if (!typePath && !typeofPath) return;

  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;

  var typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;

  if (!typeofPath.get("argument").isIdentifier({ name: name })) return;

  return _babeltraverselibpathinferenceinfererreferencejs6160_t.createTypeAnnotationBasedOnTypeof(typePath.node.value);
}

function _babeltraverselibpathinferenceinfererreferencejs6160_getParentConditionalPath(path) {
  var parentPath = void 0;
  while (parentPath = path.parentPath) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      } else {
        return parentPath;
      }
    } else {
      path = parentPath;
    }
  }
}

function _babeltraverselibpathinferenceinfererreferencejs6160_getConditionalAnnotation(path, name) {
  var ifStatement = _babeltraverselibpathinferenceinfererreferencejs6160_getParentConditionalPath(path);
  if (!ifStatement) return;

  var test = ifStatement.get("test");
  var paths = [test];
  var types = [];

  do {
    var _path = paths.shift().resolve();

    if (_path.isLogicalExpression()) {
      paths.push(_path.get("left"));
      paths.push(_path.get("right"));
    }

    if (_path.isBinaryExpression()) {
      var type = _babeltraverselibpathinferenceinfererreferencejs6160_inferAnnotationFromBinaryExpression(name, _path);
      if (type) types.push(type);
    }
  } while (paths.length);

  if (types.length) {
    return {
      typeAnnotation: _babeltraverselibpathinferenceinfererreferencejs6160_t.createUnionTypeAnnotation(types),
      ifStatement: ifStatement
    };
  } else {
    return _babeltraverselibpathinferenceinfererreferencejs6160_getConditionalAnnotation(ifStatement, name);
  }
}
$m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'].exports = $m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/li...inference/inferer-reference.js ≠≠*/

/*== node_modules/slash/index.js ==*/
$m['slash/index.js#1.0.0'] = { exports: {} };
'use strict';

$m['slash/index.js#1.0.0'].exports = function (str) {
	var isExtendedLengthPath = /^\\\\\?\\/.test(str);
	var hasNonAscii = /[^\x00-\x80]+/.test(str);

	if (isExtendedLengthPath || hasNonAscii) {
		return str;
	}

	return str.replace(/\\/g, '/');
};
/*≠≠ node_modules/slash/index.js ≠≠*/

/*== node_modules/lodash/escapeRegExp.js ==*/
$m['lodash/escapeRegExp.js#4.16.2'] = { exports: {} };
var _lodashescapeRegExpjs4162_toString = $m['lodash/toString.js#4.16.2'].exports;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var _lodashescapeRegExpjs4162_reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    _lodashescapeRegExpjs4162_reHasRegExpChar = RegExp(_lodashescapeRegExpjs4162_reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function _lodashescapeRegExpjs4162_escapeRegExp(string) {
  string = _lodashescapeRegExpjs4162_toString(string);
  return string && _lodashescapeRegExpjs4162_reHasRegExpChar.test(string) ? string.replace(_lodashescapeRegExpjs4162_reRegExpChar, '\\$&') : string;
}

$m['lodash/escapeRegExp.js#4.16.2'].exports = _lodashescapeRegExpjs4162_escapeRegExp;
/*≠≠ node_modules/lodash/escapeRegExp.js ≠≠*/

/*== node_modules/lodash/startsWith.js ==*/
$m['lodash/startsWith.js#4.16.2'] = { exports: {} };
var _lodashstartsWithjs4162_baseClamp = $m['lodash/_baseClamp.js#4.16.2'].exports,
    _lodashstartsWithjs4162_baseToString = $m['lodash/_baseToString.js#4.16.2'].exports,
    _lodashstartsWithjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports,
    _lodashstartsWithjs4162_toString = $m['lodash/toString.js#4.16.2'].exports;

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function _lodashstartsWithjs4162_startsWith(string, target, position) {
  string = _lodashstartsWithjs4162_toString(string);
  position = _lodashstartsWithjs4162_baseClamp(_lodashstartsWithjs4162_toInteger(position), 0, string.length);
  target = _lodashstartsWithjs4162_baseToString(target);
  return string.slice(position, position + target.length) == target;
}

$m['lodash/startsWith.js#4.16.2'].exports = _lodashstartsWithjs4162_startsWith;
/*≠≠ node_modules/lodash/startsWith.js ≠≠*/

/*== node_modules/lodash/isBoolean.js ==*/
$m['lodash/isBoolean.js#4.16.2'] = { exports: {} };
var _lodashisBooleanjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisBooleanjs4162_boolTag = '[object Boolean]';

/** Used for built-in method references. */
var _lodashisBooleanjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisBooleanjs4162_objectToString = _lodashisBooleanjs4162_objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function _lodashisBooleanjs4162_isBoolean(value) {
  return value === true || value === false || _lodashisBooleanjs4162_isObjectLike(value) && _lodashisBooleanjs4162_objectToString.call(value) == _lodashisBooleanjs4162_boolTag;
}

$m['lodash/isBoolean.js#4.16.2'].exports = _lodashisBooleanjs4162_isBoolean;
/*≠≠ node_modules/lodash/isBoolean.js ≠≠*/

/*== node_modules/minimatch/minimatch.js ==*/
$m['minimatch/minimatch.js#3.0.3'] = { exports: {} };
$m['minimatch/minimatch.js#3.0.3'].exports = _minimatchminimatchjs303_minimatch;
_minimatchminimatchjs303_minimatch.Minimatch = _minimatchminimatchjs303_Minimatch;

var _minimatchminimatchjs303_path = { sep: '/' };
try {
  _minimatchminimatchjs303_path = require('path');
} catch (er) {}

var _minimatchminimatchjs303_GLOBSTAR = _minimatchminimatchjs303_minimatch.GLOBSTAR = _minimatchminimatchjs303_Minimatch.GLOBSTAR = {};
var _minimatchminimatchjs303_expand = $m['brace-expansion/index.js#1.1.6'].exports;

var _minimatchminimatchjs303_plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var _minimatchminimatchjs303_qmark = '[^/]';

// * => any number of characters
var _minimatchminimatchjs303_star = _minimatchminimatchjs303_qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var _minimatchminimatchjs303_twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var _minimatchminimatchjs303_twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var _minimatchminimatchjs303_reSpecials = _minimatchminimatchjs303_charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function _minimatchminimatchjs303_charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var _minimatchminimatchjs303_slashSplit = /\/+/;

_minimatchminimatchjs303_minimatch.filter = _minimatchminimatchjs303_filter;
function _minimatchminimatchjs303_filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return _minimatchminimatchjs303_minimatch(p, pattern, options);
  };
}

function _minimatchminimatchjs303_ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t;
}

_minimatchminimatchjs303_minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs303_minimatch;

  var orig = _minimatchminimatchjs303_minimatch;

  var m = function minimatch(p, pattern, options) {
    return orig.minimatch(p, pattern, _minimatchminimatchjs303_ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, _minimatchminimatchjs303_ext(def, options));
  };

  return m;
};

_minimatchminimatchjs303_Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs303_Minimatch;
  return _minimatchminimatchjs303_minimatch.defaults(def).Minimatch;
};

function _minimatchminimatchjs303_minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === '';

  return new _minimatchminimatchjs303_Minimatch(pattern, options).match(p);
}

function _minimatchminimatchjs303_Minimatch(pattern, options) {
  if (!(this instanceof _minimatchminimatchjs303_Minimatch)) {
    return new _minimatchminimatchjs303_Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (_minimatchminimatchjs303_path.sep !== '/') {
    pattern = pattern.split(_minimatchminimatchjs303_path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

_minimatchminimatchjs303_Minimatch.prototype.debug = function () {};

_minimatchminimatchjs303_Minimatch.prototype.make = _minimatchminimatchjs303_make;
function _minimatchminimatchjs303_make() {
  // don't do it more than once.
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(_minimatchminimatchjs303_slashSplit);
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

_minimatchminimatchjs303_Minimatch.prototype.parseNegate = _minimatchminimatchjs303_parseNegate;
function _minimatchminimatchjs303_parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
_minimatchminimatchjs303_minimatch.braceExpand = function (pattern, options) {
  return _minimatchminimatchjs303_braceExpand(pattern, options);
};

_minimatchminimatchjs303_Minimatch.prototype.braceExpand = _minimatchminimatchjs303_braceExpand;

function _minimatchminimatchjs303_braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof _minimatchminimatchjs303_Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern];
  }

  return _minimatchminimatchjs303_expand(pattern);
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
_minimatchminimatchjs303_Minimatch.prototype.parse = _minimatchminimatchjs303_parse;
var _minimatchminimatchjs303_SUBPARSE = {};
function _minimatchminimatchjs303_parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long');
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return _minimatchminimatchjs303_GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += _minimatchminimatchjs303_star;
          hasMagic = true;
          break;
        case '?':
          re += _minimatchminimatchjs303_qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && _minimatchminimatchjs303_reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false;

      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;

      case '(':
        if (inClass) {
          re += '(';
          continue;
        }

        if (!stateChar) {
          re += '\\(';
          continue;
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: _minimatchminimatchjs303_plTypes[stateChar].open,
          close: _minimatchminimatchjs303_plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }

        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue;
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, _minimatchminimatchjs303_SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (_minimatchminimatchjs303_reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, _minimatchminimatchjs303_SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });

    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? _minimatchminimatchjs303_star : pl.type === '?' ? _minimatchminimatchjs303_qmark : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== _minimatchminimatchjs303_SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === _minimatchminimatchjs303_SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return _minimatchminimatchjs303_globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

_minimatchminimatchjs303_minimatch.makeRe = function (pattern, options) {
  return new _minimatchminimatchjs303_Minimatch(pattern, options || {}).makeRe();
};

_minimatchminimatchjs303_Minimatch.prototype.makeRe = _minimatchminimatchjs303_makeRe;
function _minimatchminimatchjs303_makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? _minimatchminimatchjs303_star : options.dot ? _minimatchminimatchjs303_twoStarDot : _minimatchminimatchjs303_twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === _minimatchminimatchjs303_GLOBSTAR ? twoStar : typeof p === 'string' ? _minimatchminimatchjs303_regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}

_minimatchminimatchjs303_minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new _minimatchminimatchjs303_Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};

_minimatchminimatchjs303_Minimatch.prototype.match = _minimatchminimatchjs303_match;
function _minimatchminimatchjs303_match(f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;

  // windows: need to use /, not \
  if (_minimatchminimatchjs303_path.sep !== '/') {
    f = f.split(_minimatchminimatchjs303_path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(_minimatchminimatchjs303_slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
_minimatchminimatchjs303_Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false;

    if (p === _minimatchminimatchjs303_GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
    return emptyFileEnd;
  }

  // should be unreachable.
  throw new Error('wtf?');
};

// replace stuff like \* with *
function _minimatchminimatchjs303_globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function _minimatchminimatchjs303_regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/*≠≠ node_modules/minimatch/minimatch.js ≠≠*/

/*== node_modules/lodash/includes.js ==*/
$m['lodash/includes.js#4.16.2'] = { exports: {} };
var _lodashincludesjs4162_baseIndexOf = $m['lodash/_baseIndexOf.js#4.16.2'].exports,
    _lodashincludesjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports,
    _lodashincludesjs4162_isString = $m['lodash/isString.js#4.16.2'].exports,
    _lodashincludesjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports,
    _lodashincludesjs4162_values = $m['lodash/values.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashincludesjs4162_nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function _lodashincludesjs4162_includes(collection, value, fromIndex, guard) {
  collection = _lodashincludesjs4162_isArrayLike(collection) ? collection : _lodashincludesjs4162_values(collection);
  fromIndex = fromIndex && !guard ? _lodashincludesjs4162_toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = _lodashincludesjs4162_nativeMax(length + fromIndex, 0);
  }
  return _lodashincludesjs4162_isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _lodashincludesjs4162_baseIndexOf(collection, value, fromIndex) > -1;
}

$m['lodash/includes.js#4.16.2'].exports = _lodashincludesjs4162_includes;
/*≠≠ node_modules/lodash/includes.js ≠≠*/

/*== node_modules/lodash/isString.js ==*/
$m['lodash/isString.js#4.16.2'] = { exports: {} };
var _lodashisStringjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashisStringjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisStringjs4162_stringTag = '[object String]';

/** Used for built-in method references. */
var _lodashisStringjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisStringjs4162_objectToString = _lodashisStringjs4162_objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function _lodashisStringjs4162_isString(value) {
  return typeof value == 'string' || !_lodashisStringjs4162_isArray(value) && _lodashisStringjs4162_isObjectLike(value) && _lodashisStringjs4162_objectToString.call(value) == _lodashisStringjs4162_stringTag;
}

$m['lodash/isString.js#4.16.2'].exports = _lodashisStringjs4162_isString;
/*≠≠ node_modules/lodash/isString.js ≠≠*/

/*== node_modules/lodash/isRegExp.js ==*/
$m['lodash/isRegExp.js#4.16.2'] = { exports: {} };
var _lodashisRegExpjs4162_baseIsRegExp = $m['lodash/_baseIsRegExp.js#4.16.2'].exports,
    _lodashisRegExpjs4162_baseUnary = $m['lodash/_baseUnary.js#4.16.2'].exports,
    _lodashisRegExpjs4162_nodeUtil = $m['lodash/_nodeUtil.js#4.16.2'].exports;

/* Node.js helper references. */
var _lodashisRegExpjs4162_nodeIsRegExp = _lodashisRegExpjs4162_nodeUtil && _lodashisRegExpjs4162_nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var _lodashisRegExpjs4162_isRegExp = _lodashisRegExpjs4162_nodeIsRegExp ? _lodashisRegExpjs4162_baseUnary(_lodashisRegExpjs4162_nodeIsRegExp) : _lodashisRegExpjs4162_baseIsRegExp;

$m['lodash/isRegExp.js#4.16.2'].exports = _lodashisRegExpjs4162_isRegExp;
/*≠≠ node_modules/lodash/isRegExp.js ≠≠*/

/*== node_modules/babel-core/lib/util.js ==*/
$m['babel-core/lib/util.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/util.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/util.js#6.16.0'].exports.inspect = $m['babel-core/lib/util.js#6.16.0'].exports.inherits = undefined;

var _babelcorelibutiljs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibutiljs6160__getIterator3 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__getIterator2);

var _babelcorelibutiljs6160__util = require("util");

Object.defineProperty($m['babel-core/lib/util.js#6.16.0'].exports, "inherits", {
  enumerable: true,
  get: function get() {
    return _babelcorelibutiljs6160__util.inherits;
  }
});
Object.defineProperty($m['babel-core/lib/util.js#6.16.0'].exports, "inspect", {
  enumerable: true,
  get: function get() {
    return _babelcorelibutiljs6160__util.inspect;
  }
});
$m['babel-core/lib/util.js#6.16.0'].exports.canCompile = _babelcorelibutiljs6160_canCompile;
$m['babel-core/lib/util.js#6.16.0'].exports.list = _babelcorelibutiljs6160_list;
$m['babel-core/lib/util.js#6.16.0'].exports.regexify = _babelcorelibutiljs6160_regexify;
$m['babel-core/lib/util.js#6.16.0'].exports.arrayify = _babelcorelibutiljs6160_arrayify;
$m['babel-core/lib/util.js#6.16.0'].exports.booleanify = _babelcorelibutiljs6160_booleanify;
$m['babel-core/lib/util.js#6.16.0'].exports.shouldIgnore = _babelcorelibutiljs6160_shouldIgnore;

var _babelcorelibutiljs6160__escapeRegExp = $m['lodash/escapeRegExp.js#4.16.2'].exports;

var _babelcorelibutiljs6160__escapeRegExp2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__escapeRegExp);

var _babelcorelibutiljs6160__startsWith = $m['lodash/startsWith.js#4.16.2'].exports;

var _babelcorelibutiljs6160__startsWith2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__startsWith);

var _babelcorelibutiljs6160__isBoolean = $m['lodash/isBoolean.js#4.16.2'].exports;

var _babelcorelibutiljs6160__isBoolean2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__isBoolean);

var _babelcorelibutiljs6160__minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;

var _babelcorelibutiljs6160__minimatch2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__minimatch);

var _babelcorelibutiljs6160__includes = $m['lodash/includes.js#4.16.2'].exports;

var _babelcorelibutiljs6160__includes2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__includes);

var _babelcorelibutiljs6160__isString = $m['lodash/isString.js#4.16.2'].exports;

var _babelcorelibutiljs6160__isString2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__isString);

var _babelcorelibutiljs6160__isRegExp = $m['lodash/isRegExp.js#4.16.2'].exports;

var _babelcorelibutiljs6160__isRegExp2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__isRegExp);

var _babelcorelibutiljs6160__path = require("path");

var _babelcorelibutiljs6160__path2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__path);

var _babelcorelibutiljs6160__slash = $m['slash/index.js#1.0.0'].exports;

var _babelcorelibutiljs6160__slash2 = _babelcorelibutiljs6160__interopRequireDefault(_babelcorelibutiljs6160__slash);

function _babelcorelibutiljs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelcorelibutiljs6160_canCompile(filename, altExts) {
  var exts = altExts || _babelcorelibutiljs6160_canCompile.EXTENSIONS;
  var ext = _babelcorelibutiljs6160__path2.default.extname(filename);
  return (0, _babelcorelibutiljs6160__includes2.default)(exts, ext);
}

_babelcorelibutiljs6160_canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"];

function _babelcorelibutiljs6160_list(val) {
  if (!val) {
    return [];
  } else if (Array.isArray(val)) {
    return val;
  } else if (typeof val === "string") {
    return val.split(",");
  } else {
    return [val];
  }
}

function _babelcorelibutiljs6160_regexify(val) {
  if (!val) {
    return new RegExp(/.^/);
  }

  if (Array.isArray(val)) {
    val = new RegExp(val.map(_babelcorelibutiljs6160__escapeRegExp2.default).join("|"), "i");
  }

  if (typeof val === "string") {
    val = (0, _babelcorelibutiljs6160__slash2.default)(val);

    if ((0, _babelcorelibutiljs6160__startsWith2.default)(val, "./") || (0, _babelcorelibutiljs6160__startsWith2.default)(val, "*/")) val = val.slice(2);
    if ((0, _babelcorelibutiljs6160__startsWith2.default)(val, "**/")) val = val.slice(3);

    var regex = _babelcorelibutiljs6160__minimatch2.default.makeRe(val, { nocase: true });
    return new RegExp(regex.source.slice(1, -1), "i");
  }

  if ((0, _babelcorelibutiljs6160__isRegExp2.default)(val)) {
    return val;
  }

  throw new TypeError("illegal type for regexify");
}

function _babelcorelibutiljs6160_arrayify(val, mapFn) {
  if (!val) return [];
  if ((0, _babelcorelibutiljs6160__isBoolean2.default)(val)) return _babelcorelibutiljs6160_arrayify([val], mapFn);
  if ((0, _babelcorelibutiljs6160__isString2.default)(val)) return _babelcorelibutiljs6160_arrayify(_babelcorelibutiljs6160_list(val), mapFn);

  if (Array.isArray(val)) {
    if (mapFn) val = val.map(mapFn);
    return val;
  }

  return [val];
}

function _babelcorelibutiljs6160_booleanify(val) {
  if (val === "true" || val == 1) {
    return true;
  }

  if (val === "false" || val == 0 || !val) {
    return false;
  }

  return val;
}

function _babelcorelibutiljs6160_shouldIgnore(filename) {
  var ignore = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var only = arguments[2];

  filename = (0, _babelcorelibutiljs6160__slash2.default)(filename);

  if (only) {
    for (var _iterator = only, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibutiljs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var pattern = _ref;

      if (_babelcorelibutiljs6160__shouldIgnore(pattern, filename)) return false;
    }
    return true;
  } else if (ignore.length) {
    for (var _iterator2 = ignore, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelcorelibutiljs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _pattern = _ref2;

      if (_babelcorelibutiljs6160__shouldIgnore(_pattern, filename)) return true;
    }
  }

  return false;
}

function _babelcorelibutiljs6160__shouldIgnore(pattern, filename) {
  if (typeof pattern === "function") {
    return pattern(filename);
  } else {
    return pattern.test(filename);
  }
}
/*≠≠ node_modules/babel-core/lib/util.js ≠≠*/

/*== node_modules/lodash/_baseRest.js ==*/
$m['lodash/_baseRest.js#4.16.2'] = { exports: {} };
var _lodashbaseRestjs4162_identity = $m['lodash/identity.js#4.16.2'].exports,
    _lodashbaseRestjs4162_overRest = $m['lodash/_overRest.js#4.16.2'].exports,
    _lodashbaseRestjs4162_setToString = $m['lodash/_setToString.js#4.16.2'].exports;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function _lodashbaseRestjs4162_baseRest(func, start) {
  return _lodashbaseRestjs4162_setToString(_lodashbaseRestjs4162_overRest(func, start, _lodashbaseRestjs4162_identity), func + '');
}

$m['lodash/_baseRest.js#4.16.2'].exports = _lodashbaseRestjs4162_baseRest;
/*≠≠ node_modules/lodash/_baseRest.js ≠≠*/

/*== node_modules/lodash/_isIterateeCall.js ==*/
$m['lodash/_isIterateeCall.js#4.16.2'] = { exports: {} };
var _lodashisIterateeCalljs4162_eq = $m['lodash/eq.js#4.16.2'].exports,
    _lodashisIterateeCalljs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports,
    _lodashisIterateeCalljs4162_isIndex = $m['lodash/_isIndex.js#4.16.2'].exports,
    _lodashisIterateeCalljs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function _lodashisIterateeCalljs4162_isIterateeCall(value, index, object) {
  if (!_lodashisIterateeCalljs4162_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number' ? _lodashisIterateeCalljs4162_isArrayLike(object) && _lodashisIterateeCalljs4162_isIndex(index, object.length) : type == 'string' && index in object) {
    return _lodashisIterateeCalljs4162_eq(object[index], value);
  }
  return false;
}

$m['lodash/_isIterateeCall.js#4.16.2'].exports = _lodashisIterateeCalljs4162_isIterateeCall;
/*≠≠ node_modules/lodash/_isIterateeCall.js ≠≠*/

/*== node_modules/lodash/_createAssigner.js ==*/
$m['lodash/_createAssigner.js#4.16.2'] = { exports: {} };
var _lodashcreateAssignerjs4162_baseRest = $m['lodash/_baseRest.js#4.16.2'].exports,
    _lodashcreateAssignerjs4162_isIterateeCall = $m['lodash/_isIterateeCall.js#4.16.2'].exports;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function _lodashcreateAssignerjs4162_createAssigner(assigner) {
  return _lodashcreateAssignerjs4162_baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && _lodashcreateAssignerjs4162_isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

$m['lodash/_createAssigner.js#4.16.2'].exports = _lodashcreateAssignerjs4162_createAssigner;
/*≠≠ node_modules/lodash/_createAssigner.js ≠≠*/

/*== node_modules/lodash/_Stack.js ==*/
$m['lodash/_Stack.js#4.16.2'] = { exports: {} };
var _lodashStackjs4162_ListCache = $m['lodash/_ListCache.js#4.16.2'].exports,
    _lodashStackjs4162_stackClear = $m['lodash/_stackClear.js#4.16.2'].exports,
    _lodashStackjs4162_stackDelete = $m['lodash/_stackDelete.js#4.16.2'].exports,
    _lodashStackjs4162_stackGet = $m['lodash/_stackGet.js#4.16.2'].exports,
    _lodashStackjs4162_stackHas = $m['lodash/_stackHas.js#4.16.2'].exports,
    _lodashStackjs4162_stackSet = $m['lodash/_stackSet.js#4.16.2'].exports;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashStackjs4162_Stack(entries) {
  var data = this.__data__ = new _lodashStackjs4162_ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
_lodashStackjs4162_Stack.prototype.clear = _lodashStackjs4162_stackClear;
_lodashStackjs4162_Stack.prototype['delete'] = _lodashStackjs4162_stackDelete;
_lodashStackjs4162_Stack.prototype.get = _lodashStackjs4162_stackGet;
_lodashStackjs4162_Stack.prototype.has = _lodashStackjs4162_stackHas;
_lodashStackjs4162_Stack.prototype.set = _lodashStackjs4162_stackSet;

$m['lodash/_Stack.js#4.16.2'].exports = _lodashStackjs4162_Stack;
/*≠≠ node_modules/lodash/_Stack.js ≠≠*/

/*== node_modules/lodash/_arrayEach.js ==*/
$m['lodash/_arrayEach.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function _lodasharrayEachjs4162_arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

$m['lodash/_arrayEach.js#4.16.2'].exports = _lodasharrayEachjs4162_arrayEach;
/*≠≠ node_modules/lodash/_arrayEach.js ≠≠*/

/*== node_modules/lodash/_assignMergeValue.js ==*/
$m['lodash/_assignMergeValue.js#4.16.2'] = { exports: {} };
var _lodashassignMergeValuejs4162_baseAssignValue = $m['lodash/_baseAssignValue.js#4.16.2'].exports,
    _lodashassignMergeValuejs4162_eq = $m['lodash/eq.js#4.16.2'].exports;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function _lodashassignMergeValuejs4162_assignMergeValue(object, key, value) {
  if (value !== undefined && !_lodashassignMergeValuejs4162_eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
    _lodashassignMergeValuejs4162_baseAssignValue(object, key, value);
  }
}

$m['lodash/_assignMergeValue.js#4.16.2'].exports = _lodashassignMergeValuejs4162_assignMergeValue;
/*≠≠ node_modules/lodash/_assignMergeValue.js ≠≠*/

/*== node_modules/lodash/_baseKeysIn.js ==*/
$m['lodash/_baseKeysIn.js#4.16.2'] = { exports: {} };
var _lodashbaseKeysInjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseKeysInjs4162_isPrototype = $m['lodash/_isPrototype.js#4.16.2'].exports,
    _lodashbaseKeysInjs4162_nativeKeysIn = $m['lodash/_nativeKeysIn.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashbaseKeysInjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseKeysInjs4162_hasOwnProperty = _lodashbaseKeysInjs4162_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashbaseKeysInjs4162_baseKeysIn(object) {
  if (!_lodashbaseKeysInjs4162_isObject(object)) {
    return _lodashbaseKeysInjs4162_nativeKeysIn(object);
  }
  var isProto = _lodashbaseKeysInjs4162_isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_lodashbaseKeysInjs4162_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_baseKeysIn.js#4.16.2'].exports = _lodashbaseKeysInjs4162_baseKeysIn;
/*≠≠ node_modules/lodash/_baseKeysIn.js ≠≠*/

/*== node_modules/lodash/_baseMergeDeep.js ==*/
$m['lodash/_baseMergeDeep.js#4.16.2'] = { exports: {} };
var _lodashbaseMergeDeepjs4162_assignMergeValue = $m['lodash/_assignMergeValue.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_baseClone = $m['lodash/_baseClone.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_copyArray = $m['lodash/_copyArray.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isArguments = $m['lodash/isArguments.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isFunction = $m['lodash/isFunction.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isPlainObject = $m['lodash/isPlainObject.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_isTypedArray = $m['lodash/isTypedArray.js#4.16.2'].exports,
    _lodashbaseMergeDeepjs4162_toPlainObject = $m['lodash/toPlainObject.js#4.16.2'].exports;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function _lodashbaseMergeDeepjs4162_baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    _lodashbaseMergeDeepjs4162_assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (_lodashbaseMergeDeepjs4162_isArray(srcValue) || _lodashbaseMergeDeepjs4162_isTypedArray(srcValue)) {
      if (_lodashbaseMergeDeepjs4162_isArray(objValue)) {
        newValue = objValue;
      } else if (_lodashbaseMergeDeepjs4162_isArrayLikeObject(objValue)) {
        newValue = _lodashbaseMergeDeepjs4162_copyArray(objValue);
      } else {
        isCommon = false;
        newValue = _lodashbaseMergeDeepjs4162_baseClone(srcValue, true);
      }
    } else if (_lodashbaseMergeDeepjs4162_isPlainObject(srcValue) || _lodashbaseMergeDeepjs4162_isArguments(srcValue)) {
      if (_lodashbaseMergeDeepjs4162_isArguments(objValue)) {
        newValue = _lodashbaseMergeDeepjs4162_toPlainObject(objValue);
      } else if (!_lodashbaseMergeDeepjs4162_isObject(objValue) || srcIndex && _lodashbaseMergeDeepjs4162_isFunction(objValue)) {
        isCommon = false;
        newValue = _lodashbaseMergeDeepjs4162_baseClone(srcValue, true);
      } else {
        newValue = objValue;
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _lodashbaseMergeDeepjs4162_assignMergeValue(object, key, newValue);
}

$m['lodash/_baseMergeDeep.js#4.16.2'].exports = _lodashbaseMergeDeepjs4162_baseMergeDeep;
/*≠≠ node_modules/lodash/_baseMergeDeep.js ≠≠*/

/*== node_modules/lodash/isArray.js ==*/
$m['lodash/isArray.js#4.16.2'] = { exports: {} };
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var _lodashisArrayjs4162_isArray = Array.isArray;

$m['lodash/isArray.js#4.16.2'].exports = _lodashisArrayjs4162_isArray;
/*≠≠ node_modules/lodash/isArray.js ≠≠*/

/*== node_modules/lodash/isObject.js ==*/
$m['lodash/isObject.js#4.16.2'] = { exports: {} };
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function _lodashisObjectjs4162_isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

$m['lodash/isObject.js#4.16.2'].exports = _lodashisObjectjs4162_isObject;
/*≠≠ node_modules/lodash/isObject.js ≠≠*/

/*== node_modules/lodash/isTypedArray.js ==*/
$m['lodash/isTypedArray.js#4.16.2'] = { exports: {} };
var _lodashisTypedArrayjs4162_baseIsTypedArray = $m['lodash/_baseIsTypedArray.js#4.16.2'].exports,
    _lodashisTypedArrayjs4162_baseUnary = $m['lodash/_baseUnary.js#4.16.2'].exports,
    _lodashisTypedArrayjs4162_nodeUtil = $m['lodash/_nodeUtil.js#4.16.2'].exports;

/* Node.js helper references. */
var _lodashisTypedArrayjs4162_nodeIsTypedArray = _lodashisTypedArrayjs4162_nodeUtil && _lodashisTypedArrayjs4162_nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var _lodashisTypedArrayjs4162_isTypedArray = _lodashisTypedArrayjs4162_nodeIsTypedArray ? _lodashisTypedArrayjs4162_baseUnary(_lodashisTypedArrayjs4162_nodeIsTypedArray) : _lodashisTypedArrayjs4162_baseIsTypedArray;

$m['lodash/isTypedArray.js#4.16.2'].exports = _lodashisTypedArrayjs4162_isTypedArray;
/*≠≠ node_modules/lodash/isTypedArray.js ≠≠*/

/*== node_modules/lodash/_baseMerge.js ==*/
$m['lodash/_baseMerge.js#4.16.2'] = { exports: {} };
var _lodashbaseMergejs4162_Stack = $m['lodash/_Stack.js#4.16.2'].exports,
    _lodashbaseMergejs4162_arrayEach = $m['lodash/_arrayEach.js#4.16.2'].exports,
    _lodashbaseMergejs4162_assignMergeValue = $m['lodash/_assignMergeValue.js#4.16.2'].exports,
    _lodashbaseMergejs4162_baseKeysIn = $m['lodash/_baseKeysIn.js#4.16.2'].exports,
    _lodashbaseMergejs4162_baseMergeDeep = $m['lodash/_baseMergeDeep.js#4.16.2'].exports,
    _lodashbaseMergejs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashbaseMergejs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseMergejs4162_isTypedArray = $m['lodash/isTypedArray.js#4.16.2'].exports;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function _lodashbaseMergejs4162_baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(_lodashbaseMergejs4162_isArray(source) || _lodashbaseMergejs4162_isTypedArray(source))) {
    var props = _lodashbaseMergejs4162_baseKeysIn(source);
  }
  _lodashbaseMergejs4162_arrayEach(props || source, function (srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (_lodashbaseMergejs4162_isObject(srcValue)) {
      stack || (stack = new _lodashbaseMergejs4162_Stack());
      _lodashbaseMergejs4162_baseMergeDeep(object, source, key, srcIndex, _lodashbaseMergejs4162_baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _lodashbaseMergejs4162_assignMergeValue(object, key, newValue);
    }
  });
}

$m['lodash/_baseMerge.js#4.16.2'].exports = _lodashbaseMergejs4162_baseMerge;
/*≠≠ node_modules/lodash/_baseMerge.js ≠≠*/

/*== node_modules/path-exists/index.js ==*/
$m['path-exists/index.js#1.0.0'] = { exports: {} };
'use strict';

var _pathexistsindexjs100_fs = require('fs');

$m['path-exists/index.js#1.0.0'].exports = function (pth, cb) {
	var fn = typeof _pathexistsindexjs100_fs.access === 'function' ? _pathexistsindexjs100_fs.access : _pathexistsindexjs100_fs.stat;

	fn(pth, function (err) {
		cb(null, !err);
	});
};

$m['path-exists/index.js#1.0.0'].exports.sync = function (pth) {
	var fn = typeof _pathexistsindexjs100_fs.accessSync === 'function' ? _pathexistsindexjs100_fs.accessSync : _pathexistsindexjs100_fs.statSync;

	try {
		fn(pth);
		return true;
	} catch (err) {
		return false;
	}
};
/*≠≠ node_modules/path-exists/index.js ≠≠*/

/*== node_modules/lodash/mergeWith.js ==*/
$m['lodash/mergeWith.js#4.16.2'] = { exports: {} };
var _lodashmergeWithjs4162_baseMerge = $m['lodash/_baseMerge.js#4.16.2'].exports,
    _lodashmergeWithjs4162_createAssigner = $m['lodash/_createAssigner.js#4.16.2'].exports;

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var _lodashmergeWithjs4162_mergeWith = _lodashmergeWithjs4162_createAssigner(function (object, source, srcIndex, customizer) {
  _lodashmergeWithjs4162_baseMerge(object, source, srcIndex, customizer);
});

$m['lodash/mergeWith.js#4.16.2'].exports = _lodashmergeWithjs4162_mergeWith;
/*≠≠ node_modules/lodash/mergeWith.js ≠≠*/

/*== node_modules/babel-core/lib/tr...mation/file/options/parsers.js ==*/
$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.filename = undefined;
$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.boolean = _babelcorelibtransformationfileoptionsparsersjs6160_boolean;
$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.booleanString = _babelcorelibtransformationfileoptionsparsersjs6160_booleanString;
$m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.list = _babelcorelibtransformationfileoptionsparsersjs6160_list;

var _babelcorelibtransformationfileoptionsparsersjs6160__slash = $m['slash/index.js#1.0.0'].exports;

var _babelcorelibtransformationfileoptionsparsersjs6160__slash2 = _babelcorelibtransformationfileoptionsparsersjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsparsersjs6160__slash);

var _babelcorelibtransformationfileoptionsparsersjs6160__util = $m['babel-core/lib/util.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsparsersjs6160_util = _babelcorelibtransformationfileoptionsparsersjs6160__interopRequireWildcard(_babelcorelibtransformationfileoptionsparsersjs6160__util);

function _babelcorelibtransformationfileoptionsparsersjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationfileoptionsparsersjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfileoptionsparsersjs6160_filename = $m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports.filename = _babelcorelibtransformationfileoptionsparsersjs6160__slash2.default;

function _babelcorelibtransformationfileoptionsparsersjs6160_boolean(val) {
  return !!val;
}

function _babelcorelibtransformationfileoptionsparsersjs6160_booleanString(val) {
  return _babelcorelibtransformationfileoptionsparsersjs6160_util.booleanify(val);
}

function _babelcorelibtransformationfileoptionsparsersjs6160_list(val) {
  return _babelcorelibtransformationfileoptionsparsersjs6160_util.list(val);
}
/*≠≠ node_modules/babel-core/lib/tr...mation/file/options/parsers.js ≠≠*/

/*== node_modules/babel-traverse/lib/cache.js ==*/
$m['babel-traverse/lib/cache.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/cache.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/cache.js#6.16.0'].exports.scope = $m['babel-traverse/lib/cache.js#6.16.0'].exports.path = undefined;

var _babeltraverselibcachejs6160__weakMap = $m['babel-runtime/core-js/weak-map.js#6.11.6'].exports;

var _babeltraverselibcachejs6160__weakMap2 = _babeltraverselibcachejs6160__interopRequireDefault(_babeltraverselibcachejs6160__weakMap);

$m['babel-traverse/lib/cache.js#6.16.0'].exports.clear = _babeltraverselibcachejs6160_clear;

function _babeltraverselibcachejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibcachejs6160_path = $m['babel-traverse/lib/cache.js#6.16.0'].exports.path = new _babeltraverselibcachejs6160__weakMap2.default();
var _babeltraverselibcachejs6160_scope = $m['babel-traverse/lib/cache.js#6.16.0'].exports.scope = new _babeltraverselibcachejs6160__weakMap2.default();

function _babeltraverselibcachejs6160_clear() {
  $m['babel-traverse/lib/cache.js#6.16.0'].exports.path = _babeltraverselibcachejs6160_path = new _babeltraverselibcachejs6160__weakMap2.default();
  $m['babel-traverse/lib/cache.js#6.16.0'].exports.scope = _babeltraverselibcachejs6160_scope = new _babeltraverselibcachejs6160__weakMap2.default();
}
/*≠≠ node_modules/babel-traverse/lib/cache.js ≠≠*/

/*== node_modules/babel-traverse/lib/scope/lib/renamer.js ==*/
$m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibscopelibrenamerjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibscopelibrenamerjs6160__classCallCheck3 = _babeltraverselibscopelibrenamerjs6160__interopRequireDefault(_babeltraverselibscopelibrenamerjs6160__classCallCheck2);

var _babeltraverselibscopelibrenamerjs6160__binding = $m['babel-traverse/lib/scope/binding.js#6.16.0'].exports;

var _babeltraverselibscopelibrenamerjs6160__binding2 = _babeltraverselibscopelibrenamerjs6160__interopRequireDefault(_babeltraverselibscopelibrenamerjs6160__binding);

var _babeltraverselibscopelibrenamerjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibscopelibrenamerjs6160_t = _babeltraverselibscopelibrenamerjs6160__interopRequireWildcard(_babeltraverselibscopelibrenamerjs6160__babelTypes);

function _babeltraverselibscopelibrenamerjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibscopelibrenamerjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibscopelibrenamerjs6160_renameVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
    var node = _ref.node;

    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },
  Scope: function Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path.skip();
    }
  },
  "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
    var ids = path.getOuterBindingIdentifiers();

    for (var name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  }
};

var _babeltraverselibscopelibrenamerjs6160_Renamer = function () {
  function Renamer(binding, oldName, newName) {
    (0, _babeltraverselibscopelibrenamerjs6160__classCallCheck3.default)(this, Renamer);

    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
    var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;
    if (!exportDeclar) return;

    var isDefault = exportDeclar.isExportDefaultDeclaration();

    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier("default");
    }

    var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
    var specifiers = [];

    for (var name in bindingIdentifiers) {
      var localName = name === this.oldName ? this.newName : name;
      var exportedName = isDefault ? "default" : name;
      specifiers.push(_babeltraverselibscopelibrenamerjs6160_t.exportSpecifier(_babeltraverselibscopelibrenamerjs6160_t.identifier(localName), _babeltraverselibscopelibrenamerjs6160_t.identifier(exportedName)));
    }

    if (specifiers.length) {
      var aliasDeclar = _babeltraverselibscopelibrenamerjs6160_t.exportNamedDeclaration(null, specifiers);

      if (parentDeclar.isFunctionDeclaration()) {
        aliasDeclar._blockHoist = 3;
      }

      exportDeclar.insertAfter(aliasDeclar);
      exportDeclar.replaceWith(parentDeclar.node);
    }
  };

  Renamer.prototype.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
    return;

    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;
    if (this.binding.kind !== "hoisted") return;

    path.node.id = _babeltraverselibscopelibrenamerjs6160_t.identifier(this.oldName);
    path.node._blockHoist = 3;

    path.replaceWith(_babeltraverselibscopelibrenamerjs6160_t.variableDeclaration("let", [_babeltraverselibscopelibrenamerjs6160_t.variableDeclarator(_babeltraverselibscopelibrenamerjs6160_t.identifier(this.newName), _babeltraverselibscopelibrenamerjs6160_t.toExpression(path.node))]));
  };

  Renamer.prototype.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
    return;

    if (!path.isFunctionExpression() && !path.isClassExpression()) return;
    if (this.binding.kind !== "local") return;

    path.node.id = _babeltraverselibscopelibrenamerjs6160_t.identifier(this.oldName);

    this.binding.scope.parent.push({
      id: _babeltraverselibscopelibrenamerjs6160_t.identifier(this.newName)
    });

    path.replaceWith(_babeltraverselibscopelibrenamerjs6160_t.assignmentExpression("=", _babeltraverselibscopelibrenamerjs6160_t.identifier(this.newName), path.node));
  };

  Renamer.prototype.rename = function rename(block) {
    var binding = this.binding;
    var oldName = this.oldName;
    var newName = this.newName;
    var scope = binding.scope;
    var path = binding.path;

    var parentDeclar = path.find(function (path) {
      return path.isDeclaration() || path.isFunctionExpression();
    });
    if (parentDeclar) {
      this.maybeConvertFromExportDeclaration(parentDeclar);
    }

    scope.traverse(block || scope.block, _babeltraverselibscopelibrenamerjs6160_renameVisitor, this);

    if (!block) {
      scope.removeOwnBinding(oldName);
      scope.bindings[newName] = binding;
      this.binding.identifier.name = newName;
    }

    if (binding.type === "hoisted") {}

    if (parentDeclar) {
      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
      this.maybeConvertFromClassFunctionExpression(parentDeclar);
    }
  };

  return Renamer;
}();

$m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'].exports.default = _babeltraverselibscopelibrenamerjs6160_Renamer;
$m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'].exports = $m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/lib/scope/lib/renamer.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/lib/hoister.js ==*/
$m['babel-traverse/lib/path/lib/hoister.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/lib/hoister.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathlibhoisterjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibpathlibhoisterjs6160__classCallCheck3 = _babeltraverselibpathlibhoisterjs6160__interopRequireDefault(_babeltraverselibpathlibhoisterjs6160__classCallCheck2);

var _babeltraverselibpathlibhoisterjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathlibhoisterjs6160__getIterator3 = _babeltraverselibpathlibhoisterjs6160__interopRequireDefault(_babeltraverselibpathlibhoisterjs6160__getIterator2);

var _babeltraverselibpathlibhoisterjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathlibhoisterjs6160_t = _babeltraverselibpathlibhoisterjs6160__interopRequireWildcard(_babeltraverselibpathlibhoisterjs6160__babelTypes);

function _babeltraverselibpathlibhoisterjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathlibhoisterjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibpathlibhoisterjs6160_referenceVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.isJSXIdentifier() && _babeltraverselibpathlibhoisterjs6160__babelTypes.react.isCompatTag(path.node.name)) {
      return;
    }

    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return;

    if (binding !== state.scope.getBinding(path.node.name)) return;

    if (binding.constant) {
      state.bindings[path.node.name] = binding;
    } else {
      for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathlibhoisterjs6160__getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var violationPath = _ref;

        state.breakOnScopePaths = state.breakOnScopePaths.concat(violationPath.getAncestry());
      }
    }
  }
};

var _babeltraverselibpathlibhoisterjs6160_PathHoister = function () {
  function PathHoister(path, scope) {
    (0, _babeltraverselibpathlibhoisterjs6160__classCallCheck3.default)(this, PathHoister);

    this.breakOnScopePaths = [];
    this.bindings = {};
    this.scopes = [];
    this.scope = scope;
    this.path = path;
  }

  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
    for (var key in this.bindings) {
      var binding = this.bindings[key];
      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
        return false;
      }
    }

    return true;
  };

  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
    var scope = this.path.scope;
    do {
      if (this.isCompatibleScope(scope)) {
        this.scopes.push(scope);
      } else {
        break;
      }

      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
        break;
      }
    } while (scope = scope.parent);
  };

  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
    var path = this._getAttachmentPath();
    if (!path) return;

    var targetScope = path.scope;

    if (targetScope.path === path) {
      targetScope = path.scope.parent;
    }

    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (var name in this.bindings) {
        if (!targetScope.hasOwnBinding(name)) continue;

        var binding = this.bindings[name];

        if (binding.kind === "param") continue;

        if (binding.path.getStatementParent().key > path.key) return;
      }
    }

    return path;
  };

  PathHoister.prototype._getAttachmentPath = function _getAttachmentPath() {
    var scopes = this.scopes;

    var scope = scopes.pop();
    if (!scope) return;

    if (scope.path.isFunction()) {
      if (this.hasOwnParamBindings(scope)) {
        if (this.scope === scope) return;

        return scope.path.get("body").get("body")[0];
      } else {
        return this.getNextScopeStatementParent();
      }
    } else if (scope.path.isProgram()) {
      return this.getNextScopeStatementParent();
    }
  };

  PathHoister.prototype.getNextScopeStatementParent = function getNextScopeStatementParent() {
    var scope = this.scopes.pop();
    if (scope) return scope.path.getStatementParent();
  };

  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
    for (var name in this.bindings) {
      if (!scope.hasOwnBinding(name)) continue;

      var binding = this.bindings[name];
      if (binding.kind === "param") return true;
    }
    return false;
  };

  PathHoister.prototype.run = function run() {
    var node = this.path.node;
    if (node._hoisted) return;
    node._hoisted = true;

    this.path.traverse(_babeltraverselibpathlibhoisterjs6160_referenceVisitor, this);

    this.getCompatibleScopes();

    var attachTo = this.getAttachmentPath();
    if (!attachTo) return;

    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;

    var uid = attachTo.scope.generateUidIdentifier("ref");
    attachTo.insertBefore([_babeltraverselibpathlibhoisterjs6160_t.variableDeclaration("var", [_babeltraverselibpathlibhoisterjs6160_t.variableDeclarator(uid, this.path.node)])]);

    var parent = this.path.parentPath;
    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      uid = _babeltraverselibpathlibhoisterjs6160_t.JSXExpressionContainer(uid);
    }

    this.path.replaceWith(uid);
  };

  return PathHoister;
}();

$m['babel-traverse/lib/path/lib/hoister.js#6.16.0'].exports.default = _babeltraverselibpathlibhoisterjs6160_PathHoister;
$m['babel-traverse/lib/path/lib/hoister.js#6.16.0'].exports = $m['babel-traverse/lib/path/lib/hoister.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/lib/path/lib/hoister.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/inference/inferers.js ==*/
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.Class = $m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.Function = $m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.Identifier = undefined;

var _babeltraverselibpathinferenceinferersjs6160__infererReference = $m['babel-traverse/lib/path/inference/inferer-reference.js#6.16.0'].exports;

Object.defineProperty($m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports, "Identifier", {
  enumerable: true,
  get: function get() {
    return _babeltraverselibpathinferenceinferersjs6160__interopRequireDefault(_babeltraverselibpathinferenceinferersjs6160__infererReference).default;
  }
});
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.VariableDeclarator = _babeltraverselibpathinferenceinferersjs6160_VariableDeclarator;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.TypeCastExpression = _babeltraverselibpathinferenceinferersjs6160_TypeCastExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.NewExpression = _babeltraverselibpathinferenceinferersjs6160_NewExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.TemplateLiteral = _babeltraverselibpathinferenceinferersjs6160_TemplateLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.UnaryExpression = _babeltraverselibpathinferenceinferersjs6160_UnaryExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.BinaryExpression = _babeltraverselibpathinferenceinferersjs6160_BinaryExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.LogicalExpression = _babeltraverselibpathinferenceinferersjs6160_LogicalExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.ConditionalExpression = _babeltraverselibpathinferenceinferersjs6160_ConditionalExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.SequenceExpression = _babeltraverselibpathinferenceinferersjs6160_SequenceExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.AssignmentExpression = _babeltraverselibpathinferenceinferersjs6160_AssignmentExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.UpdateExpression = _babeltraverselibpathinferenceinferersjs6160_UpdateExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.StringLiteral = _babeltraverselibpathinferenceinferersjs6160_StringLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.NumericLiteral = _babeltraverselibpathinferenceinferersjs6160_NumericLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.BooleanLiteral = _babeltraverselibpathinferenceinferersjs6160_BooleanLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.NullLiteral = _babeltraverselibpathinferenceinferersjs6160_NullLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.RegExpLiteral = _babeltraverselibpathinferenceinferersjs6160_RegExpLiteral;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.ObjectExpression = _babeltraverselibpathinferenceinferersjs6160_ObjectExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.ArrayExpression = _babeltraverselibpathinferenceinferersjs6160_ArrayExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.RestElement = _babeltraverselibpathinferenceinferersjs6160_RestElement;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.CallExpression = _babeltraverselibpathinferenceinferersjs6160_CallExpression;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.TaggedTemplateExpression = _babeltraverselibpathinferenceinferersjs6160_TaggedTemplateExpression;

var _babeltraverselibpathinferenceinferersjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathinferenceinferersjs6160_t = _babeltraverselibpathinferenceinferersjs6160__interopRequireWildcard(_babeltraverselibpathinferenceinferersjs6160__babelTypes);

function _babeltraverselibpathinferenceinferersjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathinferenceinferersjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathinferenceinferersjs6160_VariableDeclarator() {
  var id = this.get("id");

  if (id.isIdentifier()) {
    return this.get("init").getTypeAnnotation();
  } else {
    return;
  }
}

function _babeltraverselibpathinferenceinferersjs6160_TypeCastExpression(node) {
  return node.typeAnnotation;
}

_babeltraverselibpathinferenceinferersjs6160_TypeCastExpression.validParent = true;

function _babeltraverselibpathinferenceinferersjs6160_NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(node.callee);
  }
}

function _babeltraverselibpathinferenceinferersjs6160_TemplateLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.stringTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_UnaryExpression(node) {
  var operator = node.operator;

  if (operator === "void") {
    return _babeltraverselibpathinferenceinferersjs6160_t.voidTypeAnnotation();
  } else if (_babeltraverselibpathinferenceinferersjs6160_t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation();
  } else if (_babeltraverselibpathinferenceinferersjs6160_t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return _babeltraverselibpathinferenceinferersjs6160_t.stringTypeAnnotation();
  } else if (_babeltraverselibpathinferenceinferersjs6160_t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return _babeltraverselibpathinferenceinferersjs6160_t.booleanTypeAnnotation();
  }
}

function _babeltraverselibpathinferenceinferersjs6160_BinaryExpression(node) {
  var operator = node.operator;

  if (_babeltraverselibpathinferenceinferersjs6160_t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation();
  } else if (_babeltraverselibpathinferenceinferersjs6160_t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return _babeltraverselibpathinferenceinferersjs6160_t.booleanTypeAnnotation();
  } else if (operator === "+") {
    var right = this.get("right");
    var left = this.get("left");

    if (left.isBaseType("number") && right.isBaseType("number")) {
      return _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      return _babeltraverselibpathinferenceinferersjs6160_t.stringTypeAnnotation();
    }

    return _babeltraverselibpathinferenceinferersjs6160_t.unionTypeAnnotation([_babeltraverselibpathinferenceinferersjs6160_t.stringTypeAnnotation(), _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation()]);
  }
}

function _babeltraverselibpathinferenceinferersjs6160_LogicalExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_t.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
}

function _babeltraverselibpathinferenceinferersjs6160_ConditionalExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_t.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
}

function _babeltraverselibpathinferenceinferersjs6160_SequenceExpression() {
  return this.get("expressions").pop().getTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_UpdateExpression(node) {
  var operator = node.operator;
  if (operator === "++" || operator === "--") {
    return _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation();
  }
}

function _babeltraverselibpathinferenceinferersjs6160_StringLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.stringTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_NumericLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.numberTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_BooleanLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.booleanTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_NullLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.nullLiteralTypeAnnotation();
}

function _babeltraverselibpathinferenceinferersjs6160_RegExpLiteral() {
  return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("RegExp"));
}

function _babeltraverselibpathinferenceinferersjs6160_ObjectExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("Object"));
}

function _babeltraverselibpathinferenceinferersjs6160_ArrayExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("Array"));
}

function _babeltraverselibpathinferenceinferersjs6160_RestElement() {
  return _babeltraverselibpathinferenceinferersjs6160_ArrayExpression();
}

_babeltraverselibpathinferenceinferersjs6160_RestElement.validParent = true;

function _babeltraverselibpathinferenceinferersjs6160_Func() {
  return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("Function"));
}

$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.Function = _babeltraverselibpathinferenceinferersjs6160_Func;
$m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports.Class = _babeltraverselibpathinferenceinferersjs6160_Func;
function _babeltraverselibpathinferenceinferersjs6160_CallExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_resolveCall(this.get("callee"));
}

function _babeltraverselibpathinferenceinferersjs6160_TaggedTemplateExpression() {
  return _babeltraverselibpathinferenceinferersjs6160_resolveCall(this.get("tag"));
}

function _babeltraverselibpathinferenceinferersjs6160_resolveCall(callee) {
  callee = callee.resolve();

  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("AsyncIterator"));
      } else {
        return _babeltraverselibpathinferenceinferersjs6160_t.genericTypeAnnotation(_babeltraverselibpathinferenceinferersjs6160_t.identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {}
    }
  }
}
/*≠≠ node_modules/babel-traverse/lib/path/inference/inferers.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/index.js ==*/
$m['babel-traverse/lib/path/index.js#6.16.0'] = function () {
$m['babel-traverse/lib/path/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/index.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathindexjs6160__getIterator3 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__getIterator2);

var _babeltraverselibpathindexjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibpathindexjs6160__classCallCheck3 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__classCallCheck2);

var _babeltraverselibpathindexjs6160__virtualTypes = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports;

var _babeltraverselibpathindexjs6160_virtualTypes = _babeltraverselibpathindexjs6160__interopRequireWildcard(_babeltraverselibpathindexjs6160__virtualTypes);

var _babeltraverselibpathindexjs6160__debug2 = $m['debug/browser.js#2.2.0'].exports;

var _babeltraverselibpathindexjs6160__debug3 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__debug2);

var _babeltraverselibpathindexjs6160__invariant = $m['invariant/browser.js#2.2.1'].exports;

var _babeltraverselibpathindexjs6160__invariant2 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__invariant);

var _babeltraverselibpathindexjs6160__index = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathindexjs6160__index2 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__index);

var _babeltraverselibpathindexjs6160__assign = $m['lodash/assign.js#4.16.2'].exports;

var _babeltraverselibpathindexjs6160__assign2 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__assign);

var _babeltraverselibpathindexjs6160__scope = require("babel-traverse/lib/scope/index.js#6.16.0");

var _babeltraverselibpathindexjs6160__scope2 = _babeltraverselibpathindexjs6160__interopRequireDefault(_babeltraverselibpathindexjs6160__scope);

var _babeltraverselibpathindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathindexjs6160_t = _babeltraverselibpathindexjs6160__interopRequireWildcard(_babeltraverselibpathindexjs6160__babelTypes);

var _babeltraverselibpathindexjs6160__cache = $m['babel-traverse/lib/cache.js#6.16.0'].exports;

function _babeltraverselibpathindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibpathindexjs6160__debug = (0, _babeltraverselibpathindexjs6160__debug3.default)("babel");

var _babeltraverselibpathindexjs6160_NodePath = function () {
  function NodePath(hub, parent) {
    (0, _babeltraverselibpathindexjs6160__classCallCheck3.default)(this, NodePath);

    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }

  NodePath.get = function get(_ref) {
    var hub = _ref.hub;
    var parentPath = _ref.parentPath;
    var parent = _ref.parent;
    var container = _ref.container;
    var listKey = _ref.listKey;
    var key = _ref.key;

    if (!hub && parentPath) {
      hub = parentPath.hub;
    }

    (0, _babeltraverselibpathindexjs6160__invariant2.default)(parent, "To get a node path the parent needs to exist");

    var targetNode = container[key];

    var paths = _babeltraverselibpathindexjs6160__cache.path.get(parent) || [];
    if (!_babeltraverselibpathindexjs6160__cache.path.has(parent)) {
      _babeltraverselibpathindexjs6160__cache.path.set(parent, paths);
    }

    var path = void 0;

    for (var i = 0; i < paths.length; i++) {
      var pathCheck = paths[i];
      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }

    if (!path) {
      path = new NodePath(hub, parent);
      paths.push(path);
    }

    path.setup(parentPath, container, listKey, key);

    return path;
  };

  NodePath.prototype.getScope = function getScope(scope) {
    var ourScope = scope;

    if (this.isScope()) {
      ourScope = new _babeltraverselibpathindexjs6160__scope2.default(this, scope);
    }

    return ourScope;
  };

  NodePath.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  NodePath.prototype.getData = function getData(key, def) {
    var val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  };

  NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(msg) {
    var Error = arguments.length <= 1 || arguments[1] === undefined ? SyntaxError : arguments[1];

    return this.hub.file.buildCodeFrameError(this.node, msg, Error);
  };

  NodePath.prototype.traverse = function traverse(visitor, state) {
    (0, _babeltraverselibpathindexjs6160__index2.default)(this.node, visitor, this.scope, state, this);
  };

  NodePath.prototype.mark = function mark(type, message) {
    this.hub.file.metadata.marked.push({
      type: type,
      message: message,
      loc: this.node.loc
    });
  };

  NodePath.prototype.set = function set(key, node) {
    _babeltraverselibpathindexjs6160_t.validate(this.node, key, node);
    this.node[key] = node;
  };

  NodePath.prototype.getPathLocation = function getPathLocation() {
    var parts = [];
    var path = this;
    do {
      var key = path.key;
      if (path.inList) key = path.listKey + "[" + key + "]";
      parts.unshift(key);
    } while (path = path.parentPath);
    return parts.join(".");
  };

  NodePath.prototype.debug = function debug(buildMessage) {
    if (!_babeltraverselibpathindexjs6160__debug.enabled) return;
    _babeltraverselibpathindexjs6160__debug(this.getPathLocation() + " " + this.type + ": " + buildMessage());
  };

  return NodePath;
}();

$m['babel-traverse/lib/path/index.js#6.16.0'].exports.default = _babeltraverselibpathindexjs6160_NodePath;

(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, require("babel-traverse/lib/path/replacement.js#6.16.0"));
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/evaluation.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/conversion.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/introspection.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, require("babel-traverse/lib/path/context.js#6.16.0"));
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/removal.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/modification.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/family.js#6.16.0'].exports);
(0, _babeltraverselibpathindexjs6160__assign2.default)(_babeltraverselibpathindexjs6160_NodePath.prototype, $m['babel-traverse/lib/path/comments.js#6.16.0'].exports);

var _babeltraverselibpathindexjs6160__loop2 = function _loop2() {
  if (_babeltraverselibpathindexjs6160__isArray) {
    if (_babeltraverselibpathindexjs6160__i >= _babeltraverselibpathindexjs6160__iterator.length) return "break";
    _babeltraverselibpathindexjs6160__ref2 = _babeltraverselibpathindexjs6160__iterator[_babeltraverselibpathindexjs6160__i++];
  } else {
    _babeltraverselibpathindexjs6160__i = _babeltraverselibpathindexjs6160__iterator.next();
    if (_babeltraverselibpathindexjs6160__i.done) return "break";
    _babeltraverselibpathindexjs6160__ref2 = _babeltraverselibpathindexjs6160__i.value;
  }

  var type = _babeltraverselibpathindexjs6160__ref2;

  var typeKey = "is" + type;
  _babeltraverselibpathindexjs6160_NodePath.prototype[typeKey] = function (opts) {
    return _babeltraverselibpathindexjs6160_t[typeKey](this.node, opts);
  };

  _babeltraverselibpathindexjs6160_NodePath.prototype["assert" + type] = function (opts) {
    if (!this[typeKey](opts)) {
      throw new TypeError("Expected node path of type " + type);
    }
  };
};

for (var _iterator = _babeltraverselibpathindexjs6160_t.TYPES, _babeltraverselibpathindexjs6160__isArray = Array.isArray(_babeltraverselibpathindexjs6160__iterator), _babeltraverselibpathindexjs6160__i = 0, _babeltraverselibpathindexjs6160__iterator = _babeltraverselibpathindexjs6160__isArray ? _babeltraverselibpathindexjs6160__iterator : (0, _babeltraverselibpathindexjs6160__getIterator3.default)(_babeltraverselibpathindexjs6160__iterator);;) {
  var _babeltraverselibpathindexjs6160__ref2;

  var _babeltraverselibpathindexjs6160__ret2 = _babeltraverselibpathindexjs6160__loop2();

  if (_babeltraverselibpathindexjs6160__ret2 === "break") break;
}

var _babeltraverselibpathindexjs6160__loop = function _loop(type) {
  if (type[0] === "_") return "continue";
  if (_babeltraverselibpathindexjs6160_t.TYPES.indexOf(type) < 0) _babeltraverselibpathindexjs6160_t.TYPES.push(type);

  var virtualType = _babeltraverselibpathindexjs6160_virtualTypes[type];

  _babeltraverselibpathindexjs6160_NodePath.prototype["is" + type] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
};

for (var _babeltraverselibpathindexjs6160_type in _babeltraverselibpathindexjs6160_virtualTypes) {
  var _babeltraverselibpathindexjs6160__ret = _babeltraverselibpathindexjs6160__loop(_babeltraverselibpathindexjs6160_type);

  if (_babeltraverselibpathindexjs6160__ret === "continue") continue;
}
$m['babel-traverse/lib/path/index.js#6.16.0'].exports = $m['babel-traverse/lib/path/index.js#6.16.0'].exports["default"];
};
/*≠≠ node_modules/babel-traverse/lib/path/index.js ≠≠*/

/*== node_modules/babel-traverse/lib/scope/index.js ==*/
$m['babel-traverse/lib/scope/index.js#6.16.0'] = function () {
$m['babel-traverse/lib/scope/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/scope/index.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibscopeindexjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babeltraverselibscopeindexjs6160__keys2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__keys);

var _babeltraverselibscopeindexjs6160__create = $m['babel-runtime/core-js/object/create.js#6.11.6'].exports;

var _babeltraverselibscopeindexjs6160__create2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__create);

var _babeltraverselibscopeindexjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibscopeindexjs6160__classCallCheck3 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__classCallCheck2);

var _babeltraverselibscopeindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibscopeindexjs6160__getIterator3 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__getIterator2);

var _babeltraverselibscopeindexjs6160__includes = $m['lodash/includes.js#4.16.2'].exports;

var _babeltraverselibscopeindexjs6160__includes2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__includes);

var _babeltraverselibscopeindexjs6160__repeat = $m['lodash/repeat.js#4.16.2'].exports;

var _babeltraverselibscopeindexjs6160__repeat2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__repeat);

var _babeltraverselibscopeindexjs6160__renamer = $m['babel-traverse/lib/scope/lib/renamer.js#6.16.0'].exports;

var _babeltraverselibscopeindexjs6160__renamer2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__renamer);

var _babeltraverselibscopeindexjs6160__index = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babeltraverselibscopeindexjs6160__index2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__index);

var _babeltraverselibscopeindexjs6160__defaults = $m['lodash/defaults.js#4.16.2'].exports;

var _babeltraverselibscopeindexjs6160__defaults2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__defaults);

var _babeltraverselibscopeindexjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babeltraverselibscopeindexjs6160_messages = _babeltraverselibscopeindexjs6160__interopRequireWildcard(_babeltraverselibscopeindexjs6160__babelMessages);

var _babeltraverselibscopeindexjs6160__binding2 = $m['babel-traverse/lib/scope/binding.js#6.16.0'].exports;

var _babeltraverselibscopeindexjs6160__binding3 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__binding2);

var _babeltraverselibscopeindexjs6160__globals = $m['globals/index.js#8.18.0'].exports;

var _babeltraverselibscopeindexjs6160__globals2 = _babeltraverselibscopeindexjs6160__interopRequireDefault(_babeltraverselibscopeindexjs6160__globals);

var _babeltraverselibscopeindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibscopeindexjs6160_t = _babeltraverselibscopeindexjs6160__interopRequireWildcard(_babeltraverselibscopeindexjs6160__babelTypes);

var _babeltraverselibscopeindexjs6160__cache = $m['babel-traverse/lib/cache.js#6.16.0'].exports;

function _babeltraverselibscopeindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibscopeindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibscopeindexjs6160__crawlCallsCount = 0;

function _babeltraverselibscopeindexjs6160_getCache(path, parentScope, self) {
  var scopes = _babeltraverselibscopeindexjs6160__cache.scope.get(path.node) || [];

  for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var scope = _ref;

    if (scope.parent === parentScope && scope.path === path) return scope;
  }

  scopes.push(self);

  if (!_babeltraverselibscopeindexjs6160__cache.scope.has(path.node)) {
    _babeltraverselibscopeindexjs6160__cache.scope.set(path.node, scopes);
  }
}

var _babeltraverselibscopeindexjs6160_collectorVisitor = {
  For: function For(path) {
    for (var _iterator2 = _babeltraverselibscopeindexjs6160_t.FOR_INIT_KEYS, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var key = _ref2;

      var declar = path.get(key);
      if (declar.isVar()) path.scope.getFunctionParent().registerBinding("var", declar);
    }
  },
  Declaration: function Declaration(path) {
    if (path.isBlockScoped()) return;

    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) return;

    path.scope.getFunctionParent().registerDeclaration(path);
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement: function ForXStatement(path, state) {
    var left = path.get("left");
    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(left);
    }
  },

  ExportDeclaration: {
    exit: function exit(path) {
      var node = path.node;
      var scope = path.scope;

      var declar = node.declaration;
      if (_babeltraverselibscopeindexjs6160_t.isClassDeclaration(declar) || _babeltraverselibscopeindexjs6160_t.isFunctionDeclaration(declar)) {
        var _id = declar.id;
        if (!_id) return;

        var binding = scope.getBinding(_id.name);
        if (binding) binding.reference(path);
      } else if (_babeltraverselibscopeindexjs6160_t.isVariableDeclaration(declar)) {
        for (var _iterator3 = declar.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator3);;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var decl = _ref3;

          var ids = _babeltraverselibscopeindexjs6160_t.getBindingIdentifiers(decl);
          for (var name in ids) {
            var _binding = scope.getBinding(name);
            if (_binding) _binding.reference(path);
          }
        }
      }
    }
  },

  LabeledStatement: function LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression: function AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression: function UpdateExpression(path, state) {
    state.constantViolations.push(path.get("argument"));
  },
  UnaryExpression: function UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path.get("argument"));
    }
  },
  BlockScoped: function BlockScoped(path) {
    var scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var id = path.node.id;
    if (!id) return;

    var name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },
  Block: function Block(path) {
    var paths = path.get("body");
    for (var _iterator4 = paths, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator4);;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var bodyPath = _ref4;

      if (bodyPath.isFunctionDeclaration()) {
        path.scope.getBlockParent().registerDeclaration(bodyPath);
      }
    }
  }
};

var _babeltraverselibscopeindexjs6160_uid = 0;

var _babeltraverselibscopeindexjs6160_Scope = function () {
  function Scope(path, parentScope) {
    (0, _babeltraverselibscopeindexjs6160__classCallCheck3.default)(this, Scope);

    if (parentScope && parentScope.block === path.node) {
      return parentScope;
    }

    var cached = _babeltraverselibscopeindexjs6160_getCache(path, parentScope, this);
    if (cached) return cached;

    this.uid = _babeltraverselibscopeindexjs6160_uid++;
    this.parent = parentScope;
    this.hub = path.hub;

    this.parentBlock = path.parent;
    this.block = path.node;
    this.path = path;
  }

  Scope.prototype.traverse = function traverse(node, opts, state) {
    (0, _babeltraverselibscopeindexjs6160__index2.default)(node, opts, this, state, this.path);
  };

  Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? "temp" : arguments[0];

    var id = this.generateUidIdentifier(name);
    this.push({ id: id });
    return id;
  };

  Scope.prototype.generateUidIdentifier = function generateUidIdentifier() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? "temp" : arguments[0];

    return _babeltraverselibscopeindexjs6160_t.identifier(this.generateUid(name));
  };

  Scope.prototype.generateUid = function generateUid() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? "temp" : arguments[0];

    name = _babeltraverselibscopeindexjs6160_t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");

    var uid = void 0;
    var i = 0;
    do {
      uid = this._generateUid(name, i);
      i++;
    } while (this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

    var program = this.getProgramParent();
    program.references[uid] = true;
    program.uids[uid] = true;

    return uid;
  };

  Scope.prototype._generateUid = function _generateUid(name, i) {
    var id = name;
    if (i > 1) id += i;
    return "_" + id;
  };

  Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
    var node = parent;

    if (_babeltraverselibscopeindexjs6160_t.isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (_babeltraverselibscopeindexjs6160_t.isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (_babeltraverselibscopeindexjs6160_t.isObjectProperty(node) || _babeltraverselibscopeindexjs6160_t.isObjectMethod(node)) {
      node = node.key;
    }

    var parts = [];

    var add = function add(node) {
      if (_babeltraverselibscopeindexjs6160_t.isModuleDeclaration(node)) {
        if (node.source) {
          add(node.source);
        } else if (node.specifiers && node.specifiers.length) {
          for (var _iterator5 = node.specifiers, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator5);;) {
            var _ref5;

            if (_isArray5) {
              if (_i5 >= _iterator5.length) break;
              _ref5 = _iterator5[_i5++];
            } else {
              _i5 = _iterator5.next();
              if (_i5.done) break;
              _ref5 = _i5.value;
            }

            var specifier = _ref5;

            add(specifier);
          }
        } else if (node.declaration) {
          add(node.declaration);
        }
      } else if (_babeltraverselibscopeindexjs6160_t.isModuleSpecifier(node)) {
        add(node.local);
      } else if (_babeltraverselibscopeindexjs6160_t.isMemberExpression(node)) {
        add(node.object);
        add(node.property);
      } else if (_babeltraverselibscopeindexjs6160_t.isIdentifier(node)) {
        parts.push(node.name);
      } else if (_babeltraverselibscopeindexjs6160_t.isLiteral(node)) {
        parts.push(node.value);
      } else if (_babeltraverselibscopeindexjs6160_t.isCallExpression(node)) {
        add(node.callee);
      } else if (_babeltraverselibscopeindexjs6160_t.isObjectExpression(node) || _babeltraverselibscopeindexjs6160_t.isObjectPattern(node)) {
        for (var _iterator6 = node.properties, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator6);;) {
          var _ref6;

          if (_isArray6) {
            if (_i6 >= _iterator6.length) break;
            _ref6 = _iterator6[_i6++];
          } else {
            _i6 = _iterator6.next();
            if (_i6.done) break;
            _ref6 = _i6.value;
          }

          var prop = _ref6;

          add(prop.key || prop.argument);
        }
      }
    };

    add(node);

    var id = parts.join("$");
    id = id.replace(/^_/, "") || defaultName || "ref";

    return this.generateUidIdentifier(id.slice(0, 20));
  };

  Scope.prototype.isStatic = function isStatic(node) {
    if (_babeltraverselibscopeindexjs6160_t.isThisExpression(node) || _babeltraverselibscopeindexjs6160_t.isSuper(node)) {
      return true;
    }

    if (_babeltraverselibscopeindexjs6160_t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }

    return false;
  };

  Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
    if (this.isStatic(node)) {
      return null;
    } else {
      var _id2 = this.generateUidIdentifierBasedOnNode(node);
      if (!dontPush) this.push({ id: _id2 });
      return _id2;
    }
  };

  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
    if (kind === "param") return;

    if (kind === "hoisted" && local.kind === "let") return;

    var duplicate = false;

    if (!duplicate) duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module";

    if (!duplicate) duplicate = local.kind === "param" && (kind === "let" || kind === "const");

    if (duplicate) {
      throw this.hub.file.buildCodeFrameError(id, _babeltraverselibscopeindexjs6160_messages.get("scopeDuplicateDeclaration", name), TypeError);
    }
  };

  Scope.prototype.rename = function rename(oldName, newName, block) {
    var binding = this.getBinding(oldName);
    if (binding) {
      newName = newName || this.generateUidIdentifier(oldName).name;
      return new _babeltraverselibscopeindexjs6160__renamer2.default(binding, oldName, newName).rename(block);
    }
  };

  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value;
      map[oldName] = null;
    }
  };

  Scope.prototype.dump = function dump() {
    var sep = (0, _babeltraverselibscopeindexjs6160__repeat2.default)("-", 60);
    console.log(sep);
    var scope = this;
    do {
      console.log("#", scope.block.type);
      for (var name in scope.bindings) {
        var binding = scope.bindings[name];
        console.log(" -", name, {
          constant: binding.constant,
          references: binding.references,
          violations: binding.constantViolations.length,
          kind: binding.kind
        });
      }
    } while (scope = scope.parent);
    console.log(sep);
  };

  Scope.prototype.toArray = function toArray(node, i) {
    var file = this.hub.file;

    if (_babeltraverselibscopeindexjs6160_t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding && binding.constant && binding.path.isGenericType("Array")) return node;
    }

    if (_babeltraverselibscopeindexjs6160_t.isArrayExpression(node)) {
      return node;
    }

    if (_babeltraverselibscopeindexjs6160_t.isIdentifier(node, { name: "arguments" })) {
      return _babeltraverselibscopeindexjs6160_t.callExpression(_babeltraverselibscopeindexjs6160_t.memberExpression(_babeltraverselibscopeindexjs6160_t.memberExpression(_babeltraverselibscopeindexjs6160_t.memberExpression(_babeltraverselibscopeindexjs6160_t.identifier("Array"), _babeltraverselibscopeindexjs6160_t.identifier("prototype")), _babeltraverselibscopeindexjs6160_t.identifier("slice")), _babeltraverselibscopeindexjs6160_t.identifier("call")), [node]);
    }

    var helperName = "toArray";
    var args = [node];
    if (i === true) {
      helperName = "toConsumableArray";
    } else if (i) {
      args.push(_babeltraverselibscopeindexjs6160_t.numericLiteral(i));
      helperName = "slicedToArray";
    }
    return _babeltraverselibscopeindexjs6160_t.callExpression(file.addHelper(helperName), args);
  };

  Scope.prototype.registerDeclaration = function registerDeclaration(path) {
    if (path.isLabeledStatement()) {
      this.registerBinding("label", path);
    } else if (path.isFunctionDeclaration()) {
      this.registerBinding("hoisted", path.get("id"), path);
    } else if (path.isVariableDeclaration()) {
      var declarations = path.get("declarations");
      for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator7);;) {
        var _ref7;

        if (_isArray7) {
          if (_i7 >= _iterator7.length) break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done) break;
          _ref7 = _i7.value;
        }

        var declar = _ref7;

        this.registerBinding(path.node.kind, declar);
      }
    } else if (path.isClassDeclaration()) {
      this.registerBinding("let", path);
    } else if (path.isImportDeclaration()) {
      var specifiers = path.get("specifiers");
      for (var _iterator8 = specifiers, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var specifier = _ref8;

        this.registerBinding("module", specifier);
      }
    } else if (path.isExportDeclaration()) {
      var _declar = path.get("declaration");
      if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
        this.registerDeclaration(_declar);
      }
    } else {
      this.registerBinding("unknown", path);
    }
  };

  Scope.prototype.buildUndefinedNode = function buildUndefinedNode() {
    if (this.hasBinding("undefined")) {
      return _babeltraverselibscopeindexjs6160_t.unaryExpression("void", _babeltraverselibscopeindexjs6160_t.numericLiteral(0), true);
    } else {
      return _babeltraverselibscopeindexjs6160_t.identifier("undefined");
    }
  };

  Scope.prototype.registerConstantViolation = function registerConstantViolation(path) {
    var ids = path.getBindingIdentifiers();
    for (var name in ids) {
      var binding = this.getBinding(name);
      if (binding) binding.reassign(path);
    }
  };

  Scope.prototype.registerBinding = function registerBinding(kind, path) {
    var bindingPath = arguments.length <= 2 || arguments[2] === undefined ? path : arguments[2];

    if (!kind) throw new ReferenceError("no `kind`");

    if (path.isVariableDeclaration()) {
      var declarators = path.get("declarations");
      for (var _iterator9 = declarators, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator9);;) {
        var _ref9;

        if (_isArray9) {
          if (_i9 >= _iterator9.length) break;
          _ref9 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done) break;
          _ref9 = _i9.value;
        }

        var declar = _ref9;

        this.registerBinding(kind, declar);
      }
      return;
    }

    var parent = this.getProgramParent();
    var ids = path.getBindingIdentifiers(true);

    for (var name in ids) {
      for (var _iterator10 = ids[name], _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator10);;) {
        var _ref10;

        if (_isArray10) {
          if (_i10 >= _iterator10.length) break;
          _ref10 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done) break;
          _ref10 = _i10.value;
        }

        var _id3 = _ref10;

        var local = this.getOwnBinding(name);
        if (local) {
          if (local.identifier === _id3) continue;

          this.checkBlockScopedCollisions(local, kind, name, _id3);
        }

        if (local && local.path.isFlow()) local = null;

        parent.references[name] = true;

        this.bindings[name] = new _babeltraverselibscopeindexjs6160__binding3.default({
          identifier: _id3,
          existing: local,
          scope: this,
          path: bindingPath,
          kind: kind
        });
      }
    }
  };

  Scope.prototype.addGlobal = function addGlobal(node) {
    this.globals[node.name] = node;
  };

  Scope.prototype.hasUid = function hasUid(name) {
    var scope = this;

    do {
      if (scope.uids[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasGlobal = function hasGlobal(name) {
    var scope = this;

    do {
      if (scope.globals[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasReference = function hasReference(name) {
    var scope = this;

    do {
      if (scope.references[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.isPure = function isPure(node, constantsOnly) {
    if (_babeltraverselibscopeindexjs6160_t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (!binding) return false;
      if (constantsOnly) return binding.constant;
      return true;
    } else if (_babeltraverselibscopeindexjs6160_t.isClass(node)) {
      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) return false;
      return this.isPure(node.body, constantsOnly);
    } else if (_babeltraverselibscopeindexjs6160_t.isClassBody(node)) {
      for (var _iterator11 = node.body, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator11);;) {
        var _ref11;

        if (_isArray11) {
          if (_i11 >= _iterator11.length) break;
          _ref11 = _iterator11[_i11++];
        } else {
          _i11 = _iterator11.next();
          if (_i11.done) break;
          _ref11 = _i11.value;
        }

        var method = _ref11;

        if (!this.isPure(method, constantsOnly)) return false;
      }
      return true;
    } else if (_babeltraverselibscopeindexjs6160_t.isBinary(node)) {
      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
    } else if (_babeltraverselibscopeindexjs6160_t.isArrayExpression(node)) {
      for (var _iterator12 = node.elements, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator12);;) {
        var _ref12;

        if (_isArray12) {
          if (_i12 >= _iterator12.length) break;
          _ref12 = _iterator12[_i12++];
        } else {
          _i12 = _iterator12.next();
          if (_i12.done) break;
          _ref12 = _i12.value;
        }

        var elem = _ref12;

        if (!this.isPure(elem, constantsOnly)) return false;
      }
      return true;
    } else if (_babeltraverselibscopeindexjs6160_t.isObjectExpression(node)) {
      for (var _iterator13 = node.properties, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator13);;) {
        var _ref13;

        if (_isArray13) {
          if (_i13 >= _iterator13.length) break;
          _ref13 = _iterator13[_i13++];
        } else {
          _i13 = _iterator13.next();
          if (_i13.done) break;
          _ref13 = _i13.value;
        }

        var prop = _ref13;

        if (!this.isPure(prop, constantsOnly)) return false;
      }
      return true;
    } else if (_babeltraverselibscopeindexjs6160_t.isClassMethod(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      if (node.kind === "get" || node.kind === "set") return false;
      return true;
    } else if (_babeltraverselibscopeindexjs6160_t.isClassProperty(node) || _babeltraverselibscopeindexjs6160_t.isObjectProperty(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      return this.isPure(node.value, constantsOnly);
    } else if (_babeltraverselibscopeindexjs6160_t.isUnaryExpression(node)) {
      return this.isPure(node.argument, constantsOnly);
    } else {
      return _babeltraverselibscopeindexjs6160_t.isPureish(node);
    }
  };

  Scope.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  Scope.prototype.getData = function getData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) return data;
    } while (scope = scope.parent);
  };

  Scope.prototype.removeData = function removeData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) scope.data[key] = null;
    } while (scope = scope.parent);
  };

  Scope.prototype.init = function init() {
    if (!this.references) this.crawl();
  };

  Scope.prototype.crawl = function crawl() {
    _babeltraverselibscopeindexjs6160__crawlCallsCount++;
    this._crawl();
    _babeltraverselibscopeindexjs6160__crawlCallsCount--;
  };

  Scope.prototype._crawl = function _crawl() {
    var path = this.path;

    this.references = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);
    this.bindings = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);
    this.globals = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);
    this.uids = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);
    this.data = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);

    if (path.isLoop()) {
      for (var _iterator14 = _babeltraverselibscopeindexjs6160_t.FOR_INIT_KEYS, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator14);;) {
        var _ref14;

        if (_isArray14) {
          if (_i14 >= _iterator14.length) break;
          _ref14 = _iterator14[_i14++];
        } else {
          _i14 = _iterator14.next();
          if (_i14.done) break;
          _ref14 = _i14.value;
        }

        var key = _ref14;

        var node = path.get(key);
        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
      }
    }

    if (path.isFunctionExpression() && path.has("id")) {
      if (!path.get("id").node[_babeltraverselibscopeindexjs6160_t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path.get("id"), path);
      }
    }

    if (path.isClassExpression() && path.has("id")) {
      if (!path.get("id").node[_babeltraverselibscopeindexjs6160_t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path);
      }
    }

    if (path.isFunction()) {
      var params = path.get("params");
      for (var _iterator15 = params, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator15);;) {
        var _ref15;

        if (_isArray15) {
          if (_i15 >= _iterator15.length) break;
          _ref15 = _iterator15[_i15++];
        } else {
          _i15 = _iterator15.next();
          if (_i15.done) break;
          _ref15 = _i15.value;
        }

        var param = _ref15;

        this.registerBinding("param", param);
      }
    }

    if (path.isCatchClause()) {
      this.registerBinding("let", path);
    }

    var parent = this.getProgramParent();
    if (parent.crawling) return;

    var state = {
      references: [],
      constantViolations: [],
      assignments: []
    };

    this.crawling = true;
    path.traverse(_babeltraverselibscopeindexjs6160_collectorVisitor, state);
    this.crawling = false;

    for (var _iterator16 = state.assignments, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator16);;) {
      var _ref16;

      if (_isArray16) {
        if (_i16 >= _iterator16.length) break;
        _ref16 = _iterator16[_i16++];
      } else {
        _i16 = _iterator16.next();
        if (_i16.done) break;
        _ref16 = _i16.value;
      }

      var _path = _ref16;

      var ids = _path.getBindingIdentifiers();
      var programParent = void 0;
      for (var name in ids) {
        if (_path.scope.getBinding(name)) continue;

        programParent = programParent || _path.scope.getProgramParent();
        programParent.addGlobal(ids[name]);
      }

      _path.scope.registerConstantViolation(_path);
    }

    for (var _iterator17 = state.references, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator17);;) {
      var _ref17;

      if (_isArray17) {
        if (_i17 >= _iterator17.length) break;
        _ref17 = _iterator17[_i17++];
      } else {
        _i17 = _iterator17.next();
        if (_i17.done) break;
        _ref17 = _i17.value;
      }

      var ref = _ref17;

      var binding = ref.scope.getBinding(ref.node.name);
      if (binding) {
        binding.reference(ref);
      } else {
        ref.scope.getProgramParent().addGlobal(ref.node);
      }
    }

    for (var _iterator18 = state.constantViolations, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator18);;) {
      var _ref18;

      if (_isArray18) {
        if (_i18 >= _iterator18.length) break;
        _ref18 = _iterator18[_i18++];
      } else {
        _i18 = _iterator18.next();
        if (_i18.done) break;
        _ref18 = _i18.value;
      }

      var _path2 = _ref18;

      _path2.scope.registerConstantViolation(_path2);
    }
  };

  Scope.prototype.push = function push(opts) {
    var path = this.path;

    if (!path.isBlockStatement() && !path.isProgram()) {
      path = this.getBlockParent().path;
    }

    if (path.isSwitchStatement()) {
      path = this.getFunctionParent().path;
    }

    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
      _babeltraverselibscopeindexjs6160_t.ensureBlock(path.node);
      path = path.get("body");
    }

    var unique = opts.unique;
    var kind = opts.kind || "var";
    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;

    var dataKey = "declaration:" + kind + ":" + blockHoist;
    var declarPath = !unique && path.getData(dataKey);

    if (!declarPath) {
      var declar = _babeltraverselibscopeindexjs6160_t.variableDeclaration(kind, []);
      declar._generated = true;
      declar._blockHoist = blockHoist;

      var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

      declarPath = _path$unshiftContaine[0];

      if (!unique) path.setData(dataKey, declarPath);
    }

    var declarator = _babeltraverselibscopeindexjs6160_t.variableDeclarator(opts.id, opts.init);
    declarPath.node.declarations.push(declarator);
    this.registerBinding(kind, declarPath.get("declarations").pop());
  };

  Scope.prototype.getProgramParent = function getProgramParent() {
    var scope = this;
    do {
      if (scope.path.isProgram()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getFunctionParent = function getFunctionParent() {
    var scope = this;
    do {
      if (scope.path.isFunctionParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getBlockParent = function getBlockParent() {
    var scope = this;
    do {
      if (scope.path.isBlockParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  };

  Scope.prototype.getAllBindings = function getAllBindings() {
    var ids = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);

    var scope = this;
    do {
      (0, _babeltraverselibscopeindexjs6160__defaults2.default)(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);

    return ids;
  };

  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
    var ids = (0, _babeltraverselibscopeindexjs6160__create2.default)(null);

    for (var _iterator19 = arguments, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : (0, _babeltraverselibscopeindexjs6160__getIterator3.default)(_iterator19);;) {
      var _ref19;

      if (_isArray19) {
        if (_i19 >= _iterator19.length) break;
        _ref19 = _iterator19[_i19++];
      } else {
        _i19 = _iterator19.next();
        if (_i19.done) break;
        _ref19 = _i19.value;
      }

      var kind = _ref19;

      var scope = this;
      do {
        for (var name in scope.bindings) {
          var binding = scope.bindings[name];
          if (binding.kind === kind) ids[name] = binding;
        }
        scope = scope.parent;
      } while (scope);
    }

    return ids;
  };

  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
    return this.getBindingIdentifier(name) === node;
  };

  Scope.prototype.warnOnFlowBinding = function warnOnFlowBinding(binding) {
    if (_babeltraverselibscopeindexjs6160__crawlCallsCount === 0 && binding && binding.path.isFlow()) {
      console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 6.8. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      ");
    }
    return binding;
  };

  Scope.prototype.getBinding = function getBinding(name) {
    var scope = this;

    do {
      var binding = scope.getOwnBinding(name);
      if (binding) return this.warnOnFlowBinding(binding);
    } while (scope = scope.parent);
  };

  Scope.prototype.getOwnBinding = function getOwnBinding(name) {
    return this.warnOnFlowBinding(this.bindings[name]);
  };

  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
    var info = this.getBinding(name);
    return info && info.identifier;
  };

  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
    var binding = this.bindings[name];
    return binding && binding.identifier;
  };

  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
    return !!this.getOwnBinding(name);
  };

  Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name, noGlobals)) return true;
    if (this.hasUid(name)) return true;
    if (!noGlobals && (0, _babeltraverselibscopeindexjs6160__includes2.default)(Scope.globals, name)) return true;
    if (!noGlobals && (0, _babeltraverselibscopeindexjs6160__includes2.default)(Scope.contextVariables, name)) return true;
    return false;
  };

  Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {
    return this.parent && this.parent.hasBinding(name, noGlobals);
  };

  Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
      info.scope = scope;
      scope.bindings[name] = info;
    }
  };

  Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
    delete this.bindings[name];
  };

  Scope.prototype.removeBinding = function removeBinding(name) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
    }

    var scope = this;
    do {
      if (scope.uids[name]) {
        scope.uids[name] = false;
      }
    } while (scope = scope.parent);
  };

  return Scope;
}();

_babeltraverselibscopeindexjs6160_Scope.globals = (0, _babeltraverselibscopeindexjs6160__keys2.default)(_babeltraverselibscopeindexjs6160__globals2.default.builtin);
_babeltraverselibscopeindexjs6160_Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
$m['babel-traverse/lib/scope/index.js#6.16.0'].exports.default = _babeltraverselibscopeindexjs6160_Scope;
$m['babel-traverse/lib/scope/index.js#6.16.0'].exports = $m['babel-traverse/lib/scope/index.js#6.16.0'].exports["default"];
};
/*≠≠ node_modules/babel-traverse/lib/scope/index.js ≠≠*/

/*== node_modules/babel-traverse/lib/hub.js ==*/
$m['babel-traverse/lib/hub.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/hub.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibhubjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibhubjs6160__classCallCheck3 = _babeltraverselibhubjs6160__interopRequireDefault(_babeltraverselibhubjs6160__classCallCheck2);

function _babeltraverselibhubjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibhubjs6160_Hub = function Hub(file, options) {
  (0, _babeltraverselibhubjs6160__classCallCheck3.default)(this, Hub);

  this.file = file;
  this.options = options;
};

$m['babel-traverse/lib/hub.js#6.16.0'].exports.default = _babeltraverselibhubjs6160_Hub;
$m['babel-traverse/lib/hub.js#6.16.0'].exports = $m['babel-traverse/lib/hub.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/lib/hub.js ≠≠*/

/*== node_modules/babel-traverse/lib/context.js ==*/
$m['babel-traverse/lib/context.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/context.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibcontextjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibcontextjs6160__getIterator3 = _babeltraverselibcontextjs6160__interopRequireDefault(_babeltraverselibcontextjs6160__getIterator2);

var _babeltraverselibcontextjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babeltraverselibcontextjs6160__classCallCheck3 = _babeltraverselibcontextjs6160__interopRequireDefault(_babeltraverselibcontextjs6160__classCallCheck2);

var _babeltraverselibcontextjs6160__path2 = require("babel-traverse/lib/path/index.js#6.16.0");

var _babeltraverselibcontextjs6160__path3 = _babeltraverselibcontextjs6160__interopRequireDefault(_babeltraverselibcontextjs6160__path2);

var _babeltraverselibcontextjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibcontextjs6160_t = _babeltraverselibcontextjs6160__interopRequireWildcard(_babeltraverselibcontextjs6160__babelTypes);

function _babeltraverselibcontextjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibcontextjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibcontextjs6160_testing = process.env.NODE_ENV === "test";

var _babeltraverselibcontextjs6160_TraversalContext = function () {
  function TraversalContext(scope, opts, state, parentPath) {
    (0, _babeltraverselibcontextjs6160__classCallCheck3.default)(this, TraversalContext);
    this.queue = null;

    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
    var opts = this.opts;
    if (opts.enter || opts.exit) return true;

    if (opts[node.type]) return true;

    var keys = _babeltraverselibcontextjs6160_t.VISITOR_KEYS[node.type];
    if (!keys || !keys.length) return false;

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibcontextjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;

      if (node[key]) return true;
    }

    return false;
  };

  TraversalContext.prototype.create = function create(node, obj, key, listKey) {
    return _babeltraverselibcontextjs6160__path3.default.get({
      parentPath: this.parentPath,
      parent: node,
      container: obj,
      key: key,
      listKey: listKey
    });
  };

  TraversalContext.prototype.maybeQueue = function maybeQueue(path, notPriority) {
    if (this.trap) {
      throw new Error("Infinite cycle detected");
    }

    if (this.queue) {
      if (notPriority) {
        this.queue.push(path);
      } else {
        this.priorityQueue.push(path);
      }
    }
  };

  TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
    if (container.length === 0) return false;

    var queue = [];

    for (var key = 0; key < container.length; key++) {
      var node = container[key];
      if (node && this.shouldVisit(node)) {
        queue.push(this.create(parent, container, key, listKey));
      }
    }

    return this.visitQueue(queue);
  };

  TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
    if (this.shouldVisit(node[key])) {
      return this.visitQueue([this.create(node, node, key)]);
    } else {
      return false;
    }
  };

  TraversalContext.prototype.visitQueue = function visitQueue(queue) {
    this.queue = queue;
    this.priorityQueue = [];

    var visited = [];
    var stop = false;

    for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibcontextjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      path.resync();

      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
        path.pushContext(this);
      }

      if (path.key === null) continue;

      if (_babeltraverselibcontextjs6160_testing && queue.length >= 10000) {
        this.trap = true;
      }

      if (visited.indexOf(path.node) >= 0) continue;
      visited.push(path.node);

      if (path.visit()) {
        stop = true;
        break;
      }

      if (this.priorityQueue.length) {
        stop = this.visitQueue(this.priorityQueue);
        this.priorityQueue = [];
        this.queue = queue;
        if (stop) break;
      }
    }

    for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltraverselibcontextjs6160__getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var _path = _ref3;

      _path.popContext();
    }

    this.queue = null;

    return stop;
  };

  TraversalContext.prototype.visit = function visit(node, key) {
    var nodes = node[key];
    if (!nodes) return false;

    if (Array.isArray(nodes)) {
      return this.visitMultiple(nodes, node, key);
    } else {
      return this.visitSingle(node, key);
    }
  };

  return TraversalContext;
}();

$m['babel-traverse/lib/context.js#6.16.0'].exports.default = _babeltraverselibcontextjs6160_TraversalContext;
$m['babel-traverse/lib/context.js#6.16.0'].exports = $m['babel-traverse/lib/context.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-traverse/lib/context.js ≠≠*/

/*== node_modules/babel-traverse/lib/visitors.js ==*/
$m['babel-traverse/lib/visitors.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/visitors.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibvisitorsjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babeltraverselibvisitorsjs6160__typeof3 = _babeltraverselibvisitorsjs6160__interopRequireDefault(_babeltraverselibvisitorsjs6160__typeof2);

var _babeltraverselibvisitorsjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babeltraverselibvisitorsjs6160__keys2 = _babeltraverselibvisitorsjs6160__interopRequireDefault(_babeltraverselibvisitorsjs6160__keys);

var _babeltraverselibvisitorsjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibvisitorsjs6160__getIterator3 = _babeltraverselibvisitorsjs6160__interopRequireDefault(_babeltraverselibvisitorsjs6160__getIterator2);

$m['babel-traverse/lib/visitors.js#6.16.0'].exports.explode = _babeltraverselibvisitorsjs6160_explode;
$m['babel-traverse/lib/visitors.js#6.16.0'].exports.verify = _babeltraverselibvisitorsjs6160_verify;
$m['babel-traverse/lib/visitors.js#6.16.0'].exports.merge = _babeltraverselibvisitorsjs6160_merge;

var _babeltraverselibvisitorsjs6160__virtualTypes = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports;

var _babeltraverselibvisitorsjs6160_virtualTypes = _babeltraverselibvisitorsjs6160__interopRequireWildcard(_babeltraverselibvisitorsjs6160__virtualTypes);

var _babeltraverselibvisitorsjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babeltraverselibvisitorsjs6160_messages = _babeltraverselibvisitorsjs6160__interopRequireWildcard(_babeltraverselibvisitorsjs6160__babelMessages);

var _babeltraverselibvisitorsjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibvisitorsjs6160_t = _babeltraverselibvisitorsjs6160__interopRequireWildcard(_babeltraverselibvisitorsjs6160__babelTypes);

var _babeltraverselibvisitorsjs6160__clone = $m['lodash/clone.js#4.16.2'].exports;

var _babeltraverselibvisitorsjs6160__clone2 = _babeltraverselibvisitorsjs6160__interopRequireDefault(_babeltraverselibvisitorsjs6160__clone);

function _babeltraverselibvisitorsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibvisitorsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibvisitorsjs6160_explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (var nodeType in visitor) {
    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(nodeType)) continue;

    var parts = nodeType.split("|");
    if (parts.length === 1) continue;

    var fns = visitor[nodeType];
    delete visitor[nodeType];

    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibvisitorsjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var part = _ref;

      visitor[part] = fns;
    }
  }

  _babeltraverselibvisitorsjs6160_verify(visitor);

  delete visitor.__esModule;

  _babeltraverselibvisitorsjs6160_ensureEntranceObjects(visitor);

  _babeltraverselibvisitorsjs6160_ensureCallbackArrays(visitor);

  for (var _iterator2 = (0, _babeltraverselibvisitorsjs6160__keys2.default)(visitor), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibvisitorsjs6160__getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _nodeType3 = _ref2;

    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(_nodeType3)) continue;

    var wrapper = _babeltraverselibvisitorsjs6160_virtualTypes[_nodeType3];
    if (!wrapper) continue;

    var _fns2 = visitor[_nodeType3];
    for (var type in _fns2) {
      _fns2[type] = _babeltraverselibvisitorsjs6160_wrapCheck(wrapper, _fns2[type]);
    }

    delete visitor[_nodeType3];

    if (wrapper.types) {
      for (var _iterator4 = wrapper.types, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _babeltraverselibvisitorsjs6160__getIterator3.default)(_iterator4);;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _type = _ref4;

        if (visitor[_type]) {
          _babeltraverselibvisitorsjs6160_mergePair(visitor[_type], _fns2);
        } else {
          visitor[_type] = _fns2;
        }
      }
    } else {
      _babeltraverselibvisitorsjs6160_mergePair(visitor, _fns2);
    }
  }

  for (var _nodeType in visitor) {
    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(_nodeType)) continue;

    var _fns = visitor[_nodeType];

    var aliases = _babeltraverselibvisitorsjs6160_t.FLIPPED_ALIAS_KEYS[_nodeType];

    var deprecratedKey = _babeltraverselibvisitorsjs6160_t.DEPRECATED_KEYS[_nodeType];
    if (deprecratedKey) {
      console.trace("Visitor defined for " + _nodeType + " but it has been renamed to " + deprecratedKey);
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;

    delete visitor[_nodeType];

    for (var _iterator3 = aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltraverselibvisitorsjs6160__getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var alias = _ref3;

      var existing = visitor[alias];
      if (existing) {
        _babeltraverselibvisitorsjs6160_mergePair(existing, _fns);
      } else {
        visitor[alias] = (0, _babeltraverselibvisitorsjs6160__clone2.default)(_fns);
      }
    }
  }

  for (var _nodeType2 in visitor) {
    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(_nodeType2)) continue;

    _babeltraverselibvisitorsjs6160_ensureCallbackArrays(visitor[_nodeType2]);
  }

  return visitor;
}

function _babeltraverselibvisitorsjs6160_verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error(_babeltraverselibvisitorsjs6160_messages.get("traverseVerifyRootFunction"));
  }

  for (var nodeType in visitor) {
    if (nodeType === "enter" || nodeType === "exit") {
      _babeltraverselibvisitorsjs6160_validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(nodeType)) continue;

    if (_babeltraverselibvisitorsjs6160_t.TYPES.indexOf(nodeType) < 0) {
      throw new Error(_babeltraverselibvisitorsjs6160_messages.get("traverseVerifyNodeType", nodeType));
    }

    var visitors = visitor[nodeType];
    if ((typeof visitors === "undefined" ? "undefined" : (0, _babeltraverselibvisitorsjs6160__typeof3.default)(visitors)) === "object") {
      for (var visitorKey in visitors) {
        if (visitorKey === "enter" || visitorKey === "exit") {
          _babeltraverselibvisitorsjs6160_validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
        } else {
          throw new Error(_babeltraverselibvisitorsjs6160_messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
        }
      }
    }
  }

  visitor._verified = true;
}

function _babeltraverselibvisitorsjs6160_validateVisitorMethods(path, val) {
  var fns = [].concat(val);
  for (var _iterator5 = fns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _babeltraverselibvisitorsjs6160__getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var fn = _ref5;

    if (typeof fn !== "function") {
      throw new TypeError("Non-function found defined in " + path + " with type " + (typeof fn === "undefined" ? "undefined" : (0, _babeltraverselibvisitorsjs6160__typeof3.default)(fn)));
    }
  }
}

function _babeltraverselibvisitorsjs6160_merge(visitors) {
  var states = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var wrapper = arguments[2];

  var rootVisitor = {};

  for (var i = 0; i < visitors.length; i++) {
    var visitor = visitors[i];
    var state = states[i];

    _babeltraverselibvisitorsjs6160_explode(visitor);

    for (var type in visitor) {
      var visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = _babeltraverselibvisitorsjs6160_wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      _babeltraverselibvisitorsjs6160_mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function _babeltraverselibvisitorsjs6160_wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  var newVisitor = {};

  var _loop = function _loop(key) {
    var fns = oldVisitor[key];

    if (!Array.isArray(fns)) return "continue";

    fns = fns.map(function (fn) {
      var newFn = fn;

      if (state) {
        newFn = function newFn(path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      return newFn;
    });

    newVisitor[key] = fns;
  };

  for (var key in oldVisitor) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return newVisitor;
}

function _babeltraverselibvisitorsjs6160_ensureEntranceObjects(obj) {
  for (var key in obj) {
    if (_babeltraverselibvisitorsjs6160_shouldIgnoreKey(key)) continue;

    var fns = obj[key];
    if (typeof fns === "function") {
      obj[key] = { enter: fns };
    }
  }
}

function _babeltraverselibvisitorsjs6160_ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function _babeltraverselibvisitorsjs6160_wrapCheck(wrapper, fn) {
  var newFn = function newFn(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };
  newFn.toString = function () {
    return fn.toString();
  };
  return newFn;
}

function _babeltraverselibvisitorsjs6160_shouldIgnoreKey(key) {
  if (key[0] === "_") return true;

  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "blacklist" || key === "noScope" || key === "skipKeys") return true;

  return false;
}

function _babeltraverselibvisitorsjs6160_mergePair(dest, src) {
  for (var key in src) {
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}
/*≠≠ node_modules/babel-traverse/lib/visitors.js ≠≠*/

/*== node_modules/babel-messages/lib/index.js ==*/
$m['babel-messages/lib/index.js#6.8.0'] = { exports: {} };
/*istanbul ignore next*/"use strict";

$m['babel-messages/lib/index.js#6.8.0'].exports.__esModule = true;
$m['babel-messages/lib/index.js#6.8.0'].exports.MESSAGES = undefined;

var _babelmessageslibindexjs680__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babelmessageslibindexjs680__stringify2 = _babelmessageslibindexjs680__interopRequireDefault(_babelmessageslibindexjs680__stringify);

$m['babel-messages/lib/index.js#6.8.0'].exports.get = _babelmessageslibindexjs680_get;
/*istanbul ignore next*/$m['babel-messages/lib/index.js#6.8.0'].exports.parseArgs = _babelmessageslibindexjs680_parseArgs;

var /*istanbul ignore next*/_babelmessageslibindexjs680__util = require("util");

/*istanbul ignore next*/
var _babelmessageslibindexjs680_util = _babelmessageslibindexjs680__interopRequireWildcard(_babelmessageslibindexjs680__util);

/*istanbul ignore next*/
function _babelmessageslibindexjs680__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelmessageslibindexjs680__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Mapping of messages to be used in Babel.
 * Messages can include $0-style placeholders.
 */

var _babelmessageslibindexjs680_MESSAGES = /*istanbul ignore next*/$m['babel-messages/lib/index.js#6.8.0'].exports.MESSAGES = {
  tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
  classesIllegalBareSuper: "Illegal use of bare super",
  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
  scopeDuplicateDeclaration: "Duplicate declaration $1",
  settersNoRest: "Setters aren't allowed to have a rest",
  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
  expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
  readOnly: "$1 is read-only",
  unknownForHead: "Unknown node type $1 in ForStatement",
  didYouMean: "Did you mean $1?",
  codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
  missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
  unsupportedOutputType: "Unsupported output type $1",
  illegalMethodName: "Illegal method name $1",
  lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",

  modulesIllegalExportName: "Illegal export $1",
  modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",

  undeclaredVariable: "Reference to undeclared variable $1",
  undeclaredVariableType: "Referencing a type alias outside of a type annotation",
  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",

  traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",
  traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
  traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
  traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",

  pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",
  pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3",
  pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",
  pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3"
};

/**
 * Get a message with $0 placeholders replaced by arguments.
 */

/* eslint max-len: 0 */

function _babelmessageslibindexjs680_get(key) {
  /*istanbul ignore next*/
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var msg = _babelmessageslibindexjs680_MESSAGES[key];
  if (!msg) throw new ReferenceError( /*istanbul ignore next*/"Unknown message " + /*istanbul ignore next*/(0, _babelmessageslibindexjs680__stringify2.default)(key));

  // stringify args
  args = _babelmessageslibindexjs680_parseArgs(args);

  // replace $0 placeholders with args
  return msg.replace(/\$(\d+)/g, function (str, i) {
    return args[i - 1];
  });
}

/**
 * Stingify arguments to be used inside messages.
 */

function _babelmessageslibindexjs680_parseArgs(args) {
  return args.map(function (val) {
    if (val != null && val.inspect) {
      return val.inspect();
    } else {
      try {
        return (/*istanbul ignore next*/(0, _babelmessageslibindexjs680__stringify2.default)(val) || val + ""
        );
      } catch (e) {
        return _babelmessageslibindexjs680_util.inspect(val);
      }
    }
  });
}
/*≠≠ node_modules/babel-messages/lib/index.js ≠≠*/

/*== node_modules/babel-traverse/lib/index.js ==*/
$m['babel-traverse/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/index.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/index.js#6.16.0'].exports.visitors = $m['babel-traverse/lib/index.js#6.16.0'].exports.Hub = $m['babel-traverse/lib/index.js#6.16.0'].exports.Scope = $m['babel-traverse/lib/index.js#6.16.0'].exports.NodePath = undefined;

var _babeltraverselibindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibindexjs6160__getIterator3 = _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__getIterator2);

var _babeltraverselibindexjs6160__path = require("babel-traverse/lib/path/index.js#6.16.0");

Object.defineProperty($m['babel-traverse/lib/index.js#6.16.0'].exports, "NodePath", {
  enumerable: true,
  get: function get() {
    return _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__path).default;
  }
});

var _babeltraverselibindexjs6160__scope = require("babel-traverse/lib/scope/index.js#6.16.0");

Object.defineProperty($m['babel-traverse/lib/index.js#6.16.0'].exports, "Scope", {
  enumerable: true,
  get: function get() {
    return _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__scope).default;
  }
});

var _babeltraverselibindexjs6160__hub = $m['babel-traverse/lib/hub.js#6.16.0'].exports;

Object.defineProperty($m['babel-traverse/lib/index.js#6.16.0'].exports, "Hub", {
  enumerable: true,
  get: function get() {
    return _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__hub).default;
  }
});
$m['babel-traverse/lib/index.js#6.16.0'].exports.default = _babeltraverselibindexjs6160_traverse;

var _babeltraverselibindexjs6160__context = $m['babel-traverse/lib/context.js#6.16.0'].exports;

var _babeltraverselibindexjs6160__context2 = _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__context);

var _babeltraverselibindexjs6160__visitors = $m['babel-traverse/lib/visitors.js#6.16.0'].exports;

var _babeltraverselibindexjs6160_visitors = _babeltraverselibindexjs6160__interopRequireWildcard(_babeltraverselibindexjs6160__visitors);

var _babeltraverselibindexjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babeltraverselibindexjs6160_messages = _babeltraverselibindexjs6160__interopRequireWildcard(_babeltraverselibindexjs6160__babelMessages);

var _babeltraverselibindexjs6160__includes = $m['lodash/includes.js#4.16.2'].exports;

var _babeltraverselibindexjs6160__includes2 = _babeltraverselibindexjs6160__interopRequireDefault(_babeltraverselibindexjs6160__includes);

var _babeltraverselibindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibindexjs6160_t = _babeltraverselibindexjs6160__interopRequireWildcard(_babeltraverselibindexjs6160__babelTypes);

var _babeltraverselibindexjs6160__cache = $m['babel-traverse/lib/cache.js#6.16.0'].exports;

var _babeltraverselibindexjs6160_cache = _babeltraverselibindexjs6160__interopRequireWildcard(_babeltraverselibindexjs6160__cache);

function _babeltraverselibindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-traverse/lib/index.js#6.16.0'].exports.visitors = _babeltraverselibindexjs6160_visitors;
function _babeltraverselibindexjs6160_traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error(_babeltraverselibindexjs6160_messages.get("traverseNeedsParent", parent.type));
    }
  }

  _babeltraverselibindexjs6160_visitors.explode(opts);

  _babeltraverselibindexjs6160_traverse.node(parent, opts, scope, state, parentPath);
}

_babeltraverselibindexjs6160_traverse.visitors = _babeltraverselibindexjs6160_visitors;
_babeltraverselibindexjs6160_traverse.verify = _babeltraverselibindexjs6160_visitors.verify;
_babeltraverselibindexjs6160_traverse.explode = _babeltraverselibindexjs6160_visitors.explode;

_babeltraverselibindexjs6160_traverse.NodePath = require("babel-traverse/lib/path/index.js#6.16.0");
_babeltraverselibindexjs6160_traverse.Scope = require("babel-traverse/lib/scope/index.js#6.16.0");
_babeltraverselibindexjs6160_traverse.Hub = $m['babel-traverse/lib/hub.js#6.16.0'].exports;

_babeltraverselibindexjs6160_traverse.cheap = function (node, enter) {
  return _babeltraverselibindexjs6160_t.traverseFast(node, enter);
};

_babeltraverselibindexjs6160_traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  var keys = _babeltraverselibindexjs6160_t.VISITOR_KEYS[node.type];
  if (!keys) return;

  var context = new _babeltraverselibindexjs6160__context2.default(scope, opts, state, parentPath);
  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibindexjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var key = _ref;

    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};

_babeltraverselibindexjs6160_traverse.clearNode = function (node, opts) {
  _babeltraverselibindexjs6160_t.removeProperties(node, opts);

  _babeltraverselibindexjs6160_cache.path.delete(node);
};

_babeltraverselibindexjs6160_traverse.removeProperties = function (tree, opts) {
  _babeltraverselibindexjs6160_t.traverseFast(tree, _babeltraverselibindexjs6160_traverse.clearNode, opts);
  return tree;
};

function _babeltraverselibindexjs6160_hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

_babeltraverselibindexjs6160_traverse.hasType = function (tree, scope, type, blacklistTypes) {
  if ((0, _babeltraverselibindexjs6160__includes2.default)(blacklistTypes, tree.type)) return false;

  if (tree.type === type) return true;

  var state = {
    has: false,
    type: type
  };

  _babeltraverselibindexjs6160_traverse(tree, {
    blacklist: blacklistTypes,
    enter: _babeltraverselibindexjs6160_hasBlacklistedType
  }, scope, state);

  return state.has;
};

_babeltraverselibindexjs6160_traverse.clearCache = function () {
  _babeltraverselibindexjs6160_cache.clear();
};

_babeltraverselibindexjs6160_traverse.copyCache = function (source, destination) {
  if (_babeltraverselibindexjs6160_cache.path.has(source)) {
    _babeltraverselibindexjs6160_cache.path.set(destination, _babeltraverselibindexjs6160_cache.path.get(source));
  }
};
/*≠≠ node_modules/babel-traverse/lib/index.js ≠≠*/

/*== node_modules/babel-core/lib/tr...rmation/file/options/config.js ==*/
$m['babel-core/lib/transformation/file/options/config.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/config.js#6.16.0'].exports = {
  filename: {
    type: "filename",
    description: "filename to use when reading from stdin - this will be used in source-maps, errors etc",
    default: "unknown",
    shorthand: "f"
  },

  filenameRelative: {
    hidden: true,
    type: "string"
  },

  inputSourceMap: {
    hidden: true
  },

  env: {
    hidden: true,
    default: {}
  },

  mode: {
    description: "",
    hidden: true
  },

  retainLines: {
    type: "boolean",
    default: false,
    description: "retain line numbers - will result in really ugly code"
  },

  highlightCode: {
    description: "enable/disable ANSI syntax highlighting of code frames (on by default)",
    type: "boolean",
    default: true
  },

  suppressDeprecationMessages: {
    type: "boolean",
    default: false,
    hidden: true
  },

  presets: {
    type: "list",
    description: "",
    default: []
  },

  plugins: {
    type: "list",
    default: [],
    description: ""
  },

  ignore: {
    type: "list",
    description: "list of glob paths to **not** compile",
    default: []
  },

  only: {
    type: "list",
    description: "list of glob paths to **only** compile"
  },

  code: {
    hidden: true,
    default: true,
    type: "boolean"
  },

  metadata: {
    hidden: true,
    default: true,
    type: "boolean"
  },

  ast: {
    hidden: true,
    default: true,
    type: "boolean"
  },

  extends: {
    type: "string",
    hidden: true
  },

  comments: {
    type: "boolean",
    default: true,
    description: "write comments to generated output (true by default)"
  },

  shouldPrintComment: {
    hidden: true,
    description: "optional callback to control whether a comment should be inserted, when this is used the comments option is ignored"
  },

  wrapPluginVisitorMethod: {
    hidden: true,
    description: "optional callback to wrap all visitor methods"
  },

  compact: {
    type: "booleanString",
    default: "auto",
    description: "do not include superfluous whitespace characters and line terminators [true|false|auto]"
  },

  minified: {
    type: "boolean",
    default: false,
    description: "save as much bytes when printing [true|false]"
  },

  sourceMap: {
    alias: "sourceMaps",
    hidden: true
  },

  sourceMaps: {
    type: "booleanString",
    description: "[true|false|inline]",
    default: false,
    shorthand: "s"
  },

  sourceMapTarget: {
    type: "string",
    description: "set `file` on returned source map"
  },

  sourceFileName: {
    type: "string",
    description: "set `sources[0]` on returned source map"
  },

  sourceRoot: {
    type: "filename",
    description: "the root from which all sources are relative"
  },

  babelrc: {
    description: "Whether or not to look up .babelrc and .babelignore files",
    type: "boolean",
    default: true
  },

  sourceType: {
    description: "",
    default: "module"
  },

  auxiliaryCommentBefore: {
    type: "string",
    description: "print a comment before any injected non-user code"
  },

  auxiliaryCommentAfter: {
    type: "string",
    description: "print a comment after any injected non-user code"
  },

  resolveModuleSource: {
    hidden: true
  },

  getModuleId: {
    hidden: true
  },

  moduleRoot: {
    type: "filename",
    description: "optional prefix for the AMD module formatter that will be prepend to the filename on module definitions"
  },

  moduleIds: {
    type: "boolean",
    default: false,
    shorthand: "M",
    description: "insert an explicit id for modules"
  },

  moduleId: {
    description: "specify a custom name for module ids",
    type: "string"
  },

  passPerPreset: {
    description: "Whether to spawn a traversal pass per a preset. By default all presets are merged.",
    type: "boolean",
    default: false,
    hidden: true
  },

  parserOpts: {
    description: "Options to pass into the parser, or to change parsers (parserOpts.parser)",
    default: false
  },

  generatorOpts: {
    description: "Options to pass into the generator, or to change generators (generatorOpts.generator)",
    default: false
  }
};
/*≠≠ node_modules/babel-core/lib/tr...rmation/file/options/config.js ≠≠*/

/*== node_modules/babel-runtime/helpers/typeof.js ==*/
$m['babel-runtime/helpers/typeof.js#6.11.6'] = { exports: {} };
"use strict";

$m['babel-runtime/helpers/typeof.js#6.11.6'].exports.__esModule = true;

var _babelruntimehelperstypeofjs6116__iterator = $m['babel-runtime/core-js/symbol/iterator.js#6.11.6'].exports;

var _babelruntimehelperstypeofjs6116__iterator2 = _babelruntimehelperstypeofjs6116__interopRequireDefault(_babelruntimehelperstypeofjs6116__iterator);

var _babelruntimehelperstypeofjs6116__symbol = $m['babel-runtime/core-js/symbol.js#6.11.6'].exports;

var _babelruntimehelperstypeofjs6116__symbol2 = _babelruntimehelperstypeofjs6116__interopRequireDefault(_babelruntimehelperstypeofjs6116__symbol);

var _babelruntimehelperstypeofjs6116__typeof = typeof _babelruntimehelperstypeofjs6116__symbol2.default === "function" && typeof _babelruntimehelperstypeofjs6116__iterator2.default === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof _babelruntimehelperstypeofjs6116__symbol2.default === "function" && obj.constructor === _babelruntimehelperstypeofjs6116__symbol2.default ? "symbol" : typeof obj;
};

function _babelruntimehelperstypeofjs6116__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-runtime/helpers/typeof.js#6.11.6'].exports.default = typeof _babelruntimehelperstypeofjs6116__symbol2.default === "function" && _babelruntimehelperstypeofjs6116__typeof(_babelruntimehelperstypeofjs6116__iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _babelruntimehelperstypeofjs6116__typeof(obj);
} : function (obj) {
  return obj && typeof _babelruntimehelperstypeofjs6116__symbol2.default === "function" && obj.constructor === _babelruntimehelperstypeofjs6116__symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _babelruntimehelperstypeofjs6116__typeof(obj);
};
/*≠≠ node_modules/babel-runtime/helpers/typeof.js ≠≠*/

/*== node_modules/babel-core/lib/helpers/resolve.js ==*/
$m['babel-core/lib/helpers/resolve.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/helpers/resolve.js#6.16.0'].exports.__esModule = true;

var _babelcorelibhelpersresolvejs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelcorelibhelpersresolvejs6160__typeof3 = _babelcorelibhelpersresolvejs6160__interopRequireDefault(_babelcorelibhelpersresolvejs6160__typeof2);

$m['babel-core/lib/helpers/resolve.js#6.16.0'].exports.default = function (loc) {
  var relative = arguments.length <= 1 || arguments[1] === undefined ? process.cwd() : arguments[1];

  if ((typeof _babelcorelibhelpersresolvejs6160__module2.default === "undefined" ? "undefined" : (0, _babelcorelibhelpersresolvejs6160__typeof3.default)(_babelcorelibhelpersresolvejs6160__module2.default)) === "object") return null;

  var relativeMod = _babelcorelibhelpersresolvejs6160_relativeModules[relative];

  if (!relativeMod) {
    relativeMod = new _babelcorelibhelpersresolvejs6160__module2.default();

    var filename = _babelcorelibhelpersresolvejs6160__path2.default.join(relative, ".babelrc");
    relativeMod.id = filename;
    relativeMod.filename = filename;

    relativeMod.paths = _babelcorelibhelpersresolvejs6160__module2.default._nodeModulePaths(relative);
    _babelcorelibhelpersresolvejs6160_relativeModules[relative] = relativeMod;
  }

  try {
    return _babelcorelibhelpersresolvejs6160__module2.default._resolveFilename(loc, relativeMod);
  } catch (err) {
    return null;
  }
};

var _babelcorelibhelpersresolvejs6160__module = require("module");

var _babelcorelibhelpersresolvejs6160__module2 = _babelcorelibhelpersresolvejs6160__interopRequireDefault(_babelcorelibhelpersresolvejs6160__module);

var _babelcorelibhelpersresolvejs6160__path = require("path");

var _babelcorelibhelpersresolvejs6160__path2 = _babelcorelibhelpersresolvejs6160__interopRequireDefault(_babelcorelibhelpersresolvejs6160__path);

function _babelcorelibhelpersresolvejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibhelpersresolvejs6160_relativeModules = {};

$m['babel-core/lib/helpers/resolve.js#6.16.0'].exports = $m['babel-core/lib/helpers/resolve.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/helpers/resolve.js ≠≠*/

/*== node_modules/babel-runtime/core-js/map.js ==*/
$m['babel-runtime/core-js/map.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/map.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/map.js ≠≠*/

/*== node_modules/js-tokens/index.js ==*/
$m['js-tokens/index.js#2.0.0'] = { exports: {} };
// Copyright 2014, 2015, 2016 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
$m['js-tokens/index.js#2.0.0'].exports = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

$m['js-tokens/index.js#2.0.0'].exports.matchToToken = function (match) {
  var token = { type: "invalid", value: match[0] };
  if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
  return token;
};
/*≠≠ node_modules/js-tokens/index.js ≠≠*/

/*== node_modules/esutils/lib/utils.js ==*/
$m['esutils/lib/utils.js#2.0.2'] = { exports: {} };
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
  'use strict';

  $m['esutils/lib/utils.js#2.0.2'].exports.ast = $m['esutils/lib/ast.js#2.0.2'].exports;
  $m['esutils/lib/utils.js#2.0.2'].exports.code = $m['esutils/lib/code.js#2.0.2'].exports;
  $m['esutils/lib/utils.js#2.0.2'].exports.keyword = $m['esutils/lib/keyword.js#2.0.2'].exports;
})();
/* vim: set sw=4 ts=4 et tw=80 : */
/*≠≠ node_modules/esutils/lib/utils.js ≠≠*/

/*== node_modules/chalk/index.js ==*/
$m['chalk/index.js#1.1.3'] = { exports: {} };
'use strict';

var _chalkindexjs113_escapeStringRegexp = $m['escape-string-regexp/index.js#1.0.5'].exports;
var _chalkindexjs113_ansiStyles = $m['ansi-styles/index.js#2.2.1'].exports;
var _chalkindexjs113_stripAnsi = $m['strip-ansi/index.js#3.0.1'].exports;
var _chalkindexjs113_hasAnsi = $m['has-ansi/index.js#2.0.0'].exports;
var _chalkindexjs113_supportsColor = $m['supports-color/index.js#2.0.0'].exports;
var _chalkindexjs113_defineProps = Object.defineProperties;
var _chalkindexjs113_isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function _chalkindexjs113_Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? _chalkindexjs113_supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (_chalkindexjs113_isSimpleWindowsTerm) {
	_chalkindexjs113_ansiStyles.blue.open = '\u001b[94m';
}

var _chalkindexjs113_styles = function () {
	var ret = {};

	Object.keys(_chalkindexjs113_ansiStyles).forEach(function (key) {
		_chalkindexjs113_ansiStyles[key].closeRe = new RegExp(_chalkindexjs113_escapeStringRegexp(_chalkindexjs113_ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return _chalkindexjs113_build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
}();

var _chalkindexjs113_proto = _chalkindexjs113_defineProps(function chalk() {}, _chalkindexjs113_styles);

function _chalkindexjs113_build(_styles) {
	var builder = function () {
		return _chalkindexjs113_applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = _chalkindexjs113_proto;

	return builder;
}

function _chalkindexjs113_applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = _chalkindexjs113_ansiStyles.dim.open;
	if (_chalkindexjs113_isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		_chalkindexjs113_ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = _chalkindexjs113_ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	_chalkindexjs113_ansiStyles.dim.open = originalDim;

	return str;
}

function _chalkindexjs113_init() {
	var ret = {};

	Object.keys(_chalkindexjs113_styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return _chalkindexjs113_build.call(this, [name]);
			}
		};
	});

	return ret;
}

_chalkindexjs113_defineProps(_chalkindexjs113_Chalk.prototype, _chalkindexjs113_init());

$m['chalk/index.js#1.1.3'].exports = new _chalkindexjs113_Chalk();
$m['chalk/index.js#1.1.3'].exports.styles = _chalkindexjs113_ansiStyles;
$m['chalk/index.js#1.1.3'].exports.hasColor = _chalkindexjs113_hasAnsi;
$m['chalk/index.js#1.1.3'].exports.stripColor = _chalkindexjs113_stripAnsi;
$m['chalk/index.js#1.1.3'].exports.supportsColor = _chalkindexjs113_supportsColor;
/*≠≠ node_modules/chalk/index.js ≠≠*/

/*== node_modules/babel-code-frame/lib/index.js ==*/
$m['babel-code-frame/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-code-frame/lib/index.js#6.16.0'].exports.__esModule = true;

$m['babel-code-frame/lib/index.js#6.16.0'].exports.default = function (rawLines, lineNumber, colNumber) {
  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  colNumber = Math.max(colNumber, 0);

  var highlighted = opts.highlightCode && _babelcodeframelibindexjs6160__chalk2.default.supportsColor;
  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };
  if (highlighted) rawLines = _babelcodeframelibindexjs6160_highlight(rawLines);

  var linesAbove = opts.linesAbove || 2;
  var linesBelow = opts.linesBelow || 3;

  var lines = rawLines.split(_babelcodeframelibindexjs6160_NEWLINE);
  var start = Math.max(lineNumber - (linesAbove + 1), 0);
  var end = Math.min(lines.length, lineNumber + linesBelow);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  var numberMaxWidth = String(end).length;

  var frame = lines.slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = (" " + number).slice(-numberMaxWidth);
    var gutter = " " + paddedNumber + " | ";
    if (number === lineNumber) {
      var markerLine = "";
      if (colNumber) {
        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
        markerLine = ["\n ", maybeHighlight(_babelcodeframelibindexjs6160_defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(_babelcodeframelibindexjs6160_defs.marker, "^")].join("");
      }
      return [maybeHighlight(_babelcodeframelibindexjs6160_defs.marker, ">"), maybeHighlight(_babelcodeframelibindexjs6160_defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " " + maybeHighlight(_babelcodeframelibindexjs6160_defs.gutter, gutter) + line;
    }
  }).join("\n");

  if (highlighted) {
    return _babelcodeframelibindexjs6160__chalk2.default.reset(frame);
  } else {
    return frame;
  }
};

var _babelcodeframelibindexjs6160__jsTokens = $m['js-tokens/index.js#2.0.0'].exports;

var _babelcodeframelibindexjs6160__jsTokens2 = _babelcodeframelibindexjs6160__interopRequireDefault(_babelcodeframelibindexjs6160__jsTokens);

var _babelcodeframelibindexjs6160__esutils = $m['esutils/lib/utils.js#2.0.2'].exports;

var _babelcodeframelibindexjs6160__esutils2 = _babelcodeframelibindexjs6160__interopRequireDefault(_babelcodeframelibindexjs6160__esutils);

var _babelcodeframelibindexjs6160__chalk = $m['chalk/index.js#1.1.3'].exports;

var _babelcodeframelibindexjs6160__chalk2 = _babelcodeframelibindexjs6160__interopRequireDefault(_babelcodeframelibindexjs6160__chalk);

function _babelcodeframelibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcodeframelibindexjs6160_defs = {
  keyword: _babelcodeframelibindexjs6160__chalk2.default.cyan,
  capitalized: _babelcodeframelibindexjs6160__chalk2.default.yellow,
  jsx_tag: _babelcodeframelibindexjs6160__chalk2.default.yellow,
  punctuator: _babelcodeframelibindexjs6160__chalk2.default.yellow,

  number: _babelcodeframelibindexjs6160__chalk2.default.magenta,
  string: _babelcodeframelibindexjs6160__chalk2.default.green,
  regex: _babelcodeframelibindexjs6160__chalk2.default.magenta,
  comment: _babelcodeframelibindexjs6160__chalk2.default.grey,
  invalid: _babelcodeframelibindexjs6160__chalk2.default.white.bgRed.bold,
  gutter: _babelcodeframelibindexjs6160__chalk2.default.grey,
  marker: _babelcodeframelibindexjs6160__chalk2.default.red.bold
};

var _babelcodeframelibindexjs6160_NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

var _babelcodeframelibindexjs6160_JSX_TAG = /^[a-z][\w-]*$/i;

var _babelcodeframelibindexjs6160_BRACKET = /^[()\[\]{}]$/;

function _babelcodeframelibindexjs6160_getTokenType(match) {
  var _match$slice = match.slice(-2);

  var offset = _match$slice[0];
  var text = _match$slice[1];

  var token = _babelcodeframelibindexjs6160__jsTokens2.default.matchToToken(match);

  if (token.type === "name") {
    if (_babelcodeframelibindexjs6160__esutils2.default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (_babelcodeframelibindexjs6160_JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && _babelcodeframelibindexjs6160_BRACKET.test(token.value)) {
    return "bracket";
  }

  return token.type;
}

function _babelcodeframelibindexjs6160_highlight(text) {
  return text.replace(_babelcodeframelibindexjs6160__jsTokens2.default, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = _babelcodeframelibindexjs6160_getTokenType(args);
    var colorize = _babelcodeframelibindexjs6160_defs[type];
    if (colorize) {
      return args[0].split(_babelcodeframelibindexjs6160_NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

$m['babel-code-frame/lib/index.js#6.16.0'].exports = $m['babel-code-frame/lib/index.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-code-frame/lib/index.js ≠≠*/

/*== node_modules/lodash/_baseRepeat.js ==*/
$m['lodash/_baseRepeat.js#4.16.2'] = { exports: {} };
/** Used as references for various `Number` constants. */
var _lodashbaseRepeatjs4162_MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashbaseRepeatjs4162_nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function _lodashbaseRepeatjs4162_baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > _lodashbaseRepeatjs4162_MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = _lodashbaseRepeatjs4162_nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

$m['lodash/_baseRepeat.js#4.16.2'].exports = _lodashbaseRepeatjs4162_baseRepeat;
/*≠≠ node_modules/lodash/_baseRepeat.js ≠≠*/

/*== node_modules/lodash/toInteger.js ==*/
$m['lodash/toInteger.js#4.16.2'] = { exports: {} };
var _lodashtoIntegerjs4162_toFinite = $m['lodash/toFinite.js#4.16.2'].exports;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function _lodashtoIntegerjs4162_toInteger(value) {
  var result = _lodashtoIntegerjs4162_toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

$m['lodash/toInteger.js#4.16.2'].exports = _lodashtoIntegerjs4162_toInteger;
/*≠≠ node_modules/lodash/toInteger.js ≠≠*/

/*== node_modules/lodash/toString.js ==*/
$m['lodash/toString.js#4.16.2'] = { exports: {} };
var _lodashtoStringjs4162_baseToString = $m['lodash/_baseToString.js#4.16.2'].exports;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function _lodashtoStringjs4162_toString(value) {
  return value == null ? '' : _lodashtoStringjs4162_baseToString(value);
}

$m['lodash/toString.js#4.16.2'].exports = _lodashtoStringjs4162_toString;
/*≠≠ node_modules/lodash/toString.js ≠≠*/

/*== node_modules/lodash/repeat.js ==*/
$m['lodash/repeat.js#4.16.2'] = { exports: {} };
var _lodashrepeatjs4162_baseRepeat = $m['lodash/_baseRepeat.js#4.16.2'].exports,
    _lodashrepeatjs4162_isIterateeCall = $m['lodash/_isIterateeCall.js#4.16.2'].exports,
    _lodashrepeatjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports,
    _lodashrepeatjs4162_toString = $m['lodash/toString.js#4.16.2'].exports;

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function _lodashrepeatjs4162_repeat(string, n, guard) {
  if (guard ? _lodashrepeatjs4162_isIterateeCall(string, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = _lodashrepeatjs4162_toInteger(n);
  }
  return _lodashrepeatjs4162_baseRepeat(_lodashrepeatjs4162_toString(string), n);
}

$m['lodash/repeat.js#4.16.2'].exports = _lodashrepeatjs4162_repeat;
/*≠≠ node_modules/lodash/repeat.js ≠≠*/

/*== node_modules/babel-runtime/core-js/object/assign.js ==*/
$m['babel-runtime/core-js/object/assign.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/object/assign.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/object/assign.js ≠≠*/

/*== node_modules/babel-runtime/core-js/object/create.js ==*/
$m['babel-runtime/core-js/object/create.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/object/create.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/object/create.js ≠≠*/

/*== node_modules/path-is-absolute/index.js ==*/
$m['path-is-absolute/index.js#1.0.1'] = { exports: {} };
'use strict';

function _pathisabsoluteindexjs101_posix(path) {
	return path.charAt(0) === '/';
}

function _pathisabsoluteindexjs101_win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

$m['path-is-absolute/index.js#1.0.1'].exports = process.platform === 'win32' ? _pathisabsoluteindexjs101_win32 : _pathisabsoluteindexjs101_posix;
$m['path-is-absolute/index.js#1.0.1'].exports.posix = _pathisabsoluteindexjs101_posix;
$m['path-is-absolute/index.js#1.0.1'].exports.win32 = _pathisabsoluteindexjs101_win32;
/*≠≠ node_modules/path-is-absolute/index.js ≠≠*/

/*== node_modules/lodash/_assignValue.js ==*/
$m['lodash/_assignValue.js#4.16.2'] = { exports: {} };
var _lodashassignValuejs4162_baseAssignValue = $m['lodash/_baseAssignValue.js#4.16.2'].exports,
    _lodashassignValuejs4162_eq = $m['lodash/eq.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashassignValuejs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashassignValuejs4162_hasOwnProperty = _lodashassignValuejs4162_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function _lodashassignValuejs4162_assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_lodashassignValuejs4162_hasOwnProperty.call(object, key) && _lodashassignValuejs4162_eq(objValue, value)) || value === undefined && !(key in object)) {
    _lodashassignValuejs4162_baseAssignValue(object, key, value);
  }
}

$m['lodash/_assignValue.js#4.16.2'].exports = _lodashassignValuejs4162_assignValue;
/*≠≠ node_modules/lodash/_assignValue.js ≠≠*/

/*== node_modules/lodash/_baseAssign.js ==*/
$m['lodash/_baseAssign.js#4.16.2'] = { exports: {} };
var _lodashbaseAssignjs4162_copyObject = $m['lodash/_copyObject.js#4.16.2'].exports,
    _lodashbaseAssignjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function _lodashbaseAssignjs4162_baseAssign(object, source) {
  return object && _lodashbaseAssignjs4162_copyObject(source, _lodashbaseAssignjs4162_keys(source), object);
}

$m['lodash/_baseAssign.js#4.16.2'].exports = _lodashbaseAssignjs4162_baseAssign;
/*≠≠ node_modules/lodash/_baseAssign.js ≠≠*/

/*== node_modules/lodash/_cloneBuffer.js ==*/
$m['lodash/_cloneBuffer.js#4.16.2'] = { exports: {} };
var _lodashcloneBufferjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/** Detect free variable `exports`. */
var _lodashcloneBufferjs4162_freeExports = typeof $m['lodash/_cloneBuffer.js#4.16.2'].exports == 'object' && $m['lodash/_cloneBuffer.js#4.16.2'].exports && !$m['lodash/_cloneBuffer.js#4.16.2'].exports.nodeType && $m['lodash/_cloneBuffer.js#4.16.2'].exports;

/** Detect free variable `module`. */
var _lodashcloneBufferjs4162_freeModule = _lodashcloneBufferjs4162_freeExports && typeof $m['lodash/_cloneBuffer.js#4.16.2'] == 'object' && $m['lodash/_cloneBuffer.js#4.16.2'] && !$m['lodash/_cloneBuffer.js#4.16.2'].nodeType && $m['lodash/_cloneBuffer.js#4.16.2'];

/** Detect the popular CommonJS extension `module.exports`. */
var _lodashcloneBufferjs4162_moduleExports = _lodashcloneBufferjs4162_freeModule && _lodashcloneBufferjs4162_freeModule.exports === _lodashcloneBufferjs4162_freeExports;

/** Built-in value references. */
var _lodashcloneBufferjs4162_Buffer = _lodashcloneBufferjs4162_moduleExports ? _lodashcloneBufferjs4162_root.Buffer : undefined,
    _lodashcloneBufferjs4162_allocUnsafe = _lodashcloneBufferjs4162_Buffer ? _lodashcloneBufferjs4162_Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function _lodashcloneBufferjs4162_cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = _lodashcloneBufferjs4162_allocUnsafe ? _lodashcloneBufferjs4162_allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

$m['lodash/_cloneBuffer.js#4.16.2'].exports = _lodashcloneBufferjs4162_cloneBuffer;
/*≠≠ node_modules/lodash/_cloneBuffer.js ≠≠*/

/*== node_modules/lodash/_copyArray.js ==*/
$m['lodash/_copyArray.js#4.16.2'] = { exports: {} };
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function _lodashcopyArrayjs4162_copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

$m['lodash/_copyArray.js#4.16.2'].exports = _lodashcopyArrayjs4162_copyArray;
/*≠≠ node_modules/lodash/_copyArray.js ≠≠*/

/*== node_modules/lodash/_copySymbols.js ==*/
$m['lodash/_copySymbols.js#4.16.2'] = { exports: {} };
var _lodashcopySymbolsjs4162_copyObject = $m['lodash/_copyObject.js#4.16.2'].exports,
    _lodashcopySymbolsjs4162_getSymbols = $m['lodash/_getSymbols.js#4.16.2'].exports;

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function _lodashcopySymbolsjs4162_copySymbols(source, object) {
  return _lodashcopySymbolsjs4162_copyObject(source, _lodashcopySymbolsjs4162_getSymbols(source), object);
}

$m['lodash/_copySymbols.js#4.16.2'].exports = _lodashcopySymbolsjs4162_copySymbols;
/*≠≠ node_modules/lodash/_copySymbols.js ≠≠*/

/*== node_modules/lodash/_getAllKeys.js ==*/
$m['lodash/_getAllKeys.js#4.16.2'] = { exports: {} };
var _lodashgetAllKeysjs4162_baseGetAllKeys = $m['lodash/_baseGetAllKeys.js#4.16.2'].exports,
    _lodashgetAllKeysjs4162_getSymbols = $m['lodash/_getSymbols.js#4.16.2'].exports,
    _lodashgetAllKeysjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function _lodashgetAllKeysjs4162_getAllKeys(object) {
  return _lodashgetAllKeysjs4162_baseGetAllKeys(object, _lodashgetAllKeysjs4162_keys, _lodashgetAllKeysjs4162_getSymbols);
}

$m['lodash/_getAllKeys.js#4.16.2'].exports = _lodashgetAllKeysjs4162_getAllKeys;
/*≠≠ node_modules/lodash/_getAllKeys.js ≠≠*/

/*== node_modules/lodash/_getTag.js ==*/
$m['lodash/_getTag.js#4.16.2'] = { exports: {} };
var _lodashgetTagjs4162_DataView = $m['lodash/_DataView.js#4.16.2'].exports,
    _lodashgetTagjs4162_Map = $m['lodash/_Map.js#4.16.2'].exports,
    _lodashgetTagjs4162_Promise = $m['lodash/_Promise.js#4.16.2'].exports,
    _lodashgetTagjs4162_Set = $m['lodash/_Set.js#4.16.2'].exports,
    _lodashgetTagjs4162_WeakMap = $m['lodash/_WeakMap.js#4.16.2'].exports,
    _lodashgetTagjs4162_baseGetTag = $m['lodash/_baseGetTag.js#4.16.2'].exports,
    _lodashgetTagjs4162_toSource = $m['lodash/_toSource.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashgetTagjs4162_mapTag = '[object Map]',
    _lodashgetTagjs4162_objectTag = '[object Object]',
    _lodashgetTagjs4162_promiseTag = '[object Promise]',
    _lodashgetTagjs4162_setTag = '[object Set]',
    _lodashgetTagjs4162_weakMapTag = '[object WeakMap]';

var _lodashgetTagjs4162_dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var _lodashgetTagjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashgetTagjs4162_objectToString = _lodashgetTagjs4162_objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var _lodashgetTagjs4162_dataViewCtorString = _lodashgetTagjs4162_toSource(_lodashgetTagjs4162_DataView),
    _lodashgetTagjs4162_mapCtorString = _lodashgetTagjs4162_toSource(_lodashgetTagjs4162_Map),
    _lodashgetTagjs4162_promiseCtorString = _lodashgetTagjs4162_toSource(_lodashgetTagjs4162_Promise),
    _lodashgetTagjs4162_setCtorString = _lodashgetTagjs4162_toSource(_lodashgetTagjs4162_Set),
    _lodashgetTagjs4162_weakMapCtorString = _lodashgetTagjs4162_toSource(_lodashgetTagjs4162_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var _lodashgetTagjs4162_getTag = _lodashgetTagjs4162_baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (_lodashgetTagjs4162_DataView && _lodashgetTagjs4162_getTag(new _lodashgetTagjs4162_DataView(new ArrayBuffer(1))) != _lodashgetTagjs4162_dataViewTag || _lodashgetTagjs4162_Map && _lodashgetTagjs4162_getTag(new _lodashgetTagjs4162_Map()) != _lodashgetTagjs4162_mapTag || _lodashgetTagjs4162_Promise && _lodashgetTagjs4162_getTag(_lodashgetTagjs4162_Promise.resolve()) != _lodashgetTagjs4162_promiseTag || _lodashgetTagjs4162_Set && _lodashgetTagjs4162_getTag(new _lodashgetTagjs4162_Set()) != _lodashgetTagjs4162_setTag || _lodashgetTagjs4162_WeakMap && _lodashgetTagjs4162_getTag(new _lodashgetTagjs4162_WeakMap()) != _lodashgetTagjs4162_weakMapTag) {
    _lodashgetTagjs4162_getTag = function (value) {
        var result = _lodashgetTagjs4162_objectToString.call(value),
            Ctor = result == _lodashgetTagjs4162_objectTag ? value.constructor : undefined,
            ctorString = Ctor ? _lodashgetTagjs4162_toSource(Ctor) : undefined;

        if (ctorString) {
            switch (ctorString) {
                case _lodashgetTagjs4162_dataViewCtorString:
                    return _lodashgetTagjs4162_dataViewTag;
                case _lodashgetTagjs4162_mapCtorString:
                    return _lodashgetTagjs4162_mapTag;
                case _lodashgetTagjs4162_promiseCtorString:
                    return _lodashgetTagjs4162_promiseTag;
                case _lodashgetTagjs4162_setCtorString:
                    return _lodashgetTagjs4162_setTag;
                case _lodashgetTagjs4162_weakMapCtorString:
                    return _lodashgetTagjs4162_weakMapTag;
            }
        }
        return result;
    };
}

$m['lodash/_getTag.js#4.16.2'].exports = _lodashgetTagjs4162_getTag;
/*≠≠ node_modules/lodash/_getTag.js ≠≠*/

/*== node_modules/lodash/_initCloneArray.js ==*/
$m['lodash/_initCloneArray.js#4.16.2'] = { exports: {} };
/** Used for built-in method references. */
var _lodashinitCloneArrayjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashinitCloneArrayjs4162_hasOwnProperty = _lodashinitCloneArrayjs4162_objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function _lodashinitCloneArrayjs4162_initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && _lodashinitCloneArrayjs4162_hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

$m['lodash/_initCloneArray.js#4.16.2'].exports = _lodashinitCloneArrayjs4162_initCloneArray;
/*≠≠ node_modules/lodash/_initCloneArray.js ≠≠*/

/*== node_modules/lodash/_initCloneByTag.js ==*/
$m['lodash/_initCloneByTag.js#4.16.2'] = { exports: {} };
var _lodashinitCloneByTagjs4162_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneDataView = $m['lodash/_cloneDataView.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneMap = $m['lodash/_cloneMap.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneRegExp = $m['lodash/_cloneRegExp.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneSet = $m['lodash/_cloneSet.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneSymbol = $m['lodash/_cloneSymbol.js#4.16.2'].exports,
    _lodashinitCloneByTagjs4162_cloneTypedArray = $m['lodash/_cloneTypedArray.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashinitCloneByTagjs4162_boolTag = '[object Boolean]',
    _lodashinitCloneByTagjs4162_dateTag = '[object Date]',
    _lodashinitCloneByTagjs4162_mapTag = '[object Map]',
    _lodashinitCloneByTagjs4162_numberTag = '[object Number]',
    _lodashinitCloneByTagjs4162_regexpTag = '[object RegExp]',
    _lodashinitCloneByTagjs4162_setTag = '[object Set]',
    _lodashinitCloneByTagjs4162_stringTag = '[object String]',
    _lodashinitCloneByTagjs4162_symbolTag = '[object Symbol]';

var _lodashinitCloneByTagjs4162_arrayBufferTag = '[object ArrayBuffer]',
    _lodashinitCloneByTagjs4162_dataViewTag = '[object DataView]',
    _lodashinitCloneByTagjs4162_float32Tag = '[object Float32Array]',
    _lodashinitCloneByTagjs4162_float64Tag = '[object Float64Array]',
    _lodashinitCloneByTagjs4162_int8Tag = '[object Int8Array]',
    _lodashinitCloneByTagjs4162_int16Tag = '[object Int16Array]',
    _lodashinitCloneByTagjs4162_int32Tag = '[object Int32Array]',
    _lodashinitCloneByTagjs4162_uint8Tag = '[object Uint8Array]',
    _lodashinitCloneByTagjs4162_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashinitCloneByTagjs4162_uint16Tag = '[object Uint16Array]',
    _lodashinitCloneByTagjs4162_uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function _lodashinitCloneByTagjs4162_initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case _lodashinitCloneByTagjs4162_arrayBufferTag:
      return _lodashinitCloneByTagjs4162_cloneArrayBuffer(object);

    case _lodashinitCloneByTagjs4162_boolTag:
    case _lodashinitCloneByTagjs4162_dateTag:
      return new Ctor(+object);

    case _lodashinitCloneByTagjs4162_dataViewTag:
      return _lodashinitCloneByTagjs4162_cloneDataView(object, isDeep);

    case _lodashinitCloneByTagjs4162_float32Tag:case _lodashinitCloneByTagjs4162_float64Tag:
    case _lodashinitCloneByTagjs4162_int8Tag:case _lodashinitCloneByTagjs4162_int16Tag:case _lodashinitCloneByTagjs4162_int32Tag:
    case _lodashinitCloneByTagjs4162_uint8Tag:case _lodashinitCloneByTagjs4162_uint8ClampedTag:case _lodashinitCloneByTagjs4162_uint16Tag:case _lodashinitCloneByTagjs4162_uint32Tag:
      return _lodashinitCloneByTagjs4162_cloneTypedArray(object, isDeep);

    case _lodashinitCloneByTagjs4162_mapTag:
      return _lodashinitCloneByTagjs4162_cloneMap(object, isDeep, cloneFunc);

    case _lodashinitCloneByTagjs4162_numberTag:
    case _lodashinitCloneByTagjs4162_stringTag:
      return new Ctor(object);

    case _lodashinitCloneByTagjs4162_regexpTag:
      return _lodashinitCloneByTagjs4162_cloneRegExp(object);

    case _lodashinitCloneByTagjs4162_setTag:
      return _lodashinitCloneByTagjs4162_cloneSet(object, isDeep, cloneFunc);

    case _lodashinitCloneByTagjs4162_symbolTag:
      return _lodashinitCloneByTagjs4162_cloneSymbol(object);
  }
}

$m['lodash/_initCloneByTag.js#4.16.2'].exports = _lodashinitCloneByTagjs4162_initCloneByTag;
/*≠≠ node_modules/lodash/_initCloneByTag.js ≠≠*/

/*== node_modules/lodash/_initCloneObject.js ==*/
$m['lodash/_initCloneObject.js#4.16.2'] = { exports: {} };
var _lodashinitCloneObjectjs4162_baseCreate = $m['lodash/_baseCreate.js#4.16.2'].exports,
    _lodashinitCloneObjectjs4162_getPrototype = $m['lodash/_getPrototype.js#4.16.2'].exports,
    _lodashinitCloneObjectjs4162_isPrototype = $m['lodash/_isPrototype.js#4.16.2'].exports;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function _lodashinitCloneObjectjs4162_initCloneObject(object) {
    return typeof object.constructor == 'function' && !_lodashinitCloneObjectjs4162_isPrototype(object) ? _lodashinitCloneObjectjs4162_baseCreate(_lodashinitCloneObjectjs4162_getPrototype(object)) : {};
}

$m['lodash/_initCloneObject.js#4.16.2'].exports = _lodashinitCloneObjectjs4162_initCloneObject;
/*≠≠ node_modules/lodash/_initCloneObject.js ≠≠*/

/*== node_modules/lodash/isBuffer.js ==*/
$m['lodash/isBuffer.js#4.16.2'] = { exports: {} };
var _lodashisBufferjs4162_root = $m['lodash/_root.js#4.16.2'].exports,
    _lodashisBufferjs4162_stubFalse = $m['lodash/stubFalse.js#4.16.2'].exports;

/** Detect free variable `exports`. */
var _lodashisBufferjs4162_freeExports = typeof $m['lodash/isBuffer.js#4.16.2'].exports == 'object' && $m['lodash/isBuffer.js#4.16.2'].exports && !$m['lodash/isBuffer.js#4.16.2'].exports.nodeType && $m['lodash/isBuffer.js#4.16.2'].exports;

/** Detect free variable `module`. */
var _lodashisBufferjs4162_freeModule = _lodashisBufferjs4162_freeExports && typeof $m['lodash/isBuffer.js#4.16.2'] == 'object' && $m['lodash/isBuffer.js#4.16.2'] && !$m['lodash/isBuffer.js#4.16.2'].nodeType && $m['lodash/isBuffer.js#4.16.2'];

/** Detect the popular CommonJS extension `module.exports`. */
var _lodashisBufferjs4162_moduleExports = _lodashisBufferjs4162_freeModule && _lodashisBufferjs4162_freeModule.exports === _lodashisBufferjs4162_freeExports;

/** Built-in value references. */
var _lodashisBufferjs4162_Buffer = _lodashisBufferjs4162_moduleExports ? _lodashisBufferjs4162_root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashisBufferjs4162_nativeIsBuffer = _lodashisBufferjs4162_Buffer ? _lodashisBufferjs4162_Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var _lodashisBufferjs4162_isBuffer = _lodashisBufferjs4162_nativeIsBuffer || _lodashisBufferjs4162_stubFalse;

$m['lodash/isBuffer.js#4.16.2'].exports = _lodashisBufferjs4162_isBuffer;
/*≠≠ node_modules/lodash/isBuffer.js ≠≠*/

/*== node_modules/lodash/keys.js ==*/
$m['lodash/keys.js#4.16.2'] = { exports: {} };
var _lodashkeysjs4162_arrayLikeKeys = $m['lodash/_arrayLikeKeys.js#4.16.2'].exports,
    _lodashkeysjs4162_baseKeys = $m['lodash/_baseKeys.js#4.16.2'].exports,
    _lodashkeysjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function _lodashkeysjs4162_keys(object) {
  return _lodashkeysjs4162_isArrayLike(object) ? _lodashkeysjs4162_arrayLikeKeys(object) : _lodashkeysjs4162_baseKeys(object);
}

$m['lodash/keys.js#4.16.2'].exports = _lodashkeysjs4162_keys;
/*≠≠ node_modules/lodash/keys.js ≠≠*/

/*== node_modules/lodash/_baseClone.js ==*/
$m['lodash/_baseClone.js#4.16.2'] = { exports: {} };
var _lodashbaseClonejs4162_Stack = $m['lodash/_Stack.js#4.16.2'].exports,
    _lodashbaseClonejs4162_arrayEach = $m['lodash/_arrayEach.js#4.16.2'].exports,
    _lodashbaseClonejs4162_assignValue = $m['lodash/_assignValue.js#4.16.2'].exports,
    _lodashbaseClonejs4162_baseAssign = $m['lodash/_baseAssign.js#4.16.2'].exports,
    _lodashbaseClonejs4162_cloneBuffer = $m['lodash/_cloneBuffer.js#4.16.2'].exports,
    _lodashbaseClonejs4162_copyArray = $m['lodash/_copyArray.js#4.16.2'].exports,
    _lodashbaseClonejs4162_copySymbols = $m['lodash/_copySymbols.js#4.16.2'].exports,
    _lodashbaseClonejs4162_getAllKeys = $m['lodash/_getAllKeys.js#4.16.2'].exports,
    _lodashbaseClonejs4162_getTag = $m['lodash/_getTag.js#4.16.2'].exports,
    _lodashbaseClonejs4162_initCloneArray = $m['lodash/_initCloneArray.js#4.16.2'].exports,
    _lodashbaseClonejs4162_initCloneByTag = $m['lodash/_initCloneByTag.js#4.16.2'].exports,
    _lodashbaseClonejs4162_initCloneObject = $m['lodash/_initCloneObject.js#4.16.2'].exports,
    _lodashbaseClonejs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashbaseClonejs4162_isBuffer = $m['lodash/isBuffer.js#4.16.2'].exports,
    _lodashbaseClonejs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseClonejs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashbaseClonejs4162_argsTag = '[object Arguments]',
    _lodashbaseClonejs4162_arrayTag = '[object Array]',
    _lodashbaseClonejs4162_boolTag = '[object Boolean]',
    _lodashbaseClonejs4162_dateTag = '[object Date]',
    _lodashbaseClonejs4162_errorTag = '[object Error]',
    _lodashbaseClonejs4162_funcTag = '[object Function]',
    _lodashbaseClonejs4162_genTag = '[object GeneratorFunction]',
    _lodashbaseClonejs4162_mapTag = '[object Map]',
    _lodashbaseClonejs4162_numberTag = '[object Number]',
    _lodashbaseClonejs4162_objectTag = '[object Object]',
    _lodashbaseClonejs4162_regexpTag = '[object RegExp]',
    _lodashbaseClonejs4162_setTag = '[object Set]',
    _lodashbaseClonejs4162_stringTag = '[object String]',
    _lodashbaseClonejs4162_symbolTag = '[object Symbol]',
    _lodashbaseClonejs4162_weakMapTag = '[object WeakMap]';

var _lodashbaseClonejs4162_arrayBufferTag = '[object ArrayBuffer]',
    _lodashbaseClonejs4162_dataViewTag = '[object DataView]',
    _lodashbaseClonejs4162_float32Tag = '[object Float32Array]',
    _lodashbaseClonejs4162_float64Tag = '[object Float64Array]',
    _lodashbaseClonejs4162_int8Tag = '[object Int8Array]',
    _lodashbaseClonejs4162_int16Tag = '[object Int16Array]',
    _lodashbaseClonejs4162_int32Tag = '[object Int32Array]',
    _lodashbaseClonejs4162_uint8Tag = '[object Uint8Array]',
    _lodashbaseClonejs4162_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashbaseClonejs4162_uint16Tag = '[object Uint16Array]',
    _lodashbaseClonejs4162_uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var _lodashbaseClonejs4162_cloneableTags = {};
_lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_argsTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_arrayTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_arrayBufferTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_dataViewTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_boolTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_dateTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_float32Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_float64Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_int8Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_int16Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_int32Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_mapTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_numberTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_objectTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_regexpTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_setTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_stringTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_symbolTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_uint8Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_uint8ClampedTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_uint16Tag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_uint32Tag] = true;
_lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_errorTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_funcTag] = _lodashbaseClonejs4162_cloneableTags[_lodashbaseClonejs4162_weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function _lodashbaseClonejs4162_baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!_lodashbaseClonejs4162_isObject(value)) {
    return value;
  }
  var isArr = _lodashbaseClonejs4162_isArray(value);
  if (isArr) {
    result = _lodashbaseClonejs4162_initCloneArray(value);
    if (!isDeep) {
      return _lodashbaseClonejs4162_copyArray(value, result);
    }
  } else {
    var tag = _lodashbaseClonejs4162_getTag(value),
        isFunc = tag == _lodashbaseClonejs4162_funcTag || tag == _lodashbaseClonejs4162_genTag;

    if (_lodashbaseClonejs4162_isBuffer(value)) {
      return _lodashbaseClonejs4162_cloneBuffer(value, isDeep);
    }
    if (tag == _lodashbaseClonejs4162_objectTag || tag == _lodashbaseClonejs4162_argsTag || isFunc && !object) {
      result = _lodashbaseClonejs4162_initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return _lodashbaseClonejs4162_copySymbols(value, _lodashbaseClonejs4162_baseAssign(result, value));
      }
    } else {
      if (!_lodashbaseClonejs4162_cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _lodashbaseClonejs4162_initCloneByTag(value, tag, _lodashbaseClonejs4162_baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _lodashbaseClonejs4162_Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? _lodashbaseClonejs4162_getAllKeys(value) : _lodashbaseClonejs4162_keys(value);
  }
  _lodashbaseClonejs4162_arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _lodashbaseClonejs4162_assignValue(result, key, _lodashbaseClonejs4162_baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

$m['lodash/_baseClone.js#4.16.2'].exports = _lodashbaseClonejs4162_baseClone;
/*≠≠ node_modules/lodash/_baseClone.js ≠≠*/

/*== node_modules/json5/lib/json5.js ==*/
$m['json5/lib/json5.js#0.4.0'] = { exports: {} };
// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var _json5libjson5js040_JSON5 = typeof $m['json5/lib/json5.js#0.4.0'].exports === 'object' ? $m['json5/lib/json5.js#0.4.0'].exports : {};

_json5libjson5js040_JSON5.parse = function () {
    "use strict";

    // This is a function that can parse a JSON5 text, producing a JavaScript
    // data structure. It is a simple, recursive descent parser. It does not use
    // eval or regular expressions, so it can be used as a model for implementing
    // a JSON5 parser in other languages.

    // We are defining the function inside of another function to avoid creating
    // global variables.

    var at,
        // The index of the current character
    ch,
        // The current character
    escapee = {
        "'": "'",
        '"': '"',
        '\\': '\\',
        '/': '/',
        '\n': '', // Replace escaped newlines in strings w/ empty string
        b: '\b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t'
    },
        ws = [' ', '\t', '\r', '\n', '\v', '\f', '\xA0', '\uFEFF'],
        text,
        error = function (m) {

        // Call error when something is wrong.

        var error = new SyntaxError();
        error.message = m;
        error.at = at;
        error.text = text;
        throw error;
    },
        next = function (c) {

        // If a c parameter is provided, verify that it matches the current character.

        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }

        // Get the next character. When there are no more characters,
        // return the empty string.

        ch = text.charAt(at);
        at += 1;
        return ch;
    },
        peek = function () {

        // Get the next character without consuming it or
        // assigning it to the ch varaible.

        return text.charAt(at);
    },
        identifier = function () {

        // Parse an identifier. Normally, reserved words are disallowed here, but we
        // only use this for unquoted object keys, where reserved words are allowed,
        // so we don't check for those here. References:
        // - http://es5.github.com/#x7.6
        // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
        // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
        // TODO Identifiers can have Unicode "letters" in them; add support for those.

        var key = ch;

        // Identifiers must start with a letter, _ or $.
        if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
            error("Bad identifier");
        }

        // Subsequent characters can contain digits.
        while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {
            key += ch;
        }

        return key;
    },
        number = function () {

        // Parse a number value.

        var number,
            sign = '',
            string = '',
            base = 10;

        if (ch === '-' || ch === '+') {
            sign = ch;
            next(ch);
        }

        // support for Infinity (could tweak to allow other words):
        if (ch === 'I') {
            number = word();
            if (typeof number !== 'number' || isNaN(number)) {
                error('Unexpected word for number');
            }
            return sign === '-' ? -number : number;
        }

        // support for NaN
        if (ch === 'N') {
            number = word();
            if (!isNaN(number)) {
                error('expected word to be NaN');
            }
            // ignore sign as -NaN also is NaN
            return number;
        }

        if (ch === '0') {
            string += ch;
            next();
            if (ch === 'x' || ch === 'X') {
                string += ch;
                next();
                base = 16;
            } else if (ch >= '0' && ch <= '9') {
                error('Octal literal');
            }
        }

        switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
        }

        if (sign === '-') {
            number = -string;
        } else {
            number = +string;
        }

        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
        string = function () {

        // Parse a string value.

        var hex,
            i,
            string = '',
            delim,
            // double quote or single quote
        uffff;

        // When parsing for string values, we must look for ' or " and \ characters.

        if (ch === '"' || ch === "'") {
            delim = ch;
            while (next()) {
                if (ch === delim) {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (ch === '\r') {
                        if (peek() === '\n') {
                            next();
                        }
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else if (ch === '\n') {
                    // unescaped newlines are invalid; see:
                    // https://github.com/aseemk/json5/issues/24
                    // TODO this feels special-cased; are there other
                    // invalid unescaped chars?
                    break;
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },
        inlineComment = function () {

        // Skip an inline comment, assuming this is one. The current character should
        // be the second / character in the // pair that begins this inline comment.
        // To finish the inline comment, we look for a newline or the end of the text.

        if (ch !== '/') {
            error("Not an inline comment");
        }

        do {
            next();
            if (ch === '\n' || ch === '\r') {
                next();
                return;
            }
        } while (ch);
    },
        blockComment = function () {

        // Skip a block comment, assuming this is one. The current character should be
        // the * character in the /* pair that begins this block comment.
        // To finish the block comment, we look for an ending */ pair of characters,
        // but we also watch for the end of text before the comment is terminated.

        if (ch !== '*') {
            error("Not a block comment");
        }

        do {
            next();
            while (ch === '*') {
                next('*');
                if (ch === '/') {
                    next('/');
                    return;
                }
            }
        } while (ch);

        error("Unterminated block comment");
    },
        comment = function () {

        // Skip a comment, whether inline or block-level, assuming this is one.
        // Comments always begin with a / character.

        if (ch !== '/') {
            error("Not a comment");
        }

        next('/');

        if (ch === '/') {
            inlineComment();
        } else if (ch === '*') {
            blockComment();
        } else {
            error("Unrecognized comment");
        }
    },
        white = function () {

        // Skip whitespace and comments.
        // Note that we're detecting comments by only a single / character.
        // This works since regular expressions are not valid JSON(5), but this will
        // break if there are other valid values that begin with a / character!

        while (ch) {
            if (ch === '/') {
                comment();
            } else if (ws.indexOf(ch) >= 0) {
                next();
            } else {
                return;
            }
        }
    },
        word = function () {

        // true, false, or null.

        switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
                next('N');
                next('a');
                next('N');
                return NaN;
        }
        error("Unexpected '" + ch + "'");
    },
        value,
        // Place holder for the value function.

    array = function () {

        // Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            while (ch) {
                if (ch === ']') {
                    next(']');
                    return array; // Potentially empty array
                }
                // ES5 allows omitting elements in arrays, e.g. [,] and
                // [,null]. We don't allow this in JSON5.
                if (ch === ',') {
                    error("Missing array element");
                } else {
                    array.push(value());
                }
                white();
                // If there's no comma after this value, this needs to
                // be the end of the array.
                if (ch !== ',') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },
        object = function () {

        // Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            while (ch) {
                if (ch === '}') {
                    next('}');
                    return object; // Potentially empty object
                }

                // Keys can be unquoted. If they are, they need to be
                // valid JS identifiers.
                if (ch === '"' || ch === "'") {
                    key = string();
                } else {
                    key = identifier();
                }

                white();
                next(':');
                object[key] = value();
                white();
                // If there's no comma after this pair, this needs to be
                // the end of the object.
                if (ch !== ',') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

    value = function () {

        // Parse a JSON value. It could be an object, an array, a string, a number,
        // or a word.

        white();
        switch (ch) {
            case '{':
                return object();
            case '[':
                return array();
            case '"':
            case "'":
                return string();
            case '-':
            case '+':
            case '.':
                return number();
            default:
                return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

    // Return the json_parse function. It will have access to all of the above
    // functions and variables.

    return function (source, reviver) {
        var result;

        text = String(source);
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

        // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the result
        // in an empty key. If there is not a reviver function, we simply return the
        // result.

        return typeof reviver === 'function' ? function walk(holder, key) {
            var k,
                v,
                value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({ '': result }, '') : result;
    };
}();

// JSON5 stringify will not quote keys where appropriate
_json5libjson5js040_JSON5.stringify = function (obj, replacer, space) {
    if (replacer && typeof replacer !== "function" && !isArray(replacer)) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function (holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof replacer === "function") {
            return replacer.call(holder, key, value);
        } else if (replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(char) {
        return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char >= '0' && char <= '9' || char === '_' || char === '$';
    }

    function isWordStart(char) {
        return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1,
            length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    _json5libjson5js040_JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    isNaN = isNaN || function (val) {
        return typeof val === 'number' && val !== val;
    };

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\'
    };
    function escapeString(string) {

        // If the string contains no control characters, no quote characters, and no
        // backslash characters, then we can safely slap some quotes around it.
        // Otherwise we must also replace the offending characters with safe escape
        // sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch (typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length - 1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    buffer += makeIndent(indentStr, objStack.length, true) + "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                var key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = { "": obj };
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};
/*≠≠ node_modules/json5/lib/json5.js ≠≠*/

/*== node_modules/babel-core/lib/tr.../options/build-config-chain.js ==*/
$m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__assign = $m['babel-runtime/core-js/object/assign.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__assign2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__assign);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__classCallCheck3 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__classCallCheck2);

$m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'].exports.default = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_buildConfigChain;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__resolve = $m['babel-core/lib/helpers/resolve.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__resolve2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__resolve);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__json = $m['json5/lib/json5.js#0.4.0'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__json2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__json);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathIsAbsolute = $m['path-is-absolute/index.js#1.0.1'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathIsAbsolute2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathIsAbsolute);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathExists = $m['path-exists/index.js#1.0.0'].exports;

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathExists2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathExists);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path = require("path");

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path);

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__fs = require("fs");

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__fs2 = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsbuildconfigchainjs6160__fs);

function _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_existsCache = {};
var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_jsonCache = {};

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_BABELIGNORE_FILENAME = ".babelignore";
var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_BABELRC_FILENAME = ".babelrc";
var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_PACKAGE_FILENAME = "package.json";

function _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_exists(filename) {
  var cached = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_existsCache[filename];
  if (cached == null) {
    return _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_existsCache[filename] = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathExists2.default.sync(filename);
  } else {
    return cached;
  }
}

function _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_buildConfigChain() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var log = arguments[1];

  var filename = opts.filename;
  var builder = new _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_ConfigChainBuilder(log);

  if (opts.babelrc !== false) {
    builder.findConfigs(filename);
  }

  builder.mergeConfig({
    options: opts,
    alias: "base",
    dirname: filename && _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.dirname(filename)
  });

  return builder.configs;
}

var _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_ConfigChainBuilder = function () {
  function ConfigChainBuilder(log) {
    (0, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__classCallCheck3.default)(this, ConfigChainBuilder);

    this.resolvedConfigs = [];
    this.configs = [];
    this.log = log;
  }

  ConfigChainBuilder.prototype.findConfigs = function findConfigs(loc) {
    if (!loc) return;

    if (!(0, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__pathIsAbsolute2.default)(loc)) {
      loc = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.join(process.cwd(), loc);
    }

    var foundConfig = false;
    var foundIgnore = false;

    while (loc !== (loc = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.dirname(loc))) {
      if (!foundConfig) {
        var configLoc = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.join(loc, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_BABELRC_FILENAME);
        if (_babelcorelibtransformationfileoptionsbuildconfigchainjs6160_exists(configLoc)) {
          this.addConfig(configLoc);
          foundConfig = true;
        }

        var pkgLoc = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.join(loc, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_PACKAGE_FILENAME);
        if (!foundConfig && _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_exists(pkgLoc)) {
          foundConfig = this.addConfig(pkgLoc, "babel", JSON);
        }
      }

      if (!foundIgnore) {
        var ignoreLoc = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.join(loc, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_BABELIGNORE_FILENAME);
        if (_babelcorelibtransformationfileoptionsbuildconfigchainjs6160_exists(ignoreLoc)) {
          this.addIgnoreConfig(ignoreLoc);
          foundIgnore = true;
        }
      }

      if (foundIgnore && foundConfig) return;
    }
  };

  ConfigChainBuilder.prototype.addIgnoreConfig = function addIgnoreConfig(loc) {
    var file = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__fs2.default.readFileSync(loc, "utf8");
    var lines = file.split("\n");

    lines = lines.map(function (line) {
      return line.replace(/#(.*?)$/, "").trim();
    }).filter(function (line) {
      return !!line;
    });

    if (lines.length) {
      this.mergeConfig({
        options: { ignore: lines },
        alias: loc,
        dirname: _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.dirname(loc)
      });
    }
  };

  ConfigChainBuilder.prototype.addConfig = function addConfig(loc, key) {
    var json = arguments.length <= 2 || arguments[2] === undefined ? _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__json2.default : arguments[2];

    if (this.resolvedConfigs.indexOf(loc) >= 0) {
      return false;
    }

    this.resolvedConfigs.push(loc);

    var content = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__fs2.default.readFileSync(loc, "utf8");
    var options = void 0;

    try {
      options = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_jsonCache[content] = _babelcorelibtransformationfileoptionsbuildconfigchainjs6160_jsonCache[content] || json.parse(content);
      if (key) options = options[key];
    } catch (err) {
      err.message = loc + ": Error while parsing JSON - " + err.message;
      throw err;
    }

    this.mergeConfig({
      options: options,
      alias: loc,
      dirname: _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__path2.default.dirname(loc)
    });

    return !!options;
  };

  ConfigChainBuilder.prototype.mergeConfig = function mergeConfig(_ref) {
    var options = _ref.options;
    var alias = _ref.alias;
    var loc = _ref.loc;
    var dirname = _ref.dirname;

    if (!options) {
      return false;
    }

    options = (0, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__assign2.default)({}, options);

    dirname = dirname || process.cwd();
    loc = loc || alias;

    if (options.extends) {
      var extendsLoc = (0, _babelcorelibtransformationfileoptionsbuildconfigchainjs6160__resolve2.default)(options.extends, dirname);
      if (extendsLoc) {
        this.addConfig(extendsLoc);
      } else {
        if (this.log) this.log.error("Couldn't resolve extends clause of " + options.extends + " in " + alias);
      }
      delete options.extends;
    }

    this.configs.push({
      options: options,
      alias: alias,
      loc: loc,
      dirname: dirname
    });

    var envOpts = void 0;
    var envKey = process.env.BABEL_ENV || process.env.NODE_ENV || "development";
    if (options.env) {
      envOpts = options.env[envKey];
      delete options.env;
    }

    this.mergeConfig({
      options: envOpts,
      alias: alias + ".env." + envKey,
      dirname: dirname
    });
  };

  return ConfigChainBuilder;
}();

$m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'].exports = $m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/tr.../options/build-config-chain.js ≠≠*/

/*== node_modules/babel-core/lib/helpers/merge.js ==*/
$m['babel-core/lib/helpers/merge.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/helpers/merge.js#6.16.0'].exports.__esModule = true;

var _babelcorelibhelpersmergejs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibhelpersmergejs6160__getIterator3 = _babelcorelibhelpersmergejs6160__interopRequireDefault(_babelcorelibhelpersmergejs6160__getIterator2);

$m['babel-core/lib/helpers/merge.js#6.16.0'].exports.default = function (dest, src) {
  if (!dest || !src) return;

  return (0, _babelcorelibhelpersmergejs6160__mergeWith2.default)(dest, src, function (a, b) {
    if (b && Array.isArray(a)) {
      var newArray = b.slice(0);

      for (var _iterator = a, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibhelpersmergejs6160__getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var item = _ref;

        if (newArray.indexOf(item) < 0) {
          newArray.push(item);
        }
      }

      return newArray;
    }
  });
};

var _babelcorelibhelpersmergejs6160__mergeWith = $m['lodash/mergeWith.js#4.16.2'].exports;

var _babelcorelibhelpersmergejs6160__mergeWith2 = _babelcorelibhelpersmergejs6160__interopRequireDefault(_babelcorelibhelpersmergejs6160__mergeWith);

function _babelcorelibhelpersmergejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-core/lib/helpers/merge.js#6.16.0'].exports = $m['babel-core/lib/helpers/merge.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/helpers/merge.js ≠≠*/

/*== node_modules/lodash/cloneDeepWith.js ==*/
$m['lodash/cloneDeepWith.js#4.16.2'] = { exports: {} };
var _lodashcloneDeepWithjs4162_baseClone = $m['lodash/_baseClone.js#4.16.2'].exports;

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function _lodashcloneDeepWithjs4162_cloneDeepWith(value, customizer) {
  return _lodashcloneDeepWithjs4162_baseClone(value, true, true, customizer);
}

$m['lodash/cloneDeepWith.js#4.16.2'].exports = _lodashcloneDeepWithjs4162_cloneDeepWith;
/*≠≠ node_modules/lodash/cloneDeepWith.js ≠≠*/

/*== node_modules/babel-core/lib/tr...ormation/file/options/index.js ==*/
$m['babel-core/lib/transformation/file/options/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/index.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/transformation/file/options/index.js#6.16.0'].exports.config = undefined;
$m['babel-core/lib/transformation/file/options/index.js#6.16.0'].exports.normaliseOptions = _babelcorelibtransformationfileoptionsindexjs6160_normaliseOptions;

var _babelcorelibtransformationfileoptionsindexjs6160__parsers = $m['babel-core/lib/transformation/file/options/parsers.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsindexjs6160_parsers = _babelcorelibtransformationfileoptionsindexjs6160__interopRequireWildcard(_babelcorelibtransformationfileoptionsindexjs6160__parsers);

var _babelcorelibtransformationfileoptionsindexjs6160__config = $m['babel-core/lib/transformation/file/options/config.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsindexjs6160__config2 = _babelcorelibtransformationfileoptionsindexjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsindexjs6160__config);

function _babelcorelibtransformationfileoptionsindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelcorelibtransformationfileoptionsindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

$m['babel-core/lib/transformation/file/options/index.js#6.16.0'].exports.config = _babelcorelibtransformationfileoptionsindexjs6160__config2.default;
function _babelcorelibtransformationfileoptionsindexjs6160_normaliseOptions() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  for (var key in options) {
    var val = options[key];
    if (val == null) continue;

    var opt = _babelcorelibtransformationfileoptionsindexjs6160__config2.default[key];
    if (opt && opt.alias) opt = _babelcorelibtransformationfileoptionsindexjs6160__config2.default[opt.alias];
    if (!opt) continue;

    var parser = _babelcorelibtransformationfileoptionsindexjs6160_parsers[opt.type];
    if (parser) val = parser(val);

    options[key] = val;
  }

  return options;
}
/*≠≠ node_modules/babel-core/lib/tr...ormation/file/options/index.js ≠≠*/

/*== node_modules/globals/index.js ==*/
$m['globals/index.js#8.18.0'] = { exports: {} };
$m['globals/index.js#8.18.0'].exports = {
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es5": {
		"Array": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"propertyIsEnumerable": false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false
	},
	"es6": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"AnalyserNode": false,
		"AnimationEvent": false,
		"applicationCache": false,
		"ApplicationCache": false,
		"ApplicationCacheErrorEvent": false,
		"atob": false,
		"Attr": false,
		"Audio": false,
		"AudioBuffer": false,
		"AudioBufferSourceNode": false,
		"AudioContext": false,
		"AudioDestinationNode": false,
		"AudioListener": false,
		"AudioNode": false,
		"AudioParam": false,
		"AudioProcessingEvent": false,
		"AutocompleteErrorEvent": false,
		"BarProp": false,
		"BatteryManager": false,
		"BeforeUnloadEvent": false,
		"BiquadFilterNode": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"CDATASection": false,
		"ChannelMergerNode": false,
		"ChannelSplitterNode": false,
		"CharacterData": false,
		"clearInterval": false,
		"clearTimeout": false,
		"clientInformation": false,
		"ClientRect": false,
		"ClientRectList": false,
		"ClipboardEvent": false,
		"close": false,
		"closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"ConvolverNode": false,
		"crypto": false,
		"Crypto": false,
		"CryptoKey": false,
		"CSS": false,
		"CSSFontFaceRule": false,
		"CSSImportRule": false,
		"CSSKeyframeRule": false,
		"CSSKeyframesRule": false,
		"CSSMediaRule": false,
		"CSSPageRule": false,
		"CSSRule": false,
		"CSSRuleList": false,
		"CSSStyleDeclaration": false,
		"CSSStyleRule": false,
		"CSSStyleSheet": false,
		"CSSSupportsRule": false,
		"CSSUnknownRule": false,
		"CSSViewportRule": false,
		"CustomEvent": false,
		"DataTransfer": false,
		"DataTransferItem": false,
		"DataTransferItemList": false,
		"Debug": false,
		"defaultStatus": false,
		"defaultstatus": false,
		"DelayNode": false,
		"DeviceMotionEvent": false,
		"DeviceOrientationEvent": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DocumentType": false,
		"DOMError": false,
		"DOMException": false,
		"DOMImplementation": false,
		"DOMParser": false,
		"DOMSettableTokenList": false,
		"DOMStringList": false,
		"DOMStringMap": false,
		"DOMTokenList": false,
		"DragEvent": false,
		"DynamicsCompressorNode": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"EventSource": false,
		"EventTarget": false,
		"external": false,
		"fetch": false,
		"File": false,
		"FileError": false,
		"FileList": false,
		"FileReader": false,
		"find": false,
		"focus": false,
		"FocusEvent": false,
		"FontFace": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GainNode": false,
		"Gamepad": false,
		"GamepadButton": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"Headers": false,
		"history": false,
		"History": false,
		"HTMLAllCollection": false,
		"HTMLAnchorElement": false,
		"HTMLAppletElement": false,
		"HTMLAreaElement": false,
		"HTMLAudioElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLCollection": false,
		"HTMLContentElement": false,
		"HTMLDataListElement": false,
		"HTMLDetailsElement": false,
		"HTMLDialogElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLDocument": false,
		"HTMLElement": false,
		"HTMLEmbedElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormControlsCollection": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLKeygenElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMarqueeElement": false,
		"HTMLMediaElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLMeterElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLOptionsCollection": false,
		"HTMLOutputElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPictureElement": false,
		"HTMLPreElement": false,
		"HTMLProgressElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLShadowElement": false,
		"HTMLSourceElement": false,
		"HTMLSpanElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTemplateElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLTrackElement": false,
		"HTMLUListElement": false,
		"HTMLUnknownElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"ImageBitmap": false,
		"ImageData": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"InputMethodContext": false,
		"Intl": false,
		"KeyboardEvent": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"Location": false,
		"locationbar": false,
		"matchMedia": false,
		"MediaElementAudioSourceNode": false,
		"MediaEncryptedEvent": false,
		"MediaError": false,
		"MediaKeyError": false,
		"MediaKeyEvent": false,
		"MediaKeyMessageEvent": false,
		"MediaKeys": false,
		"MediaKeySession": false,
		"MediaKeyStatusMap": false,
		"MediaKeySystemAccess": false,
		"MediaList": false,
		"MediaQueryList": false,
		"MediaQueryListEvent": false,
		"MediaSource": false,
		"MediaStreamAudioDestinationNode": false,
		"MediaStreamAudioSourceNode": false,
		"MediaStreamEvent": false,
		"MediaStreamTrack": false,
		"menubar": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MIDIAccess": false,
		"MIDIConnectionEvent": false,
		"MIDIInput": false,
		"MIDIInputMap": false,
		"MIDIMessageEvent": false,
		"MIDIOutput": false,
		"MIDIOutputMap": false,
		"MIDIPort": false,
		"MimeType": false,
		"MimeTypeArray": false,
		"MouseEvent": false,
		"moveBy": false,
		"moveTo": false,
		"MutationEvent": false,
		"MutationObserver": false,
		"MutationRecord": false,
		"name": false,
		"NamedNodeMap": false,
		"navigator": false,
		"Navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeIterator": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"OfflineAudioContext": false,
		"offscreenBuffering": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		"open": false,
		"openDatabase": false,
		"opener": false,
		"opera": false,
		"Option": false,
		"OscillatorNode": false,
		"outerHeight": false,
		"outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"parent": false,
		"Path2D": false,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"PeriodicWave": false,
		"Permissions": false,
		"PermissionStatus": false,
		"personalbar": false,
		"Plugin": false,
		"PluginArray": false,
		"PopStateEvent": false,
		"postMessage": false,
		"print": false,
		"ProcessingInstruction": false,
		"ProgressEvent": false,
		"prompt": false,
		"PushManager": false,
		"PushSubscription": false,
		"RadioNodeList": false,
		"Range": false,
		"ReadableByteStream": false,
		"ReadableStream": false,
		"removeEventListener": false,
		"Request": false,
		"requestAnimationFrame": false,
		"resizeBy": false,
		"resizeTo": false,
		"Response": false,
		"RTCIceCandidate": false,
		"RTCSessionDescription": false,
		"screen": false,
		"Screen": false,
		"screenLeft": false,
		"ScreenOrientation": false,
		"screenTop": false,
		"screenX": false,
		"screenY": false,
		"ScriptProcessorNode": false,
		"scroll": false,
		"scrollbars": false,
		"scrollBy": false,
		"scrollTo": false,
		"scrollX": false,
		"scrollY": false,
		"SecurityPolicyViolationEvent": false,
		"Selection": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerRegistration": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"ShadowRoot": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"speechSynthesis": false,
		"SpeechSynthesisEvent": false,
		"SpeechSynthesisUtterance": false,
		"status": false,
		"statusbar": false,
		"stop": false,
		"Storage": false,
		"StorageEvent": false,
		"styleMedia": false,
		"StyleSheet": false,
		"StyleSheetList": false,
		"SubtleCrypto": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDiscardElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEDropShadowElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGeometryElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGGraphicsElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"SVGZoomEvent": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TextEvent": false,
		"TextMetrics": false,
		"TextTrack": false,
		"TextTrackCue": false,
		"TextTrackCueList": false,
		"TextTrackList": false,
		"TimeEvent": false,
		"TimeRanges": false,
		"toolbar": false,
		"top": false,
		"Touch": false,
		"TouchEvent": false,
		"TouchList": false,
		"TrackEvent": false,
		"TransitionEvent": false,
		"TreeWalker": false,
		"UIEvent": false,
		"URL": false,
		"ValidityState": false,
		"VTTCue": false,
		"WaveShaperNode": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLDocument": false,
		"XMLHttpRequest": false,
		"XMLHttpRequestEventTarget": false,
		"XMLHttpRequestProgressEvent": false,
		"XMLHttpRequestUpload": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false,
		"XSLTProcessor": false
	},
	"worker": {
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": true,
		"console": false,
		"fetch": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": true,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onoffline": true,
		"ononline": true,
		"onrejectionhandled": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"Request": false,
		"Response": false,
		"self": true,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"WebSocket": false,
		"Worker": false,
		"XMLHttpRequest": false
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"module": false,
		"process": false,
		"require": false,
		"root": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"commonjs": {
		"exports": true,
		"module": false,
		"require": false,
		"global": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"mocha": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"jest": {
		"afterEach": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"it": false,
		"jest": false,
		"pit": false,
		"require": false,
		"xdescribe": false,
		"xit": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notOk": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"nashorn": {
		"__DIR__": false,
		"__FILE__": false,
		"__LINE__": false,
		"com": false,
		"edu": false,
		"exit": false,
		"Java": false,
		"java": false,
		"javafx": false,
		"JavaImporter": false,
		"javax": false,
		"JSAdapter": false,
		"load": false,
		"loadWithNewGlobal": false,
		"org": false,
		"Packages": false,
		"print": false,
		"quit": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"ln": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"ObjectId": false,
		"PlanCache": false,
		"print": false,
		"printjson": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	},
	"applescript": {
		"$": false,
		"Application": false,
		"Automation": false,
		"console": false,
		"delay": false,
		"Library": false,
		"ObjC": false,
		"ObjectSpecifier": false,
		"Path": false,
		"Progress": false,
		"Ref": false
	},
	"serviceworker": {
		"caches": false,
		"Cache": false,
		"CacheStorage": false,
		"Client": false,
		"clients": false,
		"Clients": false,
		"ExtendableEvent": false,
		"ExtendableMessageEvent": false,
		"FetchEvent": false,
		"importScripts": false,
		"registration": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerGlobalScope": false,
		"ServiceWorkerMessageEvent": false,
		"ServiceWorkerRegistration": false,
		"skipWaiting": false,
		"WindowClient": false
	},
	"atomtest": {
		"advanceClock": false,
		"fakeClearInterval": false,
		"fakeClearTimeout": false,
		"fakeSetInterval": false,
		"fakeSetTimeout": false,
		"resetTimeouts": false,
		"waitsForPromise": false
	},
	"embertest": {
		"andThen": false,
		"click": false,
		"currentPath": false,
		"currentRouteName": false,
		"currentURL": false,
		"fillIn": false,
		"find": false,
		"findWithAssert": false,
		"keyEvent": false,
		"pauseTest": false,
		"triggerEvent": false,
		"visit": false
	},
	"protractor": {
		"$": false,
		"$": false,
		"browser": false,
		"By": false,
		"by": false,
		"DartObject": false,
		"element": false,
		"protractor": false
	},
	"shared-node-browser": {
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"setInterval": false,
		"setTimeout": false
	},
	"webextensions": {
		"browser": false,
		"chrome": false,
		"opr": false
	},
	"greasemonkey": {
		"GM_addStyle": false,
		"GM_deleteValue": false,
		"GM_getResourceText": false,
		"GM_getResourceURL": false,
		"GM_getValue": false,
		"GM_info": false,
		"GM_listValues": false,
		"GM_log": false,
		"GM_openInTab": false,
		"GM_registerMenuCommand": false,
		"GM_setClipboard": false,
		"GM_setValue": false,
		"GM_xmlhttpRequest": false,
		"unsafeWindow": false
	}
};
/*≠≠ node_modules/globals/index.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/family.js ==*/
$m['babel-traverse/lib/path/family.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/family.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathfamilyjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathfamilyjs6160__getIterator3 = _babeltraverselibpathfamilyjs6160__interopRequireDefault(_babeltraverselibpathfamilyjs6160__getIterator2);

$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getStatementParent = _babeltraverselibpathfamilyjs6160_getStatementParent;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getOpposite = _babeltraverselibpathfamilyjs6160_getOpposite;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getCompletionRecords = _babeltraverselibpathfamilyjs6160_getCompletionRecords;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getSibling = _babeltraverselibpathfamilyjs6160_getSibling;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.get = _babeltraverselibpathfamilyjs6160_get;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports._getKey = _babeltraverselibpathfamilyjs6160__getKey;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports._getPattern = _babeltraverselibpathfamilyjs6160__getPattern;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getBindingIdentifiers = _babeltraverselibpathfamilyjs6160_getBindingIdentifiers;
$m['babel-traverse/lib/path/family.js#6.16.0'].exports.getOuterBindingIdentifiers = _babeltraverselibpathfamilyjs6160_getOuterBindingIdentifiers;

var _babeltraverselibpathfamilyjs6160__index = require("babel-traverse/lib/path/index.js#6.16.0");

var _babeltraverselibpathfamilyjs6160__index2 = _babeltraverselibpathfamilyjs6160__interopRequireDefault(_babeltraverselibpathfamilyjs6160__index);

var _babeltraverselibpathfamilyjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathfamilyjs6160_t = _babeltraverselibpathfamilyjs6160__interopRequireWildcard(_babeltraverselibpathfamilyjs6160__babelTypes);

function _babeltraverselibpathfamilyjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathfamilyjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathfamilyjs6160_getStatementParent() {
  var path = this;

  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  }

  return path;
}

function _babeltraverselibpathfamilyjs6160_getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}

function _babeltraverselibpathfamilyjs6160_getCompletionRecords() {
  var paths = [];

  var add = function add(path) {
    if (path) paths = paths.concat(path.getCompletionRecords());
  };

  if (this.isIfStatement()) {
    add(this.get("consequent"));
    add(this.get("alternate"));
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    add(this.get("body"));
  } else if (this.isProgram() || this.isBlockStatement()) {
    add(this.get("body").pop());
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    add(this.get("block"));
    add(this.get("handler"));
    add(this.get("finalizer"));
  } else {
    paths.push(this);
  }

  return paths;
}

function _babeltraverselibpathfamilyjs6160_getSibling(key) {
  return _babeltraverselibpathfamilyjs6160__index2.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  });
}

function _babeltraverselibpathfamilyjs6160_get(key, context) {
  if (context === true) context = this.context;
  var parts = key.split(".");
  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _babeltraverselibpathfamilyjs6160__getKey(key, context) {
  var _this = this;

  var node = this.node;
  var container = node[key];

  if (Array.isArray(container)) {
    return container.map(function (_, i) {
      return _babeltraverselibpathfamilyjs6160__index2.default.get({
        listKey: key,
        parentPath: _this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _babeltraverselibpathfamilyjs6160__index2.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _babeltraverselibpathfamilyjs6160__getPattern(parts, context) {
  var path = this;
  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathfamilyjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var part = _ref;

    if (part === ".") {
      path = path.parentPath;
    } else {
      if (Array.isArray(path)) {
        path = path[part];
      } else {
        path = path.get(part, context);
      }
    }
  }
  return path;
}

function _babeltraverselibpathfamilyjs6160_getBindingIdentifiers(duplicates) {
  return _babeltraverselibpathfamilyjs6160_t.getBindingIdentifiers(this.node, duplicates);
}

function _babeltraverselibpathfamilyjs6160_getOuterBindingIdentifiers(duplicates) {
  return _babeltraverselibpathfamilyjs6160_t.getOuterBindingIdentifiers(this.node, duplicates);
}
/*≠≠ node_modules/babel-traverse/lib/path/family.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/modification.js ==*/
$m['babel-traverse/lib/path/modification.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathmodificationjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babeltraverselibpathmodificationjs6160__typeof3 = _babeltraverselibpathmodificationjs6160__interopRequireDefault(_babeltraverselibpathmodificationjs6160__typeof2);

var _babeltraverselibpathmodificationjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathmodificationjs6160__getIterator3 = _babeltraverselibpathmodificationjs6160__interopRequireDefault(_babeltraverselibpathmodificationjs6160__getIterator2);

$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.insertBefore = _babeltraverselibpathmodificationjs6160_insertBefore;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports._containerInsert = _babeltraverselibpathmodificationjs6160__containerInsert;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports._containerInsertBefore = _babeltraverselibpathmodificationjs6160__containerInsertBefore;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports._containerInsertAfter = _babeltraverselibpathmodificationjs6160__containerInsertAfter;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports._maybePopFromStatements = _babeltraverselibpathmodificationjs6160__maybePopFromStatements;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.insertAfter = _babeltraverselibpathmodificationjs6160_insertAfter;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.updateSiblingKeys = _babeltraverselibpathmodificationjs6160_updateSiblingKeys;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports._verifyNodeList = _babeltraverselibpathmodificationjs6160__verifyNodeList;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.unshiftContainer = _babeltraverselibpathmodificationjs6160_unshiftContainer;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.pushContainer = _babeltraverselibpathmodificationjs6160_pushContainer;
$m['babel-traverse/lib/path/modification.js#6.16.0'].exports.hoist = _babeltraverselibpathmodificationjs6160_hoist;

var _babeltraverselibpathmodificationjs6160__cache = $m['babel-traverse/lib/cache.js#6.16.0'].exports;

var _babeltraverselibpathmodificationjs6160__hoister = $m['babel-traverse/lib/path/lib/hoister.js#6.16.0'].exports;

var _babeltraverselibpathmodificationjs6160__hoister2 = _babeltraverselibpathmodificationjs6160__interopRequireDefault(_babeltraverselibpathmodificationjs6160__hoister);

var _babeltraverselibpathmodificationjs6160__index = require("babel-traverse/lib/path/index.js#6.16.0");

var _babeltraverselibpathmodificationjs6160__index2 = _babeltraverselibpathmodificationjs6160__interopRequireDefault(_babeltraverselibpathmodificationjs6160__index);

var _babeltraverselibpathmodificationjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathmodificationjs6160_t = _babeltraverselibpathmodificationjs6160__interopRequireWildcard(_babeltraverselibpathmodificationjs6160__babelTypes);

function _babeltraverselibpathmodificationjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathmodificationjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathmodificationjs6160_insertBefore(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertBefore(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) nodes.push(this.node);
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.push(this.node);
      this._replaceWith(_babeltraverselibpathmodificationjs6160_t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function _babeltraverselibpathmodificationjs6160__containerInsert(from, nodes) {
  this.updateSiblingKeys(from, nodes.length);

  var paths = [];

  for (var i = 0; i < nodes.length; i++) {
    var to = from + i;
    var node = nodes[i];
    this.container.splice(to, 0, node);

    if (this.context) {
      var path = this.context.create(this.parent, this.container, to, this.listKey);

      if (this.context.queue) path.pushContext(this.context);
      paths.push(path);
    } else {
      paths.push(_babeltraverselibpathmodificationjs6160__index2.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: to
      }));
    }
  }

  var contexts = this._getQueueContexts();

  for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathmodificationjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _path = _ref;

    _path.setScope();
    _path.debug(function () {
      return "Inserted.";
    });

    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathmodificationjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var context = _ref2;

      context.maybeQueue(_path, true);
    }
  }

  return paths;
}

function _babeltraverselibpathmodificationjs6160__containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}

function _babeltraverselibpathmodificationjs6160__containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}

function _babeltraverselibpathmodificationjs6160__maybePopFromStatements(nodes) {
  var last = nodes[nodes.length - 1];
  var isIdentifier = _babeltraverselibpathmodificationjs6160_t.isIdentifier(last) || _babeltraverselibpathmodificationjs6160_t.isExpressionStatement(last) && _babeltraverselibpathmodificationjs6160_t.isIdentifier(last.expression);

  if (isIdentifier && !this.isCompletionRecord()) {
    nodes.pop();
  }
}

function _babeltraverselibpathmodificationjs6160_insertAfter(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertAfter(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) {
      var temp = this.scope.generateDeclaredUidIdentifier();
      nodes.unshift(_babeltraverselibpathmodificationjs6160_t.expressionStatement(_babeltraverselibpathmodificationjs6160_t.assignmentExpression("=", temp, this.node)));
      nodes.push(_babeltraverselibpathmodificationjs6160_t.expressionStatement(temp));
    }
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.unshift(this.node);
      this._replaceWith(_babeltraverselibpathmodificationjs6160_t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function _babeltraverselibpathmodificationjs6160_updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;

  var paths = _babeltraverselibpathmodificationjs6160__cache.path.get(this.parent);
  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}

function _babeltraverselibpathmodificationjs6160__verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }

  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var msg = void 0;

    if (!node) {
      msg = "has falsy node";
    } else if ((typeof node === "undefined" ? "undefined" : (0, _babeltraverselibpathmodificationjs6160__typeof3.default)(node)) !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof _babeltraverselibpathmodificationjs6160__index2.default) {
      msg = "has a NodePath when it expected a raw object";
    }

    if (msg) {
      var type = Array.isArray(node) ? "array" : typeof node === "undefined" ? "undefined" : (0, _babeltraverselibpathmodificationjs6160__typeof3.default)(node);
      throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
    }
  }

  return nodes;
}

function _babeltraverselibpathmodificationjs6160_unshiftContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var path = _babeltraverselibpathmodificationjs6160__index2.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey: listKey,
    key: 0
  });

  return path.insertBefore(nodes);
}

function _babeltraverselibpathmodificationjs6160_pushContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var container = this.node[listKey];
  var path = _babeltraverselibpathmodificationjs6160__index2.default.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey: listKey,
    key: container.length
  });

  return path.replaceWithMultiple(nodes);
}

function _babeltraverselibpathmodificationjs6160_hoist() {
  var scope = arguments.length <= 0 || arguments[0] === undefined ? this.scope : arguments[0];

  var hoister = new _babeltraverselibpathmodificationjs6160__hoister2.default(this, scope);
  return hoister.run();
}
/*≠≠ node_modules/babel-traverse/lib/path/modification.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/lib/removal-hooks.js ==*/
$m['babel-traverse/lib/path/lib/removal-hooks.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/lib/removal-hooks.js#6.16.0'].exports.__esModule = true;
var _babeltraverselibpathlibremovalhooksjs6160_hooks = $m['babel-traverse/lib/path/lib/removal-hooks.js#6.16.0'].exports.hooks = [function (self, parent) {
  if (self.key === "body" && parent.isArrowFunctionExpression()) {
    self.replaceWith(self.scope.buildUndefinedNode());
    return true;
  }
}, function (self, parent) {
  var removeParent = false;

  removeParent = removeParent || self.key === "test" && (parent.isWhile() || parent.isSwitchCase());

  removeParent = removeParent || self.key === "declaration" && parent.isExportDeclaration();

  removeParent = removeParent || self.key === "body" && parent.isLabeledStatement();

  removeParent = removeParent || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1;

  removeParent = removeParent || self.key === "expression" && parent.isExpressionStatement();

  if (removeParent) {
    parent.remove();
    return true;
  }
}, function (self, parent) {
  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
    parent.replaceWith(parent.node.expressions[0]);
    return true;
  }
}, function (self, parent) {
  if (parent.isBinary()) {
    if (self.key === "left") {
      parent.replaceWith(parent.node.right);
    } else {
      parent.replaceWith(parent.node.left);
    }
    return true;
  }
}, function (self, parent) {
  if (parent.isIfStatement() && (self.key === 'consequent' || self.key === 'alternate') || parent.isLoop() && self.key === 'body') {
    self.replaceWith({
      type: 'BlockStatement',
      body: []
    });
    return true;
  }
}];
/*≠≠ node_modules/babel-traverse/lib/path/lib/removal-hooks.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/removal.js ==*/
$m['babel-traverse/lib/path/removal.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/removal.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathremovaljs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathremovaljs6160__getIterator3 = _babeltraverselibpathremovaljs6160__interopRequireDefault(_babeltraverselibpathremovaljs6160__getIterator2);

$m['babel-traverse/lib/path/removal.js#6.16.0'].exports.remove = _babeltraverselibpathremovaljs6160_remove;
$m['babel-traverse/lib/path/removal.js#6.16.0'].exports._callRemovalHooks = _babeltraverselibpathremovaljs6160__callRemovalHooks;
$m['babel-traverse/lib/path/removal.js#6.16.0'].exports._remove = _babeltraverselibpathremovaljs6160__remove;
$m['babel-traverse/lib/path/removal.js#6.16.0'].exports._markRemoved = _babeltraverselibpathremovaljs6160__markRemoved;
$m['babel-traverse/lib/path/removal.js#6.16.0'].exports._assertUnremoved = _babeltraverselibpathremovaljs6160__assertUnremoved;

var _babeltraverselibpathremovaljs6160__removalHooks = $m['babel-traverse/lib/path/lib/removal-hooks.js#6.16.0'].exports;

function _babeltraverselibpathremovaljs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathremovaljs6160_remove() {
  this._assertUnremoved();

  this.resync();

  if (this._callRemovalHooks()) {
    this._markRemoved();
    return;
  }

  this.shareCommentsWithSiblings();
  this._remove();
  this._markRemoved();
}

function _babeltraverselibpathremovaljs6160__callRemovalHooks() {
  for (var _iterator = _babeltraverselibpathremovaljs6160__removalHooks.hooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathremovaljs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (fn(this, this.parentPath)) return true;
  }
}

function _babeltraverselibpathremovaljs6160__remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}

function _babeltraverselibpathremovaljs6160__markRemoved() {
  this.shouldSkip = true;
  this.removed = true;
  this.node = null;
}

function _babeltraverselibpathremovaljs6160__assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
}
/*≠≠ node_modules/babel-traverse/lib/path/removal.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/introspection.js ==*/
$m['babel-traverse/lib/path/introspection.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.is = undefined;

var _babeltraverselibpathintrospectionjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babeltraverselibpathintrospectionjs6160__typeof3 = _babeltraverselibpathintrospectionjs6160__interopRequireDefault(_babeltraverselibpathintrospectionjs6160__typeof2);

var _babeltraverselibpathintrospectionjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathintrospectionjs6160__getIterator3 = _babeltraverselibpathintrospectionjs6160__interopRequireDefault(_babeltraverselibpathintrospectionjs6160__getIterator2);

$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.matchesPattern = _babeltraverselibpathintrospectionjs6160_matchesPattern;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.has = _babeltraverselibpathintrospectionjs6160_has;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.isStatic = _babeltraverselibpathintrospectionjs6160_isStatic;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.isnt = _babeltraverselibpathintrospectionjs6160_isnt;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.equals = _babeltraverselibpathintrospectionjs6160_equals;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.isNodeType = _babeltraverselibpathintrospectionjs6160_isNodeType;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.canHaveVariableDeclarationOrExpression = _babeltraverselibpathintrospectionjs6160_canHaveVariableDeclarationOrExpression;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.canSwapBetweenExpressionAndStatement = _babeltraverselibpathintrospectionjs6160_canSwapBetweenExpressionAndStatement;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.isCompletionRecord = _babeltraverselibpathintrospectionjs6160_isCompletionRecord;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.isStatementOrBlock = _babeltraverselibpathintrospectionjs6160_isStatementOrBlock;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.referencesImport = _babeltraverselibpathintrospectionjs6160_referencesImport;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.getSource = _babeltraverselibpathintrospectionjs6160_getSource;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.willIMaybeExecuteBefore = _babeltraverselibpathintrospectionjs6160_willIMaybeExecuteBefore;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports._guessExecutionStatusRelativeTo = _babeltraverselibpathintrospectionjs6160__guessExecutionStatusRelativeTo;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports._guessExecutionStatusRelativeToDifferentFunctions = _babeltraverselibpathintrospectionjs6160__guessExecutionStatusRelativeToDifferentFunctions;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.resolve = _babeltraverselibpathintrospectionjs6160_resolve;
$m['babel-traverse/lib/path/introspection.js#6.16.0'].exports._resolve = _babeltraverselibpathintrospectionjs6160__resolve;

var _babeltraverselibpathintrospectionjs6160__includes = $m['lodash/includes.js#4.16.2'].exports;

var _babeltraverselibpathintrospectionjs6160__includes2 = _babeltraverselibpathintrospectionjs6160__interopRequireDefault(_babeltraverselibpathintrospectionjs6160__includes);

var _babeltraverselibpathintrospectionjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathintrospectionjs6160_t = _babeltraverselibpathintrospectionjs6160__interopRequireWildcard(_babeltraverselibpathintrospectionjs6160__babelTypes);

function _babeltraverselibpathintrospectionjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathintrospectionjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathintrospectionjs6160_matchesPattern(pattern, allowPartial) {
  if (!this.isMemberExpression()) return false;

  var parts = pattern.split(".");
  var search = [this.node];
  var i = 0;

  function matches(name) {
    var part = parts[i];
    return part === "*" || name === part;
  }

  while (search.length) {
    var node = search.shift();

    if (allowPartial && i === parts.length) {
      return true;
    }

    if (_babeltraverselibpathintrospectionjs6160_t.isIdentifier(node)) {
      if (!matches(node.name)) return false;
    } else if (_babeltraverselibpathintrospectionjs6160_t.isLiteral(node)) {
      if (!matches(node.value)) return false;
    } else if (_babeltraverselibpathintrospectionjs6160_t.isMemberExpression(node)) {
      if (node.computed && !_babeltraverselibpathintrospectionjs6160_t.isLiteral(node.property)) {
        return false;
      } else {
        search.unshift(node.property);
        search.unshift(node.object);
        continue;
      }
    } else if (_babeltraverselibpathintrospectionjs6160_t.isThisExpression(node)) {
      if (!matches("this")) return false;
    } else {
      return false;
    }

    if (++i > parts.length) {
      return false;
    }
  }

  return i === parts.length;
}

function _babeltraverselibpathintrospectionjs6160_has(key) {
  var val = this.node && this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

function _babeltraverselibpathintrospectionjs6160_isStatic() {
  return this.scope.isStatic(this.node);
}

var _babeltraverselibpathintrospectionjs6160_is = $m['babel-traverse/lib/path/introspection.js#6.16.0'].exports.is = _babeltraverselibpathintrospectionjs6160_has;

function _babeltraverselibpathintrospectionjs6160_isnt(key) {
  return !this.has(key);
}

function _babeltraverselibpathintrospectionjs6160_equals(key, value) {
  return this.node[key] === value;
}

function _babeltraverselibpathintrospectionjs6160_isNodeType(type) {
  return _babeltraverselibpathintrospectionjs6160_t.isType(this.type, type);
}

function _babeltraverselibpathintrospectionjs6160_canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function _babeltraverselibpathintrospectionjs6160_canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }

  if (this.isExpression()) {
    return _babeltraverselibpathintrospectionjs6160_t.isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return _babeltraverselibpathintrospectionjs6160_t.isExpression(replacement);
  }

  return false;
}

function _babeltraverselibpathintrospectionjs6160_isCompletionRecord(allowInsideFunction) {
  var path = this;
  var first = true;

  do {
    var container = path.container;

    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function _babeltraverselibpathintrospectionjs6160_isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || _babeltraverselibpathintrospectionjs6160_t.isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _babeltraverselibpathintrospectionjs6160__includes2.default)(_babeltraverselibpathintrospectionjs6160_t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function _babeltraverselibpathintrospectionjs6160_referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;

  var binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;

  var path = binding.path;
  var parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;

  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }

  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }

  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }

  return false;
}

function _babeltraverselibpathintrospectionjs6160_getSource() {
  var node = this.node;
  if (node.end) {
    return this.hub.file.code.slice(node.start, node.end);
  } else {
    return "";
  }
}

function _babeltraverselibpathintrospectionjs6160_willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function _babeltraverselibpathintrospectionjs6160__guessExecutionStatusRelativeTo(target) {
  var targetFuncParent = target.scope.getFunctionParent();
  var selfFuncParent = this.scope.getFunctionParent();

  if (targetFuncParent.node !== selfFuncParent.node) {
    var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);
    if (status) {
      return status;
    } else {
      target = targetFuncParent.path;
    }
  }

  var targetPaths = target.getAncestry();
  if (targetPaths.indexOf(this) >= 0) return "after";

  var selfPaths = this.getAncestry();

  var commonPath = void 0;
  var targetIndex = void 0;
  var selfIndex = void 0;
  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
    var selfPath = selfPaths[selfIndex];
    targetIndex = targetPaths.indexOf(selfPath);
    if (targetIndex >= 0) {
      commonPath = selfPath;
      break;
    }
  }
  if (!commonPath) {
    return "before";
  }

  var targetRelationship = targetPaths[targetIndex - 1];
  var selfRelationship = selfPaths[selfIndex - 1];
  if (!targetRelationship || !selfRelationship) {
    return "before";
  }

  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
    return targetRelationship.key > selfRelationship.key ? "before" : "after";
  }

  var targetKeyPosition = _babeltraverselibpathintrospectionjs6160_t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
  var selfKeyPosition = _babeltraverselibpathintrospectionjs6160_t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
  return targetKeyPosition > selfKeyPosition ? "before" : "after";
}

function _babeltraverselibpathintrospectionjs6160__guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
  var targetFuncPath = targetFuncParent.path;
  if (!targetFuncPath.isFunctionDeclaration()) return;

  var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);

  if (!binding.references) return "before";

  var referencePaths = binding.referencePaths;

  for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathintrospectionjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var path = _ref;

    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
      return;
    }
  }

  var allStatus = void 0;

  for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathintrospectionjs6160__getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _path = _ref2;

    var childOfFunction = !!_path.find(function (path) {
      return path.node === targetFuncPath.node;
    });
    if (childOfFunction) continue;

    var status = this._guessExecutionStatusRelativeTo(_path);

    if (allStatus) {
      if (allStatus !== status) return;
    } else {
      allStatus = status;
    }
  }

  return allStatus;
}

function _babeltraverselibpathintrospectionjs6160_resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}

function _babeltraverselibpathintrospectionjs6160__resolve(dangerous, resolved) {
  var _this = this;

  if (resolved && resolved.indexOf(this) >= 0) return;

  resolved = resolved || [];
  resolved.push(this);

  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {}
  } else if (this.isReferencedIdentifier()) {
    var binding = this.scope.getBinding(this.node.name);
    if (!binding) return;

    if (!binding.constant) return;

    if (binding.kind === "module") return;

    if (binding.path !== this) {
      var _ret = function () {
        var ret = binding.path.resolve(dangerous, resolved);

        if (_this.find(function (parent) {
          return parent.node === ret.node;
        })) return {
          v: void 0
        };
        return {
          v: ret
        };
      }();

      if ((typeof _ret === "undefined" ? "undefined" : (0, _babeltraverselibpathintrospectionjs6160__typeof3.default)(_ret)) === "object") return _ret.v;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {

    var targetKey = this.toComputedKey();
    if (!_babeltraverselibpathintrospectionjs6160_t.isLiteral(targetKey)) return;

    var targetName = targetKey.value;

    var target = this.get("object").resolve(dangerous, resolved);

    if (target.isObjectExpression()) {
      var props = target.get("properties");
      for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltraverselibpathintrospectionjs6160__getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var prop = _ref3;

        if (!prop.isProperty()) continue;

        var key = prop.get("key");

        var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });

        match = match || key.isLiteral({ value: targetName });

        if (match) return prop.get("value").resolve(dangerous, resolved);
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      var elems = target.get("elements");
      var elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}
/*≠≠ node_modules/babel-traverse/lib/path/introspection.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/conversion.js ==*/
$m['babel-traverse/lib/path/conversion.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/conversion.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/path/conversion.js#6.16.0'].exports.toComputedKey = _babeltraverselibpathconversionjs6160_toComputedKey;
$m['babel-traverse/lib/path/conversion.js#6.16.0'].exports.ensureBlock = _babeltraverselibpathconversionjs6160_ensureBlock;
$m['babel-traverse/lib/path/conversion.js#6.16.0'].exports.arrowFunctionToShadowed = _babeltraverselibpathconversionjs6160_arrowFunctionToShadowed;

var _babeltraverselibpathconversionjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathconversionjs6160_t = _babeltraverselibpathconversionjs6160__interopRequireWildcard(_babeltraverselibpathconversionjs6160__babelTypes);

function _babeltraverselibpathconversionjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathconversionjs6160_toComputedKey() {
  var node = this.node;

  var key = void 0;
  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!node.computed) {
    if (_babeltraverselibpathconversionjs6160_t.isIdentifier(key)) key = _babeltraverselibpathconversionjs6160_t.stringLiteral(key.name);
  }

  return key;
}

function _babeltraverselibpathconversionjs6160_ensureBlock() {
  return _babeltraverselibpathconversionjs6160_t.ensureBlock(this.node);
}

function _babeltraverselibpathconversionjs6160_arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;

  this.ensureBlock();

  var node = this.node;

  node.expression = false;
  node.type = "FunctionExpression";
  node.shadow = node.shadow || true;
}
/*≠≠ node_modules/babel-traverse/lib/path/conversion.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/evaluation.js ==*/
$m['babel-traverse/lib/path/evaluation.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/evaluation.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathevaluationjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babeltraverselibpathevaluationjs6160__typeof3 = _babeltraverselibpathevaluationjs6160__interopRequireDefault(_babeltraverselibpathevaluationjs6160__typeof2);

var _babeltraverselibpathevaluationjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathevaluationjs6160__getIterator3 = _babeltraverselibpathevaluationjs6160__interopRequireDefault(_babeltraverselibpathevaluationjs6160__getIterator2);

var _babeltraverselibpathevaluationjs6160__map = $m['babel-runtime/core-js/map.js#6.11.6'].exports;

var _babeltraverselibpathevaluationjs6160__map2 = _babeltraverselibpathevaluationjs6160__interopRequireDefault(_babeltraverselibpathevaluationjs6160__map);

$m['babel-traverse/lib/path/evaluation.js#6.16.0'].exports.evaluateTruthy = _babeltraverselibpathevaluationjs6160_evaluateTruthy;
$m['babel-traverse/lib/path/evaluation.js#6.16.0'].exports.evaluate = _babeltraverselibpathevaluationjs6160_evaluate;

function _babeltraverselibpathevaluationjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibpathevaluationjs6160_VALID_CALLEES = ["String", "Number", "Math"];
var _babeltraverselibpathevaluationjs6160_INVALID_METHODS = ["random"];

function _babeltraverselibpathevaluationjs6160_evaluateTruthy() {
  var res = this.evaluate();
  if (res.confident) return !!res.value;
}

function _babeltraverselibpathevaluationjs6160_evaluate() {
  var confident = true;
  var deoptPath = void 0;
  var seen = new _babeltraverselibpathevaluationjs6160__map2.default();

  function deopt(path) {
    if (!confident) return;
    deoptPath = path;
    confident = false;
  }

  var value = evaluate(this);
  if (!confident) value = undefined;
  return {
    confident: confident,
    deopt: deoptPath,
    value: value
  };

  function evaluate(path) {
    var node = path.node;

    if (seen.has(node)) {
      var existing = seen.get(node);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path);
        return;
      }
    } else {
      var item = { resolved: false };
      seen.set(node, item);

      var val = _evaluate(path);
      if (confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }

  function _evaluate(path) {
    if (!confident) return;

    var node = path.node;

    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluate(exprs[exprs.length - 1]);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      var str = "";

      var i = 0;
      var _exprs = path.get("expressions");

      for (var _iterator = node.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathevaluationjs6160__getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var elem = _ref;

        if (!confident) break;

        str += elem.value.cooked;

        var expr = _exprs[i++];
        if (expr) str += String(evaluate(expr));
      }

      if (!confident) return;
      return str;
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluate(path.get("test"));
      if (!confident) return;
      if (testResult) {
        return evaluate(path.get("consequent"));
      } else {
        return evaluate(path.get("alternate"));
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluate(path.get("expression"));
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {
      var property = path.get("property");
      var object = path.get("object");

      if (object.isLiteral() && property.isIdentifier()) {
        var _value = object.node.value;
        var type = typeof _value === "undefined" ? "undefined" : (0, _babeltraverselibpathevaluationjs6160__typeof3.default)(_value);
        if (type === "number" || type === "string") {
          return _value[property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path);
      }

      if (binding && binding.hasValue) {
        return binding.value;
      } else {
        if (node.name === "undefined") {
          return undefined;
        } else if (node.name === "Infinity") {
          return Infinity;
        } else if (node.name === "NaN") {
          return NaN;
        }

        var resolved = path.resolve();
        if (resolved === path) {
          return deopt(path);
        } else {
          return evaluate(resolved);
        }
      }
    }

    if (path.isUnaryExpression({ prefix: true })) {
      if (node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");
      if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluate(argument);
      if (!confident) return;
      switch (node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg === "undefined" ? "undefined" : (0, _babeltraverselibpathevaluationjs6160__typeof3.default)(arg);
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");
      for (var _iterator2 = elems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathevaluationjs6160__getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _elem = _ref2;

        _elem = _elem.evaluate();

        if (_elem.confident) {
          arr.push(_elem.value);
        } else {
          return deopt(_elem);
        }
      }
      return arr;
    }

    if (path.isObjectExpression()) {}

    if (path.isLogicalExpression()) {
      var wasConfident = confident;
      var left = evaluate(path.get("left"));
      var leftConfident = confident;
      confident = wasConfident;
      var right = evaluate(path.get("right"));
      var rightConfident = confident;
      confident = leftConfident && rightConfident;

      switch (node.operator) {
        case "||":
          if (left && leftConfident) {
            confident = true;
            return left;
          }

          if (!confident) return;

          return left || right;
        case "&&":
          if (!left && leftConfident || !right && rightConfident) {
            confident = true;
          }

          if (!confident) return;

          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluate(path.get("left"));
      if (!confident) return;
      var _right = evaluate(path.get("right"));
      if (!confident) return;

      switch (node.operator) {
        case "-":
          return _left - _right;
        case "+":
          return _left + _right;
        case "/":
          return _left / _right;
        case "*":
          return _left * _right;
        case "%":
          return _left % _right;
        case "**":
          return Math.pow(_left, _right);
        case "<":
          return _left < _right;
        case ">":
          return _left > _right;
        case "<=":
          return _left <= _right;
        case ">=":
          return _left >= _right;
        case "==":
          return _left == _right;
        case "!=":
          return _left != _right;
        case "===":
          return _left === _right;
        case "!==":
          return _left !== _right;
        case "|":
          return _left | _right;
        case "&":
          return _left & _right;
        case "^":
          return _left ^ _right;
        case "<<":
          return _left << _right;
        case ">>":
          return _left >> _right;
        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context = void 0;
      var func = void 0;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && _babeltraverselibpathevaluationjs6160_VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global[node.callee.name];
      }

      if (callee.isMemberExpression()) {
        var _object = callee.get("object");
        var _property = callee.get("property");

        if (_object.isIdentifier() && _property.isIdentifier() && _babeltraverselibpathevaluationjs6160_VALID_CALLEES.indexOf(_object.node.name) >= 0 && _babeltraverselibpathevaluationjs6160_INVALID_METHODS.indexOf(_property.node.name) < 0) {
          context = global[_object.node.name];
          func = context[_property.node.name];
        }

        if (_object.isLiteral() && _property.isIdentifier()) {
          var _type = (0, _babeltraverselibpathevaluationjs6160__typeof3.default)(_object.node.value);
          if (_type === "string" || _type === "number") {
            context = _object.node.value;
            func = context[_property.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(evaluate);
        if (!confident) return;

        return func.apply(context, args);
      }
    }

    deopt(path);
  }
}
/*≠≠ node_modules/babel-traverse/lib/path/evaluation.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/inference/index.js ==*/
$m['babel-traverse/lib/path/inference/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathinferenceindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathinferenceindexjs6160__getIterator3 = _babeltraverselibpathinferenceindexjs6160__interopRequireDefault(_babeltraverselibpathinferenceindexjs6160__getIterator2);

$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.getTypeAnnotation = _babeltraverselibpathinferenceindexjs6160_getTypeAnnotation;
$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports._getTypeAnnotation = _babeltraverselibpathinferenceindexjs6160__getTypeAnnotation;
$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.isBaseType = _babeltraverselibpathinferenceindexjs6160_isBaseType;
$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.couldBeBaseType = _babeltraverselibpathinferenceindexjs6160_couldBeBaseType;
$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.baseTypeStrictlyMatches = _babeltraverselibpathinferenceindexjs6160_baseTypeStrictlyMatches;
$m['babel-traverse/lib/path/inference/index.js#6.16.0'].exports.isGenericType = _babeltraverselibpathinferenceindexjs6160_isGenericType;

var _babeltraverselibpathinferenceindexjs6160__inferers = $m['babel-traverse/lib/path/inference/inferers.js#6.16.0'].exports;

var _babeltraverselibpathinferenceindexjs6160_inferers = _babeltraverselibpathinferenceindexjs6160__interopRequireWildcard(_babeltraverselibpathinferenceindexjs6160__inferers);

var _babeltraverselibpathinferenceindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathinferenceindexjs6160_t = _babeltraverselibpathinferenceindexjs6160__interopRequireWildcard(_babeltraverselibpathinferenceindexjs6160__babelTypes);

function _babeltraverselibpathinferenceindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathinferenceindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathinferenceindexjs6160_getTypeAnnotation() {
  if (this.typeAnnotation) return this.typeAnnotation;

  var type = this._getTypeAnnotation() || _babeltraverselibpathinferenceindexjs6160_t.anyTypeAnnotation();
  if (_babeltraverselibpathinferenceindexjs6160_t.isTypeAnnotation(type)) type = type.typeAnnotation;
  return this.typeAnnotation = type;
}

function _babeltraverselibpathinferenceindexjs6160__getTypeAnnotation() {
  var node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      var declar = this.parentPath.parentPath;
      var declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return _babeltraverselibpathinferenceindexjs6160_t.stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return _babeltraverselibpathinferenceindexjs6160_t.anyTypeAnnotation();
      }

      return _babeltraverselibpathinferenceindexjs6160_t.voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  var inferer = _babeltraverselibpathinferenceindexjs6160_inferers[node.type];
  if (inferer) {
    return inferer.call(this, node);
  }

  inferer = _babeltraverselibpathinferenceindexjs6160_inferers[this.parentPath.type];
  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}

function _babeltraverselibpathinferenceindexjs6160_isBaseType(baseName, soft) {
  return _babeltraverselibpathinferenceindexjs6160__isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _babeltraverselibpathinferenceindexjs6160__isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return _babeltraverselibpathinferenceindexjs6160_t.isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return _babeltraverselibpathinferenceindexjs6160_t.isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return _babeltraverselibpathinferenceindexjs6160_t.isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return _babeltraverselibpathinferenceindexjs6160_t.isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return _babeltraverselibpathinferenceindexjs6160_t.isMixedTypeAnnotation(type);
  } else if (baseName === "void") {
    return _babeltraverselibpathinferenceindexjs6160_t.isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error("Unknown base type " + baseName);
    }
  }
}

function _babeltraverselibpathinferenceindexjs6160_couldBeBaseType(name) {
  var type = this.getTypeAnnotation();
  if (_babeltraverselibpathinferenceindexjs6160_t.isAnyTypeAnnotation(type)) return true;

  if (_babeltraverselibpathinferenceindexjs6160_t.isUnionTypeAnnotation(type)) {
    for (var _iterator = type.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathinferenceindexjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type2 = _ref;

      if (_babeltraverselibpathinferenceindexjs6160_t.isAnyTypeAnnotation(type2) || _babeltraverselibpathinferenceindexjs6160__isBaseType(name, type2, true)) {
        return true;
      }
    }
    return false;
  } else {
    return _babeltraverselibpathinferenceindexjs6160__isBaseType(name, type, true);
  }
}

function _babeltraverselibpathinferenceindexjs6160_baseTypeStrictlyMatches(right) {
  var left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();

  if (!_babeltraverselibpathinferenceindexjs6160_t.isAnyTypeAnnotation(left) && _babeltraverselibpathinferenceindexjs6160_t.isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}

function _babeltraverselibpathinferenceindexjs6160_isGenericType(genericName) {
  var type = this.getTypeAnnotation();
  return _babeltraverselibpathinferenceindexjs6160_t.isGenericTypeAnnotation(type) && _babeltraverselibpathinferenceindexjs6160_t.isIdentifier(type.id, { name: genericName });
}
/*≠≠ node_modules/babel-traverse/lib/path/inference/index.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/ancestry.js ==*/
$m['babel-traverse/lib/path/ancestry.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathancestryjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathancestryjs6160__getIterator3 = _babeltraverselibpathancestryjs6160__interopRequireDefault(_babeltraverselibpathancestryjs6160__getIterator2);

$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.findParent = _babeltraverselibpathancestryjs6160_findParent;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.find = _babeltraverselibpathancestryjs6160_find;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.getFunctionParent = _babeltraverselibpathancestryjs6160_getFunctionParent;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.getStatementParent = _babeltraverselibpathancestryjs6160_getStatementParent;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.getEarliestCommonAncestorFrom = _babeltraverselibpathancestryjs6160_getEarliestCommonAncestorFrom;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.getDeepestCommonAncestorFrom = _babeltraverselibpathancestryjs6160_getDeepestCommonAncestorFrom;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.getAncestry = _babeltraverselibpathancestryjs6160_getAncestry;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.inType = _babeltraverselibpathancestryjs6160_inType;
$m['babel-traverse/lib/path/ancestry.js#6.16.0'].exports.inShadow = _babeltraverselibpathancestryjs6160_inShadow;

var _babeltraverselibpathancestryjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathancestryjs6160_t = _babeltraverselibpathancestryjs6160__interopRequireWildcard(_babeltraverselibpathancestryjs6160__babelTypes);

var _babeltraverselibpathancestryjs6160__index = require("babel-traverse/lib/path/index.js#6.16.0");

var _babeltraverselibpathancestryjs6160__index2 = _babeltraverselibpathancestryjs6160__interopRequireDefault(_babeltraverselibpathancestryjs6160__index);

function _babeltraverselibpathancestryjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathancestryjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathancestryjs6160_findParent(callback) {
  var path = this;
  while (path = path.parentPath) {
    if (callback(path)) return path;
  }
  return null;
}

function _babeltraverselibpathancestryjs6160_find(callback) {
  var path = this;
  do {
    if (callback(path)) return path;
  } while (path = path.parentPath);
  return null;
}

function _babeltraverselibpathancestryjs6160_getFunctionParent() {
  return this.findParent(function (path) {
    return path.isFunction() || path.isProgram();
  });
}

function _babeltraverselibpathancestryjs6160_getStatementParent() {
  var path = this;
  do {
    if (Array.isArray(path.container)) {
      return path;
    }
  } while (path = path.parentPath);
}

function _babeltraverselibpathancestryjs6160_getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    var earliest = void 0;
    var keys = _babeltraverselibpathancestryjs6160_t.VISITOR_KEYS[deepest.type];

    for (var _iterator = ancestries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathancestryjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var ancestry = _ref;

      var path = ancestry[i + 1];

      if (!earliest) {
        earliest = path;
        continue;
      }

      if (path.listKey && earliest.listKey === path.listKey) {
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        }
      }

      var earliestKeyIndex = keys.indexOf(earliest.parentKey);
      var currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path;
      }
    }

    return earliest;
  });
}

function _babeltraverselibpathancestryjs6160_getDeepestCommonAncestorFrom(paths, filter) {
  var _this = this;

  if (!paths.length) {
    return this;
  }

  if (paths.length === 1) {
    return paths[0];
  }

  var minDepth = Infinity;

  var lastCommonIndex = void 0,
      lastCommon = void 0;

  var ancestries = paths.map(function (path) {
    var ancestry = [];

    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== _this);

    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }

    return ancestry;
  });

  var first = ancestries[0];

  depthLoop: for (var i = 0; i < minDepth; i++) {
    var shouldMatch = first[i];

    for (var _iterator2 = ancestries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathancestryjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var ancestry = _ref2;

      if (ancestry[i] !== shouldMatch) {
        break depthLoop;
      }
    }

    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }

  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}

function _babeltraverselibpathancestryjs6160_getAncestry() {
  var path = this;
  var paths = [];
  do {
    paths.push(path);
  } while (path = path.parentPath);
  return paths;
}

function _babeltraverselibpathancestryjs6160_inType() {
  var path = this;
  while (path) {
    for (var _iterator3 = arguments, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babeltraverselibpathancestryjs6160__getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var type = _ref3;

      if (path.node.type === type) return true;
    }
    path = path.parentPath;
  }

  return false;
}

function _babeltraverselibpathancestryjs6160_inShadow(key) {
  var parentFn = this.isFunction() ? this : this.findParent(function (p) {
    return p.isFunction();
  });
  if (!parentFn) return;

  if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {
    var shadow = parentFn.node.shadow;

    if (shadow && (!key || shadow[key] !== false)) {
      return parentFn;
    }
  } else if (parentFn.isArrowFunctionExpression()) {
    return parentFn;
  }

  return null;
}
/*≠≠ node_modules/babel-traverse/lib/path/ancestry.js ≠≠*/

/*== node_modules/lodash/_copyObject.js ==*/
$m['lodash/_copyObject.js#4.16.2'] = { exports: {} };
var _lodashcopyObjectjs4162_assignValue = $m['lodash/_assignValue.js#4.16.2'].exports,
    _lodashcopyObjectjs4162_baseAssignValue = $m['lodash/_baseAssignValue.js#4.16.2'].exports;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function _lodashcopyObjectjs4162_copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _lodashcopyObjectjs4162_baseAssignValue(object, key, newValue);
    } else {
      _lodashcopyObjectjs4162_assignValue(object, key, newValue);
    }
  }
  return object;
}

$m['lodash/_copyObject.js#4.16.2'].exports = _lodashcopyObjectjs4162_copyObject;
/*≠≠ node_modules/lodash/_copyObject.js ≠≠*/

/*== node_modules/lodash/isArrayLike.js ==*/
$m['lodash/isArrayLike.js#4.16.2'] = { exports: {} };
var _lodashisArrayLikejs4162_isFunction = $m['lodash/isFunction.js#4.16.2'].exports,
    _lodashisArrayLikejs4162_isLength = $m['lodash/isLength.js#4.16.2'].exports;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function _lodashisArrayLikejs4162_isArrayLike(value) {
  return value != null && _lodashisArrayLikejs4162_isLength(value.length) && !_lodashisArrayLikejs4162_isFunction(value);
}

$m['lodash/isArrayLike.js#4.16.2'].exports = _lodashisArrayLikejs4162_isArrayLike;
/*≠≠ node_modules/lodash/isArrayLike.js ≠≠*/

/*== node_modules/lodash/_isPrototype.js ==*/
$m['lodash/_isPrototype.js#4.16.2'] = { exports: {} };
/** Used for built-in method references. */
var _lodashisPrototypejs4162_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function _lodashisPrototypejs4162_isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || _lodashisPrototypejs4162_objectProto;

  return value === proto;
}

$m['lodash/_isPrototype.js#4.16.2'].exports = _lodashisPrototypejs4162_isPrototype;
/*≠≠ node_modules/lodash/_isPrototype.js ≠≠*/

/*== node_modules/lodash/assign.js ==*/
$m['lodash/assign.js#4.16.2'] = { exports: {} };
var _lodashassignjs4162_assignValue = $m['lodash/_assignValue.js#4.16.2'].exports,
    _lodashassignjs4162_copyObject = $m['lodash/_copyObject.js#4.16.2'].exports,
    _lodashassignjs4162_createAssigner = $m['lodash/_createAssigner.js#4.16.2'].exports,
    _lodashassignjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports,
    _lodashassignjs4162_isPrototype = $m['lodash/_isPrototype.js#4.16.2'].exports,
    _lodashassignjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashassignjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashassignjs4162_hasOwnProperty = _lodashassignjs4162_objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var _lodashassignjs4162_assign = _lodashassignjs4162_createAssigner(function (object, source) {
  if (_lodashassignjs4162_isPrototype(source) || _lodashassignjs4162_isArrayLike(source)) {
    _lodashassignjs4162_copyObject(source, _lodashassignjs4162_keys(source), object);
    return;
  }
  for (var key in source) {
    if (_lodashassignjs4162_hasOwnProperty.call(source, key)) {
      _lodashassignjs4162_assignValue(object, key, source[key]);
    }
  }
});

$m['lodash/assign.js#4.16.2'].exports = _lodashassignjs4162_assign;
/*≠≠ node_modules/lodash/assign.js ≠≠*/

/*== node_modules/babel-runtime/helpers/possibleConstructorReturn.js ==*/
$m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'] = { exports: {} };
"use strict";

$m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports.__esModule = true;

var _babelruntimehelperspossibleConstructorReturnjs6116__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelruntimehelperspossibleConstructorReturnjs6116__typeof3 = _babelruntimehelperspossibleConstructorReturnjs6116__interopRequireDefault(_babelruntimehelperspossibleConstructorReturnjs6116__typeof2);

function _babelruntimehelperspossibleConstructorReturnjs6116__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _babelruntimehelperspossibleConstructorReturnjs6116__typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
/*≠≠ node_modules/babel-runtime/helpers/possibleConstructorReturn.js ≠≠*/

/*== node_modules/babel-runtime/helpers/inherits.js ==*/
$m['babel-runtime/helpers/inherits.js#6.11.6'] = { exports: {} };
"use strict";

$m['babel-runtime/helpers/inherits.js#6.11.6'].exports.__esModule = true;

var _babelruntimehelpersinheritsjs6116__setPrototypeOf = $m['babel-runtime/core-js/object/set-prototype-of.js#6.11.6'].exports;

var _babelruntimehelpersinheritsjs6116__setPrototypeOf2 = _babelruntimehelpersinheritsjs6116__interopRequireDefault(_babelruntimehelpersinheritsjs6116__setPrototypeOf);

var _babelruntimehelpersinheritsjs6116__create = $m['babel-runtime/core-js/object/create.js#6.11.6'].exports;

var _babelruntimehelpersinheritsjs6116__create2 = _babelruntimehelpersinheritsjs6116__interopRequireDefault(_babelruntimehelpersinheritsjs6116__create);

var _babelruntimehelpersinheritsjs6116__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelruntimehelpersinheritsjs6116__typeof3 = _babelruntimehelpersinheritsjs6116__interopRequireDefault(_babelruntimehelpersinheritsjs6116__typeof2);

function _babelruntimehelpersinheritsjs6116__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-runtime/helpers/inherits.js#6.11.6'].exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _babelruntimehelpersinheritsjs6116__typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _babelruntimehelpersinheritsjs6116__create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _babelruntimehelpersinheritsjs6116__setPrototypeOf2.default ? (0, _babelruntimehelpersinheritsjs6116__setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
/*≠≠ node_modules/babel-runtime/helpers/inherits.js ≠≠*/

/*== node_modules/babel-core/lib/tr...file/options/option-manager.js ==*/
$m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'] = function () {
$m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__assign = $m['babel-runtime/core-js/object/assign.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__assign2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__assign);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__getIterator3 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__getIterator2);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof2);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__classCallCheck3 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__classCallCheck2);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__node = $m['babel-core/lib/api/node.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160_context = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireWildcard(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__node);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin2 = $m['babel-core/lib/transformation/plugin.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin3 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin2);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160_messages = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireWildcard(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__babelMessages);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__index = $m['babel-core/lib/transformation/file/options/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve = $m['babel-core/lib/helpers/resolve.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__cloneDeepWith = $m['lodash/cloneDeepWith.js#4.16.2'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__cloneDeepWith2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__cloneDeepWith);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__clone = $m['lodash/clone.js#4.16.2'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__clone2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__clone);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__merge = $m['babel-core/lib/helpers/merge.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__merge2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__merge);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config2 = $m['babel-core/lib/transformation/file/options/config.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__config2);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__removed = $m['babel-core/lib/transformation/file/options/removed.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__removed2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__removed);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__buildConfigChain = $m['babel-core/lib/transformation/file/options/build-config-chain.js#6.16.0'].exports;

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__buildConfigChain2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__buildConfigChain);

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__path = require("path");

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160__path2 = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(_babelcorelibtransformationfileoptionsoptionmanagerjs6160__path);

function _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationfileoptionsoptionmanagerjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfileoptionsoptionmanagerjs6160_OptionManager = function () {
  function OptionManager(log) {
    (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__classCallCheck3.default)(this, OptionManager);

    this.resolvedConfigs = [];
    this.options = OptionManager.createBareOptions();
    this.log = log;
  }

  OptionManager.memoisePluginContainer = function memoisePluginContainer(fn, loc, i, alias) {
    for (var _iterator = OptionManager.memoisedPlugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var cache = _ref;

      if (cache.container === fn) return cache.plugin;
    }

    var obj = void 0;

    if (typeof fn === "function") {
      obj = fn(_babelcorelibtransformationfileoptionsoptionmanagerjs6160_context);
    } else {
      obj = fn;
    }

    if ((typeof obj === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(obj)) === "object") {
      var _plugin = new _babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin3.default(obj, alias);
      OptionManager.memoisedPlugins.push({
        container: fn,
        plugin: _plugin
      });
      return _plugin;
    } else {
      throw new TypeError(_babelcorelibtransformationfileoptionsoptionmanagerjs6160_messages.get("pluginNotObject", loc, i, typeof obj === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(obj)) + loc + i);
    }
  };

  OptionManager.createBareOptions = function createBareOptions() {
    var opts = {};

    for (var _key in _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3.default) {
      var opt = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3.default[_key];
      opts[_key] = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__clone2.default)(opt.default);
    }

    return opts;
  };

  OptionManager.normalisePlugin = function normalisePlugin(plugin, loc, i, alias) {
    plugin = plugin.__esModule ? plugin.default : plugin;

    if (!(plugin instanceof _babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin3.default)) {
      if (typeof plugin === "function" || (typeof plugin === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(plugin)) === "object") {
        plugin = OptionManager.memoisePluginContainer(plugin, loc, i, alias);
      } else {
        throw new TypeError(_babelcorelibtransformationfileoptionsoptionmanagerjs6160_messages.get("pluginNotFunction", loc, i, typeof plugin === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(plugin)));
      }
    }

    plugin.init(loc, i);

    return plugin;
  };

  OptionManager.normalisePlugins = function normalisePlugins(loc, dirname, plugins) {
    return plugins.map(function (val, i) {
      var plugin = void 0,
          options = void 0;

      if (!val) {
        throw new TypeError("Falsy value found in plugins");
      }

      if (Array.isArray(val)) {
        plugin = val[0];
        options = val[1];
      } else {
        plugin = val;
      }

      var alias = typeof plugin === "string" ? plugin : loc + "$" + i;

      if (typeof plugin === "string") {
        var pluginLoc = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2.default)("babel-plugin-" + plugin, dirname) || (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2.default)(plugin, dirname);
        if (pluginLoc) {
          plugin = require(pluginLoc);
        } else {
          throw new ReferenceError(_babelcorelibtransformationfileoptionsoptionmanagerjs6160_messages.get("pluginUnknown", plugin, loc, i, dirname));
        }
      }

      plugin = OptionManager.normalisePlugin(plugin, loc, i, alias);

      return [plugin, options];
    });
  };

  OptionManager.prototype.mergeOptions = function mergeOptions(_ref2) {
    var _this = this;

    var rawOpts = _ref2.options;
    var extendingOpts = _ref2.extending;
    var alias = _ref2.alias;
    var loc = _ref2.loc;
    var dirname = _ref2.dirname;

    alias = alias || "foreign";
    if (!rawOpts) return;

    if ((typeof rawOpts === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(rawOpts)) !== "object" || Array.isArray(rawOpts)) {
      this.log.error("Invalid options type for " + alias, TypeError);
    }

    var opts = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__cloneDeepWith2.default)(rawOpts, function (val) {
      if (val instanceof _babelcorelibtransformationfileoptionsoptionmanagerjs6160__plugin3.default) {
        return val;
      }
    });

    dirname = dirname || process.cwd();
    loc = loc || alias;

    for (var _key2 in opts) {
      var option = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3.default[_key2];

      if (!option && this.log) {
        var pluginOptsInfo = "Check out http://babeljs.io/docs/usage/options/ for more info";

        if (_babelcorelibtransformationfileoptionsoptionmanagerjs6160__removed2.default[_key2]) {
          this.log.error("Using removed Babel 5 option: " + alias + "." + _key2 + " - " + _babelcorelibtransformationfileoptionsoptionmanagerjs6160__removed2.default[_key2].message, ReferenceError);
        } else {
          this.log.error("Unknown option: " + alias + "." + _key2 + ". " + pluginOptsInfo, ReferenceError);
        }
      }
    }

    (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__index.normaliseOptions)(opts);

    if (opts.plugins) {
      opts.plugins = OptionManager.normalisePlugins(loc, dirname, opts.plugins);
    }

    if (opts.presets) {
      if (opts.passPerPreset) {
        opts.presets = this.resolvePresets(opts.presets, dirname, function (preset, presetLoc) {
          _this.mergeOptions({
            options: preset,
            extending: preset,
            alias: presetLoc,
            loc: presetLoc,
            dirname: dirname
          });
        });
      } else {
        this.mergePresets(opts.presets, dirname);
        delete opts.presets;
      }
    }

    if (rawOpts === extendingOpts) {
      (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__assign2.default)(extendingOpts, opts);
    } else {
      (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__merge2.default)(extendingOpts || this.options, opts);
    }
  };

  OptionManager.prototype.mergePresets = function mergePresets(presets, dirname) {
    var _this2 = this;

    this.resolvePresets(presets, dirname, function (presetOpts, presetLoc) {
      _this2.mergeOptions({
        options: presetOpts,
        alias: presetLoc,
        loc: presetLoc,
        dirname: _babelcorelibtransformationfileoptionsoptionmanagerjs6160__path2.default.dirname(presetLoc || "")
      });
    });
  };

  OptionManager.prototype.resolvePresets = function resolvePresets(presets, dirname, onResolve) {
    return presets.map(function (val) {
      var options = void 0;
      if (Array.isArray(val)) {
        if (val.length > 2) {
          throw new Error("Unexpected extra options " + (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2.default)(val.slice(2)) + " passed to preset.");
        }

        var _val = val;
        val = _val[0];
        options = _val[1];
      }

      var presetLoc = void 0;
      try {
        if (typeof val === "string") {
          presetLoc = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2.default)("babel-preset-" + val, dirname) || (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2.default)(val, dirname);

          if (!presetLoc) {
            var matches = val.match(/^(@[^/]+)\/(.+)$/);
            if (matches) {
              var orgName = matches[1];
              var presetPath = matches[2];

              val = orgName + "/babel-preset-" + presetPath;
              presetLoc = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__resolve2.default)(val, dirname);
            }
          }

          if (!presetLoc) {
            throw new Error("Couldn't find preset " + (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2.default)(val) + " relative to directory " + (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2.default)(dirname));
          }

          val = require(presetLoc);
        }

        if ((typeof val === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(val)) === "object" && val.__esModule) val = val.default;

        if ((typeof val === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(val)) === "object" && val.buildPreset) val = val.buildPreset;

        if (typeof val !== "function" && options !== undefined) {
          throw new Error("Options " + (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2.default)(options) + " passed to " + (presetLoc || "a preset") + " which does not accept options.");
        }

        if (typeof val === "function") val = val(_babelcorelibtransformationfileoptionsoptionmanagerjs6160_context, options);

        if ((typeof val === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__typeof3.default)(val)) !== "object") {
          throw new Error("Unsupported preset format: " + val + ".");
        }

        onResolve && onResolve(val, presetLoc);
      } catch (e) {
        if (presetLoc) {
          e.message += " (While processing preset: " + (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__stringify2.default)(presetLoc) + ")";
        }
        throw e;
      }
      return val;
    });
  };

  OptionManager.prototype.normaliseOptions = function normaliseOptions() {
    var opts = this.options;

    for (var _key3 in _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3.default) {
      var option = _babelcorelibtransformationfileoptionsoptionmanagerjs6160__config3.default[_key3];
      var val = opts[_key3];

      if (!val && option.optional) continue;

      if (option.alias) {
        opts[option.alias] = opts[option.alias] || val;
      } else {
        opts[_key3] = val;
      }
    }
  };

  OptionManager.prototype.init = function init() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    for (var _iterator2 = (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__buildConfigChain2.default)(opts, this.log), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelcorelibtransformationfileoptionsoptionmanagerjs6160__getIterator3.default)(_iterator2);;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      var _config = _ref3;

      this.mergeOptions(_config);
    }

    this.normaliseOptions(opts);

    return this.options;
  };

  return OptionManager;
}();

$m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'].exports.default = _babelcorelibtransformationfileoptionsoptionmanagerjs6160_OptionManager;

_babelcorelibtransformationfileoptionsoptionmanagerjs6160_OptionManager.memoisedPlugins = [];
$m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'].exports = $m['babel-core/lib/transformation/file/options/option-manager.js#6.16.0'].exports["default"];
};
/*≠≠ node_modules/babel-core/lib/tr...file/options/option-manager.js ≠≠*/

/*== node_modules/babel-core/lib/store.js ==*/
$m['babel-core/lib/store.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/store.js#6.16.0'].exports.__esModule = true;

var _babelcorelibstorejs6160__map = $m['babel-runtime/core-js/map.js#6.11.6'].exports;

var _babelcorelibstorejs6160__map2 = _babelcorelibstorejs6160__interopRequireDefault(_babelcorelibstorejs6160__map);

var _babelcorelibstorejs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibstorejs6160__classCallCheck3 = _babelcorelibstorejs6160__interopRequireDefault(_babelcorelibstorejs6160__classCallCheck2);

var _babelcorelibstorejs6160__possibleConstructorReturn2 = $m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports;

var _babelcorelibstorejs6160__possibleConstructorReturn3 = _babelcorelibstorejs6160__interopRequireDefault(_babelcorelibstorejs6160__possibleConstructorReturn2);

var _babelcorelibstorejs6160__inherits2 = $m['babel-runtime/helpers/inherits.js#6.11.6'].exports;

var _babelcorelibstorejs6160__inherits3 = _babelcorelibstorejs6160__interopRequireDefault(_babelcorelibstorejs6160__inherits2);

function _babelcorelibstorejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibstorejs6160_Store = function (_Map) {
  (0, _babelcorelibstorejs6160__inherits3.default)(Store, _Map);

  function Store() {
    (0, _babelcorelibstorejs6160__classCallCheck3.default)(this, Store);

    var _this = (0, _babelcorelibstorejs6160__possibleConstructorReturn3.default)(this, _Map.call(this));

    _this.dynamicData = {};
    return _this;
  }

  Store.prototype.setDynamic = function setDynamic(key, fn) {
    this.dynamicData[key] = fn;
  };

  Store.prototype.get = function get(key) {
    if (this.has(key)) {
      return _Map.prototype.get.call(this, key);
    } else {
      if (Object.prototype.hasOwnProperty.call(this.dynamicData, key)) {
        var val = this.dynamicData[key]();
        this.set(key, val);
        return val;
      }
    }
  };

  return Store;
}(_babelcorelibstorejs6160__map2.default);

$m['babel-core/lib/store.js#6.16.0'].exports.default = _babelcorelibstorejs6160_Store;
$m['babel-core/lib/store.js#6.16.0'].exports = $m['babel-core/lib/store.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/store.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/plugin.js ==*/
$m['babel-core/lib/transformation/plugin.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/plugin.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationpluginjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibtransformationpluginjs6160__getIterator3 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__getIterator2);

var _babelcorelibtransformationpluginjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationpluginjs6160__classCallCheck3 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__classCallCheck2);

var _babelcorelibtransformationpluginjs6160__possibleConstructorReturn2 = $m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports;

var _babelcorelibtransformationpluginjs6160__possibleConstructorReturn3 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__possibleConstructorReturn2);

var _babelcorelibtransformationpluginjs6160__inherits2 = $m['babel-runtime/helpers/inherits.js#6.11.6'].exports;

var _babelcorelibtransformationpluginjs6160__inherits3 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__inherits2);

var _babelcorelibtransformationpluginjs6160__optionManager = require("babel-core/lib/transformation/file/options/option-manager.js#6.16.0");

var _babelcorelibtransformationpluginjs6160__optionManager2 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__optionManager);

var _babelcorelibtransformationpluginjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babelcorelibtransformationpluginjs6160_messages = _babelcorelibtransformationpluginjs6160__interopRequireWildcard(_babelcorelibtransformationpluginjs6160__babelMessages);

var _babelcorelibtransformationpluginjs6160__store = $m['babel-core/lib/store.js#6.16.0'].exports;

var _babelcorelibtransformationpluginjs6160__store2 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__store);

var _babelcorelibtransformationpluginjs6160__babelTraverse = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationpluginjs6160__babelTraverse2 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__babelTraverse);

var _babelcorelibtransformationpluginjs6160__assign = $m['lodash/assign.js#4.16.2'].exports;

var _babelcorelibtransformationpluginjs6160__assign2 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__assign);

var _babelcorelibtransformationpluginjs6160__clone = $m['lodash/clone.js#4.16.2'].exports;

var _babelcorelibtransformationpluginjs6160__clone2 = _babelcorelibtransformationpluginjs6160__interopRequireDefault(_babelcorelibtransformationpluginjs6160__clone);

function _babelcorelibtransformationpluginjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationpluginjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationpluginjs6160_GLOBAL_VISITOR_PROPS = ["enter", "exit"];

var _babelcorelibtransformationpluginjs6160_Plugin = function (_Store) {
  (0, _babelcorelibtransformationpluginjs6160__inherits3.default)(Plugin, _Store);

  function Plugin(plugin, key) {
    (0, _babelcorelibtransformationpluginjs6160__classCallCheck3.default)(this, Plugin);

    var _this = (0, _babelcorelibtransformationpluginjs6160__possibleConstructorReturn3.default)(this, _Store.call(this));

    _this.initialized = false;
    _this.raw = (0, _babelcorelibtransformationpluginjs6160__assign2.default)({}, plugin);
    _this.key = _this.take("name") || key;

    _this.manipulateOptions = _this.take("manipulateOptions");
    _this.post = _this.take("post");
    _this.pre = _this.take("pre");
    _this.visitor = _this.normaliseVisitor((0, _babelcorelibtransformationpluginjs6160__clone2.default)(_this.take("visitor")) || {});
    return _this;
  }

  Plugin.prototype.take = function take(key) {
    var val = this.raw[key];
    delete this.raw[key];
    return val;
  };

  Plugin.prototype.chain = function chain(target, key) {
    if (!target[key]) return this[key];
    if (!this[key]) return target[key];

    var fns = [target[key], this[key]];

    return function () {
      var val = void 0;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibtransformationpluginjs6160__getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var fn = _ref;

        if (fn) {
          var ret = fn.apply(this, args);
          if (ret != null) val = ret;
        }
      }
      return val;
    };
  };

  Plugin.prototype.maybeInherit = function maybeInherit(loc) {
    var inherits = this.take("inherits");
    if (!inherits) return;

    inherits = _babelcorelibtransformationpluginjs6160__optionManager2.default.normalisePlugin(inherits, loc, "inherits");

    this.manipulateOptions = this.chain(inherits, "manipulateOptions");
    this.post = this.chain(inherits, "post");
    this.pre = this.chain(inherits, "pre");
    this.visitor = _babelcorelibtransformationpluginjs6160__babelTraverse2.default.visitors.merge([inherits.visitor, this.visitor]);
  };

  Plugin.prototype.init = function init(loc, i) {
    if (this.initialized) return;
    this.initialized = true;

    this.maybeInherit(loc);

    for (var key in this.raw) {
      throw new Error(_babelcorelibtransformationpluginjs6160_messages.get("pluginInvalidProperty", loc, i, key));
    }
  };

  Plugin.prototype.normaliseVisitor = function normaliseVisitor(visitor) {
    for (var _iterator2 = _babelcorelibtransformationpluginjs6160_GLOBAL_VISITOR_PROPS, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelcorelibtransformationpluginjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var key = _ref2;

      if (visitor[key]) {
        throw new Error("Plugins aren't allowed to specify catch-all enter/exit handlers. Please target individual nodes.");
      }
    }

    _babelcorelibtransformationpluginjs6160__babelTraverse2.default.explode(visitor);
    return visitor;
  };

  return Plugin;
}(_babelcorelibtransformationpluginjs6160__store2.default);

$m['babel-core/lib/transformation/plugin.js#6.16.0'].exports.default = _babelcorelibtransformationpluginjs6160_Plugin;
$m['babel-core/lib/transformation/plugin.js#6.16.0'].exports = $m['babel-core/lib/transformation/plugin.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/transformation/plugin.js ≠≠*/

/*== node_modules/babylon/lib/parser/index.js ==*/
$m['babylon/lib/parser/index.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/parser/index.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/parser/index.js#6.11.2'].exports.plugins = undefined;

var _babylonlibparserindexjs6112__identifier = $m['babylon/lib/util/identifier.js#6.11.2'].exports;

var _babylonlibparserindexjs6112__options = $m['babylon/lib/options.js#6.11.2'].exports;

var _babylonlibparserindexjs6112__tokenizer = $m['babylon/lib/tokenizer/index.js#6.11.2'].exports;

var _babylonlibparserindexjs6112__tokenizer2 = _babylonlibparserindexjs6112__interopRequireDefault(_babylonlibparserindexjs6112__tokenizer);

function _babylonlibparserindexjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babylonlibparserindexjs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _babylonlibparserindexjs6112__possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _babylonlibparserindexjs6112__inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var _babylonlibparserindexjs6112_plugins = $m['babylon/lib/parser/index.js#6.11.2'].exports.plugins = {};

var _babylonlibparserindexjs6112_Parser = function (_Tokenizer) {
  _babylonlibparserindexjs6112__inherits(Parser, _Tokenizer);

  function Parser(options, input) {
    _babylonlibparserindexjs6112__classCallCheck(this, Parser);

    options = (0, _babylonlibparserindexjs6112__options.getOptions)(options);

    var _this = _babylonlibparserindexjs6112__possibleConstructorReturn(this, _Tokenizer.call(this, options, input));

    _this.options = options;
    _this.inModule = _this.options.sourceType === "module";
    _this.isReservedWord = _babylonlibparserindexjs6112__identifier.reservedWords[6];
    _this.input = input;
    _this.plugins = _this.loadPlugins(_this.options.plugins);
    _this.filename = options.sourceFilename;

    // If enabled, skip leading hashbang line.
    if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
      _this.skipLineComment(2);
    }
    return _this;
  }

  Parser.prototype.hasPlugin = function hasPlugin(name) {
    return !!(this.plugins["*"] || this.plugins[name]);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(plugins) {
    var pluginMap = {};

    if (plugins.indexOf("flow") >= 0) {
      // ensure flow plugin loads last
      plugins = plugins.filter(function (plugin) {
        return plugin !== "flow";
      });
      plugins.push("flow");
    }

    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var name = _ref;

      if (!pluginMap[name]) {
        pluginMap[name] = true;

        var plugin = $m['babylon/lib/parser/index.js#6.11.2'].exports.plugins[name];
        if (plugin) plugin(this);
      }
    }

    return pluginMap;
  };

  Parser.prototype.parse = function parse() {
    var file = this.startNode();
    var program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  };

  return Parser;
}(_babylonlibparserindexjs6112__tokenizer2.default);

$m['babylon/lib/parser/index.js#6.11.2'].exports.default = _babylonlibparserindexjs6112_Parser;
/*≠≠ node_modules/babylon/lib/parser/index.js ≠≠*/

/*== node_modules/babylon/lib/parser/util.js ==*/
$m['babylon/lib/parser/util.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparserutiljs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibparserutiljs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparserutiljs6112__index2 = _babylonlibparserutiljs6112__interopRequireDefault(_babylonlibparserutiljs6112__index);

var _babylonlibparserutiljs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

function _babylonlibparserutiljs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibparserutiljs6112_pp = _babylonlibparserutiljs6112__index2.default.prototype;

// ## Parser utilities

// TODO

_babylonlibparserutiljs6112_pp.addExtra = function (node, key, val) {
  if (!node) return;

  var extra = node.extra = node.extra || {};
  extra[key] = val;
};

// TODO

_babylonlibparserutiljs6112_pp.isRelational = function (op) {
  return this.match(_babylonlibparserutiljs6112__types.types.relational) && this.state.value === op;
};

// TODO

_babylonlibparserutiljs6112_pp.expectRelational = function (op) {
  if (this.isRelational(op)) {
    this.next();
  } else {
    this.unexpected();
  }
};

// Tests whether parsed token is a contextual keyword.

_babylonlibparserutiljs6112_pp.isContextual = function (name) {
  return this.match(_babylonlibparserutiljs6112__types.types.name) && this.state.value === name;
};

// Consumes contextual keyword if possible.

_babylonlibparserutiljs6112_pp.eatContextual = function (name) {
  return this.state.value === name && this.eat(_babylonlibparserutiljs6112__types.types.name);
};

// Asserts that following token is given contextual keyword.

_babylonlibparserutiljs6112_pp.expectContextual = function (name, message) {
  if (!this.eatContextual(name)) this.unexpected(null, message);
};

// Test whether a semicolon can be inserted at the current position.

_babylonlibparserutiljs6112_pp.canInsertSemicolon = function () {
  return this.match(_babylonlibparserutiljs6112__types.types.eof) || this.match(_babylonlibparserutiljs6112__types.types.braceR) || _babylonlibparserutiljs6112__whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
};

// TODO

_babylonlibparserutiljs6112_pp.isLineTerminator = function () {
  return this.eat(_babylonlibparserutiljs6112__types.types.semi) || this.canInsertSemicolon();
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

_babylonlibparserutiljs6112_pp.semicolon = function () {
  if (!this.isLineTerminator()) this.unexpected();
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.

_babylonlibparserutiljs6112_pp.expect = function (type, pos) {
  return this.eat(type) || this.unexpected(pos);
};

// Raise an unexpected token error.

_babylonlibparserutiljs6112_pp.unexpected = function (pos) {
  var message = arguments.length <= 1 || arguments[1] === undefined ? "Unexpected token" : arguments[1];

  this.raise(pos != null ? pos : this.state.start, message);
};
/*≠≠ node_modules/babylon/lib/parser/util.js ≠≠*/

/*== node_modules/babylon/lib/parser/statement.js ==*/
$m['babylon/lib/parser/statement.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparserstatementjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibparserstatementjs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparserstatementjs6112__index2 = _babylonlibparserstatementjs6112__interopRequireDefault(_babylonlibparserstatementjs6112__index);

var _babylonlibparserstatementjs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

function _babylonlibparserstatementjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibparserstatementjs6112_pp = _babylonlibparserstatementjs6112__index2.default.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

/* eslint indent: 0 */
/* eslint max-len: 0 */

_babylonlibparserstatementjs6112_pp.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, _babylonlibparserstatementjs6112__types.types.eof);

  file.program = this.finishNode(program, "Program");
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, "File");
};

var _babylonlibparserstatementjs6112_loopLabel = { kind: "loop" },
    _babylonlibparserstatementjs6112_switchLabel = { kind: "switch" };

// TODO

_babylonlibparserstatementjs6112_pp.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, "raw", raw);
  this.addExtra(directiveLiteral, "rawValue", val);

  directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);

  return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

_babylonlibparserstatementjs6112_pp.parseStatement = function (declaration, topLevel) {
  if (this.match(_babylonlibparserstatementjs6112__types.types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type,
      node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _babylonlibparserstatementjs6112__types.types._break:case _babylonlibparserstatementjs6112__types.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _babylonlibparserstatementjs6112__types.types._debugger:
      return this.parseDebuggerStatement(node);
    case _babylonlibparserstatementjs6112__types.types._do:
      return this.parseDoStatement(node);
    case _babylonlibparserstatementjs6112__types.types._for:
      return this.parseForStatement(node);
    case _babylonlibparserstatementjs6112__types.types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case _babylonlibparserstatementjs6112__types.types._class:
      if (!declaration) this.unexpected();
      this.takeDecorators(node);
      return this.parseClass(node, true);

    case _babylonlibparserstatementjs6112__types.types._if:
      return this.parseIfStatement(node);
    case _babylonlibparserstatementjs6112__types.types._return:
      return this.parseReturnStatement(node);
    case _babylonlibparserstatementjs6112__types.types._switch:
      return this.parseSwitchStatement(node);
    case _babylonlibparserstatementjs6112__types.types._throw:
      return this.parseThrowStatement(node);
    case _babylonlibparserstatementjs6112__types.types._try:
      return this.parseTryStatement(node);

    case _babylonlibparserstatementjs6112__types.types._let:
    case _babylonlibparserstatementjs6112__types.types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case _babylonlibparserstatementjs6112__types.types._var:
      return this.parseVarStatement(node, starttype);

    case _babylonlibparserstatementjs6112__types.types._while:
      return this.parseWhileStatement(node);
    case _babylonlibparserstatementjs6112__types.types._with:
      return this.parseWithStatement(node);
    case _babylonlibparserstatementjs6112__types.types.braceL:
      return this.parseBlock();
    case _babylonlibparserstatementjs6112__types.types.semi:
      return this.parseEmptyStatement(node);
    case _babylonlibparserstatementjs6112__types.types._export:
    case _babylonlibparserstatementjs6112__types.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === _babylonlibparserstatementjs6112__types.types._import ? this.parseImport(node) : this.parseExport(node);

    case _babylonlibparserstatementjs6112__types.types.name:
      if (this.state.value === "async") {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(_babylonlibparserstatementjs6112__types.types._function) && !this.canInsertSemicolon()) {
          this.expect(_babylonlibparserstatementjs6112__types.types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === _babylonlibparserstatementjs6112__types.types.name && expr.type === "Identifier" && this.eat(_babylonlibparserstatementjs6112__types.types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

_babylonlibparserstatementjs6112_pp.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

_babylonlibparserstatementjs6112_pp.parseDecorators = function (allowExport) {
  while (this.match(_babylonlibparserstatementjs6112__types.types.at)) {
    this.state.decorators.push(this.parseDecorator());
  }

  if (allowExport && this.match(_babylonlibparserstatementjs6112__types.types._export)) {
    return;
  }

  if (!this.match(_babylonlibparserstatementjs6112__types.types._class)) {
    this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
  }
};

_babylonlibparserstatementjs6112_pp.parseDecorator = function () {
  if (!this.hasPlugin("decorators")) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, "Decorator");
};

_babylonlibparserstatementjs6112_pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(_babylonlibparserstatementjs6112__types.types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i < this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

_babylonlibparserstatementjs6112_pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

_babylonlibparserstatementjs6112_pp.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(_babylonlibparserstatementjs6112_loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(_babylonlibparserstatementjs6112__types.types._while);
  node.test = this.parseParenExpression();
  this.eat(_babylonlibparserstatementjs6112__types.types.semi);
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

_babylonlibparserstatementjs6112_pp.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(_babylonlibparserstatementjs6112_loopLabel);

  var forAwait = false;
  if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
    forAwait = true;
    this.next();
  }
  this.expect(_babylonlibparserstatementjs6112__types.types.parenL);

  if (this.match(_babylonlibparserstatementjs6112__types.types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(_babylonlibparserstatementjs6112__types.types._var) || this.match(_babylonlibparserstatementjs6112__types.types._let) || this.match(_babylonlibparserstatementjs6112__types.types._const)) {
    var _init = this.startNode(),
        varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");

    if (this.match(_babylonlibparserstatementjs6112__types.types._in) || this.isContextual("of")) {
      if (_init.declarations.length === 1 && !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(_babylonlibparserstatementjs6112__types.types._in) || this.isContextual("of")) {
    var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
    this.toAssignable(init, undefined, description);
    this.checkLVal(init, undefined, undefined, description);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

_babylonlibparserstatementjs6112_pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

_babylonlibparserstatementjs6112_pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_babylonlibparserstatementjs6112__types.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

_babylonlibparserstatementjs6112_pp.parseReturnStatement = function (node) {
  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, "'return' outside of function");
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

_babylonlibparserstatementjs6112_pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_babylonlibparserstatementjs6112__types.types.braceL);
  this.state.labels.push(_babylonlibparserstatementjs6112_switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(_babylonlibparserstatementjs6112__types.types.braceR);) {
    if (this.match(_babylonlibparserstatementjs6112__types.types._case) || this.match(_babylonlibparserstatementjs6112__types.types._default)) {
      var isCase = this.match(_babylonlibparserstatementjs6112__types.types._case);
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_babylonlibparserstatementjs6112__types.types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

_babylonlibparserstatementjs6112_pp.parseThrowStatement = function (node) {
  this.next();
  if (_babylonlibparserstatementjs6112__whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var _babylonlibparserstatementjs6112_empty = [];

_babylonlibparserstatementjs6112_pp.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(_babylonlibparserstatementjs6112__types.types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(_babylonlibparserstatementjs6112__types.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null), "catch clause");
    this.expect(_babylonlibparserstatementjs6112__types.types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.guardedHandlers = _babylonlibparserstatementjs6112_empty;
  node.finalizer = this.eat(_babylonlibparserstatementjs6112__types.types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

_babylonlibparserstatementjs6112_pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

_babylonlibparserstatementjs6112_pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(_babylonlibparserstatementjs6112_loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

_babylonlibparserstatementjs6112_pp.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

_babylonlibparserstatementjs6112_pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

_babylonlibparserstatementjs6112_pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.state.type.isLoop ? "loop" : this.match(_babylonlibparserstatementjs6112__types.types._switch) ? "switch" : null;
  for (var i = this.state.labels.length - 1; i >= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

_babylonlibparserstatementjs6112_pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

_babylonlibparserstatementjs6112_pp.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(_babylonlibparserstatementjs6112__types.types.braceL);
  this.parseBlockBody(node, allowDirectives, false, _babylonlibparserstatementjs6112__types.types.braceR);
  return this.finishNode(node, "BlockStatement");
};

// TODO

_babylonlibparserstatementjs6112_pp.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives && !parsedNonDirective && stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined && directive.value.value === "use strict") {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, "Octal literal in strict mode");
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

_babylonlibparserstatementjs6112_pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_babylonlibparserstatementjs6112__types.types.semi);
  node.test = this.match(_babylonlibparserstatementjs6112__types.types.semi) ? null : this.parseExpression();
  this.expect(_babylonlibparserstatementjs6112__types.types.semi);
  node.update = this.match(_babylonlibparserstatementjs6112__types.types.parenR) ? null : this.parseExpression();
  this.expect(_babylonlibparserstatementjs6112__types.types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

_babylonlibparserstatementjs6112_pp.parseForIn = function (node, init, forAwait) {
  var type = void 0;
  if (forAwait) {
    this.eatContextual("of");
    type = "ForAwaitStatement";
  } else {
    type = this.match(_babylonlibparserstatementjs6112__types.types._in) ? "ForInStatement" : "ForOfStatement";
    this.next();
  }
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_babylonlibparserstatementjs6112__types.types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

_babylonlibparserstatementjs6112_pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(_babylonlibparserstatementjs6112__types.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === _babylonlibparserstatementjs6112__types.types._const && !(this.match(_babylonlibparserstatementjs6112__types.types._in) || this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(_babylonlibparserstatementjs6112__types.types._in) || this.isContextual("of")))) {
      this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_babylonlibparserstatementjs6112__types.types.comma)) break;
  }
  return node;
};

_babylonlibparserstatementjs6112_pp.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true, undefined, "variable declaration");
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

_babylonlibparserstatementjs6112_pp.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(_babylonlibparserstatementjs6112__types.types.star)) {
    if (node.async && !this.hasPlugin("asyncGenerators")) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement && !optionalId && !this.match(_babylonlibparserstatementjs6112__types.types.name) && !this.match(_babylonlibparserstatementjs6112__types.types._yield)) {
    this.unexpected();
  }

  if (this.match(_babylonlibparserstatementjs6112__types.types.name) || this.match(_babylonlibparserstatementjs6112__types.types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

_babylonlibparserstatementjs6112_pp.parseFunctionParams = function (node) {
  this.expect(_babylonlibparserstatementjs6112__types.types.parenL);
  node.params = this.parseBindingList(_babylonlibparserstatementjs6112__types.types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

_babylonlibparserstatementjs6112_pp.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

_babylonlibparserstatementjs6112_pp.isClassProperty = function () {
  return this.match(_babylonlibparserstatementjs6112__types.types.eq) || this.isLineTerminator();
};

_babylonlibparserstatementjs6112_pp.isClassMutatorStarter = function () {
  return false;
};

_babylonlibparserstatementjs6112_pp.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructorCall = false;
  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(_babylonlibparserstatementjs6112__types.types.braceL);

  while (!this.eat(_babylonlibparserstatementjs6112__types.types.braceR)) {
    if (this.eat(_babylonlibparserstatementjs6112__types.types.semi)) {
      continue;
    }

    if (this.match(_babylonlibparserstatementjs6112__types.types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    var isConstructorCall = false;
    var isMaybeStatic = this.match(_babylonlibparserstatementjs6112__types.types.name) && this.state.value === "static";
    var isGenerator = this.eat(_babylonlibparserstatementjs6112__types.types.star);
    var isGetSet = false;
    var isAsync = false;

    this.parsePropertyName(method);

    method.static = isMaybeStatic && !this.match(_babylonlibparserstatementjs6112__types.types.parenL);
    if (method.static) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_babylonlibparserstatementjs6112__types.types.star);
      this.parsePropertyName(method);
    }

    if (!isGenerator) {
      if (this.isClassProperty()) {
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }

      if (method.key.type === "Identifier" && !method.computed && this.hasPlugin("classConstructorCall") && method.key.name === "call" && this.match(_babylonlibparserstatementjs6112__types.types.name) && this.state.value === "constructor") {
        isConstructorCall = true;
        this.parsePropertyName(method);
      }
    }

    var isAsyncMethod = !this.match(_babylonlibparserstatementjs6112__types.types.parenL) && !method.computed && method.key.type === "Identifier" && method.key.name === "async";
    if (isAsyncMethod) {
      if (this.hasPlugin("asyncGenerators") && this.eat(_babylonlibparserstatementjs6112__types.types.star)) isGenerator = true;
      isAsync = true;
      this.parsePropertyName(method);
    }

    method.kind = "method";

    if (!method.computed) {
      var key = method.key;

      // handle get/set methods
      // eg. class Foo { get bar() {} set bar() {} }

      if (!isAsync && !isGenerator && !this.isClassMutatorStarter() && key.type === "Identifier" && !this.match(_babylonlibparserstatementjs6112__types.types.parenL) && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }

      // disallow invalid constructors
      var isConstructor = !isConstructorCall && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor");
      if (isConstructor) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this.raise(key.start, "Constructor can't be an async function");
        method.kind = "constructor";
        hadConstructor = true;
      }

      // disallow static prototype method
      var isStaticPrototype = method.static && (key.type === "Identifier" && key.name === "prototype" || key.type === "StringLiteral" && key.value === "prototype");
      if (isStaticPrototype) {
        this.raise(key.start, "Classes may not have static property named prototype");
      }
    }

    // convert constructor to a constructor call
    if (isConstructorCall) {
      if (hadConstructorCall) this.raise(method.start, "Duplicate constructor call in the same class");
      method.kind = "constructorCall";
      hadConstructorCall = true;
    }

    // disallow decorators on class constructors
    if ((method.kind === "constructor" || method.kind === "constructorCall") && method.decorators) {
      this.raise(method.start, "You can't attach decorators to a class constructor");
    }

    this.parseClassMethod(classBody, method, isGenerator, isAsync);

    // get methods aren't allowed to have any parameters
    // set methods must have exactly 1 parameter
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.params.length !== paramCount) {
        var start = method.start;
        if (method.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no method");
  }

  node.body = this.finishNode(classBody, "ClassBody");

  this.state.strict = oldStrict;
};

_babylonlibparserstatementjs6112_pp.parseClassProperty = function (node) {
  if (this.match(_babylonlibparserstatementjs6112__types.types.eq)) {
    if (!this.hasPlugin("classProperties")) this.unexpected();
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  return this.finishNode(node, "ClassProperty");
};

_babylonlibparserstatementjs6112_pp.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "ClassMethod"));
};

_babylonlibparserstatementjs6112_pp.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(_babylonlibparserstatementjs6112__types.types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

_babylonlibparserstatementjs6112_pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_babylonlibparserstatementjs6112__types.types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

_babylonlibparserstatementjs6112_pp.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.match(_babylonlibparserstatementjs6112__types.types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
  } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
    if (this.match(_babylonlibparserstatementjs6112__types.types.comma) && this.lookahead().type === _babylonlibparserstatementjs6112__types.types.star) {
      this.expect(_babylonlibparserstatementjs6112__types.types.comma);
      var _specifier2 = this.startNode();
      this.expect(_babylonlibparserstatementjs6112__types.types.star);
      this.expectContextual("as");
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(_babylonlibparserstatementjs6112__types.types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(_babylonlibparserstatementjs6112__types.types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.match(_babylonlibparserstatementjs6112__types.types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node, true, true);
    return this.finishNode(node, "ExportDefaultDeclaration");
  } else if (this.state.type.keyword || this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node, true);
  return this.finishNode(node, "ExportNamedDeclaration");
};

_babylonlibparserstatementjs6112_pp.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

_babylonlibparserstatementjs6112_pp.isExportDefaultSpecifier = function () {
  if (this.match(_babylonlibparserstatementjs6112__types.types.name)) {
    return this.state.value !== "type" && this.state.value !== "async" && this.state.value !== "interface";
  }

  if (!this.match(_babylonlibparserstatementjs6112__types.types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === _babylonlibparserstatementjs6112__types.types.comma || lookahead.type === _babylonlibparserstatementjs6112__types.types.name && lookahead.value === "from";
};

_babylonlibparserstatementjs6112_pp.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(_babylonlibparserstatementjs6112__types.types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

_babylonlibparserstatementjs6112_pp.parseExportFrom = function (node, expect) {
  if (this.eatContextual("from")) {
    node.source = this.match(_babylonlibparserstatementjs6112__types.types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

_babylonlibparserstatementjs6112_pp.shouldParseExportDeclaration = function () {
  return this.isContextual("async");
};

_babylonlibparserstatementjs6112_pp.checkExport = function (node, checkNames, isDefault) {
  if (checkNames) {
    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      this.checkDuplicateExports(node, "default", isDefault);
    } else if (node.specifiers && node.specifiers.length) {
      // Named exports
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        var name = specifier.exported.name;
        if (name === "default") isDefault = true;
        this.checkDuplicateExports(specifier, name, isDefault);
      }
    } else if (node.declaration) {
      // Exported declarations
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        this.checkDuplicateExports(node, node.declaration.id.name, isDefault);
      } else if (node.declaration.type === "VariableDeclaration") {
        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var declaration = _ref3;

          if (declaration.id.name) {
            this.checkDuplicateExports(declaration, declaration.id.name, isDefault);
          }
        }
      }
    }
  }

  if (this.state.decorators.length) {
    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
    if (!node.declaration || !isClass) {
      this.raise(node.start, "You can only use decorators on an export when exporting a class");
    }
    this.takeDecorators(node.declaration);
  }
};

_babylonlibparserstatementjs6112_pp.checkDuplicateExports = function (node, name, isDefault) {
  if (this.state.exportedIdentifiers.indexOf(name) > -1) {
    this.raiseDuplicateExportError(node, name, isDefault);
  }
  this.state.exportedIdentifiers.push(name);
};

_babylonlibparserstatementjs6112_pp.raiseDuplicateExportError = function (node, name, isDefault) {
  this.raise(node.start, isDefault ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
};

// Parses a comma-separated list of module exports.

_babylonlibparserstatementjs6112_pp.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from '...']
  this.expect(_babylonlibparserstatementjs6112__types.types.braceL);

  while (!this.eat(_babylonlibparserstatementjs6112__types.types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserstatementjs6112__types.types.comma);
      if (this.eat(_babylonlibparserstatementjs6112__types.types.braceR)) break;
    }

    var isDefault = this.match(_babylonlibparserstatementjs6112__types.types._default);
    if (isDefault && !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom && !this.isContextual("from")) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

_babylonlibparserstatementjs6112_pp.parseImport = function (node) {
  this.next();

  // import '...'
  if (this.match(_babylonlibparserstatementjs6112__types.types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual("from");
    node.source = this.match(_babylonlibparserstatementjs6112__types.types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

_babylonlibparserstatementjs6112_pp.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(_babylonlibparserstatementjs6112__types.types.name)) {
    // import defaultObj, { x, y as z } from '...'
    var startPos = this.state.start,
        startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(_babylonlibparserstatementjs6112__types.types.comma)) return;
  }

  if (this.match(_babylonlibparserstatementjs6112__types.types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual("as");
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
    return;
  }

  this.expect(_babylonlibparserstatementjs6112__types.types.braceL);
  while (!this.eat(_babylonlibparserstatementjs6112__types.types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserstatementjs6112__types.types.comma);
      if (this.eat(_babylonlibparserstatementjs6112__types.types.braceR)) break;
    }

    var _specifier3 = this.startNode();
    _specifier3.imported = this.parseIdentifier(true);
    _specifier3.local = this.eatContextual("as") ? this.parseIdentifier() : _specifier3.imported.__clone();
    this.checkLVal(_specifier3.local, true, undefined, "import specifier");
    node.specifiers.push(this.finishNode(_specifier3, "ImportSpecifier"));
  }
};

_babylonlibparserstatementjs6112_pp.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true, undefined, "default import specifier");
  return this.finishNode(node, "ImportDefaultSpecifier");
};
/*≠≠ node_modules/babylon/lib/parser/statement.js ≠≠*/

/*== node_modules/babylon/lib/parser/lval.js ==*/
$m['babylon/lib/parser/lval.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparserlvaljs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibparserlvaljs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparserlvaljs6112__index2 = _babylonlibparserlvaljs6112__interopRequireDefault(_babylonlibparserlvaljs6112__index);

var _babylonlibparserlvaljs6112__identifier = $m['babylon/lib/util/identifier.js#6.11.2'].exports;

function _babylonlibparserlvaljs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibparserlvaljs6112_pp = _babylonlibparserlvaljs6112__index2.default.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

/* eslint indent: 0 */

_babylonlibparserlvaljs6112_pp.toAssignable = function (node, isBinding, contextDescription) {
  if (node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var prop = _ref;

          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;

      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;

      case "SpreadProperty":
        node.type = "RestProperty";
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
          this.raise(node.start, message);
        }
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

_babylonlibparserlvaljs6112_pp.toAssignableList = function (exprList, isBinding, contextDescription) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type === "RestElement") {
      --end;
    } else if (last && last.type === "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding, contextDescription);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
        this.unexpected(arg.start);
      }
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding, contextDescription);
  }
  return exprList;
};

// Convert list of expression atoms to a list of

_babylonlibparserlvaljs6112_pp.toReferencedList = function (exprList) {
  return exprList;
};

// Parses spread element.

_babylonlibparserlvaljs6112_pp.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

_babylonlibparserlvaljs6112_pp.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseBindingIdentifier();
  return this.finishNode(node, "RestElement");
};

_babylonlibparserlvaljs6112_pp.shouldAllowYieldIdentifier = function () {
  return this.match(_babylonlibparserlvaljs6112__types.types._yield) && !this.state.strict && !this.state.inGenerator;
};

_babylonlibparserlvaljs6112_pp.parseBindingIdentifier = function () {
  return this.parseIdentifier(this.shouldAllowYieldIdentifier());
};

// Parses lvalue (assignable) atom.

_babylonlibparserlvaljs6112_pp.parseBindingAtom = function () {
  switch (this.state.type) {
    case _babylonlibparserlvaljs6112__types.types._yield:
      if (this.state.strict || this.state.inGenerator) this.unexpected();
    // fall-through
    case _babylonlibparserlvaljs6112__types.types.name:
      return this.parseIdentifier(true);

    case _babylonlibparserlvaljs6112__types.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_babylonlibparserlvaljs6112__types.types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");

    case _babylonlibparserlvaljs6112__types.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

_babylonlibparserlvaljs6112_pp.parseBindingList = function (close, allowEmpty) {
  var elts = [];
  var first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserlvaljs6112__types.types.comma);
    }
    if (allowEmpty && this.match(_babylonlibparserlvaljs6112__types.types.comma)) {
      elts.push(null);
    } else if (this.eat(close)) {
      break;
    } else if (this.match(_babylonlibparserlvaljs6112__types.types.ellipsis)) {
      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
      this.expect(close);
      break;
    } else {
      var decorators = [];
      while (this.match(_babylonlibparserlvaljs6112__types.types.at)) {
        decorators.push(this.parseDecorator());
      }
      var left = this.parseMaybeDefault();
      if (decorators.length) {
        left.decorators = decorators;
      }
      this.parseAssignableListItemTypes(left);
      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
    }
  }
  return elts;
};

_babylonlibparserlvaljs6112_pp.parseAssignableListItemTypes = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

_babylonlibparserlvaljs6112_pp.parseMaybeDefault = function (startPos, startLoc, left) {
  startLoc = startLoc || this.state.startLoc;
  startPos = startPos || this.state.start;
  left = left || this.parseBindingAtom();
  if (!this.eat(_babylonlibparserlvaljs6112__types.types.eq)) return left;

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval — something that can be assigned
// to.

_babylonlibparserlvaljs6112_pp.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
  switch (expr.type) {
    case "Identifier":
      if (this.state.strict && (_babylonlibparserlvaljs6112__identifier.reservedWords.strictBind(expr.name) || _babylonlibparserlvaljs6112__identifier.reservedWords.strict(expr.name))) {
        this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }

      if (checkClashes) {
        // we need to prefix this with an underscore for the cases where we have a key of
        // `__proto__`. there's a bug in old V8 where the following wouldn't work:
        //
        //   > var obj = Object.create(null);
        //   undefined
        //   > obj.__proto__
        //   null
        //   > obj.__proto__ = true;
        //   true
        //   > obj.__proto__
        //   null
        var key = "_" + expr.name;

        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.type === "ObjectProperty") prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;

    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var elem = _ref3;

        if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;

    case "RestProperty":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;

    default:
      {
        var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
        this.raise(expr.start, message);
      }
  }
};
/*≠≠ node_modules/babylon/lib/parser/lval.js ≠≠*/

/*== node_modules/babylon/lib/parser/expression.js ==*/
$m['babylon/lib/parser/expression.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparserexpressionjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibparserexpressionjs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparserexpressionjs6112__index2 = _babylonlibparserexpressionjs6112__interopRequireDefault(_babylonlibparserexpressionjs6112__index);

var _babylonlibparserexpressionjs6112__identifier = $m['babylon/lib/util/identifier.js#6.11.2'].exports;

function _babylonlibparserexpressionjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibparserexpressionjs6112_pp = _babylonlibparserexpressionjs6112__index2.default.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

/* eslint indent: 0 */
/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

_babylonlibparserexpressionjs6112_pp.checkPropClash = function (prop, propHash) {
  if (prop.computed) return;

  var key = prop.key;
  var name = void 0;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;

    case "StringLiteral":
    case "NumericLiteral":
      name = String(key.value);
      break;

    default:
      return;
  }

  if (name === "__proto__" && prop.kind === "init") {
    if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
    propHash.proto = true;
  }
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

_babylonlibparserexpressionjs6112_pp.parseExpression = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.match(_babylonlibparserexpressionjs6112__types.types.comma)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_babylonlibparserexpressionjs6112__types.types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    }
    this.toReferencedList(node.expressions);
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

_babylonlibparserexpressionjs6112_pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
  if (this.match(_babylonlibparserexpressionjs6112__types.types._yield) && this.state.inGenerator) {
    return this.parseYield();
  }

  var failOnShorthandAssign = void 0;
  if (refShorthandDefaultPos) {
    failOnShorthandAssign = false;
  } else {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  }

  var startPos = this.state.start;
  var startLoc = this.state.startLoc;

  if (this.match(_babylonlibparserexpressionjs6112__types.types.parenL) || this.match(_babylonlibparserexpressionjs6112__types.types.name)) {
    this.state.potentialArrowAt = this.state.start;
  }

  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.state.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.state.value;
    node.left = this.match(_babylonlibparserexpressionjs6112__types.types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly

    this.checkLVal(left, undefined, undefined, "assignment expression");

    if (left.extra && left.extra.parenthesized) {
      var errorMsg = void 0;
      if (left.type === "ObjectPattern") {
        errorMsg = "`({a}) = 0` use `({a} = 0)`";
      } else if (left.type === "ArrayPattern") {
        errorMsg = "`([a]) = 0` use `([a] = 0)`";
      }
      if (errorMsg) {
        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
      }
    }

    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }

  return left;
};

// Parse a ternary conditional (`?:`) operator.

_babylonlibparserexpressionjs6112_pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
};

_babylonlibparserexpressionjs6112_pp.parseConditional = function (expr, noIn, startPos, startLoc) {
  if (this.eat(_babylonlibparserexpressionjs6112__types.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_babylonlibparserexpressionjs6112__types.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

_babylonlibparserexpressionjs6112_pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  } else {
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

_babylonlibparserexpressionjs6112_pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.state.type.binop;
  if (prec != null && (!noIn || !this.match(_babylonlibparserexpressionjs6112__types.types._in))) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.state.value;

      if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
        this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
      }

      var op = this.state.type;
      this.next();

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);

      this.finishNode(node, op === _babylonlibparserexpressionjs6112__types.types.logicalOR || op === _babylonlibparserexpressionjs6112__types.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

_babylonlibparserexpressionjs6112_pp.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.state.type.prefix) {
    var node = this.startNode();
    var update = this.match(_babylonlibparserexpressionjs6112__types.types.incDec);
    node.operator = this.state.value;
    node.prefix = true;
    this.next();

    var argType = this.state.type;
    node.argument = this.parseMaybeUnary();

    this.addExtra(node, "parenthesizedArgument", argType === _babylonlibparserexpressionjs6112__types.types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (update) {
      this.checkLVal(node.argument, undefined, undefined, "prefix operation");
    } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raise(node.start, "Deleting local variable in strict mode");
    }

    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }

  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.state.type.postfix && !this.canInsertSemicolon()) {
    var _node = this.startNodeAt(startPos, startLoc);
    _node.operator = this.state.value;
    _node.prefix = false;
    _node.argument = expr;
    this.checkLVal(expr, undefined, undefined, "postfix operation");
    this.next();
    expr = this.finishNode(_node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

_babylonlibparserexpressionjs6112_pp.parseExprSubscripts = function (refShorthandDefaultPos) {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var potentialArrowAt = this.state.potentialArrowAt;
  var expr = this.parseExprAtom(refShorthandDefaultPos);

  if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
    return expr;
  }

  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  }

  return this.parseSubscripts(expr, startPos, startLoc);
};

_babylonlibparserexpressionjs6112_pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (!noCalls && this.eat(_babylonlibparserexpressionjs6112__types.types.doubleColon)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.eat(_babylonlibparserexpressionjs6112__types.types.dot)) {
      var _node2 = this.startNodeAt(startPos, startLoc);
      _node2.object = base;
      _node2.property = this.parseIdentifier(true);
      _node2.computed = false;
      base = this.finishNode(_node2, "MemberExpression");
    } else if (this.eat(_babylonlibparserexpressionjs6112__types.types.bracketL)) {
      var _node3 = this.startNodeAt(startPos, startLoc);
      _node3.object = base;
      _node3.property = this.parseExpression();
      _node3.computed = true;
      this.expect(_babylonlibparserexpressionjs6112__types.types.bracketR);
      base = this.finishNode(_node3, "MemberExpression");
    } else if (!noCalls && this.match(_babylonlibparserexpressionjs6112__types.types.parenL)) {
      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
      this.next();

      var _node4 = this.startNodeAt(startPos, startLoc);
      _node4.callee = base;
      _node4.arguments = this.parseCallExpressionArguments(_babylonlibparserexpressionjs6112__types.types.parenR, possibleAsync);
      base = this.finishNode(_node4, "CallExpression");

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
      } else {
        this.toReferencedList(_node4.arguments);
      }
    } else if (this.match(_babylonlibparserexpressionjs6112__types.types.backQuote)) {
      var _node5 = this.startNodeAt(startPos, startLoc);
      _node5.tag = base;
      _node5.quasi = this.parseTemplate();
      base = this.finishNode(_node5, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

_babylonlibparserexpressionjs6112_pp.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
  var innerParenStart = void 0;

  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserexpressionjs6112__types.types.comma);
      if (this.eat(close)) break;
    }

    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
    if (this.match(_babylonlibparserexpressionjs6112__types.types.parenL) && !innerParenStart) {
      innerParenStart = this.state.start;
    }

    elts.push(this.parseExprListItem(undefined, possibleAsyncArrow ? { start: 0 } : undefined));
  }

  // we found an async arrow function so let's not allow any inner parens
  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
    this.unexpected();
  }

  return elts;
};

_babylonlibparserexpressionjs6112_pp.shouldParseAsyncArrow = function () {
  return this.match(_babylonlibparserexpressionjs6112__types.types.arrow);
};

_babylonlibparserexpressionjs6112_pp.parseAsyncArrowFromCallExpression = function (node, call) {
  this.expect(_babylonlibparserexpressionjs6112__types.types.arrow);
  return this.parseArrowExpression(node, call.arguments, true);
};

// Parse a no-call expression (like argument of `new` or `::` operators).

_babylonlibparserexpressionjs6112_pp.parseNoCallExpr = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

_babylonlibparserexpressionjs6112_pp.parseExprAtom = function (refShorthandDefaultPos) {
  var node = void 0,
      canBeArrow = this.state.potentialArrowAt === this.state.start;
  switch (this.state.type) {
    case _babylonlibparserexpressionjs6112__types.types._super:
      if (!this.state.inMethod && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next();
      if (!this.match(_babylonlibparserexpressionjs6112__types.types.parenL) && !this.match(_babylonlibparserexpressionjs6112__types.types.bracketL) && !this.match(_babylonlibparserexpressionjs6112__types.types.dot)) {
        this.unexpected();
      }
      if (this.match(_babylonlibparserexpressionjs6112__types.types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() outside of class constructor");
      }
      return this.finishNode(node, "Super");

    case _babylonlibparserexpressionjs6112__types.types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case _babylonlibparserexpressionjs6112__types.types._yield:
      if (this.state.inGenerator) this.unexpected();

    case _babylonlibparserexpressionjs6112__types.types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);

      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(_babylonlibparserexpressionjs6112__types.types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(_babylonlibparserexpressionjs6112__types.types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(_babylonlibparserexpressionjs6112__types.types.arrow);
        // let foo = bar => {};
        return this.parseArrowExpression(node, params, true);
      }

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_babylonlibparserexpressionjs6112__types.types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }

      return id;

    case _babylonlibparserexpressionjs6112__types.types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }

    case _babylonlibparserexpressionjs6112__types.types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;

    case _babylonlibparserexpressionjs6112__types.types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");

    case _babylonlibparserexpressionjs6112__types.types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");

    case _babylonlibparserexpressionjs6112__types.types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");

    case _babylonlibparserexpressionjs6112__types.types._true:case _babylonlibparserexpressionjs6112__types.types._false:
      node = this.startNode();
      node.value = this.match(_babylonlibparserexpressionjs6112__types.types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");

    case _babylonlibparserexpressionjs6112__types.types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);

    case _babylonlibparserexpressionjs6112__types.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_babylonlibparserexpressionjs6112__types.types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");

    case _babylonlibparserexpressionjs6112__types.types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case _babylonlibparserexpressionjs6112__types.types._function:
      return this.parseFunctionExpression();

    case _babylonlibparserexpressionjs6112__types.types.at:
      this.parseDecorators();

    case _babylonlibparserexpressionjs6112__types.types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);

    case _babylonlibparserexpressionjs6112__types.types._new:
      return this.parseNew();

    case _babylonlibparserexpressionjs6112__types.types.backQuote:
      return this.parseTemplate();

    case _babylonlibparserexpressionjs6112__types.types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }

    default:
      this.unexpected();
  }
};

_babylonlibparserexpressionjs6112_pp.parseFunctionExpression = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);
  if (this.state.inGenerator && this.eat(_babylonlibparserexpressionjs6112__types.types.dot) && this.hasPlugin("functionSent")) {
    return this.parseMetaProperty(node, meta, "sent");
  } else {
    return this.parseFunction(node, false);
  }
};

_babylonlibparserexpressionjs6112_pp.parseMetaProperty = function (node, meta, propertyName) {
  node.meta = meta;
  node.property = this.parseIdentifier(true);

  if (node.property.name !== propertyName) {
    this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
  }

  return this.finishNode(node, "MetaProperty");
};

_babylonlibparserexpressionjs6112_pp.parseLiteral = function (value, type) {
  var node = this.startNode();
  this.addExtra(node, "rawValue", value);
  this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
  node.value = value;
  this.next();
  return this.finishNode(node, type);
};

_babylonlibparserexpressionjs6112_pp.parseParenExpression = function () {
  this.expect(_babylonlibparserexpressionjs6112__types.types.parenL);
  var val = this.parseExpression();
  this.expect(_babylonlibparserexpressionjs6112__types.types.parenR);
  return val;
};

_babylonlibparserexpressionjs6112_pp.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow, isAsync) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var val = void 0;
  this.expect(_babylonlibparserexpressionjs6112__types.types.parenL);

  var innerStartPos = this.state.start,
      innerStartLoc = this.state.startLoc;
  var exprList = [],
      first = true;
  var refShorthandDefaultPos = { start: 0 },
      spreadStart = void 0,
      optionalCommaStart = void 0;
  var refNeedsArrowPos = { start: 0 };
  while (!this.match(_babylonlibparserexpressionjs6112__types.types.parenR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserexpressionjs6112__types.types.comma, refNeedsArrowPos.start || null);
      if (this.match(_babylonlibparserexpressionjs6112__types.types.parenR)) {
        optionalCommaStart = this.state.start;
        break;
      }
    }

    if (this.match(_babylonlibparserexpressionjs6112__types.types.ellipsis)) {
      var spreadNodeStartPos = this.state.start,
          spreadNodeStartLoc = this.state.startLoc;
      spreadStart = this.state.start;
      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartLoc, spreadNodeStartPos));
      break;
    } else {
      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
    }
  }

  var innerEndPos = this.state.start;
  var innerEndLoc = this.state.startLoc;
  this.expect(_babylonlibparserexpressionjs6112__types.types.parenR);

  var arrowNode = this.startNodeAt(startPos, startLoc);
  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var param = _ref;

      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);
    }

    return this.parseArrowExpression(arrowNode, exprList, isAsync);
  }

  if (!exprList.length) {
    if (isAsync) {
      return;
    } else {
      this.unexpected(this.state.lastTokStart);
    }
  }
  if (optionalCommaStart) this.unexpected(optionalCommaStart);
  if (spreadStart) this.unexpected(spreadStart);
  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.toReferencedList(val.expressions);
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }

  this.addExtra(val, "parenthesized", true);
  this.addExtra(val, "parenStart", startPos);

  return val;
};

_babylonlibparserexpressionjs6112_pp.shouldParseArrow = function () {
  return !this.canInsertSemicolon();
};

_babylonlibparserexpressionjs6112_pp.parseArrow = function (node) {
  if (this.eat(_babylonlibparserexpressionjs6112__types.types.arrow)) {
    return node;
  }
};

_babylonlibparserexpressionjs6112_pp.parseParenItem = function (node) {
  return node;
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call — at
// least, not without wrapping it in parentheses. Thus, it uses the

_babylonlibparserexpressionjs6112_pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);

  if (this.eat(_babylonlibparserexpressionjs6112__types.types.dot)) {
    return this.parseMetaProperty(node, meta, "target");
  }

  node.callee = this.parseNoCallExpr();

  if (this.eat(_babylonlibparserexpressionjs6112__types.types.parenL)) {
    node.arguments = this.parseExprList(_babylonlibparserexpressionjs6112__types.types.parenR);
    this.toReferencedList(node.arguments);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

_babylonlibparserexpressionjs6112_pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
    cooked: this.state.value
  };
  this.next();
  elem.tail = this.match(_babylonlibparserexpressionjs6112__types.types.backQuote);
  return this.finishNode(elem, "TemplateElement");
};

_babylonlibparserexpressionjs6112_pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_babylonlibparserexpressionjs6112__types.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_babylonlibparserexpressionjs6112__types.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

_babylonlibparserexpressionjs6112_pp.parseObj = function (isPattern, refShorthandDefaultPos) {
  var decorators = [];
  var propHash = Object.create(null);
  var first = true;
  var node = this.startNode();

  node.properties = [];
  this.next();

  while (!this.eat(_babylonlibparserexpressionjs6112__types.types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserexpressionjs6112__types.types.comma);
      if (this.eat(_babylonlibparserexpressionjs6112__types.types.braceR)) break;
    }

    while (this.match(_babylonlibparserexpressionjs6112__types.types.at)) {
      decorators.push(this.parseDecorator());
    }

    var prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos = void 0,
        startLoc = void 0;
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    if (this.hasPlugin("objectRestSpread") && this.match(_babylonlibparserexpressionjs6112__types.types.ellipsis)) {
      prop = this.parseSpread();
      prop.type = isPattern ? "RestProperty" : "SpreadProperty";
      node.properties.push(prop);
      continue;
    }

    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refShorthandDefaultPos) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(_babylonlibparserexpressionjs6112__types.types.star);
    }

    if (!isPattern && this.isContextual("async")) {
      if (isGenerator) this.unexpected();

      var asyncId = this.parseIdentifier();
      if (this.match(_babylonlibparserexpressionjs6112__types.types.colon) || this.match(_babylonlibparserexpressionjs6112__types.types.parenL) || this.match(_babylonlibparserexpressionjs6112__types.types.braceR)) {
        prop.key = asyncId;
      } else {
        isAsync = true;
        if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(_babylonlibparserexpressionjs6112__types.types.star);
        this.parsePropertyName(prop);
      }
    } else {
      this.parsePropertyName(prop);
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
    this.checkPropClash(prop, propHash);

    if (prop.shorthand) {
      this.addExtra(prop, "shorthand", true);
    }

    node.properties.push(prop);
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no property");
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

_babylonlibparserexpressionjs6112_pp.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
  if (isAsync || isGenerator || this.match(_babylonlibparserexpressionjs6112__types.types.parenL)) {
    if (isPattern) this.unexpected();
    prop.kind = "method";
    prop.method = true;
    this.parseMethod(prop, isGenerator, isAsync);
    return this.finishNode(prop, "ObjectMethod");
  }

  if (this.eat(_babylonlibparserexpressionjs6112__types.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
    return this.finishNode(prop, "ObjectProperty");
  }

  if (!prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && !this.match(_babylonlibparserexpressionjs6112__types.types.comma) && !this.match(_babylonlibparserexpressionjs6112__types.types.braceR)) {
    if (isGenerator || isAsync || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    this.parseMethod(prop, false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.params.length !== paramCount) {
      var start = prop.start;
      if (prop.kind === "get") {
        this.raise(start, "getter should have no params");
      } else {
        this.raise(start, "setter should have exactly one param");
      }
    }
    return this.finishNode(prop, "ObjectMethod");
  }

  if (!prop.computed && prop.key.type === "Identifier") {
    if (isPattern) {
      var illegalBinding = this.isKeyword(prop.key.name);
      if (!illegalBinding && this.state.strict) {
        illegalBinding = _babylonlibparserexpressionjs6112__identifier.reservedWords.strictBind(prop.key.name) || _babylonlibparserexpressionjs6112__identifier.reservedWords.strict(prop.key.name);
      }
      if (illegalBinding) {
        this.raise(prop.key.start, "Binding " + prop.key.name);
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else if (this.match(_babylonlibparserexpressionjs6112__types.types.eq) && refShorthandDefaultPos) {
      if (!refShorthandDefaultPos.start) {
        refShorthandDefaultPos.start = this.state.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else {
      prop.value = prop.key.__clone();
    }
    prop.shorthand = true;
    return this.finishNode(prop, "ObjectProperty");
  }

  this.unexpected();
};

_babylonlibparserexpressionjs6112_pp.parsePropertyName = function (prop) {
  if (this.eat(_babylonlibparserexpressionjs6112__types.types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(_babylonlibparserexpressionjs6112__types.types.bracketR);
    return prop.key;
  } else {
    prop.computed = false;
    return prop.key = this.match(_babylonlibparserexpressionjs6112__types.types.num) || this.match(_babylonlibparserexpressionjs6112__types.types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  }
};

// Initialize empty function node.

_babylonlibparserexpressionjs6112_pp.initFunction = function (node, isAsync) {
  node.id = null;
  node.generator = false;
  node.expression = false;
  node.async = !!isAsync;
};

// Parse object or class method.

_babylonlibparserexpressionjs6112_pp.parseMethod = function (node, isGenerator, isAsync) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = node.kind || true;
  this.initFunction(node, isAsync);
  this.expect(_babylonlibparserexpressionjs6112__types.types.parenL);
  node.params = this.parseBindingList(_babylonlibparserexpressionjs6112__types.types.parenR);
  node.generator = isGenerator;
  this.parseFunctionBody(node);
  this.state.inMethod = oldInMethod;
  return node;
};

// Parse arrow function expression with given parameters.

_babylonlibparserexpressionjs6112_pp.parseArrowExpression = function (node, params, isAsync) {
  this.initFunction(node, isAsync);
  node.params = this.toAssignableList(params, true, "arrow function parameters");
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

// Parse function body and check parameters.

_babylonlibparserexpressionjs6112_pp.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && !this.match(_babylonlibparserexpressionjs6112__types.types.braceL);

  var oldInAsync = this.state.inAsync;
  this.state.inAsync = node.async;
  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.state.inFunction,
        oldInGen = this.state.inGenerator,
        oldLabels = this.state.labels;
    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;
  }
  this.state.inAsync = oldInAsync;

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  var checkLVal = this.state.strict;
  var isStrict = false;

  // arrow function
  if (allowExpression) checkLVal = true;

  // normal function
  if (!isExpression && node.body.directives.length) {
    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var directive = _ref2;

      if (directive.value.value === "use strict") {
        isStrict = true;
        checkLVal = true;
        break;
      }
    }
  }

  //
  if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
    this.raise(node.id.start, "Binding yield in strict mode");
  }

  if (checkLVal) {
    var nameHash = Object.create(null);
    var oldStrict = this.state.strict;
    if (isStrict) this.state.strict = true;
    if (node.id) {
      this.checkLVal(node.id, true, undefined, "function name");
    }
    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var param = _ref3;

      if (isStrict && param.type !== "Identifier") {
        this.raise(param.start, "Non-simple parameter in strict mode");
      }
      this.checkLVal(param, true, nameHash, "function parameter list");
    }
    this.state.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

_babylonlibparserexpressionjs6112_pp.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(_babylonlibparserexpressionjs6112__types.types.comma);
      if (this.eat(close)) break;
    }

    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
  }
  return elts;
};

_babylonlibparserexpressionjs6112_pp.parseExprListItem = function (allowEmpty, refShorthandDefaultPos) {
  var elt = void 0;
  if (allowEmpty && this.match(_babylonlibparserexpressionjs6112__types.types.comma)) {
    elt = null;
  } else if (this.match(_babylonlibparserexpressionjs6112__types.types.ellipsis)) {
    elt = this.parseSpread(refShorthandDefaultPos);
  } else {
    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem);
  }
  return elt;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

_babylonlibparserexpressionjs6112_pp.parseIdentifier = function (liberal) {
  var node = this.startNode();

  if (this.match(_babylonlibparserexpressionjs6112__types.types.name)) {
    if (!liberal && this.state.strict && _babylonlibparserexpressionjs6112__identifier.reservedWords.strict(this.state.value)) {
      this.raise(this.state.start, "The keyword '" + this.state.value + "' is reserved");
    }

    node.name = this.state.value;
  } else if (liberal && this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }

  if (!liberal && node.name === "await" && this.state.inAsync) {
    this.raise(node.start, "invalid use of await inside of an async function");
  }

  node.loc.identifierName = node.name;

  this.next();
  return this.finishNode(node, "Identifier");
};

// Parses await expression inside async function.

_babylonlibparserexpressionjs6112_pp.parseAwait = function (node) {
  if (!this.state.inAsync) {
    this.unexpected();
  }
  if (this.match(_babylonlibparserexpressionjs6112__types.types.star)) {
    this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
  }
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};

// Parses yield expression inside generator.

_babylonlibparserexpressionjs6112_pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.match(_babylonlibparserexpressionjs6112__types.types.semi) || this.canInsertSemicolon() || !this.match(_babylonlibparserexpressionjs6112__types.types.star) && !this.state.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_babylonlibparserexpressionjs6112__types.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};
/*≠≠ node_modules/babylon/lib/parser/expression.js ≠≠*/

/*== node_modules/babylon/lib/parser/node.js ==*/
$m['babylon/lib/parser/node.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparsernodejs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparsernodejs6112__index2 = _babylonlibparsernodejs6112__interopRequireDefault(_babylonlibparsernodejs6112__index);

var _babylonlibparsernodejs6112__location = $m['babylon/lib/util/location.js#6.11.2'].exports;

function _babylonlibparsernodejs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babylonlibparsernodejs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// Start an AST node, attaching a start offset.

var _babylonlibparsernodejs6112_pp = _babylonlibparsernodejs6112__index2.default.prototype;
var _babylonlibparsernodejs6112_commentKeys = ["leadingComments", "trailingComments", "innerComments"];

var _babylonlibparsernodejs6112_Node = function () {
  function Node(pos, loc, filename) {
    _babylonlibparsernodejs6112__classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new _babylonlibparsernodejs6112__location.SourceLocation(loc);
    if (filename) this.loc.filename = filename;
  }

  Node.prototype.__clone = function __clone() {
    var node2 = new Node();
    for (var key in this) {
      // Do not clone comments that are already attached to the node
      if (_babylonlibparsernodejs6112_commentKeys.indexOf(key) < 0) {
        node2[key] = this[key];
      }
    }

    return node2;
  };

  return Node;
}();

_babylonlibparsernodejs6112_pp.startNode = function () {
  return new _babylonlibparsernodejs6112_Node(this.state.start, this.state.startLoc, this.filename);
};

_babylonlibparsernodejs6112_pp.startNodeAt = function (pos, loc) {
  return new _babylonlibparsernodejs6112_Node(pos, loc, this.filename);
};

function _babylonlibparsernodejs6112_finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  node.loc.end = loc;
  this.processComment(node);
  return node;
}

// Finish an AST node, adding `type` and `end` properties.

_babylonlibparsernodejs6112_pp.finishNode = function (node, type) {
  return _babylonlibparsernodejs6112_finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
};

// Finish node at given position

_babylonlibparsernodejs6112_pp.finishNodeAt = function (node, type, pos, loc) {
  return _babylonlibparsernodejs6112_finishNodeAt.call(this, node, type, pos, loc);
};
/*≠≠ node_modules/babylon/lib/parser/node.js ≠≠*/

/*== node_modules/babylon/lib/parser/location.js ==*/
$m['babylon/lib/parser/location.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparserlocationjs6112__location = $m['babylon/lib/util/location.js#6.11.2'].exports;

var _babylonlibparserlocationjs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparserlocationjs6112__index2 = _babylonlibparserlocationjs6112__interopRequireDefault(_babylonlibparserlocationjs6112__index);

function _babylonlibparserlocationjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibparserlocationjs6112_pp = _babylonlibparserlocationjs6112__index2.default.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

_babylonlibparserlocationjs6112_pp.raise = function (pos, message) {
  var loc = (0, _babylonlibparserlocationjs6112__location.getLineInfo)(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  throw err;
};
/*≠≠ node_modules/babylon/lib/parser/location.js ≠≠*/

/*== node_modules/babylon/lib/parser/comments.js ==*/
$m['babylon/lib/parser/comments.js#6.11.2'] = { exports: {} };
"use strict";

var _babylonlibparsercommentsjs6112__index = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibparsercommentsjs6112__index2 = _babylonlibparsercommentsjs6112__interopRequireDefault(_babylonlibparsercommentsjs6112__index);

function _babylonlibparsercommentsjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babylonlibparsercommentsjs6112_last(stack) {
  return stack[stack.length - 1];
} /* eslint max-len: 0 */

/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var _babylonlibparsercommentsjs6112_pp = _babylonlibparsercommentsjs6112__index2.default.prototype;

_babylonlibparsercommentsjs6112_pp.addComment = function (comment) {
  if (this.filename) comment.loc.filename = this.filename;
  this.state.trailingComments.push(comment);
  this.state.leadingComments.push(comment);
};

_babylonlibparsercommentsjs6112_pp.processComment = function (node) {
  if (node.type === "Program" && node.body.length > 0) return;

  var stack = this.state.commentStack;

  var lastChild = void 0,
      trailingComments = void 0,
      i = void 0,
      j = void 0;

  if (this.state.trailingComments.length > 0) {
    // If the first comment in trailingComments comes after the
    // current node, then we're good - all comments in the array will
    // come after the node and so it's safe to add them as official
    // trailingComments.
    if (this.state.trailingComments[0].start >= node.end) {
      trailingComments = this.state.trailingComments;
      this.state.trailingComments = [];
    } else {
      // Otherwise, if the first comment doesn't come after the
      // current node, that means we have a mix of leading and trailing
      // comments in the array and that leadingComments contains the
      // same items as trailingComments. Reset trailingComments to
      // zero items and we'll handle this by evaluating leadingComments
      // later.
      this.state.trailingComments.length = 0;
    }
  } else {
    var lastInStack = _babylonlibparsercommentsjs6112_last(stack);
    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
      trailingComments = lastInStack.trailingComments;
      lastInStack.trailingComments = null;
    }
  }

  // Eating the stack.
  while (stack.length > 0 && _babylonlibparsercommentsjs6112_last(stack).start >= node.start) {
    lastChild = stack.pop();
  }

  if (lastChild) {
    if (lastChild.leadingComments) {
      if (lastChild !== node && _babylonlibparsercommentsjs6112_last(lastChild.leadingComments).end <= node.start) {
        node.leadingComments = lastChild.leadingComments;
        lastChild.leadingComments = null;
      } else {
        // A leading comment for an anonymous class had been stolen by its first ClassMethod,
        // so this takes back the leading comment.
        // See also: https://github.com/eslint/espree/issues/158
        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
          if (lastChild.leadingComments[i].end <= node.start) {
            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
            break;
          }
        }
      }
    }
  } else if (this.state.leadingComments.length > 0) {
    if (_babylonlibparsercommentsjs6112_last(this.state.leadingComments).end <= node.start) {
      if (this.state.commentPreviousNode) {
        for (j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }
      }
      if (this.state.leadingComments.length > 0) {
        node.leadingComments = this.state.leadingComments;
        this.state.leadingComments = [];
      }
    } else {
      // https://github.com/eslint/espree/issues/2
      //
      // In special cases, such as return (without a value) and
      // debugger, all comments will end up as leadingComments and
      // will otherwise be eliminated. This step runs when the
      // commentStack is empty and there are comments left
      // in leadingComments.
      //
      // This loop figures out the stopping point between the actual
      // leading and trailing comments by finding the location of the
      // first comment that comes after the given node.
      for (i = 0; i < this.state.leadingComments.length; i++) {
        if (this.state.leadingComments[i].end > node.start) {
          break;
        }
      }

      // Split the array based on the location of the first comment
      // that comes after the node. Keep in mind that this could
      // result in an empty array, and if so, the array must be
      // deleted.
      node.leadingComments = this.state.leadingComments.slice(0, i);
      if (node.leadingComments.length === 0) {
        node.leadingComments = null;
      }

      // Similarly, trailing comments are attached later. The variable
      // must be reset to null if there are no trailing comments.
      trailingComments = this.state.leadingComments.slice(i);
      if (trailingComments.length === 0) {
        trailingComments = null;
      }
    }
  }

  this.state.commentPreviousNode = node;

  if (trailingComments) {
    if (trailingComments.length && trailingComments[0].start >= node.start && _babylonlibparsercommentsjs6112_last(trailingComments).end <= node.end) {
      node.innerComments = trailingComments;
    } else {
      node.trailingComments = trailingComments;
    }
  }

  stack.push(node);
};
/*≠≠ node_modules/babylon/lib/parser/comments.js ≠≠*/

/*== node_modules/babylon/lib/tokenizer/types.js ==*/
$m['babylon/lib/tokenizer/types.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/tokenizer/types.js#6.11.2'].exports.__esModule = true;

function _babylonlibtokenizertypesjs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var _babylonlibtokenizertypesjs6112_TokenType = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports.TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  _babylonlibtokenizertypesjs6112__classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function _babylonlibtokenizertypesjs6112_binop(name, prec) {
  return new _babylonlibtokenizertypesjs6112_TokenType(name, { beforeExpr: true, binop: prec });
}
var _babylonlibtokenizertypesjs6112_beforeExpr = { beforeExpr: true },
    _babylonlibtokenizertypesjs6112_startsExpr = { startsExpr: true };

var _babylonlibtokenizertypesjs6112_types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports.types = {
  num: new _babylonlibtokenizertypesjs6112_TokenType("num", _babylonlibtokenizertypesjs6112_startsExpr),
  regexp: new _babylonlibtokenizertypesjs6112_TokenType("regexp", _babylonlibtokenizertypesjs6112_startsExpr),
  string: new _babylonlibtokenizertypesjs6112_TokenType("string", _babylonlibtokenizertypesjs6112_startsExpr),
  name: new _babylonlibtokenizertypesjs6112_TokenType("name", _babylonlibtokenizertypesjs6112_startsExpr),
  eof: new _babylonlibtokenizertypesjs6112_TokenType("eof"),

  // Punctuation token types.
  bracketL: new _babylonlibtokenizertypesjs6112_TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new _babylonlibtokenizertypesjs6112_TokenType("]"),
  braceL: new _babylonlibtokenizertypesjs6112_TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceBarL: new _babylonlibtokenizertypesjs6112_TokenType("{|", { beforeExpr: true, startsExpr: true }),
  braceR: new _babylonlibtokenizertypesjs6112_TokenType("}"),
  braceBarR: new _babylonlibtokenizertypesjs6112_TokenType("|}"),
  parenL: new _babylonlibtokenizertypesjs6112_TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new _babylonlibtokenizertypesjs6112_TokenType(")"),
  comma: new _babylonlibtokenizertypesjs6112_TokenType(",", _babylonlibtokenizertypesjs6112_beforeExpr),
  semi: new _babylonlibtokenizertypesjs6112_TokenType(";", _babylonlibtokenizertypesjs6112_beforeExpr),
  colon: new _babylonlibtokenizertypesjs6112_TokenType(":", _babylonlibtokenizertypesjs6112_beforeExpr),
  doubleColon: new _babylonlibtokenizertypesjs6112_TokenType("::", _babylonlibtokenizertypesjs6112_beforeExpr),
  dot: new _babylonlibtokenizertypesjs6112_TokenType("."),
  question: new _babylonlibtokenizertypesjs6112_TokenType("?", _babylonlibtokenizertypesjs6112_beforeExpr),
  arrow: new _babylonlibtokenizertypesjs6112_TokenType("=>", _babylonlibtokenizertypesjs6112_beforeExpr),
  template: new _babylonlibtokenizertypesjs6112_TokenType("template"),
  ellipsis: new _babylonlibtokenizertypesjs6112_TokenType("...", _babylonlibtokenizertypesjs6112_beforeExpr),
  backQuote: new _babylonlibtokenizertypesjs6112_TokenType("`", _babylonlibtokenizertypesjs6112_startsExpr),
  dollarBraceL: new _babylonlibtokenizertypesjs6112_TokenType("${", { beforeExpr: true, startsExpr: true }),
  at: new _babylonlibtokenizertypesjs6112_TokenType("@"),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new _babylonlibtokenizertypesjs6112_TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new _babylonlibtokenizertypesjs6112_TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new _babylonlibtokenizertypesjs6112_TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new _babylonlibtokenizertypesjs6112_TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: _babylonlibtokenizertypesjs6112_binop("||", 1),
  logicalAND: _babylonlibtokenizertypesjs6112_binop("&&", 2),
  bitwiseOR: _babylonlibtokenizertypesjs6112_binop("|", 3),
  bitwiseXOR: _babylonlibtokenizertypesjs6112_binop("^", 4),
  bitwiseAND: _babylonlibtokenizertypesjs6112_binop("&", 5),
  equality: _babylonlibtokenizertypesjs6112_binop("==/!=", 6),
  relational: _babylonlibtokenizertypesjs6112_binop("</>", 7),
  bitShift: _babylonlibtokenizertypesjs6112_binop("<</>>", 8),
  plusMin: new _babylonlibtokenizertypesjs6112_TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: _babylonlibtokenizertypesjs6112_binop("%", 10),
  star: _babylonlibtokenizertypesjs6112_binop("*", 10),
  slash: _babylonlibtokenizertypesjs6112_binop("/", 10),
  exponent: new _babylonlibtokenizertypesjs6112_TokenType("**", { beforeExpr: true, binop: 11, rightAssociative: true })
};

// Map keyword names to token types.

var _babylonlibtokenizertypesjs6112_keywords = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports.keywords = {};

// Succinct definitions of keyword token types
function _babylonlibtokenizertypesjs6112_kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  _babylonlibtokenizertypesjs6112_keywords[name] = _babylonlibtokenizertypesjs6112_types["_" + name] = new _babylonlibtokenizertypesjs6112_TokenType(name, options);
}

_babylonlibtokenizertypesjs6112_kw("break");
_babylonlibtokenizertypesjs6112_kw("case", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("catch");
_babylonlibtokenizertypesjs6112_kw("continue");
_babylonlibtokenizertypesjs6112_kw("debugger");
_babylonlibtokenizertypesjs6112_kw("default", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("do", { isLoop: true, beforeExpr: true });
_babylonlibtokenizertypesjs6112_kw("else", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("finally");
_babylonlibtokenizertypesjs6112_kw("for", { isLoop: true });
_babylonlibtokenizertypesjs6112_kw("function", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("if");
_babylonlibtokenizertypesjs6112_kw("return", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("switch");
_babylonlibtokenizertypesjs6112_kw("throw", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("try");
_babylonlibtokenizertypesjs6112_kw("var");
_babylonlibtokenizertypesjs6112_kw("let");
_babylonlibtokenizertypesjs6112_kw("const");
_babylonlibtokenizertypesjs6112_kw("while", { isLoop: true });
_babylonlibtokenizertypesjs6112_kw("with");
_babylonlibtokenizertypesjs6112_kw("new", { beforeExpr: true, startsExpr: true });
_babylonlibtokenizertypesjs6112_kw("this", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("super", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("class");
_babylonlibtokenizertypesjs6112_kw("extends", _babylonlibtokenizertypesjs6112_beforeExpr);
_babylonlibtokenizertypesjs6112_kw("export");
_babylonlibtokenizertypesjs6112_kw("import");
_babylonlibtokenizertypesjs6112_kw("yield", { beforeExpr: true, startsExpr: true });
_babylonlibtokenizertypesjs6112_kw("null", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("true", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("false", _babylonlibtokenizertypesjs6112_startsExpr);
_babylonlibtokenizertypesjs6112_kw("in", { beforeExpr: true, binop: 7 });
_babylonlibtokenizertypesjs6112_kw("instanceof", { beforeExpr: true, binop: 7 });
_babylonlibtokenizertypesjs6112_kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
_babylonlibtokenizertypesjs6112_kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
_babylonlibtokenizertypesjs6112_kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });
/*≠≠ node_modules/babylon/lib/tokenizer/types.js ≠≠*/

/*== node_modules/babylon/lib/tokenizer/index.js ==*/
$m['babylon/lib/tokenizer/index.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/tokenizer/index.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/tokenizer/index.js#6.11.2'].exports.Token = undefined;

var _babylonlibtokenizerindexjs6112__identifier = $m['babylon/lib/util/identifier.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__context = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__location = $m['babylon/lib/util/location.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__state = $m['babylon/lib/tokenizer/state.js#6.11.2'].exports;

var _babylonlibtokenizerindexjs6112__state2 = _babylonlibtokenizerindexjs6112__interopRequireDefault(_babylonlibtokenizerindexjs6112__state);

function _babylonlibtokenizerindexjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babylonlibtokenizerindexjs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
} /* eslint max-len: 0 */
/* eslint indent: 0 */

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var _babylonlibtokenizerindexjs6112_Token = $m['babylon/lib/tokenizer/index.js#6.11.2'].exports.Token = function Token(state) {
  _babylonlibtokenizerindexjs6112__classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new _babylonlibtokenizerindexjs6112__location.SourceLocation(state.startLoc, state.endLoc);
};

// ## Tokenizer

function _babylonlibtokenizerindexjs6112_codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  } else {
    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
  }
}

var _babylonlibtokenizerindexjs6112_Tokenizer = function () {
  function Tokenizer(options, input) {
    _babylonlibtokenizerindexjs6112__classCallCheck(this, Tokenizer);

    this.state = new _babylonlibtokenizerindexjs6112__state2.default();
    this.state.init(options, input);
  }

  // Move to the next token

  Tokenizer.prototype.next = function next() {
    if (!this.isLookahead) {
      this.state.tokens.push(new _babylonlibtokenizerindexjs6112_Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  };

  // TODO

  Tokenizer.prototype.eat = function eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // TODO

  Tokenizer.prototype.match = function match(type) {
    return this.state.type === type;
  };

  // TODO

  Tokenizer.prototype.isKeyword = function isKeyword(word) {
    return (0, _babylonlibtokenizerindexjs6112__identifier.isKeyword)(word);
  };

  // TODO

  Tokenizer.prototype.lookahead = function lookahead() {
    var old = this.state;
    this.state = old.clone(true);

    this.isLookahead = true;
    this.next();
    this.isLookahead = false;

    var curr = this.state.clone(true);
    this.state = old;
    return curr;
  };

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  Tokenizer.prototype.setStrict = function setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(_babylonlibtokenizerindexjs6112__types.types.num) && !this.match(_babylonlibtokenizerindexjs6112__types.types.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  };

  Tokenizer.prototype.curContext = function curContext() {
    return this.state.context[this.state.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  Tokenizer.prototype.nextToken = function nextToken() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();

    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.eof);

    if (curContext.override) {
      return curContext.override(this);
    } else {
      return this.readToken(this.fullCharCodeAtPos());
    }
  };

  Tokenizer.prototype.readToken = function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if ((0, _babylonlibtokenizerindexjs6112__identifier.isIdentifierStart)(code) || code === 92 /* '\' */) {
        return this.readWord();
      } else {
      return this.getTokenFromCode(code);
    }
  };

  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
    var code = this.input.charCodeAt(this.state.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;

    var next = this.input.charCodeAt(this.state.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };

  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new _babylonlibtokenizerindexjs6112__location.SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  };

  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
    var startLoc = this.state.curPosition();
    var start = this.state.pos,
        end = this.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");

    this.state.pos = end + 2;
    _babylonlibtokenizerindexjs6112__whitespace.lineBreakG.lastIndex = start;
    var match = void 0;
    while ((match = _babylonlibtokenizerindexjs6112__whitespace.lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  };

  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
    var start = this.state.pos;
    var startLoc = this.state.curPosition();
    var ch = this.input.charCodeAt(this.state.pos += startSkip);
    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++this.state.pos;
      ch = this.input.charCodeAt(this.state.pos);
    }

    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  Tokenizer.prototype.skipSpace = function skipSpace() {
    loop: while (this.state.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 32:case 160:
          // ' '
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:case 8232:case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          // '/'
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && _babylonlibtokenizerindexjs6112__whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  Tokenizer.prototype.finishToken = function finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    var prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //


  Tokenizer.prototype.readToken_dot = function readToken_dot() {
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }

    var next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.state.pos += 3;
      return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.ellipsis);
    } else {
      ++this.state.pos;
      return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.dot);
    }
  };

  Tokenizer.prototype.readToken_slash = function readToken_slash() {
    // '/'
    if (this.state.exprAllowed) {
      ++this.state.pos;
      return this.readRegexp();
    }

    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.assign, 2);
    } else {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.slash, 1);
    }
  };

  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
    // '%*'
    var type = code === 42 ? _babylonlibtokenizerindexjs6112__types.types.star : _babylonlibtokenizerindexjs6112__types.types.modulo;
    var width = 1;
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 42) {
      // '*'
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = _babylonlibtokenizerindexjs6112__types.types.exponent;
    }

    if (next === 61) {
      width++;
      type = _babylonlibtokenizerindexjs6112__types.types.assign;
    }

    return this.finishOp(type, width);
  };

  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
    // '|&'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) return this.finishOp(code === 124 ? _babylonlibtokenizerindexjs6112__types.types.logicalOR : _babylonlibtokenizerindexjs6112__types.types.logicalAND, 2);
    if (next === 61) return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.assign, 2);
    if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.braceBarR, 2);
    return this.finishOp(code === 124 ? _babylonlibtokenizerindexjs6112__types.types.bitwiseOR : _babylonlibtokenizerindexjs6112__types.types.bitwiseAND, 1);
  };

  Tokenizer.prototype.readToken_caret = function readToken_caret() {
    // '^'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.assign, 2);
    } else {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.bitwiseXOR, 1);
    }
  };

  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
    // '+-'
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && _babylonlibtokenizerindexjs6112__whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.incDec, 2);
    }

    if (next === 61) {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.assign, 2);
    } else {
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.plusMin, 1);
    }
  };

  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
    // '<>'
    var next = this.input.charCodeAt(this.state.pos + 1);
    var size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.assign, size + 1);
      return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.bitShift, size);
    }

    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      if (this.inModule) this.unexpected();
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }

    if (next === 61) {
      // <= | >=
      size = 2;
    }

    return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.relational, size);
  };

  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
    // '=!'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62) {
      // '=>'
      this.state.pos += 2;
      return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.arrow);
    }
    return this.finishOp(code === 61 ? _babylonlibtokenizerindexjs6112__types.types.eq : _babylonlibtokenizerindexjs6112__types.types.prefix, 1);
  };

  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.parenL);
      case 41:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.parenR);
      case 59:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.semi);
      case 44:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.comma);
      case 91:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.bracketL);
      case 93:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.bracketR);

      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.braceL);
        }

      case 125:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.braceR);

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.colon);
        }

      case 63:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.question);
      case 64:
        ++this.state.pos;return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.at);

      case 96:
        // '`'
        ++this.state.pos;
        return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.backQuote);

      case 48:
        // '0'
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();

      case 37:case 42:
        // '%*'
        return this.readToken_mult_modulo(code);

      case 124:case 38:
        // '|&'
        return this.readToken_pipe_amp(code);

      case 94:
        // '^'
        return this.readToken_caret();

      case 43:case 45:
        // '+-'
        return this.readToken_plus_min(code);

      case 60:case 62:
        // '<>'
        return this.readToken_lt_gt(code);

      case 61:case 33:
        // '=!'
        return this.readToken_eq_excl(code);

      case 126:
        // '~'
        return this.finishOp(_babylonlibtokenizerindexjs6112__types.types.prefix, 1);
    }

    this.raise(this.state.pos, "Unexpected character '" + _babylonlibtokenizerindexjs6112_codePointToString(code) + "'");
  };

  Tokenizer.prototype.finishOp = function finishOp(type, size) {
    var str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    return this.finishToken(type, str);
  };

  Tokenizer.prototype.readRegexp = function readRegexp() {
    var escaped = void 0,
        inClass = void 0,
        start = this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.state.pos);
      if (_babylonlibtokenizerindexjs6112__whitespace.lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    var content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = this.readWord1();
    if (mods) {
      var validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    }
    return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.regexp, {
      pattern: content,
      flags: mods
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  Tokenizer.prototype.readInt = function readInt(radix, len) {
    var start = this.state.pos,
        total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.state.pos),
          val = void 0;
      if (code >= 97) {
        val = code - 97 + 10; // a
      } else if (code >= 65) {
        val = code - 65 + 10; // A
      } else if (code >= 48 && code <= 57) {
        val = code - 48; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;

    return total;
  };

  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
    this.state.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix);
    if ((0, _babylonlibtokenizerindexjs6112__identifier.isIdentifierStart)(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");
    return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
    var start = this.state.pos,
        isFloat = false,
        octal = this.input.charCodeAt(this.state.pos) === 48;
    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.state.pos);
    if (next === 46) {
      // '.'
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (next === 69 || next === 101) {
      // 'eE'
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) ++this.state.pos; // '+-'
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
    }
    if ((0, _babylonlibtokenizerindexjs6112__identifier.isIdentifierStart)(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");

    var str = this.input.slice(start, this.state.pos),
        val = void 0;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!octal || str.length === 1) {
      val = parseInt(str, 10);
    } else if (/[89]/.test(str) || this.state.strict) {
      this.raise(start, "Invalid number");
    } else {
      val = parseInt(str, 8);
    }
    return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  Tokenizer.prototype.readCodePoint = function readCodePoint() {
    var ch = this.input.charCodeAt(this.state.pos),
        code = void 0;

    if (ch === 123) {
      var codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos);
      ++this.state.pos;
      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
    } else {
      code = this.readHexChar(4);
    }
    return code;
  };

  Tokenizer.prototype.readString = function readString(quote) {
    var out = "",
        chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else {
        if ((0, _babylonlibtokenizerindexjs6112__whitespace.isNewLine)(ch)) this.raise(this.state.start, "Unterminated string constant");
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.string, out);
  };

  // Reads template string tokens.

  Tokenizer.prototype.readTmplToken = function readTmplToken() {
    var out = "",
        chunkStart = this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        // '`', '${'
        if (this.state.pos === this.state.start && this.match(_babylonlibtokenizerindexjs6112__types.types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.dollarBraceL);
          } else {
            ++this.state.pos;
            return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(_babylonlibtokenizerindexjs6112__types.types.template, out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.state.pos;
      } else if ((0, _babylonlibtokenizerindexjs6112__whitespace.isNewLine)(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  };

  // Used to read escaped characters

  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
    var ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2)); // 'x'
      case 117:
        return _babylonlibtokenizerindexjs6112_codePointToString(this.readCodePoint()); // 'u'
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\u000b"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n'
      case 10:
        // ' \n'
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (!this.state.containsOctal) {
              this.state.containsOctal = true;
              this.state.octalPosition = this.state.pos - 2;
            }
            if (this.state.strict || inTemplate) {
              this.raise(this.state.pos - 2, "Octal literal in strict mode");
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  Tokenizer.prototype.readHexChar = function readHexChar(len) {
    var codePos = this.state.pos;
    var n = this.readInt(16, len);
    if (n === null) this.raise(codePos, "Bad character escape sequence");
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  Tokenizer.prototype.readWord1 = function readWord1() {
    this.state.containsEsc = false;
    var word = "",
        first = true,
        chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if ((0, _babylonlibtokenizerindexjs6112__identifier.isIdentifierChar)(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.state.containsEsc = true;

        word += this.input.slice(chunkStart, this.state.pos);
        var escStart = this.state.pos;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          // "u"
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        var esc = this.readCodePoint();
        if (!(first ? _babylonlibtokenizerindexjs6112__identifier.isIdentifierStart : _babylonlibtokenizerindexjs6112__identifier.isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += _babylonlibtokenizerindexjs6112_codePointToString(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  Tokenizer.prototype.readWord = function readWord() {
    var word = this.readWord1();
    var type = _babylonlibtokenizerindexjs6112__types.types.name;
    if (!this.state.containsEsc && this.isKeyword(word)) {
      type = _babylonlibtokenizerindexjs6112__types.keywords[word];
    }
    return this.finishToken(type, word);
  };

  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
    if (prevType === _babylonlibtokenizerindexjs6112__types.types.colon) {
      var parent = this.curContext();
      if (parent === _babylonlibtokenizerindexjs6112__context.types.braceStatement || parent === _babylonlibtokenizerindexjs6112__context.types.braceExpression) {
        return !parent.isExpr;
      }
    }

    if (prevType === _babylonlibtokenizerindexjs6112__types.types._return) {
      return _babylonlibtokenizerindexjs6112__whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === _babylonlibtokenizerindexjs6112__types.types._else || prevType === _babylonlibtokenizerindexjs6112__types.types.semi || prevType === _babylonlibtokenizerindexjs6112__types.types.eof || prevType === _babylonlibtokenizerindexjs6112__types.types.parenR) {
      return true;
    }

    if (prevType === _babylonlibtokenizerindexjs6112__types.types.braceL) {
      return this.curContext() === _babylonlibtokenizerindexjs6112__context.types.braceStatement;
    }

    return !this.state.exprAllowed;
  };

  Tokenizer.prototype.updateContext = function updateContext(prevType) {
    var update = void 0,
        type = this.state.type;
    if (type.keyword && prevType === _babylonlibtokenizerindexjs6112__types.types.dot) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  };

  return Tokenizer;
}();

$m['babylon/lib/tokenizer/index.js#6.11.2'].exports.default = _babylonlibtokenizerindexjs6112_Tokenizer;
/*≠≠ node_modules/babylon/lib/tokenizer/index.js ≠≠*/

/*== node_modules/babylon/lib/tokenizer/context.js ==*/
$m['babylon/lib/tokenizer/context.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/tokenizer/context.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/tokenizer/context.js#6.11.2'].exports.types = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports.TokContext = undefined;

var _babylonlibtokenizercontextjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibtokenizercontextjs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

function _babylonlibtokenizercontextjs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
} // The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var _babylonlibtokenizercontextjs6112_TokContext = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _babylonlibtokenizercontextjs6112__classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var _babylonlibtokenizercontextjs6112_types = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports.types = {
  braceStatement: new _babylonlibtokenizercontextjs6112_TokContext("{", false),
  braceExpression: new _babylonlibtokenizercontextjs6112_TokContext("{", true),
  templateQuasi: new _babylonlibtokenizercontextjs6112_TokContext("${", true),
  parenStatement: new _babylonlibtokenizercontextjs6112_TokContext("(", false),
  parenExpression: new _babylonlibtokenizercontextjs6112_TokContext("(", true),
  template: new _babylonlibtokenizercontextjs6112_TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new _babylonlibtokenizercontextjs6112_TokContext("function", true)
};

// Token-specific context update code

_babylonlibtokenizercontextjs6112__types.types.parenR.updateContext = _babylonlibtokenizercontextjs6112__types.types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();
  if (out === _babylonlibtokenizercontextjs6112_types.braceStatement && this.curContext() === _babylonlibtokenizercontextjs6112_types.functionExpression) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === _babylonlibtokenizercontextjs6112_types.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};

_babylonlibtokenizercontextjs6112__types.types.name.updateContext = function (prevType) {
  this.state.exprAllowed = false;

  if (prevType === _babylonlibtokenizercontextjs6112__types.types._let || prevType === _babylonlibtokenizercontextjs6112__types.types._const || prevType === _babylonlibtokenizercontextjs6112__types.types._var) {
    if (_babylonlibtokenizercontextjs6112__whitespace.lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
};

_babylonlibtokenizercontextjs6112__types.types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? _babylonlibtokenizercontextjs6112_types.braceStatement : _babylonlibtokenizercontextjs6112_types.braceExpression);
  this.state.exprAllowed = true;
};

_babylonlibtokenizercontextjs6112__types.types.dollarBraceL.updateContext = function () {
  this.state.context.push(_babylonlibtokenizercontextjs6112_types.templateQuasi);
  this.state.exprAllowed = true;
};

_babylonlibtokenizercontextjs6112__types.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _babylonlibtokenizercontextjs6112__types.types._if || prevType === _babylonlibtokenizercontextjs6112__types.types._for || prevType === _babylonlibtokenizercontextjs6112__types.types._with || prevType === _babylonlibtokenizercontextjs6112__types.types._while;
  this.state.context.push(statementParens ? _babylonlibtokenizercontextjs6112_types.parenStatement : _babylonlibtokenizercontextjs6112_types.parenExpression);
  this.state.exprAllowed = true;
};

_babylonlibtokenizercontextjs6112__types.types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

_babylonlibtokenizercontextjs6112__types.types._function.updateContext = function () {
  if (this.curContext() !== _babylonlibtokenizercontextjs6112_types.braceStatement) {
    this.state.context.push(_babylonlibtokenizercontextjs6112_types.functionExpression);
  }

  this.state.exprAllowed = false;
};

_babylonlibtokenizercontextjs6112__types.types.backQuote.updateContext = function () {
  if (this.curContext() === _babylonlibtokenizercontextjs6112_types.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(_babylonlibtokenizercontextjs6112_types.template);
  }
  this.state.exprAllowed = false;
};
/*≠≠ node_modules/babylon/lib/tokenizer/context.js ≠≠*/

/*== node_modules/babylon/lib/plugins/flow.js ==*/
$m['babylon/lib/plugins/flow.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/plugins/flow.js#6.11.2'].exports.__esModule = true;

$m['babylon/lib/plugins/flow.js#6.11.2'].exports.default = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend("parseFunctionBody", function (inner) {
    return function (node, allowExpression) {
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon) && !allowExpression) {
        // if allowExpression is true then we're parsing an arrow function and if
        // there's a return type then it's been handled elsewhere
        node.returnType = this.flowParseTypeAnnotation();
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend("parseStatement", function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it's a reserved word
      if (this.state.strict && this.match(_babylonlibpluginsflowjs6112__types.types.name) && this.state.value === "interface") {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend("parseExpressionStatement", function (inner) {
    return function (node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(_babylonlibpluginsflowjs6112__types.types._class) || this.match(_babylonlibpluginsflowjs6112__types.types.name) || this.match(_babylonlibpluginsflowjs6112__types.types._function) || this.match(_babylonlibpluginsflowjs6112__types.types._var)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(_babylonlibpluginsflowjs6112__types.types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend("shouldParseExportDeclaration", function (inner) {
    return function () {
      return this.isContextual("type") || this.isContextual("interface") || inner.call(this);
    };
  });

  instance.extend("parseConditional", function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos && this.match(_babylonlibpluginsflowjs6112__types.types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend("parseParenItem", function (inner) {
    return function (node, startLoc, startPos) {
      node = inner.call(this, node, startLoc, startPos);
      if (this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
        node.optional = true;
      }

      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        var typeCastNode = this.startNodeAt(startLoc, startPos);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    };
  });

  instance.extend("parseExport", function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === "ExportNamedDeclaration") {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    };
  });

  instance.extend("parseExportDeclaration", function (inner) {
    return function (node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";

        var declarationNode = this.startNode();
        this.next();

        if (this.match(_babylonlibpluginsflowjs6112__types.types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        var _declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend("parseClassId", function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don't consider `void` to be a keyword as then it'll use the void token type
  // and set startExpr
  instance.extend("isKeyword", function (inner) {
    return function (name) {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(_babylonlibpluginsflowjs6112__types.types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don't lex any token as a jsx one inside a flow type
  instance.extend("jsx_readToken", function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding, contextDescription) {
      if (node.type === "TypeCastExpression") {
        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
      } else {
        return inner.call(this, node, isBinding, contextDescription);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend("toAssignableList", function (inner) {
    return function (exprList, isBinding, contextDescription) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding, contextDescription);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we've found that are illegal in this context
  instance.extend("toReferencedList", function () {
    return function (exprList) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend("parseExprListItem", function (inner) {
    return function (allowEmpty, refShorthandDefaultPos) {
      var container = this.startNode();
      var node = inner.call(this, allowEmpty, refShorthandDefaultPos);
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (node) {
      if (node.type !== "TypeCastExpression") {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend("parseClassProperty", function (inner) {
    return function (node) {
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we're currently in the position where a class property would appear
  instance.extend("isClassProperty", function (inner) {
    return function () {
      return this.match(_babylonlibpluginsflowjs6112__types.types.colon) || inner.call(this);
    };
  });

  // parse type parameters for class methods
  instance.extend("parseClassMethod", function () {
    return function (classBody, method, isGenerator, isAsync) {
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.parseMethod(method, isGenerator, isAsync);
      classBody.body.push(this.finishNode(method, "ClassMethod"));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend("parseClassSuper", function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational("<")) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, "ClassImplements"));
        } while (this.eat(_babylonlibpluginsflowjs6112__types.types.comma));
      }
    };
  });

  // parse type parameters for object method shorthand
  instance.extend("parseObjPropValue", function (inner) {
    return function (prop) {
      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(_babylonlibpluginsflowjs6112__types.types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend("parseAssignableListItemTypes", function () {
    return function (param) {
      if (this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
        param.optional = true;
      }
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend("parseMaybeDefault", function (inner) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.apply(this, args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend("parseImportSpecifiers", function (inner) {
    return function (node) {
      node.importKind = "value";

      var kind = null;
      if (this.match(_babylonlibpluginsflowjs6112__types.types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === _babylonlibpluginsflowjs6112__types.types.name && lh.value !== "from" || lh.type === _babylonlibpluginsflowjs6112__types.types.braceL || lh.type === _babylonlibpluginsflowjs6112__types.types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse function type parameters - function foo<T>() {}
  instance.extend("parseFunctionParams", function (inner) {
    return function (node) {
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend("parseVarHead", function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number => {});
  instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
    return function (node, call) {
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        node.returnType = this.flowParseTypeAnnotation();
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend("shouldParseAsyncArrow", function (inner) {
    return function () {
      return this.match(_babylonlibpluginsflowjs6112__types.types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We'll try JSX first. If that
  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
  //    error.
  // 2. This is an arrow function. We'll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend("parseMaybeAssign", function (inner) {
    return function () {
      var jsxError = null;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (_babylonlibpluginsflowjs6112__types.types.jsxTagStart && this.match(_babylonlibpluginsflowjs6112__types.types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            jsxError = err;
          } else {
            throw err;
          }
        }
      }

      // Need to push something onto the context to stop
      // the JSX plugin from messing with the tokens
      this.state.context.push(_babylonlibpluginsflowjs6112__context.types.parenExpression);
      if (jsxError != null || this.isRelational("<")) {
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          arrowExpression.start = typeParameters.start;
          arrowExpression.loc.start = typeParameters.loc.start;
        } catch (err) {
          throw jsxError || err;
        }

        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }
      }
      this.state.context.pop();

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend("parseArrow", function (inner) {
    return function (node) {
      if (this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        var state = this.state.clone();
        try {
          var returnType = this.flowParseTypeAnnotation();
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(_babylonlibpluginsflowjs6112__types.types.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend("shouldParseArrow", function (inner) {
    return function () {
      return this.match(_babylonlibpluginsflowjs6112__types.types.colon) || inner.call(this);
    };
  });

  instance.extend("isClassMutatorStarter", function (inner) {
    return function () {
      if (this.isRelational("<")) {
        return true;
      } else {
        return inner.call(this);
      }
    };
  });
};

var _babylonlibpluginsflowjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibpluginsflowjs6112__context = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports;

var _babylonlibpluginsflowjs6112__parser = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibpluginsflowjs6112__parser2 = _babylonlibpluginsflowjs6112__interopRequireDefault(_babylonlibpluginsflowjs6112__parser);

function _babylonlibpluginsflowjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babylonlibpluginsflowjs6112_pp = _babylonlibpluginsflowjs6112__parser2.default.prototype; /* eslint indent: 0 */
/* eslint max-len: 0 */

_babylonlibpluginsflowjs6112_pp.flowParseTypeInitialiser = function (tok, allowLeadingPipeOrAnd) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || _babylonlibpluginsflowjs6112__types.types.colon);
  if (allowLeadingPipeOrAnd) {
    if (this.match(_babylonlibpluginsflowjs6112__types.types.bitwiseAND) || this.match(_babylonlibpluginsflowjs6112__types.types.bitwiseOR)) {
      this.next();
    }
  }
  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node, true);
  return this.finishNode(node, "DeclareClass");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational("<")) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(_babylonlibpluginsflowjs6112__types.types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(_babylonlibpluginsflowjs6112__types.types.parenR);
  typeNode.returnType = this.flowParseTypeInitialiser();

  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, "DeclareFunction");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclare = function (node) {
  if (this.match(_babylonlibpluginsflowjs6112__types.types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(_babylonlibpluginsflowjs6112__types.types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(_babylonlibpluginsflowjs6112__types.types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual("module")) {
    if (this.lookahead().type === _babylonlibpluginsflowjs6112__types.types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual("type")) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual("interface")) {
    return this.flowParseDeclareInterface(node);
  } else {
    this.unexpected();
  }
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, "DeclareVariable");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(_babylonlibpluginsflowjs6112__types.types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(_babylonlibpluginsflowjs6112__types.types.braceL);
  while (!this.match(_babylonlibpluginsflowjs6112__types.types.braceR)) {
    var node2 = this.startNode();

    this.expectContextual("declare", "Unexpected token. Only declares are allowed inside declare module");

    body.push(this.flowParseDeclare(node2));
  }
  this.expect(_babylonlibpluginsflowjs6112__types.types.braceR);

  this.finishNode(bodyNode, "BlockStatement");
  return this.finishNode(node, "DeclareModule");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareModuleExports = function (node) {
  this.expectContextual("module");
  this.expect(_babylonlibpluginsflowjs6112__types.types.dot);
  this.expectContextual("exports");
  node.typeAnnotation = this.flowParseTypeAnnotation();
  return this.finishNode(node, "DeclareModuleExports");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, "DeclareTypeAlias");
};

_babylonlibpluginsflowjs6112_pp.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareInterface");
};

// Interfaces

_babylonlibpluginsflowjs6112_pp.flowParseInterfaceish = function (node, allowStatic) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(_babylonlibpluginsflowjs6112__types.types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(_babylonlibpluginsflowjs6112__types.types.comma));
  }

  if (this.isContextual("mixins")) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(_babylonlibpluginsflowjs6112__types.types.comma));
  }

  node.body = this.flowParseObjectType(allowStatic);
};

_babylonlibpluginsflowjs6112_pp.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, "InterfaceExtends");
};

_babylonlibpluginsflowjs6112_pp.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node, false);
  return this.finishNode(node, "InterfaceDeclaration");
};

// Type aliases

_babylonlibpluginsflowjs6112_pp.flowParseTypeAlias = function (node) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(_babylonlibpluginsflowjs6112__types.types.eq,
  /*allowLeadingPipeOrAnd*/true);
  this.semicolon();

  return this.finishNode(node, "TypeAlias");
};

// Type annotations

_babylonlibpluginsflowjs6112_pp.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = void 0;
  if (this.match(_babylonlibpluginsflowjs6112__types.types.plusMin)) {
    if (this.state.value === "+") {
      variance = "plus";
    } else if (this.state.value === "-") {
      variance = "minus";
    }
    this.eat(_babylonlibpluginsflowjs6112__types.types.plusMin);
  }

  var ident = this.flowParseTypeAnnotatableIdentifier(false, false);
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(_babylonlibpluginsflowjs6112__types.types.eq)) {
    this.eat(_babylonlibpluginsflowjs6112__types.types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, "TypeParameter");
};

_babylonlibpluginsflowjs6112_pp.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  if (this.isRelational("<") || this.match(_babylonlibpluginsflowjs6112__types.types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(">")) {
      this.expect(_babylonlibpluginsflowjs6112__types.types.comma);
    }
  } while (!this.isRelational(">"));
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterDeclaration");
};

_babylonlibpluginsflowjs6112_pp.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode(),
      oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational("<");
  while (!this.isRelational(">")) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(">")) {
      this.expect(_babylonlibpluginsflowjs6112__types.types.comma);
    }
  }
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterInstantiation");
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectPropertyKey = function () {
  return this.match(_babylonlibpluginsflowjs6112__types.types.num) || this.match(_babylonlibpluginsflowjs6112__types.types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectTypeIndexer = function (node, isStatic) {
  node.static = isStatic;

  this.expect(_babylonlibpluginsflowjs6112__types.types.bracketL);
  node.id = this.flowParseObjectPropertyKey();
  node.key = this.flowParseTypeInitialiser();
  this.expect(_babylonlibpluginsflowjs6112__types.types.bracketR);
  node.value = this.flowParseTypeInitialiser();

  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeIndexer");
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(_babylonlibpluginsflowjs6112__types.types.parenL);
  while (this.match(_babylonlibpluginsflowjs6112__types.types.name)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(_babylonlibpluginsflowjs6112__types.types.parenR)) {
      this.expect(_babylonlibpluginsflowjs6112__types.types.comma);
    }
  }

  if (this.eat(_babylonlibpluginsflowjs6112__types.types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(_babylonlibpluginsflowjs6112__types.types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, "FunctionTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeProperty");
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeCallProperty");
};

_babylonlibpluginsflowjs6112_pp.flowParseObjectType = function (allowStatic, allowExact) {
  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = false;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact && this.match(_babylonlibpluginsflowjs6112__types.types.braceBarL)) {
    this.expect(_babylonlibpluginsflowjs6112__types.types.braceBarL);
    endDelim = _babylonlibpluginsflowjs6112__types.types.braceBarR;
    exact = true;
  } else {
    this.expect(_babylonlibpluginsflowjs6112__types.types.braceL);
    endDelim = _babylonlibpluginsflowjs6112__types.types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start,
        startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic && this.isContextual("static")) {
      this.next();
      isStatic = true;
    }

    if (this.match(_babylonlibpluginsflowjs6112__types.types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic));
    } else if (this.match(_babylonlibpluginsflowjs6112__types.types.parenL) || this.isRelational("<")) {
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, allowStatic));
    } else {
      if (isStatic && this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
        propertyKey = this.parseIdentifier();
      } else {
        propertyKey = this.flowParseObjectPropertyKey();
      }
      if (this.isRelational("<") || this.match(_babylonlibpluginsflowjs6112__types.types.parenL)) {
        // This is a method property
        nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
      } else {
        if (this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
          optional = true;
        }
        node.key = propertyKey;
        node.value = this.flowParseTypeInitialiser();
        node.optional = optional;
        node.static = isStatic;
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
      }
    }

    isStatic = false;
  }

  this.expect(endDelim);

  return this.finishNode(nodeStart, "ObjectTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowObjectTypeSemicolon = function () {
  if (!this.eat(_babylonlibpluginsflowjs6112__types.types.semi) && !this.eat(_babylonlibpluginsflowjs6112__types.types.comma) && !this.match(_babylonlibpluginsflowjs6112__types.types.braceR) && !this.match(_babylonlibpluginsflowjs6112__types.types.braceBarR)) {
    this.unexpected();
  }
};

_babylonlibpluginsflowjs6112_pp.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(_babylonlibpluginsflowjs6112__types.types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, "QualifiedTypeIdentifier");
  }

  return node;
};

_babylonlibpluginsflowjs6112_pp.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, "GenericTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(_babylonlibpluginsflowjs6112__types.types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, "TypeofTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(_babylonlibpluginsflowjs6112__types.types.bracketL);
  // We allow trailing commas
  while (this.state.pos < this.input.length && !this.match(_babylonlibpluginsflowjs6112__types.types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(_babylonlibpluginsflowjs6112__types.types.bracketR)) break;
    this.expect(_babylonlibpluginsflowjs6112__types.types.comma);
  }
  this.expect(_babylonlibpluginsflowjs6112__types.types.bracketR);
  return this.finishNode(node, "TupleTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseFunctionTypeParam = function () {
  var optional = false;
  var node = this.startNode();
  node.name = this.parseIdentifier();
  if (this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
    optional = true;
  }
  node.optional = optional;
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "FunctionTypeParam");
};

_babylonlibpluginsflowjs6112_pp.flowParseFunctionTypeParams = function () {
  var ret = { params: [], rest: null };
  while (this.match(_babylonlibpluginsflowjs6112__types.types.name)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(_babylonlibpluginsflowjs6112__types.types.parenR)) {
      this.expect(_babylonlibpluginsflowjs6112__types.types.comma);
    }
  }
  if (this.eat(_babylonlibpluginsflowjs6112__types.types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

_babylonlibpluginsflowjs6112_pp.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");

    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");

    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");

    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");

    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");

    case "string":
      return this.finishNode(node, "StringTypeAnnotation");

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
_babylonlibpluginsflowjs6112_pp.flowParsePrimaryType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;

  switch (this.state.type) {
    case _babylonlibpluginsflowjs6112__types.types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case _babylonlibpluginsflowjs6112__types.types.braceL:
      return this.flowParseObjectType(false, false);

    case _babylonlibpluginsflowjs6112__types.types.braceBarL:
      return this.flowParseObjectType(false, true);

    case _babylonlibpluginsflowjs6112__types.types.bracketL:
      return this.flowParseTupleType();

    case _babylonlibpluginsflowjs6112__types.types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(_babylonlibpluginsflowjs6112__types.types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(_babylonlibpluginsflowjs6112__types.types.parenR);

        this.expect(_babylonlibpluginsflowjs6112__types.types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;

    case _babylonlibpluginsflowjs6112__types.types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(_babylonlibpluginsflowjs6112__types.types.parenR) && !this.match(_babylonlibpluginsflowjs6112__types.types.ellipsis)) {
        if (this.match(_babylonlibpluginsflowjs6112__types.types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== _babylonlibpluginsflowjs6112__types.types.question && token !== _babylonlibpluginsflowjs6112__types.types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        type = this.flowParseType();
        this.expect(_babylonlibpluginsflowjs6112__types.types.parenR);
        return type;
      }

      tmp = this.flowParseFunctionTypeParams();
      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(_babylonlibpluginsflowjs6112__types.types.parenR);

      this.expect(_babylonlibpluginsflowjs6112__types.types.arrow);

      node.returnType = this.flowParseType();
      node.typeParameters = null;

      return this.finishNode(node, "FunctionTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types.string:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "StringLiteralTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types._true:case _babylonlibpluginsflowjs6112__types.types._false:
      node.value = this.match(_babylonlibpluginsflowjs6112__types.types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(_babylonlibpluginsflowjs6112__types.types.num)) this.unexpected();

        node.value = -this.state.value;
        this.addExtra(node, "rawValue", node.value);
        this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
        this.next();
        return this.finishNode(node, "NumericLiteralTypeAnnotation");
      }

    case _babylonlibpluginsflowjs6112__types.types.num:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "NumericLiteralTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types._null:
      node.value = this.match(_babylonlibpluginsflowjs6112__types.types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types._this:
      node.value = this.match(_babylonlibpluginsflowjs6112__types.types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");

    case _babylonlibpluginsflowjs6112__types.types.star:
      this.next();
      return this.finishNode(node, "ExistentialTypeParam");

    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

_babylonlibpluginsflowjs6112_pp.flowParsePostfixType = function () {
  var node = this.startNode();
  var type = node.elementType = this.flowParsePrimaryType();
  if (this.match(_babylonlibpluginsflowjs6112__types.types.bracketL)) {
    this.expect(_babylonlibpluginsflowjs6112__types.types.bracketL);
    this.expect(_babylonlibpluginsflowjs6112__types.types.bracketR);
    return this.finishNode(node, "ArrayTypeAnnotation");
  } else {
    return type;
  }
};

_babylonlibpluginsflowjs6112_pp.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, "NullableTypeAnnotation");
  } else {
    return this.flowParsePostfixType();
  }
};

_babylonlibpluginsflowjs6112_pp.flowParseIntersectionType = function () {
  var node = this.startNode();
  var type = this.flowParsePrefixType();
  node.types = [type];
  while (this.eat(_babylonlibpluginsflowjs6112__types.types.bitwiseAND)) {
    node.types.push(this.flowParsePrefixType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseUnionType = function () {
  var node = this.startNode();
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(_babylonlibpluginsflowjs6112__types.types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

_babylonlibpluginsflowjs6112_pp.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "TypeAnnotation");
};

_babylonlibpluginsflowjs6112_pp.flowParseTypeAnnotatableIdentifier = function (requireTypeAnnotation, canBeOptionalParam) {

  var ident = this.parseIdentifier();
  var isOptionalParam = false;

  if (canBeOptionalParam && this.eat(_babylonlibpluginsflowjs6112__types.types.question)) {
    this.expect(_babylonlibpluginsflowjs6112__types.types.question);
    isOptionalParam = true;
  }

  if (requireTypeAnnotation || this.match(_babylonlibpluginsflowjs6112__types.types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }

  if (isOptionalParam) {
    ident.optional = true;
    this.finishNode(ident, ident.type);
  }

  return ident;
};

_babylonlibpluginsflowjs6112_pp.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};
/*≠≠ node_modules/babylon/lib/plugins/flow.js ≠≠*/

/*== node_modules/babylon/lib/plugins/jsx/index.js ==*/
$m['babylon/lib/plugins/jsx/index.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/plugins/jsx/index.js#6.11.2'].exports.__esModule = true;

$m['babylon/lib/plugins/jsx/index.js#6.11.2'].exports.default = function (instance) {
  instance.extend("parseExprAtom", function (inner) {
    return function (refShortHandDefaultPos) {
      if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.jsxText)) {
        var node = this.parseLiteral(this.state.value, "JSXText");
        // https://github.com/babel/babel/issues/2078
        node.extra = null;
        return node;
      } else if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return inner.call(this, refShortHandDefaultPos);
      }
    };
  });

  instance.extend("readToken", function (inner) {
    return function (code) {
      var context = this.curContext();

      if (context === _babylonlibpluginsjsxindexjs6112__context.types.j_expr) {
        return this.jsxReadToken();
      }

      if (context === _babylonlibpluginsjsxindexjs6112__context.types.j_oTag || context === _babylonlibpluginsjsxindexjs6112__context.types.j_cTag) {
        if ((0, _babylonlibpluginsjsxindexjs6112__identifier.isIdentifierStart)(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === _babylonlibpluginsjsxindexjs6112__context.types.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart);
      }

      return inner.call(this, code);
    };
  });

  instance.extend("updateContext", function (inner) {
    return function (prevType) {
      if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.braceL)) {
        var curContext = this.curContext();
        if (curContext === _babylonlibpluginsjsxindexjs6112__context.types.j_oTag) {
          this.state.context.push(_babylonlibpluginsjsxindexjs6112__context.types.braceExpression);
        } else if (curContext === _babylonlibpluginsjsxindexjs6112__context.types.j_expr) {
          this.state.context.push(_babylonlibpluginsjsxindexjs6112__context.types.templateQuasi);
        } else {
          inner.call(this, prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.slash) && prevType === _babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(_babylonlibpluginsjsxindexjs6112__context.types.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return inner.call(this, prevType);
      }
    };
  });
};

var _babylonlibpluginsjsxindexjs6112__xhtml = $m['babylon/lib/plugins/jsx/xhtml.js#6.11.2'].exports;

var _babylonlibpluginsjsxindexjs6112__xhtml2 = _babylonlibpluginsjsxindexjs6112__interopRequireDefault(_babylonlibpluginsjsxindexjs6112__xhtml);

var _babylonlibpluginsjsxindexjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

var _babylonlibpluginsjsxindexjs6112__context = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports;

var _babylonlibpluginsjsxindexjs6112__parser = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibpluginsjsxindexjs6112__parser2 = _babylonlibpluginsjsxindexjs6112__interopRequireDefault(_babylonlibpluginsjsxindexjs6112__parser);

var _babylonlibpluginsjsxindexjs6112__identifier = $m['babylon/lib/util/identifier.js#6.11.2'].exports;

var _babylonlibpluginsjsxindexjs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

function _babylonlibpluginsjsxindexjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/* eslint indent: 0 */

var _babylonlibpluginsjsxindexjs6112_HEX_NUMBER = /^[\da-fA-F]+$/;
var _babylonlibpluginsjsxindexjs6112_DECIMAL_NUMBER = /^\d+$/;

_babylonlibpluginsjsxindexjs6112__context.types.j_oTag = new _babylonlibpluginsjsxindexjs6112__context.TokContext("<tag", false);
_babylonlibpluginsjsxindexjs6112__context.types.j_cTag = new _babylonlibpluginsjsxindexjs6112__context.TokContext("</tag", false);
_babylonlibpluginsjsxindexjs6112__context.types.j_expr = new _babylonlibpluginsjsxindexjs6112__context.TokContext("<tag>...</tag>", true, true);

_babylonlibpluginsjsxindexjs6112__types.types.jsxName = new _babylonlibpluginsjsxindexjs6112__types.TokenType("jsxName");
_babylonlibpluginsjsxindexjs6112__types.types.jsxText = new _babylonlibpluginsjsxindexjs6112__types.TokenType("jsxText", { beforeExpr: true });
_babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart = new _babylonlibpluginsjsxindexjs6112__types.TokenType("jsxTagStart", { startsExpr: true });
_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd = new _babylonlibpluginsjsxindexjs6112__types.TokenType("jsxTagEnd");

_babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart.updateContext = function () {
  this.state.context.push(_babylonlibpluginsjsxindexjs6112__context.types.j_expr); // treat as beginning of JSX expression
  this.state.context.push(_babylonlibpluginsjsxindexjs6112__context.types.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};

_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();
  if (out === _babylonlibpluginsjsxindexjs6112__context.types.j_oTag && prevType === _babylonlibpluginsjsxindexjs6112__types.types.slash || out === _babylonlibpluginsjsxindexjs6112__context.types.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === _babylonlibpluginsjsxindexjs6112__context.types.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

var _babylonlibpluginsjsxindexjs6112_pp = _babylonlibpluginsjsxindexjs6112__parser2.default.prototype;

// Reads inline JSX contents token.

_babylonlibpluginsjsxindexjs6112_pp.jsxReadToken = function () {
  var out = "";
  var chunkStart = this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated JSX contents");
    }

    var ch = this.input.charCodeAt(this.state.pos);

    switch (ch) {
      case 60: // "<"
      case 123:
        // "{"
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.jsxText, out);

      case 38:
        // "&"
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;

      default:
        if ((0, _babylonlibpluginsjsxindexjs6112__whitespace.isNewLine)(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
    }
  }
};

_babylonlibpluginsjsxindexjs6112_pp.jsxReadNewLine = function (normalizeCRLF) {
  var ch = this.input.charCodeAt(this.state.pos);
  var out = void 0;
  ++this.state.pos;
  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    ++this.state.pos;
    out = normalizeCRLF ? "\n" : "\r\n";
  } else {
    out = String.fromCharCode(ch);
  }
  ++this.state.curLine;
  this.state.lineStart = this.state.pos;

  return out;
};

_babylonlibpluginsjsxindexjs6112_pp.jsxReadString = function (quote) {
  var out = "";
  var chunkStart = ++this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.state.pos);
    if (ch === quote) break;
    if (ch === 38) {
      // "&"
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadEntity();
      chunkStart = this.state.pos;
    } else if ((0, _babylonlibpluginsjsxindexjs6112__whitespace.isNewLine)(ch)) {
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadNewLine(false);
      chunkStart = this.state.pos;
    } else {
      ++this.state.pos;
    }
  }
  out += this.input.slice(chunkStart, this.state.pos++);
  return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.string, out);
};

_babylonlibpluginsjsxindexjs6112_pp.jsxReadEntity = function () {
  var str = "";
  var count = 0;
  var entity = void 0;
  var ch = this.input[this.state.pos];

  var startPos = ++this.state.pos;
  while (this.state.pos < this.input.length && count++ < 10) {
    ch = this.input[this.state.pos++];
    if (ch === ";") {
      if (str[0] === "#") {
        if (str[1] === "x") {
          str = str.substr(2);
          if (_babylonlibpluginsjsxindexjs6112_HEX_NUMBER.test(str)) entity = String.fromCharCode(parseInt(str, 16));
        } else {
          str = str.substr(1);
          if (_babylonlibpluginsjsxindexjs6112_DECIMAL_NUMBER.test(str)) entity = String.fromCharCode(parseInt(str, 10));
        }
      } else {
        entity = _babylonlibpluginsjsxindexjs6112__xhtml2.default[str];
      }
      break;
    }
    str += ch;
  }
  if (!entity) {
    this.state.pos = startPos;
    return "&";
  }
  return entity;
};

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can"t contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

_babylonlibpluginsjsxindexjs6112_pp.jsxReadWord = function () {
  var ch = void 0;
  var start = this.state.pos;
  do {
    ch = this.input.charCodeAt(++this.state.pos);
  } while ((0, _babylonlibpluginsjsxindexjs6112__identifier.isIdentifierChar)(ch) || ch === 45); // "-"
  return this.finishToken(_babylonlibpluginsjsxindexjs6112__types.types.jsxName, this.input.slice(start, this.state.pos));
};

// Transforms JSX element name to string.

function _babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return _babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(object.object) + "." + _babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(object.property);
  }
}

// Parse next token as JSX identifier

_babylonlibpluginsjsxindexjs6112_pp.jsxParseIdentifier = function () {
  var node = this.startNode();
  if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.jsxName)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "JSXIdentifier");
};

// Parse namespaced identifier.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseNamespacedName = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var name = this.jsxParseIdentifier();
  if (!this.eat(_babylonlibpluginsjsxindexjs6112__types.types.colon)) return name;

  var node = this.startNodeAt(startPos, startLoc);
  node.namespace = name;
  node.name = this.jsxParseIdentifier();
  return this.finishNode(node, "JSXNamespacedName");
};

// Parses element name in any form - namespaced, member
// or single identifier.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseElementName = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var node = this.jsxParseNamespacedName();
  while (this.eat(_babylonlibpluginsjsxindexjs6112__types.types.dot)) {
    var newNode = this.startNodeAt(startPos, startLoc);
    newNode.object = node;
    newNode.property = this.jsxParseIdentifier();
    node = this.finishNode(newNode, "JSXMemberExpression");
  }
  return node;
};

// Parses any type of JSX attribute value.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseAttributeValue = function () {
  var node = void 0;
  switch (this.state.type) {
    case _babylonlibpluginsjsxindexjs6112__types.types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }

    case _babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart:
    case _babylonlibpluginsjsxindexjs6112__types.types.string:
      node = this.parseExprAtom();
      node.extra = null;
      return node;

    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
};

// JSXEmptyExpression is unique type since it doesn't actually parse anything,
// and so it should start at the end of last read token (left brace) and finish
// at the beginning of the next one (right brace).

_babylonlibpluginsjsxindexjs6112_pp.jsxParseEmptyExpression = function () {
  var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
  return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
};

// Parse JSX spread child

_babylonlibpluginsjsxindexjs6112_pp.jsxParseSpreadChild = function () {
  var node = this.startNode();
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.braceL);
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.ellipsis);
  node.expression = this.parseExpression();
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.braceR);

  return this.finishNode(node, "JSXSpreadChild");
};

// Parses JSX expression enclosed into curly brackets.


_babylonlibpluginsjsxindexjs6112_pp.jsxParseExpressionContainer = function () {
  var node = this.startNode();
  this.next();
  if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.braceR)) {
    node.expression = this.jsxParseEmptyExpression();
  } else {
    node.expression = this.parseExpression();
  }
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.braceR);
  return this.finishNode(node, "JSXExpressionContainer");
};

// Parses following JSX attribute name-value pair.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseAttribute = function () {
  var node = this.startNode();
  if (this.eat(_babylonlibpluginsjsxindexjs6112__types.types.braceL)) {
    this.expect(_babylonlibpluginsjsxindexjs6112__types.types.ellipsis);
    node.argument = this.parseMaybeAssign();
    this.expect(_babylonlibpluginsjsxindexjs6112__types.types.braceR);
    return this.finishNode(node, "JSXSpreadAttribute");
  }
  node.name = this.jsxParseNamespacedName();
  node.value = this.eat(_babylonlibpluginsjsxindexjs6112__types.types.eq) ? this.jsxParseAttributeValue() : null;
  return this.finishNode(node, "JSXAttribute");
};

// Parses JSX opening tag starting after "<".

_babylonlibpluginsjsxindexjs6112_pp.jsxParseOpeningElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.attributes = [];
  node.name = this.jsxParseElementName();
  while (!this.match(_babylonlibpluginsjsxindexjs6112__types.types.slash) && !this.match(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd)) {
    node.attributes.push(this.jsxParseAttribute());
  }
  node.selfClosing = this.eat(_babylonlibpluginsjsxindexjs6112__types.types.slash);
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd);
  return this.finishNode(node, "JSXOpeningElement");
};

// Parses JSX closing tag starting after "</".

_babylonlibpluginsjsxindexjs6112_pp.jsxParseClosingElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.name = this.jsxParseElementName();
  this.expect(_babylonlibpluginsjsxindexjs6112__types.types.jsxTagEnd);
  return this.finishNode(node, "JSXClosingElement");
};

// Parses entire JSX element, including it"s opening tag
// (starting after "<"), attributes, contents and closing tag.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  var children = [];
  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
  var closingElement = null;

  if (!openingElement.selfClosing) {
    contents: for (;;) {
      switch (this.state.type) {
        case _babylonlibpluginsjsxindexjs6112__types.types.jsxTagStart:
          startPos = this.state.start;startLoc = this.state.startLoc;
          this.next();
          if (this.eat(_babylonlibpluginsjsxindexjs6112__types.types.slash)) {
            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsxParseElementAt(startPos, startLoc));
          break;

        case _babylonlibpluginsjsxindexjs6112__types.types.jsxText:
          children.push(this.parseExprAtom());
          break;

        case _babylonlibpluginsjsxindexjs6112__types.types.braceL:
          if (this.lookahead().type === _babylonlibpluginsjsxindexjs6112__types.types.ellipsis) {
            children.push(this.jsxParseSpreadChild());
          } else {
            children.push(this.jsxParseExpressionContainer());
          }

          break;

        default:
          this.unexpected();
      }
    }

    if (_babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(closingElement.name) !== _babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(openingElement.name)) {
      this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + _babylonlibpluginsjsxindexjs6112_getQualifiedJSXName(openingElement.name) + ">");
    }
  }

  node.openingElement = openingElement;
  node.closingElement = closingElement;
  node.children = children;
  if (this.match(_babylonlibpluginsjsxindexjs6112__types.types.relational) && this.state.value === "<") {
    this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
  }
  return this.finishNode(node, "JSXElement");
};

// Parses entire JSX element from current position.

_babylonlibpluginsjsxindexjs6112_pp.jsxParseElement = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  this.next();
  return this.jsxParseElementAt(startPos, startLoc);
};
/*≠≠ node_modules/babylon/lib/plugins/jsx/index.js ≠≠*/

/*== node_modules/babylon/lib/index.js ==*/
$m['babylon/lib/index.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/index.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/index.js#6.11.2'].exports.tokTypes = undefined;
$m['babylon/lib/index.js#6.11.2'].exports.parse = _babylonlibindexjs6112_parse;

var _babylonlibindexjs6112__parser = $m['babylon/lib/parser/index.js#6.11.2'].exports;

var _babylonlibindexjs6112__parser2 = _babylonlibindexjs6112__interopRequireDefault(_babylonlibindexjs6112__parser);

$m['babylon/lib/parser/util.js#6.11.2'].exports;

$m['babylon/lib/parser/statement.js#6.11.2'].exports;

$m['babylon/lib/parser/lval.js#6.11.2'].exports;

$m['babylon/lib/parser/expression.js#6.11.2'].exports;

$m['babylon/lib/parser/node.js#6.11.2'].exports;

$m['babylon/lib/parser/location.js#6.11.2'].exports;

$m['babylon/lib/parser/comments.js#6.11.2'].exports;

var _babylonlibindexjs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

$m['babylon/lib/tokenizer/index.js#6.11.2'].exports;

$m['babylon/lib/tokenizer/context.js#6.11.2'].exports;

var _babylonlibindexjs6112__flow = $m['babylon/lib/plugins/flow.js#6.11.2'].exports;

var _babylonlibindexjs6112__flow2 = _babylonlibindexjs6112__interopRequireDefault(_babylonlibindexjs6112__flow);

var _babylonlibindexjs6112__jsx = $m['babylon/lib/plugins/jsx/index.js#6.11.2'].exports;

var _babylonlibindexjs6112__jsx2 = _babylonlibindexjs6112__interopRequireDefault(_babylonlibindexjs6112__jsx);

function _babylonlibindexjs6112__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

_babylonlibindexjs6112__parser.plugins.flow = _babylonlibindexjs6112__flow2.default;
_babylonlibindexjs6112__parser.plugins.jsx = _babylonlibindexjs6112__jsx2.default;

function _babylonlibindexjs6112_parse(input, options) {
  return new _babylonlibindexjs6112__parser2.default(options, input).parse();
}

$m['babylon/lib/index.js#6.11.2'].exports.tokTypes = _babylonlibindexjs6112__types.types;
/*≠≠ node_modules/babylon/lib/index.js ≠≠*/

/*== node_modules/lodash/_apply.js ==*/
$m['lodash/_apply.js#4.16.2'] = { exports: {} };
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function _lodashapplyjs4162_apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

$m['lodash/_apply.js#4.16.2'].exports = _lodashapplyjs4162_apply;
/*≠≠ node_modules/lodash/_apply.js ≠≠*/

/*== node_modules/lodash/_assignInDefaults.js ==*/
$m['lodash/_assignInDefaults.js#4.16.2'] = { exports: {} };
var _lodashassignInDefaultsjs4162_eq = $m['lodash/eq.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashassignInDefaultsjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashassignInDefaultsjs4162_hasOwnProperty = _lodashassignInDefaultsjs4162_objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function _lodashassignInDefaultsjs4162_assignInDefaults(objValue, srcValue, key, object) {
  if (objValue === undefined || _lodashassignInDefaultsjs4162_eq(objValue, _lodashassignInDefaultsjs4162_objectProto[key]) && !_lodashassignInDefaultsjs4162_hasOwnProperty.call(object, key)) {
    return srcValue;
  }
  return objValue;
}

$m['lodash/_assignInDefaults.js#4.16.2'].exports = _lodashassignInDefaultsjs4162_assignInDefaults;
/*≠≠ node_modules/lodash/_assignInDefaults.js ≠≠*/

/*== node_modules/lodash/assignInWith.js ==*/
$m['lodash/assignInWith.js#4.16.2'] = { exports: {} };
var _lodashassignInWithjs4162_copyObject = $m['lodash/_copyObject.js#4.16.2'].exports,
    _lodashassignInWithjs4162_createAssigner = $m['lodash/_createAssigner.js#4.16.2'].exports,
    _lodashassignInWithjs4162_keysIn = $m['lodash/keysIn.js#4.16.2'].exports;

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var _lodashassignInWithjs4162_assignInWith = _lodashassignInWithjs4162_createAssigner(function (object, source, srcIndex, customizer) {
  _lodashassignInWithjs4162_copyObject(source, _lodashassignInWithjs4162_keysIn(source), object, customizer);
});

$m['lodash/assignInWith.js#4.16.2'].exports = _lodashassignInWithjs4162_assignInWith;
/*≠≠ node_modules/lodash/assignInWith.js ≠≠*/

/*== node_modules/lodash/defaults.js ==*/
$m['lodash/defaults.js#4.16.2'] = { exports: {} };
var _lodashdefaultsjs4162_apply = $m['lodash/_apply.js#4.16.2'].exports,
    _lodashdefaultsjs4162_assignInDefaults = $m['lodash/_assignInDefaults.js#4.16.2'].exports,
    _lodashdefaultsjs4162_assignInWith = $m['lodash/assignInWith.js#4.16.2'].exports,
    _lodashdefaultsjs4162_baseRest = $m['lodash/_baseRest.js#4.16.2'].exports;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var _lodashdefaultsjs4162_defaults = _lodashdefaultsjs4162_baseRest(function (args) {
  args.push(undefined, _lodashdefaultsjs4162_assignInDefaults);
  return _lodashdefaultsjs4162_apply(_lodashdefaultsjs4162_assignInWith, undefined, args);
});

$m['lodash/defaults.js#4.16.2'].exports = _lodashdefaultsjs4162_defaults;
/*≠≠ node_modules/lodash/defaults.js ≠≠*/

/*== node_modules/glob/common.js ==*/
$m['glob/common.js#7.1.0'] = { exports: {} };
$m['glob/common.js#7.1.0'].exports.alphasort = _globcommonjs710_alphasort;
$m['glob/common.js#7.1.0'].exports.alphasorti = _globcommonjs710_alphasorti;
$m['glob/common.js#7.1.0'].exports.setopts = _globcommonjs710_setopts;
$m['glob/common.js#7.1.0'].exports.ownProp = _globcommonjs710_ownProp;
$m['glob/common.js#7.1.0'].exports.makeAbs = _globcommonjs710_makeAbs;
$m['glob/common.js#7.1.0'].exports.finish = _globcommonjs710_finish;
$m['glob/common.js#7.1.0'].exports.mark = _globcommonjs710_mark;
$m['glob/common.js#7.1.0'].exports.isIgnored = _globcommonjs710_isIgnored;
$m['glob/common.js#7.1.0'].exports.childrenIgnored = _globcommonjs710_childrenIgnored;

function _globcommonjs710_ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}

var _globcommonjs710_path = require("path");
var _globcommonjs710_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globcommonjs710_isAbsolute = $m['path-is-absolute/index.js#1.0.1'].exports;
var _globcommonjs710_Minimatch = _globcommonjs710_minimatch.Minimatch;

function _globcommonjs710_alphasorti(a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase());
}

function _globcommonjs710_alphasort(a, b) {
  return a.localeCompare(b);
}

function _globcommonjs710_setupIgnores(self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(_globcommonjs710_ignoreMap);
  }
}

// ignore patterns are always in dot:true mode.
function _globcommonjs710_ignoreMap(pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
    gmatcher = new _globcommonjs710_Minimatch(gpattern, { dot: true });
  }

  return {
    matcher: new _globcommonjs710_Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  };
}

function _globcommonjs710_setopts(self, pattern, options) {
  if (!options) options = {};

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir) self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  _globcommonjs710_setupIgnores(self, options);

  self.changedCwd = false;
  var cwd = process.cwd();
  if (!_globcommonjs710_ownProp(options, "cwd")) self.cwd = cwd;else {
    self.cwd = _globcommonjs710_path.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || _globcommonjs710_path.resolve(self.cwd, "/");
  self.root = _globcommonjs710_path.resolve(self.root);
  if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/");

  self.cwdAbs = _globcommonjs710_makeAbs(self, self.cwd);
  self.nomount = !!options.nomount;

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true;
  options.nocomment = true;

  self.minimatch = new _globcommonjs710_Minimatch(pattern, options);
  self.options = self.minimatch.options;
}

function _globcommonjs710_finish(self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i++) {
    var matches = self.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou) all.push(literal);else all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou) all.push.apply(all, m);else m.forEach(function (m) {
        all[m] = true;
      });
    }
  }

  if (!nou) all = Object.keys(all);

  if (!self.nosort) all = all.sort(self.nocase ? _globcommonjs710_alphasorti : _globcommonjs710_alphasort);

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !/\/$/.test(e);
        var c = self.cache[e] || self.cache[_globcommonjs710_makeAbs(self, e)];
        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir;
      });
    }
  }

  if (self.ignore.length) all = all.filter(function (m) {
    return !_globcommonjs710_isIgnored(self, m);
  });

  self.found = all;
}

function _globcommonjs710_mark(self, p) {
  var abs = _globcommonjs710_makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';

    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);

    if (m !== p) {
      var mabs = _globcommonjs710_makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m;
}

// lotta situps...
function _globcommonjs710_makeAbs(self, f) {
  var abs = f;
  if (f.charAt(0) === '/') {
    abs = _globcommonjs710_path.join(self.root, f);
  } else if (_globcommonjs710_isAbsolute(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = _globcommonjs710_path.resolve(self.cwd, f);
  } else {
    abs = _globcommonjs710_path.resolve(f);
  }

  if (process.platform === 'win32') abs = abs.replace(/\\/g, '/');

  return abs;
}

// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function _globcommonjs710_isIgnored(self, path) {
  if (!self.ignore.length) return false;

  return self.ignore.some(function (item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
  });
}

function _globcommonjs710_childrenIgnored(self, path) {
  if (!self.ignore.length) return false;

  return self.ignore.some(function (item) {
    return !!(item.gmatcher && item.gmatcher.match(path));
  });
}
/*≠≠ node_modules/glob/common.js ≠≠*/

/*== node_modules/inherits/inherits_browser.js ==*/
$m['inherits/inherits_browser.js#2.0.3'] = { exports: {} };
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  $m['inherits/inherits_browser.js#2.0.3'].exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  $m['inherits/inherits_browser.js#2.0.3'].exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
/*≠≠ node_modules/inherits/inherits_browser.js ≠≠*/

/*== lib/plugins/react/index.js ==*/
$m['lib/plugins/react/index.js'] = { exports: {} };
'use strict';

const _libpluginsreactindexjs_FILE_EXTENSIONS = ['jsx'];
const _libpluginsreactindexjs_PLUGINS = ['babel-plugin-syntax-jsx', 'babel-plugin-transform-react-display-name', 'babel-plugin-transform-react-jsx'];

$m['lib/plugins/react/index.js'].exports = {
  name: 'react',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileExtensionsForType(_libpluginsreactindexjs_FILE_EXTENSIONS, this.type);
    config.registerTargetVersionForType(this.name, _libpluginsreactindexjs_PLUGINS, this.type);
  }
};
/*≠≠ lib/plugins/react/index.js ≠≠*/

/*== lib/plugins/json/index.js ==*/
$m['lib/plugins/json/index.js'] = { exports: {} };
'use strict';

const _libpluginsjsonindexjs_FILE_EXTENSIONS = ['json'];
const _libpluginsjsonindexjs_WORKFLOW_STANDARD = ['load'];

$m['lib/plugins/json/index.js'].exports = {
  name: 'json',
  type: 'json',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    // Allow json files to be parsed as js also
    config.registerFileExtensionsForType(_libpluginsjsonindexjs_FILE_EXTENSIONS, 'js');
    config.registerFileDefinitionAndExtensionsForType(_libpluginsjsonindexjs_define, _libpluginsjsonindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsjsonindexjs_define(File, utils) {
  return class JSONFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'json', options);

      this.workflows.standard = [_libpluginsjsonindexjs_WORKFLOW_STANDARD];
      // No processing required
      this.workflows.inlineable = [[]];
    }
  };
}
/*≠≠ lib/plugins/json/index.js ≠≠*/

/*== lib/plugins/js/babel-plugin-tr...eplace-module-exports/index.js ==*/
$m['lib/plugins/js/babel-plugin-transform-replace-module-exports/index.js'] = { exports: {} };
'use strict';

/**
 * Plugin to namespace all declarations in root scope
 * @param {Babel} babel
 * @returns {Object}
 */

$m['lib/plugins/js/babel-plugin-transform-replace-module-exports/index.js'].exports = function replaceModuleExports(babel) {
  return {
    visitor: {
      Identifier(path, state) {
        const { opts } = state;
        const { scope } = path;
        const name = path.node.name;

        // Target globals only
        if (!scope.hasBinding(name, true)) {
          // Replace 'module' with '$m[*]'
          if (_libpluginsjsbabelplugintransformreplacemoduleexportsindexjs_isValidIdentifier('module', path)) {
            path.replaceWithSourceString(opts.source);
            // Replace 'exports' with '$m[*]' if not a property of another object
          } else if (_libpluginsjsbabelplugintransformreplacemoduleexportsindexjs_isValidIdentifier('exports', path)) {
            path.replaceWithSourceString(`${ opts.source }.exports`);
          }
        }
      }
    }
  };
};

/**
 * Determine if 'name' is valid identifier
 * @param {String} name
 * @param {Path} path
 * @returns {Boolean}
 */
function _libpluginsjsbabelplugintransformreplacemoduleexportsindexjs_isValidIdentifier(name, path) {
  return path.node.name == name && path.parentPath.get('property') != path && path.parentPath.get('key') != path;
}
/*≠≠ lib/plugins/js/babel-plugin-tr...eplace-module-exports/index.js ≠≠*/

/*== lib/plugins/js/babel-plugin-tr...ace-root-declarations/index.js ==*/
$m['lib/plugins/js/babel-plugin-transform-namespace-root-declarations/index.js'] = { exports: {} };
'use strict';

/**
 * Plugin to namespace all declarations in root scope
 * @param {Babel} babel
 * @returns {Object}
 */

$m['lib/plugins/js/babel-plugin-transform-namespace-root-declarations/index.js'].exports = function namespaceRootDeclarations(babel) {
  return {
    visitor: {
      Program(path, state) {
        // Rename all declarations in root scope
        for (const key in path.scope.bindings) {
          path.scope.bindings[key].scope.rename(key, `${ state.opts.source }${ key }`);
        }
      }
    }
  };
};
/*≠≠ lib/plugins/js/babel-plugin-tr...ace-root-declarations/index.js ≠≠*/

/*== node_modules/babel-core/lib/tr...mation/file/options/removed.js ==*/
$m['babel-core/lib/transformation/file/options/removed.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/options/removed.js#6.16.0'].exports = {
  "auxiliaryComment": {
    "message": "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
  },
  "blacklist": {
    "message": "Put the specific transforms you want in the `plugins` option"
  },
  "breakConfig": {
    "message": "This is not a necessary option in Babel 6"
  },
  "experimental": {
    "message": "Put the specific transforms you want in the `plugins` option"
  },
  "externalHelpers": {
    "message": "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
  },
  "extra": {
    "message": ""
  },
  "jsxPragma": {
    "message": "use the `pragma` option in the `react-jsx` plugin . Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
  },

  "loose": {
    "message": "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
  },
  "metadataUsedHelpers": {
    "message": "Not required anymore as this is enabled by default"
  },
  "modules": {
    "message": "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
  },
  "nonStandard": {
    "message": "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
  },
  "optional": {
    "message": "Put the specific transforms you want in the `plugins` option"
  },
  "sourceMapName": {
    "message": "Use the `sourceMapTarget` option"
  },
  "stage": {
    "message": "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
  },
  "whitelist": {
    "message": "Put the specific transforms you want in the `plugins` option"
  }
};
/*≠≠ node_modules/babel-core/lib/tr...mation/file/options/removed.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/comments.js ==*/
$m['babel-traverse/lib/path/comments.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/comments.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/path/comments.js#6.16.0'].exports.shareCommentsWithSiblings = _babeltraverselibpathcommentsjs6160_shareCommentsWithSiblings;
$m['babel-traverse/lib/path/comments.js#6.16.0'].exports.addComment = _babeltraverselibpathcommentsjs6160_addComment;
$m['babel-traverse/lib/path/comments.js#6.16.0'].exports.addComments = _babeltraverselibpathcommentsjs6160_addComments;
function _babeltraverselibpathcommentsjs6160_shareCommentsWithSiblings() {
  var node = this.node;
  if (!node) return;

  var trailing = node.trailingComments;
  var leading = node.leadingComments;
  if (!trailing && !leading) return;

  var prev = this.getSibling(this.key - 1);
  var next = this.getSibling(this.key + 1);

  if (!prev.node) prev = next;
  if (!next.node) next = prev;

  prev.addComments("trailing", leading);
  next.addComments("leading", trailing);
}

function _babeltraverselibpathcommentsjs6160_addComment(type, content, line) {
  this.addComments(type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

function _babeltraverselibpathcommentsjs6160_addComments(type, comments) {
  if (!comments) return;

  var node = this.node;
  if (!node) return;

  var key = type + "Comments";

  if (node[key]) {
    node[key] = node[key].concat(comments);
  } else {
    node[key] = comments;
  }
}
/*≠≠ node_modules/babel-traverse/lib/path/comments.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/context.js ==*/
$m['babel-traverse/lib/path/context.js#6.16.0'] = function () {
$m['babel-traverse/lib/path/context.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/context.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathcontextjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathcontextjs6160__getIterator3 = _babeltraverselibpathcontextjs6160__interopRequireDefault(_babeltraverselibpathcontextjs6160__getIterator2);

$m['babel-traverse/lib/path/context.js#6.16.0'].exports.call = _babeltraverselibpathcontextjs6160_call;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._call = _babeltraverselibpathcontextjs6160__call;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.isBlacklisted = _babeltraverselibpathcontextjs6160_isBlacklisted;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.visit = _babeltraverselibpathcontextjs6160_visit;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.skip = _babeltraverselibpathcontextjs6160_skip;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.skipKey = _babeltraverselibpathcontextjs6160_skipKey;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.stop = _babeltraverselibpathcontextjs6160_stop;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.setScope = _babeltraverselibpathcontextjs6160_setScope;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.setContext = _babeltraverselibpathcontextjs6160_setContext;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.resync = _babeltraverselibpathcontextjs6160_resync;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._resyncParent = _babeltraverselibpathcontextjs6160__resyncParent;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._resyncKey = _babeltraverselibpathcontextjs6160__resyncKey;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._resyncList = _babeltraverselibpathcontextjs6160__resyncList;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._resyncRemoved = _babeltraverselibpathcontextjs6160__resyncRemoved;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.popContext = _babeltraverselibpathcontextjs6160_popContext;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.pushContext = _babeltraverselibpathcontextjs6160_pushContext;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.setup = _babeltraverselibpathcontextjs6160_setup;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.setKey = _babeltraverselibpathcontextjs6160_setKey;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports.requeue = _babeltraverselibpathcontextjs6160_requeue;
$m['babel-traverse/lib/path/context.js#6.16.0'].exports._getQueueContexts = _babeltraverselibpathcontextjs6160__getQueueContexts;

var _babeltraverselibpathcontextjs6160__index = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathcontextjs6160__index2 = _babeltraverselibpathcontextjs6160__interopRequireDefault(_babeltraverselibpathcontextjs6160__index);

function _babeltraverselibpathcontextjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltraverselibpathcontextjs6160_call(key) {
  var opts = this.opts;

  this.debug(function () {
    return key;
  });

  if (this.node) {
    if (this._call(opts[key])) return true;
  }

  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }

  return false;
}

function _babeltraverselibpathcontextjs6160__call(fns) {
  if (!fns) return false;

  for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathcontextjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (!fn) continue;

    var node = this.node;
    if (!node) return true;

    var ret = fn.call(this.state, this, this.state);
    if (ret) throw new Error("Unexpected return value from visitor method " + fn);

    if (this.node !== node) return true;

    if (this.shouldStop || this.shouldSkip || this.removed) return true;
  }

  return false;
}

function _babeltraverselibpathcontextjs6160_isBlacklisted() {
  var blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}

function _babeltraverselibpathcontextjs6160_visit() {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.call("enter") || this.shouldSkip) {
    this.debug(function () {
      return "Skip...";
    });
    return this.shouldStop;
  }

  this.debug(function () {
    return "Recursing into...";
  });
  _babeltraverselibpathcontextjs6160__index2.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

  this.call("exit");

  return this.shouldStop;
}

function _babeltraverselibpathcontextjs6160_skip() {
  this.shouldSkip = true;
}

function _babeltraverselibpathcontextjs6160_skipKey(key) {
  this.skipKeys[key] = true;
}

function _babeltraverselibpathcontextjs6160_stop() {
  this.shouldStop = true;
  this.shouldSkip = true;
}

function _babeltraverselibpathcontextjs6160_setScope() {
  if (this.opts && this.opts.noScope) return;

  var target = this.context && this.context.scope;

  if (!target) {
    var path = this.parentPath;
    while (path && !target) {
      if (path.opts && path.opts.noScope) return;

      target = path.scope;
      path = path.parentPath;
    }
  }

  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}

function _babeltraverselibpathcontextjs6160_setContext(context) {
  this.shouldSkip = false;
  this.shouldStop = false;
  this.removed = false;
  this.skipKeys = {};

  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }

  this.setScope();

  return this;
}

function _babeltraverselibpathcontextjs6160_resync() {
  if (this.removed) return;

  this._resyncParent();
  this._resyncList();
  this._resyncKey();
}

function _babeltraverselibpathcontextjs6160__resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}

function _babeltraverselibpathcontextjs6160__resyncKey() {
  if (!this.container) return;

  if (this.node === this.container[this.key]) return;

  if (Array.isArray(this.container)) {
    for (var i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (var key in this.container) {
      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }

  this.key = null;
}

function _babeltraverselibpathcontextjs6160__resyncList() {
  if (!this.parent || !this.inList) return;

  var newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;

  this.container = newContainer || null;
}

function _babeltraverselibpathcontextjs6160__resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved();
  }
}

function _babeltraverselibpathcontextjs6160_popContext() {
  this.contexts.pop();
  this.setContext(this.contexts[this.contexts.length - 1]);
}

function _babeltraverselibpathcontextjs6160_pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}

function _babeltraverselibpathcontextjs6160_setup(parentPath, container, listKey, key) {
  this.inList = !!listKey;
  this.listKey = listKey;
  this.parentKey = listKey || key;
  this.container = container;

  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}

function _babeltraverselibpathcontextjs6160_setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}

function _babeltraverselibpathcontextjs6160_requeue() {
  var pathToQueue = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];

  if (pathToQueue.removed) return;

  var contexts = this.contexts;

  for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathcontextjs6160__getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var context = _ref2;

    context.maybeQueue(pathToQueue);
  }
}

function _babeltraverselibpathcontextjs6160__getQueueContexts() {
  var path = this;
  var contexts = this.contexts;
  while (!contexts.length) {
    path = path.parentPath;
    contexts = path.contexts;
  }
  return contexts;
}
};
/*≠≠ node_modules/babel-traverse/lib/path/context.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/replacement.js ==*/
$m['babel-traverse/lib/path/replacement.js#6.16.0'] = function () {
$m['babel-traverse/lib/path/replacement.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.__esModule = true;

var _babeltraverselibpathreplacementjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babeltraverselibpathreplacementjs6160__getIterator3 = _babeltraverselibpathreplacementjs6160__interopRequireDefault(_babeltraverselibpathreplacementjs6160__getIterator2);

$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.replaceWithMultiple = _babeltraverselibpathreplacementjs6160_replaceWithMultiple;
$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.replaceWithSourceString = _babeltraverselibpathreplacementjs6160_replaceWithSourceString;
$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.replaceWith = _babeltraverselibpathreplacementjs6160_replaceWith;
$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports._replaceWith = _babeltraverselibpathreplacementjs6160__replaceWith;
$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.replaceExpressionWithStatements = _babeltraverselibpathreplacementjs6160_replaceExpressionWithStatements;
$m['babel-traverse/lib/path/replacement.js#6.16.0'].exports.replaceInline = _babeltraverselibpathreplacementjs6160_replaceInline;

var _babeltraverselibpathreplacementjs6160__babelCodeFrame = $m['babel-code-frame/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathreplacementjs6160__babelCodeFrame2 = _babeltraverselibpathreplacementjs6160__interopRequireDefault(_babeltraverselibpathreplacementjs6160__babelCodeFrame);

var _babeltraverselibpathreplacementjs6160__index = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathreplacementjs6160__index2 = _babeltraverselibpathreplacementjs6160__interopRequireDefault(_babeltraverselibpathreplacementjs6160__index);

var _babeltraverselibpathreplacementjs6160__index3 = require("babel-traverse/lib/path/index.js#6.16.0");

var _babeltraverselibpathreplacementjs6160__index4 = _babeltraverselibpathreplacementjs6160__interopRequireDefault(_babeltraverselibpathreplacementjs6160__index3);

var _babeltraverselibpathreplacementjs6160__babylon = $m['babylon/lib/index.js#6.11.2'].exports;

var _babeltraverselibpathreplacementjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathreplacementjs6160_t = _babeltraverselibpathreplacementjs6160__interopRequireWildcard(_babeltraverselibpathreplacementjs6160__babelTypes);

function _babeltraverselibpathreplacementjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltraverselibpathreplacementjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltraverselibpathreplacementjs6160_hoistVariablesVisitor = {
  Function: function Function(path) {
    path.skip();
  },
  VariableDeclaration: function VariableDeclaration(path) {
    if (path.node.kind !== "var") return;

    var bindings = path.getBindingIdentifiers();
    for (var key in bindings) {
      path.scope.push({ id: bindings[key] });
    }

    var exprs = [];

    for (var _iterator = path.node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babeltraverselibpathreplacementjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var declar = _ref;

      if (declar.init) {
        exprs.push(_babeltraverselibpathreplacementjs6160_t.expressionStatement(_babeltraverselibpathreplacementjs6160_t.assignmentExpression("=", declar.id, declar.init)));
      }
    }

    path.replaceWithMultiple(exprs);
  }
};

function _babeltraverselibpathreplacementjs6160_replaceWithMultiple(nodes) {
  this.resync();

  nodes = this._verifyNodeList(nodes);
  _babeltraverselibpathreplacementjs6160_t.inheritLeadingComments(nodes[0], this.node);
  _babeltraverselibpathreplacementjs6160_t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }
}

function _babeltraverselibpathreplacementjs6160_replaceWithSourceString(replacement) {
  this.resync();

  try {
    replacement = "(" + replacement + ")";
    replacement = (0, _babeltraverselibpathreplacementjs6160__babylon.parse)(replacement);
  } catch (err) {
    var loc = err.loc;
    if (loc) {
      err.message += " - make sure this is an expression.";
      err.message += "\n" + (0, _babeltraverselibpathreplacementjs6160__babelCodeFrame2.default)(replacement, loc.line, loc.column + 1);
    }
    throw err;
  }

  replacement = replacement.program.body[0].expression;
  _babeltraverselibpathreplacementjs6160__index2.default.removeProperties(replacement);
  return this.replaceWith(replacement);
}

function _babeltraverselibpathreplacementjs6160_replaceWith(replacement) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  if (replacement instanceof _babeltraverselibpathreplacementjs6160__index4.default) {
    replacement = replacement.node;
  }

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return;
  }

  if (this.isProgram() && !_babeltraverselibpathreplacementjs6160_t.isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  if (this.isNodeType("Statement") && _babeltraverselibpathreplacementjs6160_t.isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      replacement = _babeltraverselibpathreplacementjs6160_t.expressionStatement(replacement);
    }
  }

  if (this.isNodeType("Expression") && _babeltraverselibpathreplacementjs6160_t.isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  var oldNode = this.node;
  if (oldNode) {
    _babeltraverselibpathreplacementjs6160_t.inheritsComments(replacement, oldNode);
    _babeltraverselibpathreplacementjs6160_t.removeComments(oldNode);
  }

  this._replaceWith(replacement);
  this.type = replacement.type;

  this.setScope();

  this.requeue();
}

function _babeltraverselibpathreplacementjs6160__replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    _babeltraverselibpathreplacementjs6160_t.validate(this.parent, this.key, [node]);
  } else {
    _babeltraverselibpathreplacementjs6160_t.validate(this.parent, this.key, node);
  }

  this.debug(function () {
    return "Replace with " + (node && node.type);
  });

  this.node = this.container[this.key] = node;
}

function _babeltraverselibpathreplacementjs6160_replaceExpressionWithStatements(nodes) {
  this.resync();

  var toSequenceExpression = _babeltraverselibpathreplacementjs6160_t.toSequenceExpression(nodes, this.scope);

  if (_babeltraverselibpathreplacementjs6160_t.isSequenceExpression(toSequenceExpression)) {
    var exprs = toSequenceExpression.expressions;

    if (exprs.length >= 2 && this.parentPath.isExpressionStatement()) {
      this._maybePopFromStatements(exprs);
    }

    if (exprs.length === 1) {
      this.replaceWith(exprs[0]);
    } else {
      this.replaceWith(toSequenceExpression);
    }
  } else if (toSequenceExpression) {
    this.replaceWith(toSequenceExpression);
  } else {
    var container = _babeltraverselibpathreplacementjs6160_t.functionExpression(null, [], _babeltraverselibpathreplacementjs6160_t.blockStatement(nodes));
    container.shadow = true;

    this.replaceWith(_babeltraverselibpathreplacementjs6160_t.callExpression(container, []));
    this.traverse(_babeltraverselibpathreplacementjs6160_hoistVariablesVisitor);

    var completionRecords = this.get("callee").getCompletionRecords();
    for (var _iterator2 = completionRecords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babeltraverselibpathreplacementjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      if (!path.isExpressionStatement()) continue;

      var loop = path.findParent(function (path) {
        return path.isLoop();
      });
      if (loop) {
        var callee = this.get("callee");

        var uid = callee.scope.generateDeclaredUidIdentifier("ret");
        callee.get("body").pushContainer("body", _babeltraverselibpathreplacementjs6160_t.returnStatement(uid));

        path.get("expression").replaceWith(_babeltraverselibpathreplacementjs6160_t.assignmentExpression("=", uid, path.node.expression));
      } else {
        path.replaceWith(_babeltraverselibpathreplacementjs6160_t.returnStatement(path.node.expression));
      }
    }

    return this.node;
  }
}

function _babeltraverselibpathreplacementjs6160_replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);
      this._containerInsertAfter(nodes);
      return this.remove();
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}
};
/*≠≠ node_modules/babel-traverse/lib/path/replacement.js ≠≠*/

/*== node_modules/invariant/browser.js ==*/
$m['invariant/browser.js#2.2.1'] = { exports: {} };
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var _invariantbrowserjs221_invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

$m['invariant/browser.js#2.2.1'].exports = _invariantbrowserjs221_invariant;
/*≠≠ node_modules/invariant/browser.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/core.js ==*/
$m['babel-types/lib/definitions/core.js#6.16.0'] = function () {
$m['babel-types/lib/definitions/core.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionscorejs6160__index = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltypeslibdefinitionscorejs6160_t = _babeltypeslibdefinitionscorejs6160__interopRequireWildcard(_babeltypeslibdefinitionscorejs6160__index);

var _babeltypeslibdefinitionscorejs6160__constants = $m['babel-types/lib/constants.js#6.16.0'].exports;

var _babeltypeslibdefinitionscorejs6160__index2 = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionscorejs6160__index3 = _babeltypeslibdefinitionscorejs6160__interopRequireDefault(_babeltypeslibdefinitionscorejs6160__index2);

function _babeltypeslibdefinitionscorejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babeltypeslibdefinitionscorejs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string")
    },
    left: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("LVal")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: _babeltypeslibdefinitionscorejs6160__index2.assertOneOf.apply(undefined, _babeltypeslibdefinitionscorejs6160__constants.BINARY_OPERATORS)
    },
    left: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("DirectiveLiteral")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("CallExpression", {
  visitor: ["callee", "arguments"],
  fields: {
    callee: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression", "SpreadElement")))
    }
  },
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("DebuggerStatement", {
  aliases: ["Statement"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("EmptyStatement", {
  aliases: ["Statement"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Program")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: {
    id: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier")
    },
    params: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    }
  },
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    id: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier"),
      optional: true
    },
    params: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation"],
  aliases: ["Expression", "LVal"],
  fields: {
    name: {
      validate: function validate(node, key, val) {
        if (!_babeltypeslibdefinitionscorejs6160_t.isValidIdentifier(val)) {}
      }
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string")
    },
    flags: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string"),
      default: ""
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: _babeltypeslibdefinitionscorejs6160__index2.assertOneOf.apply(undefined, _babeltypeslibdefinitionscorejs6160__constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("MemberExpression", {
  builder: ["object", "property", "computed"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    property: {
      validate: function validate(node, key, val) {
        var expectedType = node.computed ? "Expression" : "Identifier";
        (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)(expectedType)(node, key, val);
      }
    },
    computed: {
      default: false
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("NewExpression", {
  visitor: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression", "SpreadElement")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives"],
  fields: {
    directives: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "FunctionParent"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadProperty")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: {
    kind: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertOneOf)("method", "get", "set")),
      default: "method"
    },
    computed: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _babeltypeslibdefinitionscorejs6160__index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Decorator")))
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean")
    }
  },
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _babeltypeslibdefinitionscorejs6160__index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    value: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    shorthand: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  aliases: ["LVal"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("LVal")
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression"),
      optional: true
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Statement")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("SwitchCase")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ThisExpression", {
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      handler: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    },
    finalizer: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _babeltypeslibdefinitionscorejs6160__index2.assertOneOf.apply(undefined, _babeltypeslibdefinitionscorejs6160__constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _babeltypeslibdefinitionscorejs6160__index2.assertOneOf.apply(undefined, _babeltypeslibdefinitionscorejs6160__constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    kind: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("string"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertOneOf)("var", "let", "const"))
    },
    declarations: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.chain)((0, _babeltypeslibdefinitionscorejs6160__index2.assertValueType)("array"), (0, _babeltypeslibdefinitionscorejs6160__index2.assertEach)((0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("VariableDeclarator")))
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("LVal")
    },
    init: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

(0, _babeltypeslibdefinitionscorejs6160__index3.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      object: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionscorejs6160__index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});
};
/*≠≠ node_modules/babel-types/lib/definitions/core.js ≠≠*/

/*== node_modules/lodash/_baseClamp.js ==*/
$m['lodash/_baseClamp.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function _lodashbaseClampjs4162_baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

$m['lodash/_baseClamp.js#4.16.2'].exports = _lodashbaseClampjs4162_baseClamp;
/*≠≠ node_modules/lodash/_baseClamp.js ≠≠*/

/*== node_modules/lodash/_baseHas.js ==*/
$m['lodash/_baseHas.js#4.16.2'] = { exports: {} };
/** Used for built-in method references. */
var _lodashbaseHasjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseHasjs4162_hasOwnProperty = _lodashbaseHasjs4162_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function _lodashbaseHasjs4162_baseHas(object, key) {
  return object != null && _lodashbaseHasjs4162_hasOwnProperty.call(object, key);
}

$m['lodash/_baseHas.js#4.16.2'].exports = _lodashbaseHasjs4162_baseHas;
/*≠≠ node_modules/lodash/_baseHas.js ≠≠*/

/*== node_modules/babylon/lib/plugins/jsx/xhtml.js ==*/
$m['babylon/lib/plugins/jsx/xhtml.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/plugins/jsx/xhtml.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/plugins/jsx/xhtml.js#6.11.2'].exports.default = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  "int": "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
};
/*≠≠ node_modules/babylon/lib/plugins/jsx/xhtml.js ≠≠*/

/*== node_modules/babylon/lib/util/whitespace.js ==*/
$m['babylon/lib/util/whitespace.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/util/whitespace.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/util/whitespace.js#6.11.2'].exports.isNewLine = _babylonlibutilwhitespacejs6112_isNewLine;
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var _babylonlibutilwhitespacejs6112_lineBreak = $m['babylon/lib/util/whitespace.js#6.11.2'].exports.lineBreak = /\r\n?|\n|\u2028|\u2029/;
var _babylonlibutilwhitespacejs6112_lineBreakG = $m['babylon/lib/util/whitespace.js#6.11.2'].exports.lineBreakG = new RegExp(_babylonlibutilwhitespacejs6112_lineBreak.source, "g");

function _babylonlibutilwhitespacejs6112_isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var _babylonlibutilwhitespacejs6112_nonASCIIwhitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports.nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
/*≠≠ node_modules/babylon/lib/util/whitespace.js ≠≠*/

/*== node_modules/babylon/lib/options.js ==*/
$m['babylon/lib/options.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/options.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/options.js#6.11.2'].exports.getOptions = _babylonliboptionsjs6112_getOptions;
// A second optional argument can be given to further configure
var _babylonliboptionsjs6112_defaultOptions = $m['babylon/lib/options.js#6.11.2'].exports.defaultOptions = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null
};

// Interpret and default an options object

function _babylonliboptionsjs6112_getOptions(opts) {
  var options = {};
  for (var key in _babylonliboptionsjs6112_defaultOptions) {
    options[key] = opts && key in opts ? opts[key] : _babylonliboptionsjs6112_defaultOptions[key];
  }
  return options;
}
/*≠≠ node_modules/babylon/lib/options.js ≠≠*/

/*== node_modules/babylon/lib/util/identifier.js ==*/
$m['babylon/lib/util/identifier.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/util/identifier.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/util/identifier.js#6.11.2'].exports.isIdentifierStart = _babylonlibutilidentifierjs6112_isIdentifierStart;
$m['babylon/lib/util/identifier.js#6.11.2'].exports.isIdentifierChar = _babylonlibutilidentifierjs6112_isIdentifierChar;
/* eslint max-len: 0 */

// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function _babylonlibutilidentifierjs6112_makePredicate(words) {
  words = words.split(" ");
  return function (str) {
    return words.indexOf(str) >= 0;
  };
}

// Reserved word lists for various dialects of the language

var _babylonlibutilidentifierjs6112_reservedWords = $m['babylon/lib/util/identifier.js#6.11.2'].exports.reservedWords = {
  6: _babylonlibutilidentifierjs6112_makePredicate("enum await"),
  strict: _babylonlibutilidentifierjs6112_makePredicate("implements interface let package private protected public static yield"),
  strictBind: _babylonlibutilidentifierjs6112_makePredicate("eval arguments")
};

// And the keywords

var _babylonlibutilidentifierjs6112_isKeyword = $m['babylon/lib/util/identifier.js#6.11.2'].exports.isKeyword = _babylonlibutilidentifierjs6112_makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var _babylonlibutilidentifierjs6112_nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞮꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var _babylonlibutilidentifierjs6112_nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣔ-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";

var _babylonlibutilidentifierjs6112_nonASCIIidentifierStart = new RegExp("[" + _babylonlibutilidentifierjs6112_nonASCIIidentifierStartChars + "]");
var _babylonlibutilidentifierjs6112_nonASCIIidentifier = new RegExp("[" + _babylonlibutilidentifierjs6112_nonASCIIidentifierStartChars + _babylonlibutilidentifierjs6112_nonASCIIidentifierChars + "]");

_babylonlibutilidentifierjs6112_nonASCIIidentifierStartChars = _babylonlibutilidentifierjs6112_nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `bin/generate-identifier-regex.js`.
var _babylonlibutilidentifierjs6112_astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
var _babylonlibutilidentifierjs6112_astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function _babylonlibutilidentifierjs6112_isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function _babylonlibutilidentifierjs6112_isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && _babylonlibutilidentifierjs6112_nonASCIIidentifierStart.test(String.fromCharCode(code));
  return _babylonlibutilidentifierjs6112_isInAstralSet(code, _babylonlibutilidentifierjs6112_astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function _babylonlibutilidentifierjs6112_isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && _babylonlibutilidentifierjs6112_nonASCIIidentifier.test(String.fromCharCode(code));
  return _babylonlibutilidentifierjs6112_isInAstralSet(code, _babylonlibutilidentifierjs6112_astralIdentifierStartCodes) || _babylonlibutilidentifierjs6112_isInAstralSet(code, _babylonlibutilidentifierjs6112_astralIdentifierCodes);
}
/*≠≠ node_modules/babylon/lib/util/identifier.js ≠≠*/

/*== node_modules/ms/index.js ==*/
$m['ms/index.js#0.7.1'] = { exports: {} };
/**
 * Helpers.
 */

var _msindexjs071_s = 1000;
var _msindexjs071_m = _msindexjs071_s * 60;
var _msindexjs071_h = _msindexjs071_m * 60;
var _msindexjs071_d = _msindexjs071_h * 24;
var _msindexjs071_y = _msindexjs071_d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

$m['ms/index.js#0.7.1'].exports = function (val, options) {
  options = options || {};
  if ('string' == typeof val) return _msindexjs071_parse(val);
  return options.long ? _msindexjs071_long(val) : _msindexjs071_short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function _msindexjs071_parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * _msindexjs071_y;
    case 'days':
    case 'day':
    case 'd':
      return n * _msindexjs071_d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * _msindexjs071_h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * _msindexjs071_m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * _msindexjs071_s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function _msindexjs071_short(ms) {
  if (ms >= _msindexjs071_d) return Math.round(ms / _msindexjs071_d) + 'd';
  if (ms >= _msindexjs071_h) return Math.round(ms / _msindexjs071_h) + 'h';
  if (ms >= _msindexjs071_m) return Math.round(ms / _msindexjs071_m) + 'm';
  if (ms >= _msindexjs071_s) return Math.round(ms / _msindexjs071_s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function _msindexjs071_long(ms) {
  return _msindexjs071_plural(ms, _msindexjs071_d, 'day') || _msindexjs071_plural(ms, _msindexjs071_h, 'hour') || _msindexjs071_plural(ms, _msindexjs071_m, 'minute') || _msindexjs071_plural(ms, _msindexjs071_s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function _msindexjs071_plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}
/*≠≠ node_modules/ms/index.js ≠≠*/

/*== node_modules/esutils/lib/code.js ==*/
$m['esutils/lib/code.js#2.0.2'] = { exports: {} };
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39; // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 || // 0..9
        0x61 <= ch && ch <= 0x66 || // a..f
        0x41 <= ch && ch <= 0x46; // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37; // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) {
            return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch >= 0x30 && ch <= 0x39 || // 0..9
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    $m['esutils/lib/code.js#2.0.2'].exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
/*≠≠ node_modules/esutils/lib/code.js ≠≠*/

/*== node_modules/esutils/lib/ast.js ==*/
$m['esutils/lib/ast.js#2.0.2'] = { exports: {} };
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) {
            return false;
        }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) {
            return false;
        }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) {
            return false;
        }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
            case 'IfStatement':
                if (node.alternate != null) {
                    return node.alternate;
                }
                return node.consequent;

            case 'LabeledStatement':
            case 'ForStatement':
            case 'ForInStatement':
            case 'WhileStatement':
            case 'WithStatement':
                return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null) {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    $m['esutils/lib/ast.js#2.0.2'].exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
/*≠≠ node_modules/esutils/lib/ast.js ≠≠*/

/*== node_modules/jsesc/jsesc.js ==*/
$m['jsesc/jsesc.js#1.3.0'] = { exports: {} };
/*! https://mths.be/jsesc v1.3.0 by @mathias */
;(function (root) {

	// Detect free variables `exports`
	var freeExports = typeof $m['jsesc/jsesc.js#1.3.0'].exports == 'object' && $m['jsesc/jsesc.js#1.3.0'].exports;

	// Detect free variable `module`
	var freeModule = typeof $m['jsesc/jsesc.js#1.3.0'] == 'object' && $m['jsesc/jsesc.js#1.3.0'] && $m['jsesc/jsesc.js#1.3.0'].exports == freeExports && $m['jsesc/jsesc.js#1.3.0'];

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var forOwn = function (object, callback) {
		var key;
		for (key in object) {
			if (hasOwnProperty.call(object, key)) {
				callback(key, object[key]);
			}
		}
	};

	var extend = function (destination, source) {
		if (!source) {
			return destination;
		}
		forOwn(source, function (key, value) {
			destination[key] = value;
		});
		return destination;
	};

	var forEach = function (array, callback) {
		var length = array.length;
		var index = -1;
		while (++index < length) {
			callback(array[index]);
		}
	};

	var toString = object.toString;
	var isArray = function (value) {
		return toString.call(value) == '[object Array]';
	};
	var isObject = function (value) {
		// This is a very simple check, but it’s good enough for what we need.
		return toString.call(value) == '[object Object]';
	};
	var isString = function (value) {
		return typeof value == 'string' || toString.call(value) == '[object String]';
	};
	var isNumber = function (value) {
		return typeof value == 'number' || toString.call(value) == '[object Number]';
	};
	var isFunction = function (value) {
		// In a perfect world, the `typeof` check would be sufficient. However,
		// in Chrome 1–12, `typeof /x/ == 'object'`, and in IE 6–8
		// `typeof alert == 'object'` and similar for other host objects.
		return typeof value == 'function' || toString.call(value) == '[object Function]';
	};
	var isMap = function (value) {
		return toString.call(value) == '[object Map]';
	};
	var isSet = function (value) {
		return toString.call(value) == '[object Set]';
	};

	/*--------------------------------------------------------------------------*/

	// https://mathiasbynens.be/notes/javascript-escapes#single
	var singleEscapes = {
		'"': '\\"',
		'\'': '\\\'',
		'\\': '\\\\',
		'\b': '\\b',
		'\f': '\\f',
		'\n': '\\n',
		'\r': '\\r',
		'\t': '\\t'
		// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
		// '\v': '\\x0B'
	};
	var regexSingleEscape = /["'\\\b\f\n\r\t]/;

	var regexDigit = /[0-9]/;
	var regexWhitelist = /[ !#-&\(-\[\]-~]/;

	var jsesc = function (argument, options) {
		// Handle options
		var defaults = {
			'escapeEverything': false,
			'escapeEtago': false,
			'quotes': 'single',
			'wrap': false,
			'es6': false,
			'json': false,
			'compact': true,
			'lowercaseHex': false,
			'numbers': 'decimal',
			'indent': '\t',
			'__indent__': '',
			'__inline1__': false,
			'__inline2__': false
		};
		var json = options && options.json;
		if (json) {
			defaults.quotes = 'double';
			defaults.wrap = true;
		}
		options = extend(defaults, options);
		if (options.quotes != 'single' && options.quotes != 'double') {
			options.quotes = 'single';
		}
		var quote = options.quotes == 'double' ? '"' : '\'';
		var compact = options.compact;
		var indent = options.indent;
		var lowercaseHex = options.lowercaseHex;
		var oldIndent = '';
		var inline1 = options.__inline1__;
		var inline2 = options.__inline2__;
		var newLine = compact ? '' : '\n';
		var result;
		var isEmpty = true;
		var useBinNumbers = options.numbers == 'binary';
		var useOctNumbers = options.numbers == 'octal';
		var useDecNumbers = options.numbers == 'decimal';
		var useHexNumbers = options.numbers == 'hexadecimal';

		if (json && argument && isFunction(argument.toJSON)) {
			argument = argument.toJSON();
		}

		if (!isString(argument)) {
			if (isMap(argument)) {
				if (argument.size == 0) {
					return 'new Map()';
				}
				if (!compact) {
					options.__inline1__ = true;
				}
				return 'new Map(' + jsesc(Array.from(argument), options) + ')';
			}
			if (isSet(argument)) {
				if (argument.size == 0) {
					return 'new Set()';
				}
				return 'new Set(' + jsesc(Array.from(argument), options) + ')';
			}
			if (isArray(argument)) {
				result = [];
				options.wrap = true;
				if (inline1) {
					options.__inline1__ = false;
					options.__inline2__ = true;
				} else {
					oldIndent = options.__indent__;
					indent += oldIndent;
					options.__indent__ = indent;
				}
				forEach(argument, function (value) {
					isEmpty = false;
					if (inline2) {
						options.__inline2__ = false;
					}
					result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
				});
				if (isEmpty) {
					return '[]';
				}
				if (inline2) {
					return '[' + result.join(', ') + ']';
				}
				return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
			} else if (isNumber(argument)) {
				if (json) {
					// Some number values (e.g. `Infinity`) cannot be represented in JSON.
					return JSON.stringify(argument);
				}
				if (useDecNumbers) {
					return String(argument);
				}
				if (useHexNumbers) {
					var tmp = argument.toString(16);
					if (!lowercaseHex) {
						tmp = tmp.toUpperCase();
					}
					return '0x' + tmp;
				}
				if (useBinNumbers) {
					return '0b' + argument.toString(2);
				}
				if (useOctNumbers) {
					return '0o' + argument.toString(8);
				}
			} else if (!isObject(argument)) {
				if (json) {
					// For some values (e.g. `undefined`, `function` objects),
					// `JSON.stringify(value)` returns `undefined` (which isn’t valid
					// JSON) instead of `'null'`.
					return JSON.stringify(argument) || 'null';
				}
				return String(argument);
			} else {
				// it’s an object
				result = [];
				options.wrap = true;
				oldIndent = options.__indent__;
				indent += oldIndent;
				options.__indent__ = indent;
				forOwn(argument, function (key, value) {
					isEmpty = false;
					result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
				});
				if (isEmpty) {
					return '{}';
				}
				return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
			}
		}

		var string = argument;
		// Loop over each code unit in the string and escape it
		var index = -1;
		var length = string.length;
		var first;
		var second;
		var codePoint;
		result = '';
		while (++index < length) {
			var character = string.charAt(index);
			if (options.es6) {
				first = string.charCodeAt(index);
				if ( // check if it’s the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				length > index + 1 // there is a next code unit
				) {
						second = string.charCodeAt(index + 1);
						if (second >= 0xDC00 && second <= 0xDFFF) {
							// low surrogate
							// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
							codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
							var hexadecimal = codePoint.toString(16);
							if (!lowercaseHex) {
								hexadecimal = hexadecimal.toUpperCase();
							}
							result += '\\u{' + hexadecimal + '}';
							index++;
							continue;
						}
					}
			}
			if (!options.escapeEverything) {
				if (regexWhitelist.test(character)) {
					// It’s a printable ASCII character that is not `"`, `'` or `\`,
					// so don’t escape it.
					result += character;
					continue;
				}
				if (character == '"') {
					result += quote == character ? '\\"' : character;
					continue;
				}
				if (character == '\'') {
					result += quote == character ? '\\\'' : character;
					continue;
				}
			}
			if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
				result += '\\0';
				continue;
			}
			if (regexSingleEscape.test(character)) {
				// no need for a `hasOwnProperty` check here
				result += singleEscapes[character];
				continue;
			}
			var charCode = character.charCodeAt(0);
			var hexadecimal = charCode.toString(16);
			if (!lowercaseHex) {
				hexadecimal = hexadecimal.toUpperCase();
			}
			var longhand = hexadecimal.length > 2 || json;
			var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + hexadecimal).slice(longhand ? -4 : -2);
			result += escaped;
			continue;
		}
		if (options.wrap) {
			result = quote + result + quote;
		}
		if (options.escapeEtago) {
			// https://mathiasbynens.be/notes/etago
			return result.replace(/<\/(script|style)/gi, '<\\/$1');
		}
		return result;
	};

	jsesc.version = '1.3.0';

	/*--------------------------------------------------------------------------*/

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
		define(function () {
			return jsesc;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) {
			// in Node.js or RingoJS v0.8.0+
			freeModule.exports = jsesc;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			freeExports.jsesc = jsesc;
		}
	} else {
		// in Rhino or a web browser
		root.jsesc = jsesc;
	}
})(this);
/*≠≠ node_modules/jsesc/jsesc.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/classes.js ==*/
$m['babel-generator/lib/generators/classes.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.ClassDeclaration = _babelgeneratorlibgeneratorsclassesjs6160_ClassDeclaration;
$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.ClassBody = _babelgeneratorlibgeneratorsclassesjs6160_ClassBody;
$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.ClassProperty = _babelgeneratorlibgeneratorsclassesjs6160_ClassProperty;
$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.ClassMethod = _babelgeneratorlibgeneratorsclassesjs6160_ClassMethod;
function _babelgeneratorlibgeneratorsclassesjs6160_ClassDeclaration(node) {
  this.printJoin(node.decorators, node);
  this.word("class");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  }

  this.print(node.typeParameters, node);

  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }

  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

$m['babel-generator/lib/generators/classes.js#6.16.0'].exports.ClassExpression = _babelgeneratorlibgeneratorsclassesjs6160_ClassDeclaration;
function _babelgeneratorlibgeneratorsclassesjs6160_ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();

    this.indent();
    this.printSequence(node.body, node);
    this.dedent();

    if (!this.endsWith("\n")) this.newline();

    this.rightBrace();
  }
}

function _babelgeneratorlibgeneratorsclassesjs6160_ClassProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.static) {
    this.word("static");
    this.space();
  }
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this.print(node.key, node);
  }
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}

function _babelgeneratorlibgeneratorsclassesjs6160_ClassMethod(node) {
  this.printJoin(node.decorators, node);

  if (node.static) {
    this.word("static");
    this.space();
  }

  if (node.kind === "constructorCall") {
    this.word("call");
    this.space();
  }

  this._method(node);
}
/*≠≠ node_modules/babel-generator/lib/generators/classes.js ≠≠*/

/*== node_modules/babel-generator/l...enerators/template-literals.js ==*/
$m['babel-generator/lib/generators/template-literals.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/template-literals.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/template-literals.js#6.16.0'].exports.TaggedTemplateExpression = _babelgeneratorlibgeneratorstemplateliteralsjs6160_TaggedTemplateExpression;
$m['babel-generator/lib/generators/template-literals.js#6.16.0'].exports.TemplateElement = _babelgeneratorlibgeneratorstemplateliteralsjs6160_TemplateElement;
$m['babel-generator/lib/generators/template-literals.js#6.16.0'].exports.TemplateLiteral = _babelgeneratorlibgeneratorstemplateliteralsjs6160_TemplateLiteral;
function _babelgeneratorlibgeneratorstemplateliteralsjs6160_TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.quasi, node);
}

function _babelgeneratorlibgeneratorstemplateliteralsjs6160_TemplateElement(node, parent) {
  var isFirst = parent.quasis[0] === node;
  var isLast = parent.quasis[parent.quasis.length - 1] === node;

  var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");

  if (!isFirst) this.space();
  this.token(value);
  if (!isLast) this.space();
}

function _babelgeneratorlibgeneratorstemplateliteralsjs6160_TemplateLiteral(node) {
  var quasis = node.quasis;

  for (var i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);

    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}
/*≠≠ node_modules/babel-generator/l...enerators/template-literals.js ≠≠*/

/*== node_modules/lodash/_unicodeToArray.js ==*/
$m['lodash/_unicodeToArray.js#4.16.2'] = { exports: {} };
/** Used to compose unicode character classes. */
var _lodashunicodeToArrayjs4162_rsAstralRange = '\\ud800-\\udfff',
    _lodashunicodeToArrayjs4162_rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    _lodashunicodeToArrayjs4162_rsComboSymbolsRange = '\\u20d0-\\u20f0',
    _lodashunicodeToArrayjs4162_rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var _lodashunicodeToArrayjs4162_rsAstral = '[' + _lodashunicodeToArrayjs4162_rsAstralRange + ']',
    _lodashunicodeToArrayjs4162_rsCombo = '[' + _lodashunicodeToArrayjs4162_rsComboMarksRange + _lodashunicodeToArrayjs4162_rsComboSymbolsRange + ']',
    _lodashunicodeToArrayjs4162_rsFitz = '\\ud83c[\\udffb-\\udfff]',
    _lodashunicodeToArrayjs4162_rsModifier = '(?:' + _lodashunicodeToArrayjs4162_rsCombo + '|' + _lodashunicodeToArrayjs4162_rsFitz + ')',
    _lodashunicodeToArrayjs4162_rsNonAstral = '[^' + _lodashunicodeToArrayjs4162_rsAstralRange + ']',
    _lodashunicodeToArrayjs4162_rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    _lodashunicodeToArrayjs4162_rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    _lodashunicodeToArrayjs4162_rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var _lodashunicodeToArrayjs4162_reOptMod = _lodashunicodeToArrayjs4162_rsModifier + '?',
    _lodashunicodeToArrayjs4162_rsOptVar = '[' + _lodashunicodeToArrayjs4162_rsVarRange + ']?',
    _lodashunicodeToArrayjs4162_rsOptJoin = '(?:' + _lodashunicodeToArrayjs4162_rsZWJ + '(?:' + [_lodashunicodeToArrayjs4162_rsNonAstral, _lodashunicodeToArrayjs4162_rsRegional, _lodashunicodeToArrayjs4162_rsSurrPair].join('|') + ')' + _lodashunicodeToArrayjs4162_rsOptVar + _lodashunicodeToArrayjs4162_reOptMod + ')*',
    _lodashunicodeToArrayjs4162_rsSeq = _lodashunicodeToArrayjs4162_rsOptVar + _lodashunicodeToArrayjs4162_reOptMod + _lodashunicodeToArrayjs4162_rsOptJoin,
    _lodashunicodeToArrayjs4162_rsSymbol = '(?:' + [_lodashunicodeToArrayjs4162_rsNonAstral + _lodashunicodeToArrayjs4162_rsCombo + '?', _lodashunicodeToArrayjs4162_rsCombo, _lodashunicodeToArrayjs4162_rsRegional, _lodashunicodeToArrayjs4162_rsSurrPair, _lodashunicodeToArrayjs4162_rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var _lodashunicodeToArrayjs4162_reUnicode = RegExp(_lodashunicodeToArrayjs4162_rsFitz + '(?=' + _lodashunicodeToArrayjs4162_rsFitz + ')|' + _lodashunicodeToArrayjs4162_rsSymbol + _lodashunicodeToArrayjs4162_rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function _lodashunicodeToArrayjs4162_unicodeToArray(string) {
    return string.match(_lodashunicodeToArrayjs4162_reUnicode) || [];
}

$m['lodash/_unicodeToArray.js#4.16.2'].exports = _lodashunicodeToArrayjs4162_unicodeToArray;
/*≠≠ node_modules/lodash/_unicodeToArray.js ≠≠*/

/*== node_modules/lodash/_hasUnicode.js ==*/
$m['lodash/_hasUnicode.js#4.16.2'] = { exports: {} };
/** Used to compose unicode character classes. */
var _lodashhasUnicodejs4162_rsAstralRange = '\\ud800-\\udfff',
    _lodashhasUnicodejs4162_rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    _lodashhasUnicodejs4162_rsComboSymbolsRange = '\\u20d0-\\u20f0',
    _lodashhasUnicodejs4162_rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var _lodashhasUnicodejs4162_rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var _lodashhasUnicodejs4162_reHasUnicode = RegExp('[' + _lodashhasUnicodejs4162_rsZWJ + _lodashhasUnicodejs4162_rsAstralRange + _lodashhasUnicodejs4162_rsComboMarksRange + _lodashhasUnicodejs4162_rsComboSymbolsRange + _lodashhasUnicodejs4162_rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function _lodashhasUnicodejs4162_hasUnicode(string) {
  return _lodashhasUnicodejs4162_reHasUnicode.test(string);
}

$m['lodash/_hasUnicode.js#4.16.2'].exports = _lodashhasUnicodejs4162_hasUnicode;
/*≠≠ node_modules/lodash/_hasUnicode.js ≠≠*/

/*== node_modules/lodash/_asciiToArray.js ==*/
$m['lodash/_asciiToArray.js#4.16.2'] = { exports: {} };
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function _lodashasciiToArrayjs4162_asciiToArray(string) {
  return string.split('');
}

$m['lodash/_asciiToArray.js#4.16.2'].exports = _lodashasciiToArrayjs4162_asciiToArray;
/*≠≠ node_modules/lodash/_asciiToArray.js ≠≠*/

/*== node_modules/lodash/_baseSlice.js ==*/
$m['lodash/_baseSlice.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function _lodashbaseSlicejs4162_baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

$m['lodash/_baseSlice.js#4.16.2'].exports = _lodashbaseSlicejs4162_baseSlice;
/*≠≠ node_modules/lodash/_baseSlice.js ≠≠*/

/*== node_modules/number-is-nan/index.js ==*/
$m['number-is-nan/index.js#1.0.1'] = { exports: {} };
'use strict';

$m['number-is-nan/index.js#1.0.1'].exports = Number.isNaN || function (x) {
	return x !== x;
};
/*≠≠ node_modules/number-is-nan/index.js ≠≠*/

/*== node_modules/source-map/lib/quick-sort.js ==*/
$m['source-map/lib/quick-sort.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function _sourcemaplibquicksortjs056_swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function _sourcemaplibquicksortjs056_randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = _sourcemaplibquicksortjs056_randomIntInRange(p, r);
    var i = p - 1;

    _sourcemaplibquicksortjs056_swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        _sourcemaplibquicksortjs056_swap(ary, i, j);
      }
    }

    _sourcemaplibquicksortjs056_swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, p, q - 1);
    _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
$m['source-map/lib/quick-sort.js#0.5.6'].exports.quickSort = function (ary, comparator) {
  _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, 0, ary.length - 1);
};
/*≠≠ node_modules/source-map/lib/quick-sort.js ≠≠*/

/*== node_modules/source-map/lib/binary-search.js ==*/
$m['source-map/lib/binary-search.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

$m['source-map/lib/binary-search.js#0.5.6'].exports.GREATEST_LOWER_BOUND = 1;
$m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function _sourcemaplibbinarysearchjs056_recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return _sourcemaplibbinarysearchjs056_recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == $m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return _sourcemaplibbinarysearchjs056_recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == $m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
$m['source-map/lib/binary-search.js#0.5.6'].exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = _sourcemaplibbinarysearchjs056_recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || $m['source-map/lib/binary-search.js#0.5.6'].exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};
/*≠≠ node_modules/source-map/lib/binary-search.js ≠≠*/

/*== node_modules/source-map/lib/util.js ==*/
$m['source-map/lib/util.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function _sourcemaplibutiljs056_getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
$m['source-map/lib/util.js#0.5.6'].exports.getArg = _sourcemaplibutiljs056_getArg;

var _sourcemaplibutiljs056_urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var _sourcemaplibutiljs056_dataUrlRegexp = /^data:.+\,.+$/;

function _sourcemaplibutiljs056_urlParse(aUrl) {
  var match = aUrl.match(_sourcemaplibutiljs056_urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
$m['source-map/lib/util.js#0.5.6'].exports.urlParse = _sourcemaplibutiljs056_urlParse;

function _sourcemaplibutiljs056_urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
$m['source-map/lib/util.js#0.5.6'].exports.urlGenerate = _sourcemaplibutiljs056_urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function _sourcemaplibutiljs056_normalize(aPath) {
  var path = aPath;
  var url = _sourcemaplibutiljs056_urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = $m['source-map/lib/util.js#0.5.6'].exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return _sourcemaplibutiljs056_urlGenerate(url);
  }
  return path;
}
$m['source-map/lib/util.js#0.5.6'].exports.normalize = _sourcemaplibutiljs056_normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function _sourcemaplibutiljs056_join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = _sourcemaplibutiljs056_urlParse(aPath);
  var aRootUrl = _sourcemaplibutiljs056_urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return _sourcemaplibutiljs056_urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(_sourcemaplibutiljs056_dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return _sourcemaplibutiljs056_urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : _sourcemaplibutiljs056_normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return _sourcemaplibutiljs056_urlGenerate(aRootUrl);
  }
  return joined;
}
$m['source-map/lib/util.js#0.5.6'].exports.join = _sourcemaplibutiljs056_join;

$m['source-map/lib/util.js#0.5.6'].exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(_sourcemaplibutiljs056_urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function _sourcemaplibutiljs056_relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
$m['source-map/lib/util.js#0.5.6'].exports.relative = _sourcemaplibutiljs056_relative;

var _sourcemaplibutiljs056_supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function _sourcemaplibutiljs056_identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function _sourcemaplibutiljs056_toSetString(aStr) {
  if (_sourcemaplibutiljs056_isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
$m['source-map/lib/util.js#0.5.6'].exports.toSetString = _sourcemaplibutiljs056_supportsNullProto ? _sourcemaplibutiljs056_identity : _sourcemaplibutiljs056_toSetString;

function _sourcemaplibutiljs056_fromSetString(aStr) {
  if (_sourcemaplibutiljs056_isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
$m['source-map/lib/util.js#0.5.6'].exports.fromSetString = _sourcemaplibutiljs056_supportsNullProto ? _sourcemaplibutiljs056_identity : _sourcemaplibutiljs056_fromSetString;

function _sourcemaplibutiljs056_isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function _sourcemaplibutiljs056_compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByOriginalPositions = _sourcemaplibutiljs056_compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function _sourcemaplibutiljs056_compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByGeneratedPositionsDeflated = _sourcemaplibutiljs056_compareByGeneratedPositionsDeflated;

function _sourcemaplibutiljs056_strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function _sourcemaplibutiljs056_compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = _sourcemaplibutiljs056_strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return _sourcemaplibutiljs056_strcmp(mappingA.name, mappingB.name);
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByGeneratedPositionsInflated = _sourcemaplibutiljs056_compareByGeneratedPositionsInflated;
/*≠≠ node_modules/source-map/lib/util.js ≠≠*/

/*== node_modules/source-map/lib/base64.js ==*/
$m['source-map/lib/base64.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibbase64js056_intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
$m['source-map/lib/base64.js#0.5.6'].exports.encode = function (number) {
  if (0 <= number && number < _sourcemaplibbase64js056_intToCharMap.length) {
    return _sourcemaplibbase64js056_intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
$m['source-map/lib/base64.js#0.5.6'].exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};
/*≠≠ node_modules/source-map/lib/base64.js ≠≠*/

/*== node_modules/shebang-regex/index.js ==*/
$m['shebang-regex/index.js#1.0.0'] = { exports: {} };
'use strict';

$m['shebang-regex/index.js#1.0.0'].exports = /^#!.*/;
/*≠≠ node_modules/shebang-regex/index.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/plugin-pass.js ==*/
$m['babel-core/lib/transformation/plugin-pass.js#6.16.0'] = function () {
$m['babel-core/lib/transformation/plugin-pass.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/plugin-pass.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationpluginpassjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationpluginpassjs6160__classCallCheck3 = _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(_babelcorelibtransformationpluginpassjs6160__classCallCheck2);

var _babelcorelibtransformationpluginpassjs6160__possibleConstructorReturn2 = $m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports;

var _babelcorelibtransformationpluginpassjs6160__possibleConstructorReturn3 = _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(_babelcorelibtransformationpluginpassjs6160__possibleConstructorReturn2);

var _babelcorelibtransformationpluginpassjs6160__inherits2 = $m['babel-runtime/helpers/inherits.js#6.11.6'].exports;

var _babelcorelibtransformationpluginpassjs6160__inherits3 = _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(_babelcorelibtransformationpluginpassjs6160__inherits2);

var _babelcorelibtransformationpluginpassjs6160__store = $m['babel-core/lib/store.js#6.16.0'].exports;

var _babelcorelibtransformationpluginpassjs6160__store2 = _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(_babelcorelibtransformationpluginpassjs6160__store);

var _babelcorelibtransformationpluginpassjs6160__file5 = $m['babel-core/lib/transformation/file/index.js#6.16.0'].exports;

var _babelcorelibtransformationpluginpassjs6160__file6 = _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(_babelcorelibtransformationpluginpassjs6160__file5);

function _babelcorelibtransformationpluginpassjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationpluginpassjs6160_PluginPass = function (_Store) {
  (0, _babelcorelibtransformationpluginpassjs6160__inherits3.default)(PluginPass, _Store);

  function PluginPass(file, plugin) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
    (0, _babelcorelibtransformationpluginpassjs6160__classCallCheck3.default)(this, PluginPass);

    var _this = (0, _babelcorelibtransformationpluginpassjs6160__possibleConstructorReturn3.default)(this, _Store.call(this));

    _this.plugin = plugin;
    _this.key = plugin.key;
    _this.file = file;
    _this.opts = options;
    return _this;
  }

  PluginPass.prototype.addHelper = function addHelper() {
    var _file;

    return (_file = this.file).addHelper.apply(_file, arguments);
  };

  PluginPass.prototype.addImport = function addImport() {
    var _file2;

    return (_file2 = this.file).addImport.apply(_file2, arguments);
  };

  PluginPass.prototype.getModuleName = function getModuleName() {
    var _file3;

    return (_file3 = this.file).getModuleName.apply(_file3, arguments);
  };

  PluginPass.prototype.buildCodeFrameError = function buildCodeFrameError() {
    var _file4;

    return (_file4 = this.file).buildCodeFrameError.apply(_file4, arguments);
  };

  return PluginPass;
}(_babelcorelibtransformationpluginpassjs6160__store2.default);

$m['babel-core/lib/transformation/plugin-pass.js#6.16.0'].exports.default = _babelcorelibtransformationpluginpassjs6160_PluginPass;
$m['babel-core/lib/transformation/plugin-pass.js#6.16.0'].exports = $m['babel-core/lib/transformation/plugin-pass.js#6.16.0'].exports["default"];
};
/*≠≠ node_modules/babel-core/lib/transformation/plugin-pass.js ≠≠*/

/*== lib/plugins/img/index.js ==*/
$m['lib/plugins/img/index.js'] = { exports: {} };
'use strict';

const _libpluginsimgindexjs_FILE_EXTENSIONS = ['gif', 'jpg', 'jpeg', 'png', 'svg'];
const _libpluginsimgindexjs_WORKFLOW_WRITEABLE = ['compress:compress'];

$m['lib/plugins/img/index.js'].exports = {
  name: 'img',
  type: 'img',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginsimgindexjs_define, _libpluginsimgindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsimgindexjs_define(File, utils) {
  return class IMGFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'img', options);

      this.workflows.writeable = [_libpluginsimgindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Read and store file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    load(buildOptions, fn) {
      // Make sure to load as Buffer
      if (this.extension != 'svg') this.encoding = null;
      super.load(buildOptions, fn);
    }
  };
}
/*≠≠ lib/plugins/img/index.js ≠≠*/

/*== node_modules/inline-source/lib/run.js ==*/
$m['inline-source/lib/run.js#5.1.1'] = { exports: {} };
'use strict';

/**
 * Process stack for 'sources'
 * @param {Object} context
 * @param {Array} sources
 * @param {Boolean} swallowErrors
 * @param {Function} [fn]
 * @returns {null}
 */

$m['inline-source/lib/run.js#5.1.1'].exports = function run(context, sources, swallowErrors, fn) {
  let errored = false;
  let outstanding = sources.length;

  if (outstanding) {
    sources.forEach(source => {
      // Async
      if (fn) {
        let idx = 0;
        function next(err) {
          if (err) {
            if (!swallowErrors) {
              errored = true;
              return fn(err);
            }
            // Clear content
            source.content = '';
            source.errored = true;
          }

          if (!errored) {
            const handler = source.stack[idx++];

            if (handler) return handler(source, context, next);

            // Done
            if (! --outstanding) return fn(null, context.html);
          }
        };

        next();

        // Sync
      } else {
        source.stack.forEach(handler => {
          if (!errored) {
            try {
              handler(source, context);
            } catch (err) {
              if (!swallowErrors) {
                errored = true;
                throw err;
              } else {
                // Clear content
                source.content = '';
                source.errored = true;
              }
            }
          }
        });
      }
    });

    // Done sync
    if (!fn) return context.html;

    // No sources
  } else {
    return fn ? fn(null, context.html) : context.html;
  }
};
/*≠≠ node_modules/inline-source/lib/run.js ≠≠*/

/*== node_modules/is-plain-obj/index.js ==*/
$m['is-plain-obj/index.js#1.1.0'] = { exports: {} };
'use strict';

var _isplainobjindexjs110_toString = Object.prototype.toString;

$m['is-plain-obj/index.js#1.1.0'].exports = function (x) {
	var prototype;
	return _isplainobjindexjs110_toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};
/*≠≠ node_modules/is-plain-obj/index.js ≠≠*/

/*== node_modules/object-assign/index.js ==*/
$m['object-assign/index.js#4.1.0'] = { exports: {} };
'use strict';
/* eslint-disable no-unused-vars */

var _objectassignindexjs410_hasOwnProperty = Object.prototype.hasOwnProperty;
var _objectassignindexjs410_propIsEnumerable = Object.prototype.propertyIsEnumerable;

function _objectassignindexjs410_toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function _objectassignindexjs410_shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

$m['object-assign/index.js#4.1.0'].exports = _objectassignindexjs410_shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = _objectassignindexjs410_toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (_objectassignindexjs410_hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (_objectassignindexjs410_propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};
/*≠≠ node_modules/object-assign/index.js ≠≠*/

/*== node_modules/inline-source/lib/load.js ==*/
$m['inline-source/lib/load.js#5.1.1'] = { exports: {} };
'use strict';

/**
 * Load content for 'source'
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 */

$m['inline-source/lib/load.js#5.1.1'].exports = function load(source, context, next) {
  if (!source.fileContent && source.filepath) {
    // Raw buffer if image and not svg
    const encoding = source.type == 'image' && source.format != 'svg+xml' ? null : 'utf8';

    if (next) {
      context.fs.readFile(source.filepath, encoding, (err, content) => {
        if (err) return next(err);
        source.fileContent = content;
        return next();
      });
    } else {
      source.fileContent = context.fs.readFileSync(source.filepath, encoding);
    }
  } else {
    if (next) next();
  }
};
/*≠≠ node_modules/inline-source/lib/load.js ≠≠*/

/*== node_modules/htmlparser2/lib/CollectingHandler.js ==*/
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'].exports = _htmlparser2libCollectingHandlerjs391_CollectingHandler;

function _htmlparser2libCollectingHandlerjs391_CollectingHandler(cbs) {
	this._cbs = cbs || {};
	this.events = [];
}

var _htmlparser2libCollectingHandlerjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;
Object.keys(_htmlparser2libCollectingHandlerjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 0) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function () {
			this.events.push([name]);
			if (this._cbs[name]) this._cbs[name]();
		};
	} else if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 1) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function (a) {
			this.events.push([name, a]);
			if (this._cbs[name]) this._cbs[name](a);
		};
	} else if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 2) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function (a, b) {
			this.events.push([name, a, b]);
			if (this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype.onreset = function () {
	this.events = [];
	if (this._cbs.onreset) this._cbs.onreset();
};

_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype.restart = function () {
	if (this._cbs.onreset) this._cbs.onreset();

	for (var i = 0, len = this.events.length; i < len; i++) {
		if (this._cbs[this.events[i][0]]) {

			var num = this.events[i].length;

			if (num === 1) {
				this._cbs[this.events[i][0]]();
			} else if (num === 2) {
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};
};
/*≠≠ node_modules/htmlparser2/lib/CollectingHandler.js ≠≠*/

/*== node_modules/domutils/lib/helpers.js ==*/
$m['domutils/lib/helpers.js#1.5.1'] = { exports: {} };
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
$m['domutils/lib/helpers.js#1.5.1'].exports.removeSubsets = function (nodes) {
	var idx = nodes.length,
	    node,
	    ancestor,
	    replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var _domutilslibhelpersjs151_POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var _domutilslibhelpersjs151_comparePos = $m['domutils/lib/helpers.js#1.5.1'].exports.compareDocumentPosition = function (nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return _domutilslibhelpersjs151_POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return _domutilslibhelpersjs151_POSITION.FOLLOWING | _domutilslibhelpersjs151_POSITION.CONTAINED_BY;
		}
		return _domutilslibhelpersjs151_POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return _domutilslibhelpersjs151_POSITION.PRECEDING | _domutilslibhelpersjs151_POSITION.CONTAINS;
		}
		return _domutilslibhelpersjs151_POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
$m['domutils/lib/helpers.js#1.5.1'].exports.uniqueSort = function (nodes) {
	var idx = nodes.length,
	    node,
	    position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function (a, b) {
		var relative = _domutilslibhelpersjs151_comparePos(a, b);
		if (relative & _domutilslibhelpersjs151_POSITION.PRECEDING) {
			return -1;
		} else if (relative & _domutilslibhelpersjs151_POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};
/*≠≠ node_modules/domutils/lib/helpers.js ≠≠*/

/*== node_modules/domutils/lib/manipulation.js ==*/
$m['domutils/lib/manipulation.js#1.5.1'] = { exports: {} };
$m['domutils/lib/manipulation.js#1.5.1'].exports.removeElement = function (elem) {
	if (elem.prev) elem.prev.next = elem.next;
	if (elem.next) elem.next.prev = elem.prev;

	if (elem.parent) {
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.replaceElement = function (elem, replacement) {
	var prev = replacement.prev = elem.prev;
	if (prev) {
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if (next) {
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if (parent) {
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.appendChild = function (elem, child) {
	child.parent = elem;

	if (elem.children.push(child) !== 1) {
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.append = function (elem, next) {
	var parent = elem.parent,
	    currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if (currNext) {
		currNext.prev = next;
		if (parent) {
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if (parent) {
		parent.children.push(next);
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.prepend = function (elem, prev) {
	var parent = elem.parent;
	if (parent) {
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if (elem.prev) {
		elem.prev.next = prev;
	}

	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};
/*≠≠ node_modules/domutils/lib/manipulation.js ≠≠*/

/*== node_modules/domutils/lib/traversal.js ==*/
$m['domutils/lib/traversal.js#1.5.1'] = { exports: {} };
var _domutilslibtraversaljs151_getChildren = $m['domutils/lib/traversal.js#1.5.1'].exports.getChildren = function (elem) {
	return elem.children;
};

var _domutilslibtraversaljs151_getParent = $m['domutils/lib/traversal.js#1.5.1'].exports.getParent = function (elem) {
	return elem.parent;
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getSiblings = function (elem) {
	var parent = _domutilslibtraversaljs151_getParent(elem);
	return parent ? _domutilslibtraversaljs151_getChildren(parent) : [elem];
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getAttributeValue = function (elem, name) {
	return elem.attribs && elem.attribs[name];
};

$m['domutils/lib/traversal.js#1.5.1'].exports.hasAttrib = function (elem, name) {
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getName = function (elem) {
	return elem.name;
};
/*≠≠ node_modules/domutils/lib/traversal.js ≠≠*/

/*== node_modules/dom-serializer/no...odules/domelementtype/index.js ==*/
$m['domelementtype/index.js#1.1.3'] = { exports: {} };
//Types of elements found in the DOM
$m['domelementtype/index.js#1.1.3'].exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>

	isTag: function (elem) {
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
/*≠≠ node_modules/dom-serializer/no...odules/domelementtype/index.js ≠≠*/

/*== node_modules/htmlparser2/lib/ProxyHandler.js ==*/
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'].exports = _htmlparser2libProxyHandlerjs391_ProxyHandler;

function _htmlparser2libProxyHandlerjs391_ProxyHandler(cbs) {
	this._cbs = cbs || {};
}

var _htmlparser2libProxyHandlerjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;
Object.keys(_htmlparser2libProxyHandlerjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 0) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function () {
			if (this._cbs[name]) this._cbs[name]();
		};
	} else if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 1) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function (a) {
			if (this._cbs[name]) this._cbs[name](a);
		};
	} else if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 2) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function (a, b) {
			if (this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});
};
/*≠≠ node_modules/htmlparser2/lib/ProxyHandler.js ≠≠*/

/*== node_modules/htmlparser2/lib/Stream.js ==*/
$m['htmlparser2/lib/Stream.js#3.9.1'] = function () {
$m['htmlparser2/lib/Stream.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/Stream.js#3.9.1'].exports = _htmlparser2libStreamjs391_Stream;

var _htmlparser2libStreamjs391_Parser = $m['htmlparser2/lib/WritableStream.js#3.9.1'].exports;

function _htmlparser2libStreamjs391_Stream(options) {
	_htmlparser2libStreamjs391_Parser.call(this, new _htmlparser2libStreamjs391_Cbs(this), options);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libStreamjs391_Stream, _htmlparser2libStreamjs391_Parser);

_htmlparser2libStreamjs391_Stream.prototype.readable = true;

function _htmlparser2libStreamjs391_Cbs(scope) {
	this.scope = scope;
}

var _htmlparser2libStreamjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;

Object.keys(_htmlparser2libStreamjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libStreamjs391_EVENTS[name] === 0) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function () {
			this.scope.emit(name);
		};
	} else if (_htmlparser2libStreamjs391_EVENTS[name] === 1) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function (a) {
			this.scope.emit(name, a);
		};
	} else if (_htmlparser2libStreamjs391_EVENTS[name] === 2) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function (a, b) {
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});
};
/*≠≠ node_modules/htmlparser2/lib/Stream.js ≠≠*/

/*== node_modules/htmlparser2/lib/FeedHandler.js ==*/
$m['htmlparser2/lib/FeedHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/FeedHandler.js#3.9.1'] = { exports: {} };
var _htmlparser2libFeedHandlerjs391_index = $m['htmlparser2/lib/index.js#3.9.1'].exports,
    _htmlparser2libFeedHandlerjs391_DomHandler = _htmlparser2libFeedHandlerjs391_index.DomHandler,
    _htmlparser2libFeedHandlerjs391_DomUtils = _htmlparser2libFeedHandlerjs391_index.DomUtils;

//TODO: make this a streamable handler
function _htmlparser2libFeedHandlerjs391_FeedHandler(callback, options) {
	this.init(callback, options);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libFeedHandlerjs391_FeedHandler, _htmlparser2libFeedHandlerjs391_DomHandler);

_htmlparser2libFeedHandlerjs391_FeedHandler.prototype.init = _htmlparser2libFeedHandlerjs391_DomHandler;

function _htmlparser2libFeedHandlerjs391_getElements(what, where) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, true);
}
function _htmlparser2libFeedHandlerjs391_getOneElement(what, where) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function _htmlparser2libFeedHandlerjs391_fetch(what, where, recurse) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getText(_htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
}

function _htmlparser2libFeedHandlerjs391_addConditionally(obj, prop, what, where, recurse) {
	var tmp = _htmlparser2libFeedHandlerjs391_fetch(what, where, recurse);
	if (tmp) obj[prop] = tmp;
}

var _htmlparser2libFeedHandlerjs391_isValidFeed = function (value) {
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

_htmlparser2libFeedHandlerjs391_FeedHandler.prototype.onend = function () {
	var feed = {},
	    feedRoot = _htmlparser2libFeedHandlerjs391_getOneElement(_htmlparser2libFeedHandlerjs391_isValidFeed, this.dom),
	    tmp,
	    childs;

	if (feedRoot) {
		if (feedRoot.name === "feed") {
			childs = feedRoot.children;

			feed.type = "atom";
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "id", "id", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "title", "title", childs);
			if ((tmp = _htmlparser2libFeedHandlerjs391_getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "description", "subtitle", childs);
			if (tmp = _htmlparser2libFeedHandlerjs391_fetch("updated", childs)) feed.updated = new Date(tmp);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "author", "email", childs, true);

			feed.items = _htmlparser2libFeedHandlerjs391_getElements("entry", childs).map(function (item) {
				var entry = {},
				    tmp;

				item = item.children;

				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "id", "id", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "title", "title", item);
				if ((tmp = _htmlparser2libFeedHandlerjs391_getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("summary", item) || _htmlparser2libFeedHandlerjs391_fetch("content", item)) entry.description = tmp;
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("updated", item)) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = _htmlparser2libFeedHandlerjs391_getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "title", "title", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "link", "link", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "description", "description", childs);
			if (tmp = _htmlparser2libFeedHandlerjs391_fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = _htmlparser2libFeedHandlerjs391_getElements("item", feedRoot.children).map(function (item) {
				var entry = {},
				    tmp;

				item = item.children;

				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "id", "guid", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "title", "title", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "link", "link", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "description", "description", item);
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("pubDate", item)) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	_htmlparser2libFeedHandlerjs391_DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
};

$m['htmlparser2/lib/FeedHandler.js#3.9.1'].exports = _htmlparser2libFeedHandlerjs391_FeedHandler;
};
/*≠≠ node_modules/htmlparser2/lib/FeedHandler.js ≠≠*/

/*== node_modules/domelementtype/index.js ==*/
$m['domelementtype/index.js#1.3.0'] = { exports: {} };
//Types of elements found in the DOM
$m['domelementtype/index.js#1.3.0'].exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function (elem) {
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
/*≠≠ node_modules/domelementtype/index.js ≠≠*/

/*== node_modules/domhandler/lib/node.js ==*/
$m['domhandler/lib/node.js#2.3.0'] = { exports: {} };
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var _domhandlerlibnodejs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return _domhandlerlibnodejs230_nodeTypes[this.type] || _domhandlerlibnodejs230_nodeTypes.element;
	}
};

var _domhandlerlibnodejs230_domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var _domhandlerlibnodejs230_nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(_domhandlerlibnodejs230_domLvl1).forEach(function (key) {
	var shorthand = _domhandlerlibnodejs230_domLvl1[key];
	Object.defineProperty(_domhandlerlibnodejs230_NodePrototype, key, {
		get: function () {
			return this[shorthand] || null;
		},
		set: function (val) {
			this[shorthand] = val;
			return val;
		}
	});
});
/*≠≠ node_modules/domhandler/lib/node.js ≠≠*/

/*== node_modules/inline-source/lib/inline.js ==*/
$m['inline-source/lib/inline.js#5.1.1'] = { exports: {} };
'use strict';

/**
 * Inline source content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} next(err)
 */

$m['inline-source/lib/inline.js#5.1.1'].exports = function inline(source, context, next) {
  if (source.replace) {
    // Fix for PR#5
    context.html = context.html.replace(source.match, () => {
      return source.replace;
    });
  }

  if (next) next();
};
/*≠≠ node_modules/inline-source/lib/inline.js ≠≠*/

/*== lib/plugins/flow/index.js ==*/
$m['lib/plugins/flow/index.js'] = { exports: {} };
'use strict';

const _libpluginsflowindexjs_PLUGINS = ['babel-plugin-syntax-flow',
// Experimental, but needed for type syntax in Class constructors
'babel-plugin-transform-class-properties', 'babel-plugin-transform-flow-strip-types'];

$m['lib/plugins/flow/index.js'].exports = {
  name: 'flow',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerTargetVersionForType(this.name, _libpluginsflowindexjs_PLUGINS, this.type);
  }
};
/*≠≠ lib/plugins/flow/index.js ≠≠*/

/*== node_modules/lodash/_baseSortBy.js ==*/
$m['lodash/_baseSortBy.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function _lodashbaseSortByjs4162_baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

$m['lodash/_baseSortBy.js#4.16.2'].exports = _lodashbaseSortByjs4162_baseSortBy;
/*≠≠ node_modules/lodash/_baseSortBy.js ≠≠*/

/*== node_modules/lodash/_createBaseFor.js ==*/
$m['lodash/_createBaseFor.js#4.16.2'] = { exports: {} };
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function _lodashcreateBaseForjs4162_createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

$m['lodash/_createBaseFor.js#4.16.2'].exports = _lodashcreateBaseForjs4162_createBaseFor;
/*≠≠ node_modules/lodash/_createBaseFor.js ≠≠*/

/*== node_modules/lodash/_baseProperty.js ==*/
$m['lodash/_baseProperty.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function _lodashbasePropertyjs4162_baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

$m['lodash/_baseProperty.js#4.16.2'].exports = _lodashbasePropertyjs4162_baseProperty;
/*≠≠ node_modules/lodash/_baseProperty.js ≠≠*/

/*== node_modules/lodash/_baseHasIn.js ==*/
$m['lodash/_baseHasIn.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function _lodashbaseHasInjs4162_baseHasIn(object, key) {
  return object != null && key in Object(object);
}

$m['lodash/_baseHasIn.js#4.16.2'].exports = _lodashbaseHasInjs4162_baseHasIn;
/*≠≠ node_modules/lodash/_baseHasIn.js ≠≠*/

/*== node_modules/lodash/_matchesStrictComparable.js ==*/
$m['lodash/_matchesStrictComparable.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function _lodashmatchesStrictComparablejs4162_matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

$m['lodash/_matchesStrictComparable.js#4.16.2'].exports = _lodashmatchesStrictComparablejs4162_matchesStrictComparable;
/*≠≠ node_modules/lodash/_matchesStrictComparable.js ≠≠*/

/*== node_modules/lodash/_arrayMap.js ==*/
$m['lodash/_arrayMap.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function _lodasharrayMapjs4162_arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

$m['lodash/_arrayMap.js#4.16.2'].exports = _lodasharrayMapjs4162_arrayMap;
/*≠≠ node_modules/lodash/_arrayMap.js ≠≠*/

/*== lib/utils/tree.js ==*/
$m['lib/utils/tree.js'] = { exports: {} };
'use strict';

$m['lib/utils/tree.js'].exports = {
  /**
   * Retrieve shared decendants of 'ancestor' down to 'decendant'
   * Returns empty if 'decendant' isn't related to 'ancestor'
   * @param {Object} decendant
   * @param {Object} ancestor
   * @returns {Array}
   */
  getSharedDecendants(decendant, ancestor) {
    let decendants = [];
    let parent = decendant.parent;

    while (parent) {
      decendants.push(parent);
      // Stop when we hit ancestor or tree root
      parent = parent === ancestor ? null : parent.parent;
    }

    // Not related
    if (!decendants.includes(ancestor)) return [];
    return decendants;
  },

  /**
   * Walk tree from 'node', via 'key', and call 'visitorPre' on each new node
   * 'visitorPre' should return 'true' to continue recursive walk
   * 'visitorPost' will be called after potential recurse walk
   * @param {Object} node
   * @param {String} key
   * @param {Function} visitorPre
   * @param {Function} [visitorPost]
   */
  walk(node, key, visitorPre, visitorPost) {
    function _walk(nodes) {
      if (nodes) {
        for (let i = 0, n = nodes.length; i < n; i++) {
          if (visitorPre(nodes[i]) === true) _walk(nodes[i][key]);
          if (visitorPost) visitorPost(nodes[i]);
        }
      }
    }

    _walk(node[key]);
  }
};
/*≠≠ lib/utils/tree.js ≠≠*/

/*== node_modules/wrappy/wrappy.js ==*/
$m['wrappy/wrappy.js#1.0.2'] = { exports: {} };
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
$m['wrappy/wrappy.js#1.0.2'].exports = _wrappywrappyjs102_wrappy;
function _wrappywrappyjs102_wrappy(fn, cb) {
  if (fn && cb) return _wrappywrappyjs102_wrappy(fn)(cb);

  if (typeof fn !== 'function') throw new TypeError('need wrapper function');

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret;
  }
}
/*≠≠ node_modules/wrappy/wrappy.js ≠≠*/

/*== node_modules/glob/sync.js ==*/
$m['glob/sync.js#7.1.0'] = function () {
$m['glob/sync.js#7.1.0'] = { exports: {} };
$m['glob/sync.js#7.1.0'].exports = _globsyncjs710_globSync;
_globsyncjs710_globSync.GlobSync = _globsyncjs710_GlobSync;

var _globsyncjs710_fs = require('fs');
var _globsyncjs710_rp = $m['fs.realpath/index.js#1.0.0'].exports;
var _globsyncjs710_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globsyncjs710_Minimatch = _globsyncjs710_minimatch.Minimatch;
var _globsyncjs710_Glob = $m['glob/glob.js#7.1.0'].exports.Glob;
var _globsyncjs710_util = require('util');
var _globsyncjs710_path = require('path');
var _globsyncjs710_assert = require('assert');
var _globsyncjs710_isAbsolute = $m['path-is-absolute/index.js#1.0.1'].exports;
var _globsyncjs710_common = $m['glob/common.js#7.1.0'].exports;
var _globsyncjs710_alphasort = _globsyncjs710_common.alphasort;
var _globsyncjs710_alphasorti = _globsyncjs710_common.alphasorti;
var _globsyncjs710_setopts = _globsyncjs710_common.setopts;
var _globsyncjs710_ownProp = _globsyncjs710_common.ownProp;
var _globsyncjs710_childrenIgnored = _globsyncjs710_common.childrenIgnored;
var _globsyncjs710_isIgnored = _globsyncjs710_common.isIgnored;

function _globsyncjs710_globSync(pattern, options) {
  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

  return new _globsyncjs710_GlobSync(pattern, options).found;
}

function _globsyncjs710_GlobSync(pattern, options) {
  if (!pattern) throw new Error('must provide pattern');

  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

  if (!(this instanceof _globsyncjs710_GlobSync)) return new _globsyncjs710_GlobSync(pattern, options);

  _globsyncjs710_setopts(this, pattern, options);

  if (this.noprocess) return this;

  var n = this.minimatch.set.length;
  this.matches = new Array(n);
  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false);
  }
  this._finish();
}

_globsyncjs710_GlobSync.prototype._finish = function () {
  _globsyncjs710_assert(this instanceof _globsyncjs710_GlobSync);
  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);
      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = _globsyncjs710_rp.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;
        }
      }
    });
  }
  _globsyncjs710_common.finish(this);
};

_globsyncjs710_GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  _globsyncjs710_assert(this instanceof _globsyncjs710_GlobSync);

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n++;
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);
      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null) read = '.';else if (_globsyncjs710_isAbsolute(prefix) || _globsyncjs710_isAbsolute(pattern.join('/'))) {
    if (!prefix || !_globsyncjs710_isAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip processing
  if (_globsyncjs710_childrenIgnored(this, read)) return;

  var isGlobStar = remain[0] === _globsyncjs710_minimatch.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};

_globsyncjs710_GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar);

  // if the abs isn't a dir, then nothing can match!
  if (!entries) return;

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m) matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0) return;

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = _globsyncjs710_path.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return;
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) newPattern = [prefix, e];else newPattern = [e];
    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};

_globsyncjs710_GlobSync.prototype._emitMatch = function (index, e) {
  if (_globsyncjs710_isIgnored(this, e)) return;

  var abs = this._makeAbs(e);

  if (this.mark) e = this._mark(e);

  if (this.absolute) {
    e = abs;
  }

  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;

  if (this.stat) this._stat(e);
};

_globsyncjs710_GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow) return this._readdir(abs, false);

  var entries;
  var lstat;
  var stat;
  try {
    lstat = _globsyncjs710_fs.lstatSync(abs);
  } catch (er) {
    // lstat failed, doesn't exist
    return null;
  }

  var isSym = lstat.isSymbolicLink();
  this.symlinks[abs] = isSym;

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);

  return entries;
};

_globsyncjs710_GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries;

  if (inGlobStar && !_globsyncjs710_ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);

  if (_globsyncjs710_ownProp(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return null;

    if (Array.isArray(c)) return c;
  }

  try {
    return this._readdirEntries(abs, _globsyncjs710_fs.readdirSync(abs));
  } catch (er) {
    this._readdirError(abs, er);
    return null;
  }
};

_globsyncjs710_GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;

  // mark and cache dir-ness
  return entries;
};

_globsyncjs710_GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error;
      }
      break;

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) throw er;
      if (!this.silent) console.error('glob error', er);
      break;
  }
};

_globsyncjs710_GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar);

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return;

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs];

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar) return;

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue;

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true);
  }
};

_globsyncjs710_GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index]) this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists) return;

  if (prefix && _globsyncjs710_isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = _globsyncjs710_path.join(this.root, prefix);
    } else {
      prefix = _globsyncjs710_path.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
};

// Returns either 'DIR', 'FILE', or false
_globsyncjs710_GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength) return false;

  if (!this.stat && _globsyncjs710_ownProp(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c)) c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR') return c;

    if (needDir && c === 'FILE') return false;

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (!stat) {
    var lstat;
    try {
      lstat = _globsyncjs710_fs.lstatSync(abs);
    } catch (er) {
      return false;
    }

    if (lstat.isSymbolicLink()) {
      try {
        stat = _globsyncjs710_fs.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;

  var c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c !== 'DIR') return false;

  return c;
};

_globsyncjs710_GlobSync.prototype._mark = function (p) {
  return _globsyncjs710_common.mark(this, p);
};

_globsyncjs710_GlobSync.prototype._makeAbs = function (f) {
  return _globsyncjs710_common.makeAbs(this, f);
};
};
/*≠≠ node_modules/glob/sync.js ≠≠*/

/*== node_modules/balanced-match/index.js ==*/
$m['balanced-match/index.js#0.4.2'] = { exports: {} };
$m['balanced-match/index.js#0.4.2'].exports = _balancedmatchindexjs042_balanced;
function _balancedmatchindexjs042_balanced(a, b, str) {
  if (a instanceof RegExp) a = _balancedmatchindexjs042_maybeMatch(a, str);
  if (b instanceof RegExp) b = _balancedmatchindexjs042_maybeMatch(b, str);

  var r = _balancedmatchindexjs042_range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function _balancedmatchindexjs042_maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

_balancedmatchindexjs042_balanced.range = _balancedmatchindexjs042_range;
function _balancedmatchindexjs042_range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [left, right];
    }
  }

  return result;
}
/*≠≠ node_modules/balanced-match/index.js ≠≠*/

/*== node_modules/concat-map/index.js ==*/
$m['concat-map/index.js#0.0.1'] = { exports: {} };
$m['concat-map/index.js#0.0.1'].exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (_concatmapindexjs001_isArray(x)) res.push.apply(res, x);else res.push(x);
    }
    return res;
};

var _concatmapindexjs001_isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};
/*≠≠ node_modules/concat-map/index.js ≠≠*/

/*== node_modules/supports-color/index.js ==*/
$m['supports-color/index.js#2.0.0'] = { exports: {} };
'use strict';

var _supportscolorindexjs200_argv = process.argv;

var _supportscolorindexjs200_terminator = _supportscolorindexjs200_argv.indexOf('--');
var _supportscolorindexjs200_hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = _supportscolorindexjs200_argv.indexOf(flag);
	return pos !== -1 && (_supportscolorindexjs200_terminator !== -1 ? pos < _supportscolorindexjs200_terminator : true);
};

$m['supports-color/index.js#2.0.0'].exports = function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (_supportscolorindexjs200_hasFlag('no-color') || _supportscolorindexjs200_hasFlag('no-colors') || _supportscolorindexjs200_hasFlag('color=false')) {
		return false;
	}

	if (_supportscolorindexjs200_hasFlag('color') || _supportscolorindexjs200_hasFlag('colors') || _supportscolorindexjs200_hasFlag('color=true') || _supportscolorindexjs200_hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
}();
/*≠≠ node_modules/supports-color/index.js ≠≠*/

/*== node_modules/ansi-regex/index.js ==*/
$m['ansi-regex/index.js#2.0.0'] = { exports: {} };
'use strict';

$m['ansi-regex/index.js#2.0.0'].exports = function () {
	return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g
	);
};
/*≠≠ node_modules/ansi-regex/index.js ≠≠*/

/*== node_modules/ansi-styles/index.js ==*/
$m['ansi-styles/index.js#2.2.1'] = { exports: {} };
'use strict';

function _ansistylesindexjs221_assembleStyles() {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty($m['ansi-styles/index.js#2.2.1'], 'exports', {
	enumerable: true,
	get: _ansistylesindexjs221_assembleStyles
});
/*≠≠ node_modules/ansi-styles/index.js ≠≠*/

/*== node_modules/escape-string-regexp/index.js ==*/
$m['escape-string-regexp/index.js#1.0.5'] = { exports: {} };
'use strict';

var _escapestringregexpindexjs105_matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

$m['escape-string-regexp/index.js#1.0.5'].exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(_escapestringregexpindexjs105_matchOperatorsRe, '\\$&');
};
/*≠≠ node_modules/escape-string-regexp/index.js ≠≠*/

/*== lib/utils/callable.js ==*/
$m['lib/utils/callable.js'] = { exports: {} };
'use strict';

/**
 * Retrieve callable function 'fn' with 'context' and optional 'args'
 * @param {Object} context
 * @param {Function} fn
 * @param {Array} args
 * @returns {Function}
 */

$m['lib/utils/callable.js'].exports = function callable(context, fn, ...args) {
  return function callableFunction(...moreArgs) {
    context[fn].call(context, ...args, ...moreArgs);
  };
};
/*≠≠ lib/utils/callable.js ≠≠*/

/*== node_modules/is-buffer/index.js ==*/
$m['is-buffer/index.js#1.1.4'] = { exports: {} };
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
$m['is-buffer/index.js#1.1.4'].exports = function (obj) {
  return obj != null && (_isbufferindexjs114_isBuffer(obj) || _isbufferindexjs114_isSlowBuffer(obj) || !!obj._isBuffer);
};

function _isbufferindexjs114_isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function _isbufferindexjs114_isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && _isbufferindexjs114_isBuffer(obj.slice(0, 0));
}
/*≠≠ node_modules/is-buffer/index.js ≠≠*/

/*== node_modules/charenc/charenc.js ==*/
$m['charenc/charenc.js#0.0.1'] = { exports: {} };
var _charenccharencjs001_charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function (str) {
      return _charenccharencjs001_charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function (bytes) {
      return decodeURIComponent(escape(_charenccharencjs001_charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function (str) {
      for (var bytes = [], i = 0; i < str.length; i++) bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function (bytes) {
      for (var str = [], i = 0; i < bytes.length; i++) str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

$m['charenc/charenc.js#0.0.1'].exports = _charenccharencjs001_charenc;
/*≠≠ node_modules/charenc/charenc.js ≠≠*/

/*== node_modules/crypt/crypt.js ==*/
$m['crypt/crypt.js#0.0.1'] = { exports: {} };
(function () {
  var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      crypt = {
    // Bit-wise rotation left
    rotl: function (n, b) {
      return n << b | n >>> 32 - b;
    },

    // Bit-wise rotation right
    rotr: function (n, b) {
      return n << 32 - b | n >>> b;
    },

    // Swap big-endian to little-endian and vice versa
    endian: function (n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++) n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function (n) {
      for (var bytes = []; n > 0; n--) bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function (bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) words[b >>> 5] |= bytes[i] << 24 - b % 32;
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function (words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8) bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function (bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function (hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function (bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
        for (var j = 0; j < 4; j++) if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));else base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function (base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
      }
      return bytes;
    }
  };

  $m['crypt/crypt.js#0.0.1'].exports = crypt;
})();
/*≠≠ node_modules/crypt/crypt.js ≠≠*/

/*== node_modules/lodash/_arrayIncludesWith.js ==*/
$m['lodash/_arrayIncludesWith.js#4.16.2'] = { exports: {} };
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function _lodasharrayIncludesWithjs4162_arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

$m['lodash/_arrayIncludesWith.js#4.16.2'].exports = _lodasharrayIncludesWithjs4162_arrayIncludesWith;
/*≠≠ node_modules/lodash/_arrayIncludesWith.js ≠≠*/

/*== node_modules/lodash/_strictIndexOf.js ==*/
$m['lodash/_strictIndexOf.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashstrictIndexOfjs4162_strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

$m['lodash/_strictIndexOf.js#4.16.2'].exports = _lodashstrictIndexOfjs4162_strictIndexOf;
/*≠≠ node_modules/lodash/_strictIndexOf.js ≠≠*/

/*== node_modules/lodash/_baseIsNaN.js ==*/
$m['lodash/_baseIsNaN.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function _lodashbaseIsNaNjs4162_baseIsNaN(value) {
  return value !== value;
}

$m['lodash/_baseIsNaN.js#4.16.2'].exports = _lodashbaseIsNaNjs4162_baseIsNaN;
/*≠≠ node_modules/lodash/_baseIsNaN.js ≠≠*/

/*== node_modules/lodash/_baseFindIndex.js ==*/
$m['lodash/_baseFindIndex.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashbaseFindIndexjs4162_baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

$m['lodash/_baseFindIndex.js#4.16.2'].exports = _lodashbaseFindIndexjs4162_baseFindIndex;
/*≠≠ node_modules/lodash/_baseFindIndex.js ≠≠*/

/*== node_modules/lodash/_cacheHas.js ==*/
$m['lodash/_cacheHas.js#4.16.2'] = { exports: {} };
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashcacheHasjs4162_cacheHas(cache, key) {
  return cache.has(key);
}

$m['lodash/_cacheHas.js#4.16.2'].exports = _lodashcacheHasjs4162_cacheHas;
/*≠≠ node_modules/lodash/_cacheHas.js ≠≠*/

/*== node_modules/lodash/_arraySome.js ==*/
$m['lodash/_arraySome.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function _lodasharraySomejs4162_arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

$m['lodash/_arraySome.js#4.16.2'].exports = _lodasharraySomejs4162_arraySome;
/*≠≠ node_modules/lodash/_arraySome.js ≠≠*/

/*== node_modules/lodash/_setCacheHas.js ==*/
$m['lodash/_setCacheHas.js#4.16.2'] = { exports: {} };
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function _lodashsetCacheHasjs4162_setCacheHas(value) {
  return this.__data__.has(value);
}

$m['lodash/_setCacheHas.js#4.16.2'].exports = _lodashsetCacheHasjs4162_setCacheHas;
/*≠≠ node_modules/lodash/_setCacheHas.js ≠≠*/

/*== node_modules/lodash/_setCacheAdd.js ==*/
$m['lodash/_setCacheAdd.js#4.16.2'] = { exports: {} };
/** Used to stand-in for `undefined` hash values. */
var _lodashsetCacheAddjs4162_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function _lodashsetCacheAddjs4162_setCacheAdd(value) {
  this.__data__.set(value, _lodashsetCacheAddjs4162_HASH_UNDEFINED);
  return this;
}

$m['lodash/_setCacheAdd.js#4.16.2'].exports = _lodashsetCacheAddjs4162_setCacheAdd;
/*≠≠ node_modules/lodash/_setCacheAdd.js ≠≠*/

/*== node_modules/async/internal/onlyOnce.js ==*/
$m['async/internal/onlyOnce.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/onlyOnce.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/onlyOnce.js#2.0.1'].exports.default = _asyncinternalonlyOncejs201_onlyOnce;
function _asyncinternalonlyOncejs201_onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
$m['async/internal/onlyOnce.js#2.0.1'].exports = $m['async/internal/onlyOnce.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/onlyOnce.js ≠≠*/

/*== node_modules/lodash/noop.js ==*/
$m['lodash/noop.js#4.16.2'] = { exports: {} };
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function _lodashnoopjs4162_noop() {
  // No operation performed.
}

$m['lodash/noop.js#4.16.2'].exports = _lodashnoopjs4162_noop;
/*≠≠ node_modules/lodash/noop.js ≠≠*/

/*== node_modules/async/internal/doLimit.js ==*/
$m['async/internal/doLimit.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/doLimit.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/doLimit.js#2.0.1'].exports.default = _asyncinternaldoLimitjs201_doLimit;
function _asyncinternaldoLimitjs201_doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}
$m['async/internal/doLimit.js#2.0.1'].exports = $m['async/internal/doLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/doLimit.js ≠≠*/

/*== node_modules/async/internal/getIterator.js ==*/
$m['async/internal/getIterator.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/getIterator.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/internal/getIterator.js#2.0.1'].exports.default = function (coll) {
    return _asyncinternalgetIteratorjs201_iteratorSymbol && coll[_asyncinternalgetIteratorjs201_iteratorSymbol] && coll[_asyncinternalgetIteratorjs201_iteratorSymbol]();
};

var _asyncinternalgetIteratorjs201_iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

$m['async/internal/getIterator.js#2.0.1'].exports = $m['async/internal/getIterator.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/getIterator.js ≠≠*/

/*== node_modules/async/internal/once.js ==*/
$m['async/internal/once.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/once.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/once.js#2.0.1'].exports.default = _asyncinternaloncejs201_once;
function _asyncinternaloncejs201_once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
$m['async/internal/once.js#2.0.1'].exports = $m['async/internal/once.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/once.js ≠≠*/

/*== node_modules/lodash/_shortOut.js ==*/
$m['lodash/_shortOut.js#4.16.2'] = { exports: {} };
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var _lodashshortOutjs4162_HOT_COUNT = 500,
    _lodashshortOutjs4162_HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashshortOutjs4162_nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function _lodashshortOutjs4162_shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function () {
    var stamp = _lodashshortOutjs4162_nativeNow(),
        remaining = _lodashshortOutjs4162_HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= _lodashshortOutjs4162_HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

$m['lodash/_shortOut.js#4.16.2'].exports = _lodashshortOutjs4162_shortOut;
/*≠≠ node_modules/lodash/_shortOut.js ≠≠*/

/*== node_modules/lodash/constant.js ==*/
$m['lodash/constant.js#4.16.2'] = { exports: {} };
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function _lodashconstantjs4162_constant(value) {
  return function () {
    return value;
  };
}

$m['lodash/constant.js#4.16.2'].exports = _lodashconstantjs4162_constant;
/*≠≠ node_modules/lodash/constant.js ≠≠*/

/*== node_modules/lodash/identity.js ==*/
$m['lodash/identity.js#4.16.2'] = { exports: {} };
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function _lodashidentityjs4162_identity(value) {
  return value;
}

$m['lodash/identity.js#4.16.2'].exports = _lodashidentityjs4162_identity;
/*≠≠ node_modules/lodash/identity.js ≠≠*/

/*== node_modules/lodash/_baseUnary.js ==*/
$m['lodash/_baseUnary.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function _lodashbaseUnaryjs4162_baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

$m['lodash/_baseUnary.js#4.16.2'].exports = _lodashbaseUnaryjs4162_baseUnary;
/*≠≠ node_modules/lodash/_baseUnary.js ≠≠*/

/*== node_modules/lodash/isObjectLike.js ==*/
$m['lodash/isObjectLike.js#4.16.2'] = { exports: {} };
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function _lodashisObjectLikejs4162_isObjectLike(value) {
  return value != null && typeof value == 'object';
}

$m['lodash/isObjectLike.js#4.16.2'].exports = _lodashisObjectLikejs4162_isObjectLike;
/*≠≠ node_modules/lodash/isObjectLike.js ≠≠*/

/*== node_modules/lodash/isLength.js ==*/
$m['lodash/isLength.js#4.16.2'] = { exports: {} };
/** Used as references for various `Number` constants. */
var _lodashisLengthjs4162_MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function _lodashisLengthjs4162_isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= _lodashisLengthjs4162_MAX_SAFE_INTEGER;
}

$m['lodash/isLength.js#4.16.2'].exports = _lodashisLengthjs4162_isLength;
/*≠≠ node_modules/lodash/isLength.js ≠≠*/

/*== node_modules/lodash/_isIndex.js ==*/
$m['lodash/_isIndex.js#4.16.2'] = { exports: {} };
/** Used as references for various `Number` constants. */
var _lodashisIndexjs4162_MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var _lodashisIndexjs4162_reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function _lodashisIndexjs4162_isIndex(value, length) {
  length = length == null ? _lodashisIndexjs4162_MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || _lodashisIndexjs4162_reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

$m['lodash/_isIndex.js#4.16.2'].exports = _lodashisIndexjs4162_isIndex;
/*≠≠ node_modules/lodash/_isIndex.js ≠≠*/

/*== node_modules/lodash/_baseTimes.js ==*/
$m['lodash/_baseTimes.js#4.16.2'] = { exports: {} };
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function _lodashbaseTimesjs4162_baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

$m['lodash/_baseTimes.js#4.16.2'].exports = _lodashbaseTimesjs4162_baseTimes;
/*≠≠ node_modules/lodash/_baseTimes.js ≠≠*/

/*== node_modules/lodash/stubFalse.js ==*/
$m['lodash/stubFalse.js#4.16.2'] = { exports: {} };
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function _lodashstubFalsejs4162_stubFalse() {
  return false;
}

$m['lodash/stubFalse.js#4.16.2'].exports = _lodashstubFalsejs4162_stubFalse;
/*≠≠ node_modules/lodash/stubFalse.js ≠≠*/

/*== node_modules/lodash/_setToArray.js ==*/
$m['lodash/_setToArray.js#4.16.2'] = { exports: {} };
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function _lodashsetToArrayjs4162_setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

$m['lodash/_setToArray.js#4.16.2'].exports = _lodashsetToArrayjs4162_setToArray;
/*≠≠ node_modules/lodash/_setToArray.js ≠≠*/

/*== node_modules/lodash/_addSetEntry.js ==*/
$m['lodash/_addSetEntry.js#4.16.2'] = { exports: {} };
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function _lodashaddSetEntryjs4162_addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

$m['lodash/_addSetEntry.js#4.16.2'].exports = _lodashaddSetEntryjs4162_addSetEntry;
/*≠≠ node_modules/lodash/_addSetEntry.js ≠≠*/

/*== node_modules/lodash/_cloneRegExp.js ==*/
$m['lodash/_cloneRegExp.js#4.16.2'] = { exports: {} };
/** Used to match `RegExp` flags from their coerced string values. */
var _lodashcloneRegExpjs4162_reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function _lodashcloneRegExpjs4162_cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, _lodashcloneRegExpjs4162_reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

$m['lodash/_cloneRegExp.js#4.16.2'].exports = _lodashcloneRegExpjs4162_cloneRegExp;
/*≠≠ node_modules/lodash/_cloneRegExp.js ≠≠*/

/*== node_modules/lodash/_mapToArray.js ==*/
$m['lodash/_mapToArray.js#4.16.2'] = { exports: {} };
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function _lodashmapToArrayjs4162_mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

$m['lodash/_mapToArray.js#4.16.2'].exports = _lodashmapToArrayjs4162_mapToArray;
/*≠≠ node_modules/lodash/_mapToArray.js ≠≠*/

/*== node_modules/lodash/_arrayReduce.js ==*/
$m['lodash/_arrayReduce.js#4.16.2'] = { exports: {} };
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function _lodasharrayReducejs4162_arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

$m['lodash/_arrayReduce.js#4.16.2'].exports = _lodasharrayReducejs4162_arrayReduce;
/*≠≠ node_modules/lodash/_arrayReduce.js ≠≠*/

/*== node_modules/lodash/_addMapEntry.js ==*/
$m['lodash/_addMapEntry.js#4.16.2'] = { exports: {} };
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function _lodashaddMapEntryjs4162_addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

$m['lodash/_addMapEntry.js#4.16.2'].exports = _lodashaddMapEntryjs4162_addMapEntry;
/*≠≠ node_modules/lodash/_addMapEntry.js ≠≠*/

/*== node_modules/lodash/_baseGetTag.js ==*/
$m['lodash/_baseGetTag.js#4.16.2'] = { exports: {} };
/** Used for built-in method references. */
var _lodashbaseGetTagjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashbaseGetTagjs4162_objectToString = _lodashbaseGetTagjs4162_objectProto.toString;

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function _lodashbaseGetTagjs4162_baseGetTag(value) {
  return _lodashbaseGetTagjs4162_objectToString.call(value);
}

$m['lodash/_baseGetTag.js#4.16.2'].exports = _lodashbaseGetTagjs4162_baseGetTag;
/*≠≠ node_modules/lodash/_baseGetTag.js ≠≠*/

/*== node_modules/lodash/_arrayPush.js ==*/
$m['lodash/_arrayPush.js#4.16.2'] = { exports: {} };
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function _lodasharrayPushjs4162_arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

$m['lodash/_arrayPush.js#4.16.2'].exports = _lodasharrayPushjs4162_arrayPush;
/*≠≠ node_modules/lodash/_arrayPush.js ≠≠*/

/*== node_modules/lodash/stubArray.js ==*/
$m['lodash/stubArray.js#4.16.2'] = { exports: {} };
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function _lodashstubArrayjs4162_stubArray() {
  return [];
}

$m['lodash/stubArray.js#4.16.2'].exports = _lodashstubArrayjs4162_stubArray;
/*≠≠ node_modules/lodash/stubArray.js ≠≠*/

/*== node_modules/lodash/_overArg.js ==*/
$m['lodash/_overArg.js#4.16.2'] = { exports: {} };
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function _lodashoverArgjs4162_overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

$m['lodash/_overArg.js#4.16.2'].exports = _lodashoverArgjs4162_overArg;
/*≠≠ node_modules/lodash/_overArg.js ≠≠*/

/*== node_modules/lodash/_nativeKeysIn.js ==*/
$m['lodash/_nativeKeysIn.js#4.16.2'] = { exports: {} };
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashnativeKeysInjs4162_nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_nativeKeysIn.js#4.16.2'].exports = _lodashnativeKeysInjs4162_nativeKeysIn;
/*≠≠ node_modules/lodash/_nativeKeysIn.js ≠≠*/

/*== node_modules/lodash/_baseAssignValue.js ==*/
$m['lodash/_baseAssignValue.js#4.16.2'] = { exports: {} };
/** Built-in value references. */
var _lodashbaseAssignValuejs4162_defineProperty = Object.defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function _lodashbaseAssignValuejs4162_baseAssignValue(object, key, value) {
  if (key == '__proto__' && _lodashbaseAssignValuejs4162_defineProperty) {
    _lodashbaseAssignValuejs4162_defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

$m['lodash/_baseAssignValue.js#4.16.2'].exports = _lodashbaseAssignValuejs4162_baseAssignValue;
/*≠≠ node_modules/lodash/_baseAssignValue.js ≠≠*/

/*== node_modules/lodash/_isKeyable.js ==*/
$m['lodash/_isKeyable.js#4.16.2'] = { exports: {} };
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function _lodashisKeyablejs4162_isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

$m['lodash/_isKeyable.js#4.16.2'].exports = _lodashisKeyablejs4162_isKeyable;
/*≠≠ node_modules/lodash/_isKeyable.js ≠≠*/

/*== node_modules/lodash/_hashDelete.js ==*/
$m['lodash/_hashDelete.js#4.16.2'] = { exports: {} };
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashhashDeletejs4162_hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

$m['lodash/_hashDelete.js#4.16.2'].exports = _lodashhashDeletejs4162_hashDelete;
/*≠≠ node_modules/lodash/_hashDelete.js ≠≠*/

/*== node_modules/lodash/_freeGlobal.js ==*/
$m['lodash/_freeGlobal.js#4.16.2'] = { exports: {} };
/** Detect free variable `global` from Node.js. */
var _lodashfreeGlobaljs4162_freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

$m['lodash/_freeGlobal.js#4.16.2'].exports = _lodashfreeGlobaljs4162_freeGlobal;
/*≠≠ node_modules/lodash/_freeGlobal.js ≠≠*/

/*== node_modules/lodash/_getValue.js ==*/
$m['lodash/_getValue.js#4.16.2'] = { exports: {} };
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function _lodashgetValuejs4162_getValue(object, key) {
  return object == null ? undefined : object[key];
}

$m['lodash/_getValue.js#4.16.2'].exports = _lodashgetValuejs4162_getValue;
/*≠≠ node_modules/lodash/_getValue.js ≠≠*/

/*== node_modules/lodash/_toSource.js ==*/
$m['lodash/_toSource.js#4.16.2'] = { exports: {} };
/** Used for built-in method references. */
var _lodashtoSourcejs4162_funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashtoSourcejs4162_funcToString = _lodashtoSourcejs4162_funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function _lodashtoSourcejs4162_toSource(func) {
  if (func != null) {
    try {
      return _lodashtoSourcejs4162_funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

$m['lodash/_toSource.js#4.16.2'].exports = _lodashtoSourcejs4162_toSource;
/*≠≠ node_modules/lodash/_toSource.js ≠≠*/

/*== node_modules/lodash/_stackHas.js ==*/
$m['lodash/_stackHas.js#4.16.2'] = { exports: {} };
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashstackHasjs4162_stackHas(key) {
  return this.__data__.has(key);
}

$m['lodash/_stackHas.js#4.16.2'].exports = _lodashstackHasjs4162_stackHas;
/*≠≠ node_modules/lodash/_stackHas.js ≠≠*/

/*== node_modules/lodash/_stackGet.js ==*/
$m['lodash/_stackGet.js#4.16.2'] = { exports: {} };
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashstackGetjs4162_stackGet(key) {
  return this.__data__.get(key);
}

$m['lodash/_stackGet.js#4.16.2'].exports = _lodashstackGetjs4162_stackGet;
/*≠≠ node_modules/lodash/_stackGet.js ≠≠*/

/*== node_modules/lodash/_stackDelete.js ==*/
$m['lodash/_stackDelete.js#4.16.2'] = { exports: {} };
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashstackDeletejs4162_stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

$m['lodash/_stackDelete.js#4.16.2'].exports = _lodashstackDeletejs4162_stackDelete;
/*≠≠ node_modules/lodash/_stackDelete.js ≠≠*/

/*== node_modules/lodash/eq.js ==*/
$m['lodash/eq.js#4.16.2'] = { exports: {} };
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function _lodasheqjs4162_eq(value, other) {
  return value === other || value !== value && other !== other;
}

$m['lodash/eq.js#4.16.2'].exports = _lodasheqjs4162_eq;
/*≠≠ node_modules/lodash/eq.js ≠≠*/

/*== node_modules/lodash/_listCacheClear.js ==*/
$m['lodash/_listCacheClear.js#4.16.2'] = { exports: {} };
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function _lodashlistCacheClearjs4162_listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

$m['lodash/_listCacheClear.js#4.16.2'].exports = _lodashlistCacheClearjs4162_listCacheClear;
/*≠≠ node_modules/lodash/_listCacheClear.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/experimental.js ==*/
$m['babel-types/lib/definitions/experimental.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionsexperimentaljs6160__index = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionsexperimentaljs6160__index2 = _babeltypeslibdefinitionsexperimentaljs6160__interopRequireDefault(_babeltypeslibdefinitionsexperimentaljs6160__index);

function _babeltypeslibdefinitionsexperimentaljs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("ForAwaitStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {}
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("BlockStatement")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("RestProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("LVal")
    }
  }
});

(0, _babeltypeslibdefinitionsexperimentaljs6160__index2.default)("SpreadProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionsexperimentaljs6160__index.assertNodeType)("Expression")
    }
  }
});
/*≠≠ node_modules/babel-types/lib/definitions/experimental.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/misc.js ==*/
$m['babel-types/lib/definitions/misc.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionsmiscjs6160__index = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionsmiscjs6160__index2 = _babeltypeslibdefinitionsmiscjs6160__interopRequireDefault(_babeltypeslibdefinitionsmiscjs6160__index);

function _babeltypeslibdefinitionsmiscjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

(0, _babeltypeslibdefinitionsmiscjs6160__index2.default)("Noop", {
  visitor: []
});

(0, _babeltypeslibdefinitionsmiscjs6160__index2.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _babeltypeslibdefinitionsmiscjs6160__index.assertNodeType)("Expression")
    }
  }
});
/*≠≠ node_modules/babel-types/lib/definitions/misc.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/jsx.js ==*/
$m['babel-types/lib/definitions/jsx.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionsjsxjs6160__index = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionsjsxjs6160__index2 = _babeltypeslibdefinitionsjsxjs6160__interopRequireDefault(_babeltypeslibdefinitionsjsxjs6160__index);

function _babeltypeslibdefinitionsjsxjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXElement", "StringLiteral", "JSXExpressionContainer")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.chain)((0, _babeltypeslibdefinitionsjsxjs6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionsjsxjs6160__index.assertEach)((0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXElement")))
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXEmptyExpression", {
  aliases: ["JSX", "Expression"]
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX", "Expression"],
  fields: {
    name: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertValueType)("string")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX", "Expression"],
  fields: {
    object: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    },
    selfClosing: {
      default: false,
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertValueType)("boolean")
    },
    attributes: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.chain)((0, _babeltypeslibdefinitionsjsxjs6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionsjsxjs6160__index.assertEach)((0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionsjsxjs6160__index2.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _babeltypeslibdefinitionsjsxjs6160__index.assertValueType)("string")
    }
  }
});
/*≠≠ node_modules/babel-types/lib/definitions/jsx.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/flow.js ==*/
$m['babel-types/lib/definitions/flow.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionsflowjs6160__index = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionsflowjs6160__index2 = _babeltypeslibdefinitionsflowjs6160__interopRequireDefault(_babeltypeslibdefinitionsflowjs6160__index);

function _babeltypeslibdefinitionsflowjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("BooleanLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
  aliases: ["Property"],
  fields: {
    computed: {
      validate: (0, _babeltypeslibdefinitionsflowjs6160__index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareClass", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareInterface", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareModule", {
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ExistentialTypeParam", {
  aliases: ["Flow"]
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("InterfaceDeclaration", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"]
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("NumericLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("StringLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeParameter", {
  visitor: ["bound"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeParameterDeclaration", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("TypeParameterInstantiation", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("ObjectTypeProperty", {
  visitor: ["key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _babeltypeslibdefinitionsflowjs6160__index2.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});
/*≠≠ node_modules/babel-types/lib/definitions/flow.js ≠≠*/

/*== node_modules/babel-types/lib/definitions/es2015.js ==*/
$m['babel-types/lib/definitions/es2015.js#6.16.0'] = { exports: {} };
"use strict";

var _babeltypeslibdefinitionses2015js6160__index = require("babel-types/lib/definitions/index.js#6.16.0");

var _babeltypeslibdefinitionses2015js6160__index2 = _babeltypeslibdefinitionses2015js6160__interopRequireDefault(_babeltypeslibdefinitionses2015js6160__index);

function _babeltypeslibdefinitionses2015js6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("AssignmentPattern", {
  visitor: ["left", "right"],
  aliases: ["Pattern", "LVal"],
  fields: {
    left: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    elements: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")))
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    params: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("BlockStatement", "Expression")
    },
    async: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("ClassMethod", "ClassProperty")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: {
    id: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: {
    id: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("FunctionDeclaration", "ClassDeclaration", "Expression")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Declaration"),
      optional: true
    },
    specifiers: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("ExportSpecifier")))
    },
    source: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("StringLiteral"),
      optional: true
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Statement")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Identifier")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("string")
    },
    property: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("string")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: {
    kind: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("string"), (0, _babeltypeslibdefinitionses2015js6160__index.assertOneOf)("get", "set", "method", "constructor")),
      default: "method"
    },
    computed: {
      default: false,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean")
    },
    static: {
      default: false,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean")
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _babeltypeslibdefinitionses2015js6160__index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    params: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    properties: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("RestProperty", "Property")))
    },
    decorators: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Decorator")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("Super", {
  aliases: ["Expression"]
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("TemplateLiteral")
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {},
    tail: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.chain)((0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("array"), (0, _babeltypeslibdefinitionses2015js6160__index.assertEach)((0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")))
    }
  }
});

(0, _babeltypeslibdefinitionses2015js6160__index2.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _babeltypeslibdefinitionses2015js6160__index.assertNodeType)("Expression")
    }
  }
});
/*≠≠ node_modules/babel-types/lib/definitions/es2015.js ≠≠*/

/*== node_modules/babel-runtime/core-js/number/max-safe-integer.js ==*/
$m['babel-runtime/core-js/number/max-safe-integer.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/number/max-safe-integer.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/number/max-safe-integer.js ≠≠*/

/*== node_modules/babel-runtime/core-js/symbol/for.js ==*/
$m['babel-runtime/core-js/symbol/for.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/symbol/for.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/symbol/for.js ≠≠*/

/*== node_modules/debug/debug.js ==*/
$m['debug/debug.js#2.2.0'] = { exports: {} };

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

$m['debug/debug.js#2.2.0'].exports = $m['debug/debug.js#2.2.0'].exports = _debugdebugjs220_debug;
$m['debug/debug.js#2.2.0'].exports.coerce = _debugdebugjs220_coerce;
$m['debug/debug.js#2.2.0'].exports.disable = _debugdebugjs220_disable;
$m['debug/debug.js#2.2.0'].exports.enable = _debugdebugjs220_enable;
$m['debug/debug.js#2.2.0'].exports.enabled = _debugdebugjs220_enabled;
$m['debug/debug.js#2.2.0'].exports.humanize = $m['ms/index.js#0.7.1'].exports;

/**
 * The currently active debug mode names, and names to skip.
 */

$m['debug/debug.js#2.2.0'].exports.names = [];
$m['debug/debug.js#2.2.0'].exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

$m['debug/debug.js#2.2.0'].exports.formatters = {};

/**
 * Previously assigned color.
 */

var _debugdebugjs220_prevColor = 0;

/**
 * Previous log timestamp.
 */

var _debugdebugjs220_prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function _debugdebugjs220_selectColor() {
  return $m['debug/debug.js#2.2.0'].exports.colors[_debugdebugjs220_prevColor++ % $m['debug/debug.js#2.2.0'].exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function _debugdebugjs220_debug(namespace) {

  // define the `disabled` version
  function disabled() {}
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (_debugdebugjs220_prevTime || curr);
    self.diff = ms;
    self.prev = _debugdebugjs220_prevTime;
    self.curr = curr;
    _debugdebugjs220_prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = $m['debug/debug.js#2.2.0'].exports.useColors();
    if (null == self.color && self.useColors) self.color = _debugdebugjs220_selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = $m['debug/debug.js#2.2.0'].exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = $m['debug/debug.js#2.2.0'].exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof $m['debug/debug.js#2.2.0'].exports.formatArgs) {
      args = $m['debug/debug.js#2.2.0'].exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || $m['debug/debug.js#2.2.0'].exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = $m['debug/debug.js#2.2.0'].exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function _debugdebugjs220_enable(namespaces) {
  $m['debug/debug.js#2.2.0'].exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      $m['debug/debug.js#2.2.0'].exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      $m['debug/debug.js#2.2.0'].exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function _debugdebugjs220_disable() {
  $m['debug/debug.js#2.2.0'].exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function _debugdebugjs220_enabled(name) {
  var i, len;
  for (i = 0, len = $m['debug/debug.js#2.2.0'].exports.skips.length; i < len; i++) {
    if ($m['debug/debug.js#2.2.0'].exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = $m['debug/debug.js#2.2.0'].exports.names.length; i < len; i++) {
    if ($m['debug/debug.js#2.2.0'].exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function _debugdebugjs220_coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
/*≠≠ node_modules/debug/debug.js ≠≠*/

/*== node_modules/lodash/isNumber.js ==*/
$m['lodash/isNumber.js#4.16.2'] = { exports: {} };
var _lodashisNumberjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisNumberjs4162_numberTag = '[object Number]';

/** Used for built-in method references. */
var _lodashisNumberjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisNumberjs4162_objectToString = _lodashisNumberjs4162_objectProto.toString;

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function _lodashisNumberjs4162_isNumber(value) {
  return typeof value == 'number' || _lodashisNumberjs4162_isObjectLike(value) && _lodashisNumberjs4162_objectToString.call(value) == _lodashisNumberjs4162_numberTag;
}

$m['lodash/isNumber.js#4.16.2'].exports = _lodashisNumberjs4162_isNumber;
/*≠≠ node_modules/lodash/isNumber.js ≠≠*/

/*== node_modules/lodash/_baseForOwn.js ==*/
$m['lodash/_baseForOwn.js#4.16.2'] = { exports: {} };
var _lodashbaseForOwnjs4162_baseFor = $m['lodash/_baseFor.js#4.16.2'].exports,
    _lodashbaseForOwnjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function _lodashbaseForOwnjs4162_baseForOwn(object, iteratee) {
  return object && _lodashbaseForOwnjs4162_baseFor(object, iteratee, _lodashbaseForOwnjs4162_keys);
}

$m['lodash/_baseForOwn.js#4.16.2'].exports = _lodashbaseForOwnjs4162_baseForOwn;
/*≠≠ node_modules/lodash/_baseForOwn.js ≠≠*/

/*== node_modules/lodash/_createBaseEach.js ==*/
$m['lodash/_createBaseEach.js#4.16.2'] = { exports: {} };
var _lodashcreateBaseEachjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function _lodashcreateBaseEachjs4162_createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!_lodashcreateBaseEachjs4162_isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

$m['lodash/_createBaseEach.js#4.16.2'].exports = _lodashcreateBaseEachjs4162_createBaseEach;
/*≠≠ node_modules/lodash/_createBaseEach.js ≠≠*/

/*== node_modules/lodash/_baseEach.js ==*/
$m['lodash/_baseEach.js#4.16.2'] = { exports: {} };
var _lodashbaseEachjs4162_baseForOwn = $m['lodash/_baseForOwn.js#4.16.2'].exports,
    _lodashbaseEachjs4162_createBaseEach = $m['lodash/_createBaseEach.js#4.16.2'].exports;

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var _lodashbaseEachjs4162_baseEach = _lodashbaseEachjs4162_createBaseEach(_lodashbaseEachjs4162_baseForOwn);

$m['lodash/_baseEach.js#4.16.2'].exports = _lodashbaseEachjs4162_baseEach;
/*≠≠ node_modules/lodash/_baseEach.js ≠≠*/

/*== node_modules/lodash/_baseMatches.js ==*/
$m['lodash/_baseMatches.js#4.16.2'] = { exports: {} };
var _lodashbaseMatchesjs4162_baseIsMatch = $m['lodash/_baseIsMatch.js#4.16.2'].exports,
    _lodashbaseMatchesjs4162_getMatchData = $m['lodash/_getMatchData.js#4.16.2'].exports,
    _lodashbaseMatchesjs4162_matchesStrictComparable = $m['lodash/_matchesStrictComparable.js#4.16.2'].exports;

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function _lodashbaseMatchesjs4162_baseMatches(source) {
  var matchData = _lodashbaseMatchesjs4162_getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _lodashbaseMatchesjs4162_matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || _lodashbaseMatchesjs4162_baseIsMatch(object, source, matchData);
  };
}

$m['lodash/_baseMatches.js#4.16.2'].exports = _lodashbaseMatchesjs4162_baseMatches;
/*≠≠ node_modules/lodash/_baseMatches.js ≠≠*/

/*== node_modules/lodash/_baseMatchesProperty.js ==*/
$m['lodash/_baseMatchesProperty.js#4.16.2'] = { exports: {} };
var _lodashbaseMatchesPropertyjs4162_baseIsEqual = $m['lodash/_baseIsEqual.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_get = $m['lodash/get.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_hasIn = $m['lodash/hasIn.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_isKey = $m['lodash/_isKey.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_isStrictComparable = $m['lodash/_isStrictComparable.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_matchesStrictComparable = $m['lodash/_matchesStrictComparable.js#4.16.2'].exports,
    _lodashbaseMatchesPropertyjs4162_toKey = $m['lodash/_toKey.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashbaseMatchesPropertyjs4162_UNORDERED_COMPARE_FLAG = 1,
    _lodashbaseMatchesPropertyjs4162_PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function _lodashbaseMatchesPropertyjs4162_baseMatchesProperty(path, srcValue) {
  if (_lodashbaseMatchesPropertyjs4162_isKey(path) && _lodashbaseMatchesPropertyjs4162_isStrictComparable(srcValue)) {
    return _lodashbaseMatchesPropertyjs4162_matchesStrictComparable(_lodashbaseMatchesPropertyjs4162_toKey(path), srcValue);
  }
  return function (object) {
    var objValue = _lodashbaseMatchesPropertyjs4162_get(object, path);
    return objValue === undefined && objValue === srcValue ? _lodashbaseMatchesPropertyjs4162_hasIn(object, path) : _lodashbaseMatchesPropertyjs4162_baseIsEqual(srcValue, objValue, undefined, _lodashbaseMatchesPropertyjs4162_UNORDERED_COMPARE_FLAG | _lodashbaseMatchesPropertyjs4162_PARTIAL_COMPARE_FLAG);
  };
}

$m['lodash/_baseMatchesProperty.js#4.16.2'].exports = _lodashbaseMatchesPropertyjs4162_baseMatchesProperty;
/*≠≠ node_modules/lodash/_baseMatchesProperty.js ≠≠*/

/*== node_modules/lodash/property.js ==*/
$m['lodash/property.js#4.16.2'] = { exports: {} };
var _lodashpropertyjs4162_baseProperty = $m['lodash/_baseProperty.js#4.16.2'].exports,
    _lodashpropertyjs4162_basePropertyDeep = $m['lodash/_basePropertyDeep.js#4.16.2'].exports,
    _lodashpropertyjs4162_isKey = $m['lodash/_isKey.js#4.16.2'].exports,
    _lodashpropertyjs4162_toKey = $m['lodash/_toKey.js#4.16.2'].exports;

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function _lodashpropertyjs4162_property(path) {
  return _lodashpropertyjs4162_isKey(path) ? _lodashpropertyjs4162_baseProperty(_lodashpropertyjs4162_toKey(path)) : _lodashpropertyjs4162_basePropertyDeep(path);
}

$m['lodash/property.js#4.16.2'].exports = _lodashpropertyjs4162_property;
/*≠≠ node_modules/lodash/property.js ≠≠*/

/*== node_modules/lodash/_baseIteratee.js ==*/
$m['lodash/_baseIteratee.js#4.16.2'] = { exports: {} };
var _lodashbaseIterateejs4162_baseMatches = $m['lodash/_baseMatches.js#4.16.2'].exports,
    _lodashbaseIterateejs4162_baseMatchesProperty = $m['lodash/_baseMatchesProperty.js#4.16.2'].exports,
    _lodashbaseIterateejs4162_identity = $m['lodash/identity.js#4.16.2'].exports,
    _lodashbaseIterateejs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashbaseIterateejs4162_property = $m['lodash/property.js#4.16.2'].exports;

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function _lodashbaseIterateejs4162_baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return _lodashbaseIterateejs4162_identity;
  }
  if (typeof value == 'object') {
    return _lodashbaseIterateejs4162_isArray(value) ? _lodashbaseIterateejs4162_baseMatchesProperty(value[0], value[1]) : _lodashbaseIterateejs4162_baseMatches(value);
  }
  return _lodashbaseIterateejs4162_property(value);
}

$m['lodash/_baseIteratee.js#4.16.2'].exports = _lodashbaseIterateejs4162_baseIteratee;
/*≠≠ node_modules/lodash/_baseIteratee.js ≠≠*/

/*== node_modules/lodash/_getPrototype.js ==*/
$m['lodash/_getPrototype.js#4.16.2'] = { exports: {} };
var _lodashgetPrototypejs4162_overArg = $m['lodash/_overArg.js#4.16.2'].exports;

/** Built-in value references. */
var _lodashgetPrototypejs4162_getPrototype = _lodashgetPrototypejs4162_overArg(Object.getPrototypeOf, Object);

$m['lodash/_getPrototype.js#4.16.2'].exports = _lodashgetPrototypejs4162_getPrototype;
/*≠≠ node_modules/lodash/_getPrototype.js ≠≠*/

/*== node_modules/lodash/isPlainObject.js ==*/
$m['lodash/isPlainObject.js#4.16.2'] = { exports: {} };
var _lodashisPlainObjectjs4162_getPrototype = $m['lodash/_getPrototype.js#4.16.2'].exports,
    _lodashisPlainObjectjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisPlainObjectjs4162_objectTag = '[object Object]';

/** Used for built-in method references. */
var _lodashisPlainObjectjs4162_funcProto = Function.prototype,
    _lodashisPlainObjectjs4162_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashisPlainObjectjs4162_funcToString = _lodashisPlainObjectjs4162_funcProto.toString;

/** Used to check objects for own properties. */
var _lodashisPlainObjectjs4162_hasOwnProperty = _lodashisPlainObjectjs4162_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var _lodashisPlainObjectjs4162_objectCtorString = _lodashisPlainObjectjs4162_funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisPlainObjectjs4162_objectToString = _lodashisPlainObjectjs4162_objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function _lodashisPlainObjectjs4162_isPlainObject(value) {
  if (!_lodashisPlainObjectjs4162_isObjectLike(value) || _lodashisPlainObjectjs4162_objectToString.call(value) != _lodashisPlainObjectjs4162_objectTag) {
    return false;
  }
  var proto = _lodashisPlainObjectjs4162_getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = _lodashisPlainObjectjs4162_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && _lodashisPlainObjectjs4162_funcToString.call(Ctor) == _lodashisPlainObjectjs4162_objectCtorString;
}

$m['lodash/isPlainObject.js#4.16.2'].exports = _lodashisPlainObjectjs4162_isPlainObject;
/*≠≠ node_modules/lodash/isPlainObject.js ≠≠*/

/*== node_modules/debug/browser.js ==*/
$m['debug/browser.js#2.2.0'] = { exports: {} };

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

$m['debug/browser.js#2.2.0'].exports = $m['debug/browser.js#2.2.0'].exports = $m['debug/debug.js#2.2.0'].exports;
$m['debug/browser.js#2.2.0'].exports.log = _debugbrowserjs220_log;
$m['debug/browser.js#2.2.0'].exports.formatArgs = _debugbrowserjs220_formatArgs;
$m['debug/browser.js#2.2.0'].exports.save = _debugbrowserjs220_save;
$m['debug/browser.js#2.2.0'].exports.load = _debugbrowserjs220_load;
$m['debug/browser.js#2.2.0'].exports.useColors = _debugbrowserjs220_useColors;
$m['debug/browser.js#2.2.0'].exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : _debugbrowserjs220_localstorage();

/**
 * Colors.
 */

$m['debug/browser.js#2.2.0'].exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function _debugbrowserjs220_useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return 'WebkitAppearance' in document.documentElement.style ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  window.console && (console.firebug || console.exception && console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

$m['debug/browser.js#2.2.0'].exports.formatters.j = function (v) {
  return JSON.stringify(v);
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function _debugbrowserjs220_formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + $m['debug/browser.js#2.2.0'].exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function _debugbrowserjs220_log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function _debugbrowserjs220_save(namespaces) {
  try {
    if (null == namespaces) {
      $m['debug/browser.js#2.2.0'].exports.storage.removeItem('debug');
    } else {
      $m['debug/browser.js#2.2.0'].exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function _debugbrowserjs220_load() {
  var r;
  try {
    r = $m['debug/browser.js#2.2.0'].exports.storage.debug;
  } catch (e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

$m['debug/browser.js#2.2.0'].exports.enable(_debugbrowserjs220_load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function _debugbrowserjs220_localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
/*≠≠ node_modules/debug/browser.js ≠≠*/

/*== node_modules/babel-traverse/lib/path/lib/virtual-types.js ==*/
$m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.__esModule = true;
$m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Flow = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Pure = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Generated = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.User = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Var = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.BlockScoped = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Referenced = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Scope = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Expression = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Statement = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.BindingIdentifier = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.ReferencedMemberExpression = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.ReferencedIdentifier = undefined;

var _babeltraverselibpathlibvirtualtypesjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltraverselibpathlibvirtualtypesjs6160_t = _babeltraverselibpathlibvirtualtypesjs6160__interopRequireWildcard(_babeltraverselibpathlibvirtualtypesjs6160__babelTypes);

function _babeltraverselibpathlibvirtualtypesjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

var _babeltraverselibpathlibvirtualtypesjs6160_ReferencedIdentifier = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],
  checkPath: function checkPath(_ref, opts) {
    var node = _ref.node;
    var parent = _ref.parent;

    if (!_babeltraverselibpathlibvirtualtypesjs6160_t.isIdentifier(node, opts)) {
      if (_babeltraverselibpathlibvirtualtypesjs6160_t.isJSXIdentifier(node, opts)) {
        if (_babeltraverselibpathlibvirtualtypesjs6160__babelTypes.react.isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }

    return _babeltraverselibpathlibvirtualtypesjs6160_t.isReferenced(node, parent);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_ReferencedMemberExpression = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.ReferencedMemberExpression = {
  types: ["MemberExpression"],
  checkPath: function checkPath(_ref2) {
    var node = _ref2.node;
    var parent = _ref2.parent;

    return _babeltraverselibpathlibvirtualtypesjs6160_t.isMemberExpression(node) && _babeltraverselibpathlibvirtualtypesjs6160_t.isReferenced(node, parent);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_BindingIdentifier = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.BindingIdentifier = {
  types: ["Identifier"],
  checkPath: function checkPath(_ref3) {
    var node = _ref3.node;
    var parent = _ref3.parent;

    return _babeltraverselibpathlibvirtualtypesjs6160_t.isIdentifier(node) && _babeltraverselibpathlibvirtualtypesjs6160_t.isBinding(node, parent);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Statement = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Statement = {
  types: ["Statement"],
  checkPath: function checkPath(_ref4) {
    var node = _ref4.node;
    var parent = _ref4.parent;

    if (_babeltraverselibpathlibvirtualtypesjs6160_t.isStatement(node)) {
      if (_babeltraverselibpathlibvirtualtypesjs6160_t.isVariableDeclaration(node)) {
        if (_babeltraverselibpathlibvirtualtypesjs6160_t.isForXStatement(parent, { left: node })) return false;
        if (_babeltraverselibpathlibvirtualtypesjs6160_t.isForStatement(parent, { init: node })) return false;
      }

      return true;
    } else {
      return false;
    }
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Expression = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Expression = {
  types: ["Expression"],
  checkPath: function checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return _babeltraverselibpathlibvirtualtypesjs6160_t.isExpression(path.node);
    }
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Scope = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Scope = {
  types: ["Scopable"],
  checkPath: function checkPath(path) {
    return _babeltraverselibpathlibvirtualtypesjs6160_t.isScope(path.node, path.parent);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Referenced = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Referenced = {
  checkPath: function checkPath(path) {
    return _babeltraverselibpathlibvirtualtypesjs6160_t.isReferenced(path.node, path.parent);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_BlockScoped = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.BlockScoped = {
  checkPath: function checkPath(path) {
    return _babeltraverselibpathlibvirtualtypesjs6160_t.isBlockScoped(path.node);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Var = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Var = {
  types: ["VariableDeclaration"],
  checkPath: function checkPath(path) {
    return _babeltraverselibpathlibvirtualtypesjs6160_t.isVar(path.node);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_User = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.User = {
  checkPath: function checkPath(path) {
    return path.node && !!path.node.loc;
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Generated = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Generated = {
  checkPath: function checkPath(path) {
    return !path.isUser();
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Pure = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Pure = {
  checkPath: function checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }
};

var _babeltraverselibpathlibvirtualtypesjs6160_Flow = $m['babel-traverse/lib/path/lib/virtual-types.js#6.16.0'].exports.Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration"],
  checkPath: function checkPath(_ref5) {
    var node = _ref5.node;

    if (_babeltraverselibpathlibvirtualtypesjs6160_t.isFlow(node)) {
      return true;
    } else if (_babeltraverselibpathlibvirtualtypesjs6160_t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (_babeltraverselibpathlibvirtualtypesjs6160_t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else {
      return false;
    }
  }
};
/*≠≠ node_modules/babel-traverse/lib/path/lib/virtual-types.js ≠≠*/

/*== node_modules/lodash/forEach.js ==*/
$m['lodash/forEach.js#4.16.2'] = { exports: {} };
var _lodashforEachjs4162_arrayEach = $m['lodash/_arrayEach.js#4.16.2'].exports,
    _lodashforEachjs4162_baseEach = $m['lodash/_baseEach.js#4.16.2'].exports,
    _lodashforEachjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashforEachjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports;

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function _lodashforEachjs4162_forEach(collection, iteratee) {
  var func = _lodashforEachjs4162_isArray(collection) ? _lodashforEachjs4162_arrayEach : _lodashforEachjs4162_baseEach;
  return func(collection, _lodashforEachjs4162_baseIteratee(iteratee, 3));
}

$m['lodash/forEach.js#4.16.2'].exports = _lodashforEachjs4162_forEach;
/*≠≠ node_modules/lodash/forEach.js ≠≠*/

/*== node_modules/entities/lib/decode_codepoint.js ==*/
$m['entities/lib/decode_codepoint.js#1.1.1'] = { exports: {} };
var _entitieslibdecodecodepointjs111_decodeMap = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };

$m['entities/lib/decode_codepoint.js#1.1.1'].exports = _entitieslibdecodecodepointjs111_decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function _entitieslibdecodecodepointjs111_decodeCodePoint(codePoint) {

	if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
		return "\uFFFD";
	}

	if (codePoint in _entitieslibdecodecodepointjs111_decodeMap) {
		codePoint = _entitieslibdecodecodepointjs111_decodeMap[codePoint];
	}

	var output = "";

	if (codePoint > 0xFFFF) {
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}
/*≠≠ node_modules/entities/lib/decode_codepoint.js ≠≠*/

/*== node_modules/lodash/_baseMap.js ==*/
$m['lodash/_baseMap.js#4.16.2'] = { exports: {} };
var _lodashbaseMapjs4162_baseEach = $m['lodash/_baseEach.js#4.16.2'].exports,
    _lodashbaseMapjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function _lodashbaseMapjs4162_baseMap(collection, iteratee) {
  var index = -1,
      result = _lodashbaseMapjs4162_isArrayLike(collection) ? Array(collection.length) : [];

  _lodashbaseMapjs4162_baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

$m['lodash/_baseMap.js#4.16.2'].exports = _lodashbaseMapjs4162_baseMap;
/*≠≠ node_modules/lodash/_baseMap.js ≠≠*/

/*== node_modules/lodash/_baseIndexOf.js ==*/
$m['lodash/_baseIndexOf.js#4.16.2'] = { exports: {} };
var _lodashbaseIndexOfjs4162_baseFindIndex = $m['lodash/_baseFindIndex.js#4.16.2'].exports,
    _lodashbaseIndexOfjs4162_baseIsNaN = $m['lodash/_baseIsNaN.js#4.16.2'].exports,
    _lodashbaseIndexOfjs4162_strictIndexOf = $m['lodash/_strictIndexOf.js#4.16.2'].exports;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashbaseIndexOfjs4162_baseIndexOf(array, value, fromIndex) {
    return value === value ? _lodashbaseIndexOfjs4162_strictIndexOf(array, value, fromIndex) : _lodashbaseIndexOfjs4162_baseFindIndex(array, _lodashbaseIndexOfjs4162_baseIsNaN, fromIndex);
}

$m['lodash/_baseIndexOf.js#4.16.2'].exports = _lodashbaseIndexOfjs4162_baseIndexOf;
/*≠≠ node_modules/lodash/_baseIndexOf.js ≠≠*/

/*== node_modules/babylon/lib/util/location.js ==*/
$m['babylon/lib/util/location.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/util/location.js#6.11.2'].exports.__esModule = true;
$m['babylon/lib/util/location.js#6.11.2'].exports.SourceLocation = $m['babylon/lib/util/location.js#6.11.2'].exports.Position = undefined;
$m['babylon/lib/util/location.js#6.11.2'].exports.getLineInfo = _babylonlibutillocationjs6112_getLineInfo;

var _babylonlibutillocationjs6112__whitespace = $m['babylon/lib/util/whitespace.js#6.11.2'].exports;

function _babylonlibutillocationjs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var _babylonlibutillocationjs6112_Position = $m['babylon/lib/util/location.js#6.11.2'].exports.Position = function Position(line, col) {
  _babylonlibutillocationjs6112__classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var _babylonlibutillocationjs6112_SourceLocation = $m['babylon/lib/util/location.js#6.11.2'].exports.SourceLocation = function SourceLocation(start, end) {
  _babylonlibutillocationjs6112__classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function _babylonlibutillocationjs6112_getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    _babylonlibutillocationjs6112__whitespace.lineBreakG.lastIndex = cur;
    var match = _babylonlibutillocationjs6112__whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new _babylonlibutillocationjs6112_Position(line, offset - cur);
    }
  }
}
/*≠≠ node_modules/babylon/lib/util/location.js ≠≠*/

/*== node_modules/lodash/map.js ==*/
$m['lodash/map.js#4.16.2'] = { exports: {} };
var _lodashmapjs4162_arrayMap = $m['lodash/_arrayMap.js#4.16.2'].exports,
    _lodashmapjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashmapjs4162_baseMap = $m['lodash/_baseMap.js#4.16.2'].exports,
    _lodashmapjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports;

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function _lodashmapjs4162_map(collection, iteratee) {
  var func = _lodashmapjs4162_isArray(collection) ? _lodashmapjs4162_arrayMap : _lodashmapjs4162_baseMap;
  return func(collection, _lodashmapjs4162_baseIteratee(iteratee, 3));
}

$m['lodash/map.js#4.16.2'].exports = _lodashmapjs4162_map;
/*≠≠ node_modules/lodash/map.js ≠≠*/

/*== node_modules/lodash/_stringToArray.js ==*/
$m['lodash/_stringToArray.js#4.16.2'] = { exports: {} };
var _lodashstringToArrayjs4162_asciiToArray = $m['lodash/_asciiToArray.js#4.16.2'].exports,
    _lodashstringToArrayjs4162_hasUnicode = $m['lodash/_hasUnicode.js#4.16.2'].exports,
    _lodashstringToArrayjs4162_unicodeToArray = $m['lodash/_unicodeToArray.js#4.16.2'].exports;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function _lodashstringToArrayjs4162_stringToArray(string) {
    return _lodashstringToArrayjs4162_hasUnicode(string) ? _lodashstringToArrayjs4162_unicodeToArray(string) : _lodashstringToArrayjs4162_asciiToArray(string);
}

$m['lodash/_stringToArray.js#4.16.2'].exports = _lodashstringToArrayjs4162_stringToArray;
/*≠≠ node_modules/lodash/_stringToArray.js ≠≠*/

/*== node_modules/lodash/_charsEndIndex.js ==*/
$m['lodash/_charsEndIndex.js#4.16.2'] = { exports: {} };
var _lodashcharsEndIndexjs4162_baseIndexOf = $m['lodash/_baseIndexOf.js#4.16.2'].exports;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function _lodashcharsEndIndexjs4162_charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && _lodashcharsEndIndexjs4162_baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

$m['lodash/_charsEndIndex.js#4.16.2'].exports = _lodashcharsEndIndexjs4162_charsEndIndex;
/*≠≠ node_modules/lodash/_charsEndIndex.js ≠≠*/

/*== node_modules/lodash/_castSlice.js ==*/
$m['lodash/_castSlice.js#4.16.2'] = { exports: {} };
var _lodashcastSlicejs4162_baseSlice = $m['lodash/_baseSlice.js#4.16.2'].exports;

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function _lodashcastSlicejs4162_castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return !start && end >= length ? array : _lodashcastSlicejs4162_baseSlice(array, start, end);
}

$m['lodash/_castSlice.js#4.16.2'].exports = _lodashcastSlicejs4162_castSlice;
/*≠≠ node_modules/lodash/_castSlice.js ≠≠*/

/*== node_modules/entities/lib/decode.js ==*/
$m['entities/lib/decode.js#1.1.1'] = { exports: {} };
var _entitieslibdecodejs111_entityMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" },
    _entitieslibdecodejs111_legacyMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "AElig": "\u00C6", "aelig": "\u00E6", "Agrave": "\u00C0", "agrave": "\u00E0", "amp": "&", "AMP": "&", "Aring": "\u00C5", "aring": "\u00E5", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "brvbar": "\u00A6", "Ccedil": "\u00C7", "ccedil": "\u00E7", "cedil": "\u00B8", "cent": "\u00A2", "copy": "\u00A9", "COPY": "\u00A9", "curren": "\u00A4", "deg": "\u00B0", "divide": "\u00F7", "Eacute": "\u00C9", "eacute": "\u00E9", "Ecirc": "\u00CA", "ecirc": "\u00EA", "Egrave": "\u00C8", "egrave": "\u00E8", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "frac12": "\u00BD", "frac14": "\u00BC", "frac34": "\u00BE", "gt": ">", "GT": ">", "Iacute": "\u00CD", "iacute": "\u00ED", "Icirc": "\u00CE", "icirc": "\u00EE", "iexcl": "\u00A1", "Igrave": "\u00CC", "igrave": "\u00EC", "iquest": "\u00BF", "Iuml": "\u00CF", "iuml": "\u00EF", "laquo": "\u00AB", "lt": "<", "LT": "<", "macr": "\u00AF", "micro": "\u00B5", "middot": "\u00B7", "nbsp": "\u00A0", "not": "\u00AC", "Ntilde": "\u00D1", "ntilde": "\u00F1", "Oacute": "\u00D3", "oacute": "\u00F3", "Ocirc": "\u00D4", "ocirc": "\u00F4", "Ograve": "\u00D2", "ograve": "\u00F2", "ordf": "\u00AA", "ordm": "\u00BA", "Oslash": "\u00D8", "oslash": "\u00F8", "Otilde": "\u00D5", "otilde": "\u00F5", "Ouml": "\u00D6", "ouml": "\u00F6", "para": "\u00B6", "plusmn": "\u00B1", "pound": "\u00A3", "quot": "\"", "QUOT": "\"", "raquo": "\u00BB", "reg": "\u00AE", "REG": "\u00AE", "sect": "\u00A7", "shy": "\u00AD", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "szlig": "\u00DF", "THORN": "\u00DE", "thorn": "\u00FE", "times": "\u00D7", "Uacute": "\u00DA", "uacute": "\u00FA", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uml": "\u00A8", "Uuml": "\u00DC", "uuml": "\u00FC", "Yacute": "\u00DD", "yacute": "\u00FD", "yen": "\u00A5", "yuml": "\u00FF" },
    _entitieslibdecodejs111_xmlMap = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" },
    _entitieslibdecodejs111_decodeCodePoint = $m['entities/lib/decode_codepoint.js#1.1.1'].exports;

var _entitieslibdecodejs111_decodeXMLStrict = _entitieslibdecodejs111_getStrictDecoder(_entitieslibdecodejs111_xmlMap),
    _entitieslibdecodejs111_decodeHTMLStrict = _entitieslibdecodejs111_getStrictDecoder(_entitieslibdecodejs111_entityMap);

function _entitieslibdecodejs111_getStrictDecoder(map) {
	var keys = Object.keys(map).join("|"),
	    replace = _entitieslibdecodejs111_getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function (str) {
		return String(str).replace(re, replace);
	};
}

var _entitieslibdecodejs111_decodeHTML = function () {
	var legacy = Object.keys(_entitieslibdecodejs111_legacyMap).sort(_entitieslibdecodejs111_sorter);

	var keys = Object.keys(_entitieslibdecodejs111_entityMap).sort(_entitieslibdecodejs111_sorter);

	for (var i = 0, j = 0; i < keys.length; i++) {
		if (legacy[j] === keys[i]) {
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = _entitieslibdecodejs111_getReplacer(_entitieslibdecodejs111_entityMap);

	function replacer(str) {
		if (str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function (str) {
		return String(str).replace(re, replacer);
	};
}();

function _entitieslibdecodejs111_sorter(a, b) {
	return a < b ? 1 : -1;
}

function _entitieslibdecodejs111_getReplacer(map) {
	return function replace(str) {
		if (str.charAt(1) === "#") {
			if (str.charAt(2) === "X" || str.charAt(2) === "x") {
				return _entitieslibdecodejs111_decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return _entitieslibdecodejs111_decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

$m['entities/lib/decode.js#1.1.1'].exports = {
	XML: _entitieslibdecodejs111_decodeXMLStrict,
	HTML: _entitieslibdecodejs111_decodeHTML,
	HTMLStrict: _entitieslibdecodejs111_decodeHTMLStrict
};
/*≠≠ node_modules/entities/lib/decode.js ≠≠*/

/*== node_modules/entities/lib/encode.js ==*/
$m['entities/lib/encode.js#1.1.1'] = { exports: {} };
var _entitieslibencodejs111_inverseXML = _entitieslibencodejs111_getInverseObj({ "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" }),
    _entitieslibencodejs111_xmlReplacer = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseXML);

$m['entities/lib/encode.js#1.1.1'].exports.XML = _entitieslibencodejs111_getInverse(_entitieslibencodejs111_inverseXML, _entitieslibencodejs111_xmlReplacer);

var _entitieslibencodejs111_inverseHTML = _entitieslibencodejs111_getInverseObj({ "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" }),
    _entitieslibencodejs111_htmlReplacer = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseHTML);

$m['entities/lib/encode.js#1.1.1'].exports.HTML = _entitieslibencodejs111_getInverse(_entitieslibencodejs111_inverseHTML, _entitieslibencodejs111_htmlReplacer);

function _entitieslibencodejs111_getInverseObj(obj) {
	return Object.keys(obj).sort().reduce(function (inverse, name) {
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function _entitieslibencodejs111_getInverseReplacer(inverse) {
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function (k) {
		if (k.length === 1) {
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var _entitieslibencodejs111_re_nonASCII = /[^\0-\x7F]/g,
    _entitieslibencodejs111_re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function _entitieslibencodejs111_singleCharReplacer(c) {
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function _entitieslibencodejs111_astralReplacer(c) {
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function _entitieslibencodejs111_getInverse(inverse, re) {
	function func(name) {
		return inverse[name];
	}

	return function (data) {
		return data.replace(re, func).replace(_entitieslibencodejs111_re_astralSymbols, _entitieslibencodejs111_astralReplacer).replace(_entitieslibencodejs111_re_nonASCII, _entitieslibencodejs111_singleCharReplacer);
	};
}

var _entitieslibencodejs111_re_xmlChars = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseXML);

function _entitieslibencodejs111_escapeXML(data) {
	return data.replace(_entitieslibencodejs111_re_xmlChars, _entitieslibencodejs111_singleCharReplacer).replace(_entitieslibencodejs111_re_astralSymbols, _entitieslibencodejs111_astralReplacer).replace(_entitieslibencodejs111_re_nonASCII, _entitieslibencodejs111_singleCharReplacer);
}

$m['entities/lib/encode.js#1.1.1'].exports.escape = _entitieslibencodejs111_escapeXML;
/*≠≠ node_modules/entities/lib/encode.js ≠≠*/

/*== node_modules/lodash/_castPath.js ==*/
$m['lodash/_castPath.js#4.16.2'] = { exports: {} };
var _lodashcastPathjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashcastPathjs4162_stringToPath = $m['lodash/_stringToPath.js#4.16.2'].exports;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function _lodashcastPathjs4162_castPath(value) {
  return _lodashcastPathjs4162_isArray(value) ? value : _lodashcastPathjs4162_stringToPath(value);
}

$m['lodash/_castPath.js#4.16.2'].exports = _lodashcastPathjs4162_castPath;
/*≠≠ node_modules/lodash/_castPath.js ≠≠*/

/*== node_modules/lodash/isArguments.js ==*/
$m['lodash/isArguments.js#4.16.2'] = { exports: {} };
var _lodashisArgumentsjs4162_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisArgumentsjs4162_argsTag = '[object Arguments]';

/** Used for built-in method references. */
var _lodashisArgumentsjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashisArgumentsjs4162_hasOwnProperty = _lodashisArgumentsjs4162_objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisArgumentsjs4162_objectToString = _lodashisArgumentsjs4162_objectProto.toString;

/** Built-in value references. */
var _lodashisArgumentsjs4162_propertyIsEnumerable = _lodashisArgumentsjs4162_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function _lodashisArgumentsjs4162_isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return _lodashisArgumentsjs4162_isArrayLikeObject(value) && _lodashisArgumentsjs4162_hasOwnProperty.call(value, 'callee') && (!_lodashisArgumentsjs4162_propertyIsEnumerable.call(value, 'callee') || _lodashisArgumentsjs4162_objectToString.call(value) == _lodashisArgumentsjs4162_argsTag);
}

$m['lodash/isArguments.js#4.16.2'].exports = _lodashisArgumentsjs4162_isArguments;
/*≠≠ node_modules/lodash/isArguments.js ≠≠*/

/*== node_modules/lodash/_isKey.js ==*/
$m['lodash/_isKey.js#4.16.2'] = { exports: {} };
var _lodashisKeyjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashisKeyjs4162_isSymbol = $m['lodash/isSymbol.js#4.16.2'].exports;

/** Used to match property names within property paths. */
var _lodashisKeyjs4162_reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    _lodashisKeyjs4162_reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function _lodashisKeyjs4162_isKey(value, object) {
  if (_lodashisKeyjs4162_isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || _lodashisKeyjs4162_isSymbol(value)) {
    return true;
  }
  return _lodashisKeyjs4162_reIsPlainProp.test(value) || !_lodashisKeyjs4162_reIsDeepProp.test(value) || object != null && value in Object(object);
}

$m['lodash/_isKey.js#4.16.2'].exports = _lodashisKeyjs4162_isKey;
/*≠≠ node_modules/lodash/_isKey.js ≠≠*/

/*== node_modules/lodash/_toKey.js ==*/
$m['lodash/_toKey.js#4.16.2'] = { exports: {} };
var _lodashtoKeyjs4162_isSymbol = $m['lodash/isSymbol.js#4.16.2'].exports;

/** Used as references for various `Number` constants. */
var _lodashtoKeyjs4162_INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function _lodashtoKeyjs4162_toKey(value) {
  if (typeof value == 'string' || _lodashtoKeyjs4162_isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -_lodashtoKeyjs4162_INFINITY ? '-0' : result;
}

$m['lodash/_toKey.js#4.16.2'].exports = _lodashtoKeyjs4162_toKey;
/*≠≠ node_modules/lodash/_toKey.js ≠≠*/

/*== node_modules/lodash/_hasPath.js ==*/
$m['lodash/_hasPath.js#4.16.2'] = { exports: {} };
var _lodashhasPathjs4162_castPath = $m['lodash/_castPath.js#4.16.2'].exports,
    _lodashhasPathjs4162_isArguments = $m['lodash/isArguments.js#4.16.2'].exports,
    _lodashhasPathjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashhasPathjs4162_isIndex = $m['lodash/_isIndex.js#4.16.2'].exports,
    _lodashhasPathjs4162_isKey = $m['lodash/_isKey.js#4.16.2'].exports,
    _lodashhasPathjs4162_isLength = $m['lodash/isLength.js#4.16.2'].exports,
    _lodashhasPathjs4162_toKey = $m['lodash/_toKey.js#4.16.2'].exports;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function _lodashhasPathjs4162_hasPath(object, path, hasFunc) {
  path = _lodashhasPathjs4162_isKey(path, object) ? [path] : _lodashhasPathjs4162_castPath(path);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _lodashhasPathjs4162_toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object ? object.length : 0;
  return !!length && _lodashhasPathjs4162_isLength(length) && _lodashhasPathjs4162_isIndex(key, length) && (_lodashhasPathjs4162_isArray(object) || _lodashhasPathjs4162_isArguments(object));
}

$m['lodash/_hasPath.js#4.16.2'].exports = _lodashhasPathjs4162_hasPath;
/*≠≠ node_modules/lodash/_hasPath.js ≠≠*/

/*== node_modules/lodash/_Symbol.js ==*/
$m['lodash/_Symbol.js#4.16.2'] = { exports: {} };
var _lodashSymboljs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/** Built-in value references. */
var _lodashSymboljs4162_Symbol = _lodashSymboljs4162_root.Symbol;

$m['lodash/_Symbol.js#4.16.2'].exports = _lodashSymboljs4162_Symbol;
/*≠≠ node_modules/lodash/_Symbol.js ≠≠*/

/*== node_modules/lodash/isSymbol.js ==*/
$m['lodash/isSymbol.js#4.16.2'] = { exports: {} };
var _lodashisSymboljs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisSymboljs4162_symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var _lodashisSymboljs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisSymboljs4162_objectToString = _lodashisSymboljs4162_objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function _lodashisSymboljs4162_isSymbol(value) {
  return typeof value == 'symbol' || _lodashisSymboljs4162_isObjectLike(value) && _lodashisSymboljs4162_objectToString.call(value) == _lodashisSymboljs4162_symbolTag;
}

$m['lodash/isSymbol.js#4.16.2'].exports = _lodashisSymboljs4162_isSymbol;
/*≠≠ node_modules/lodash/isSymbol.js ≠≠*/

/*== node_modules/lodash/_baseToString.js ==*/
$m['lodash/_baseToString.js#4.16.2'] = { exports: {} };
var _lodashbaseToStringjs4162_Symbol = $m['lodash/_Symbol.js#4.16.2'].exports,
    _lodashbaseToStringjs4162_isSymbol = $m['lodash/isSymbol.js#4.16.2'].exports;

/** Used as references for various `Number` constants. */
var _lodashbaseToStringjs4162_INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var _lodashbaseToStringjs4162_symbolProto = _lodashbaseToStringjs4162_Symbol ? _lodashbaseToStringjs4162_Symbol.prototype : undefined,
    _lodashbaseToStringjs4162_symbolToString = _lodashbaseToStringjs4162_symbolProto ? _lodashbaseToStringjs4162_symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function _lodashbaseToStringjs4162_baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (_lodashbaseToStringjs4162_isSymbol(value)) {
    return _lodashbaseToStringjs4162_symbolToString ? _lodashbaseToStringjs4162_symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -_lodashbaseToStringjs4162_INFINITY ? '-0' : result;
}

$m['lodash/_baseToString.js#4.16.2'].exports = _lodashbaseToStringjs4162_baseToString;
/*≠≠ node_modules/lodash/_baseToString.js ≠≠*/

/*== node_modules/lodash/_mapCacheClear.js ==*/
$m['lodash/_mapCacheClear.js#4.16.2'] = { exports: {} };
var _lodashmapCacheClearjs4162_Hash = $m['lodash/_Hash.js#4.16.2'].exports,
    _lodashmapCacheClearjs4162_ListCache = $m['lodash/_ListCache.js#4.16.2'].exports,
    _lodashmapCacheClearjs4162_Map = $m['lodash/_Map.js#4.16.2'].exports;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function _lodashmapCacheClearjs4162_mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _lodashmapCacheClearjs4162_Hash(),
    'map': new (_lodashmapCacheClearjs4162_Map || _lodashmapCacheClearjs4162_ListCache)(),
    'string': new _lodashmapCacheClearjs4162_Hash()
  };
}

$m['lodash/_mapCacheClear.js#4.16.2'].exports = _lodashmapCacheClearjs4162_mapCacheClear;
/*≠≠ node_modules/lodash/_mapCacheClear.js ≠≠*/

/*== node_modules/lodash/_mapCacheDelete.js ==*/
$m['lodash/_mapCacheDelete.js#4.16.2'] = { exports: {} };
var _lodashmapCacheDeletejs4162_getMapData = $m['lodash/_getMapData.js#4.16.2'].exports;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashmapCacheDeletejs4162_mapCacheDelete(key) {
  var result = _lodashmapCacheDeletejs4162_getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

$m['lodash/_mapCacheDelete.js#4.16.2'].exports = _lodashmapCacheDeletejs4162_mapCacheDelete;
/*≠≠ node_modules/lodash/_mapCacheDelete.js ≠≠*/

/*== node_modules/lodash/_mapCacheGet.js ==*/
$m['lodash/_mapCacheGet.js#4.16.2'] = { exports: {} };
var _lodashmapCacheGetjs4162_getMapData = $m['lodash/_getMapData.js#4.16.2'].exports;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashmapCacheGetjs4162_mapCacheGet(key) {
  return _lodashmapCacheGetjs4162_getMapData(this, key).get(key);
}

$m['lodash/_mapCacheGet.js#4.16.2'].exports = _lodashmapCacheGetjs4162_mapCacheGet;
/*≠≠ node_modules/lodash/_mapCacheGet.js ≠≠*/

/*== node_modules/lodash/_mapCacheHas.js ==*/
$m['lodash/_mapCacheHas.js#4.16.2'] = { exports: {} };
var _lodashmapCacheHasjs4162_getMapData = $m['lodash/_getMapData.js#4.16.2'].exports;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashmapCacheHasjs4162_mapCacheHas(key) {
  return _lodashmapCacheHasjs4162_getMapData(this, key).has(key);
}

$m['lodash/_mapCacheHas.js#4.16.2'].exports = _lodashmapCacheHasjs4162_mapCacheHas;
/*≠≠ node_modules/lodash/_mapCacheHas.js ≠≠*/

/*== node_modules/lodash/_mapCacheSet.js ==*/
$m['lodash/_mapCacheSet.js#4.16.2'] = { exports: {} };
var _lodashmapCacheSetjs4162_getMapData = $m['lodash/_getMapData.js#4.16.2'].exports;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function _lodashmapCacheSetjs4162_mapCacheSet(key, value) {
  var data = _lodashmapCacheSetjs4162_getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

$m['lodash/_mapCacheSet.js#4.16.2'].exports = _lodashmapCacheSetjs4162_mapCacheSet;
/*≠≠ node_modules/lodash/_mapCacheSet.js ≠≠*/

/*== node_modules/lodash/_MapCache.js ==*/
$m['lodash/_MapCache.js#4.16.2'] = { exports: {} };
var _lodashMapCachejs4162_mapCacheClear = $m['lodash/_mapCacheClear.js#4.16.2'].exports,
    _lodashMapCachejs4162_mapCacheDelete = $m['lodash/_mapCacheDelete.js#4.16.2'].exports,
    _lodashMapCachejs4162_mapCacheGet = $m['lodash/_mapCacheGet.js#4.16.2'].exports,
    _lodashMapCachejs4162_mapCacheHas = $m['lodash/_mapCacheHas.js#4.16.2'].exports,
    _lodashMapCachejs4162_mapCacheSet = $m['lodash/_mapCacheSet.js#4.16.2'].exports;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashMapCachejs4162_MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `MapCache`.
_lodashMapCachejs4162_MapCache.prototype.clear = _lodashMapCachejs4162_mapCacheClear;
_lodashMapCachejs4162_MapCache.prototype['delete'] = _lodashMapCachejs4162_mapCacheDelete;
_lodashMapCachejs4162_MapCache.prototype.get = _lodashMapCachejs4162_mapCacheGet;
_lodashMapCachejs4162_MapCache.prototype.has = _lodashMapCachejs4162_mapCacheHas;
_lodashMapCachejs4162_MapCache.prototype.set = _lodashMapCachejs4162_mapCacheSet;

$m['lodash/_MapCache.js#4.16.2'].exports = _lodashMapCachejs4162_MapCache;
/*≠≠ node_modules/lodash/_MapCache.js ≠≠*/

/*== node_modules/lodash/_baseValues.js ==*/
$m['lodash/_baseValues.js#4.16.2'] = { exports: {} };
var _lodashbaseValuesjs4162_arrayMap = $m['lodash/_arrayMap.js#4.16.2'].exports;

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function _lodashbaseValuesjs4162_baseValues(object, props) {
  return _lodashbaseValuesjs4162_arrayMap(props, function (key) {
    return object[key];
  });
}

$m['lodash/_baseValues.js#4.16.2'].exports = _lodashbaseValuesjs4162_baseValues;
/*≠≠ node_modules/lodash/_baseValues.js ≠≠*/

/*== node_modules/lodash/has.js ==*/
$m['lodash/has.js#4.16.2'] = { exports: {} };
var _lodashhasjs4162_baseHas = $m['lodash/_baseHas.js#4.16.2'].exports,
    _lodashhasjs4162_hasPath = $m['lodash/_hasPath.js#4.16.2'].exports;

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function _lodashhasjs4162_has(object, path) {
  return object != null && _lodashhasjs4162_hasPath(object, path, _lodashhasjs4162_baseHas);
}

$m['lodash/has.js#4.16.2'].exports = _lodashhasjs4162_has;
/*≠≠ node_modules/lodash/has.js ≠≠*/

/*== node_modules/lodash/cloneDeep.js ==*/
$m['lodash/cloneDeep.js#4.16.2'] = { exports: {} };
var _lodashcloneDeepjs4162_baseClone = $m['lodash/_baseClone.js#4.16.2'].exports;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function _lodashcloneDeepjs4162_cloneDeep(value) {
  return _lodashcloneDeepjs4162_baseClone(value, true, true);
}

$m['lodash/cloneDeep.js#4.16.2'].exports = _lodashcloneDeepjs4162_cloneDeep;
/*≠≠ node_modules/lodash/cloneDeep.js ≠≠*/

/*== node_modules/babylon/lib/tokenizer/state.js ==*/
$m['babylon/lib/tokenizer/state.js#6.11.2'] = { exports: {} };
"use strict";

$m['babylon/lib/tokenizer/state.js#6.11.2'].exports.__esModule = true;

var _babylonlibtokenizerstatejs6112__location = $m['babylon/lib/util/location.js#6.11.2'].exports;

var _babylonlibtokenizerstatejs6112__context = $m['babylon/lib/tokenizer/context.js#6.11.2'].exports;

var _babylonlibtokenizerstatejs6112__types = $m['babylon/lib/tokenizer/types.js#6.11.2'].exports;

function _babylonlibtokenizerstatejs6112__classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var _babylonlibtokenizerstatejs6112_State = function () {
  function State() {
    _babylonlibtokenizerstatejs6112__classCallCheck(this, State);
  }

  State.prototype.init = function init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";

    this.input = input;

    this.potentialArrowAt = -1;

    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = false;

    this.labels = [];

    this.decorators = [];

    this.tokens = [];

    this.comments = [];

    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];

    this.pos = this.lineStart = 0;
    this.curLine = 1;

    this.type = _babylonlibtokenizerstatejs6112__types.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = [_babylonlibtokenizerstatejs6112__context.types.braceStatement];
    this.exprAllowed = true;

    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;

    this.exportedIdentifiers = [];

    return this;
  };

  // TODO


  // TODO


  // Used to signify the start of a potential arrow function


  // Flags to track whether we are in a function, a generator.


  // Labels in scope.


  // Leading decorators.


  // Token store.


  // Comment store.


  // Comment attachment store


  // The current position of the tokenizer in the input.


  // Properties of the current token:
  // Its type


  // For tokens that include more information than their type, the value


  // Its start and end offset


  // And, if locations are used, the {line, column} object
  // corresponding to those offsets


  // Position information for the previous token


  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.


  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.


  // TODO


  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.


  State.prototype.curPosition = function curPosition() {
    return new _babylonlibtokenizerstatejs6112__location.Position(this.curLine, this.pos - this.lineStart);
  };

  State.prototype.clone = function clone(skipArrays) {
    var state = new State();
    for (var key in this) {
      var val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }
    return state;
  };

  return State;
}();

$m['babylon/lib/tokenizer/state.js#6.11.2'].exports.default = _babylonlibtokenizerstatejs6112_State;
/*≠≠ node_modules/babylon/lib/tokenizer/state.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/types.js ==*/
$m['babel-generator/lib/generators/types.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/types.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ArrayPattern = $m['babel-generator/lib/generators/types.js#6.16.0'].exports.ObjectPattern = $m['babel-generator/lib/generators/types.js#6.16.0'].exports.RestProperty = $m['babel-generator/lib/generators/types.js#6.16.0'].exports.SpreadProperty = $m['babel-generator/lib/generators/types.js#6.16.0'].exports.SpreadElement = undefined;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.Identifier = _babelgeneratorlibgeneratorstypesjs6160_Identifier;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.RestElement = _babelgeneratorlibgeneratorstypesjs6160_RestElement;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ObjectExpression = _babelgeneratorlibgeneratorstypesjs6160_ObjectExpression;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ObjectMethod = _babelgeneratorlibgeneratorstypesjs6160_ObjectMethod;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ObjectProperty = _babelgeneratorlibgeneratorstypesjs6160_ObjectProperty;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ArrayExpression = _babelgeneratorlibgeneratorstypesjs6160_ArrayExpression;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.RegExpLiteral = _babelgeneratorlibgeneratorstypesjs6160_RegExpLiteral;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.BooleanLiteral = _babelgeneratorlibgeneratorstypesjs6160_BooleanLiteral;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.NullLiteral = _babelgeneratorlibgeneratorstypesjs6160_NullLiteral;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.NumericLiteral = _babelgeneratorlibgeneratorstypesjs6160_NumericLiteral;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.StringLiteral = _babelgeneratorlibgeneratorstypesjs6160_StringLiteral;

var _babelgeneratorlibgeneratorstypesjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorstypesjs6160_t = _babelgeneratorlibgeneratorstypesjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorstypesjs6160__babelTypes);

var _babelgeneratorlibgeneratorstypesjs6160__jsesc = $m['jsesc/jsesc.js#1.3.0'].exports;

var _babelgeneratorlibgeneratorstypesjs6160__jsesc2 = _babelgeneratorlibgeneratorstypesjs6160__interopRequireDefault(_babelgeneratorlibgeneratorstypesjs6160__jsesc);

function _babelgeneratorlibgeneratorstypesjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibgeneratorstypesjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibgeneratorstypesjs6160_Identifier(node) {
  if (node.variance) {
    if (node.variance === "plus") {
      this.token("+");
    } else if (node.variance === "minus") {
      this.token("-");
    }
  }

  this.word(node.name);
}

function _babelgeneratorlibgeneratorstypesjs6160_RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}

$m['babel-generator/lib/generators/types.js#6.16.0'].exports.SpreadElement = _babelgeneratorlibgeneratorstypesjs6160_RestElement;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.SpreadProperty = _babelgeneratorlibgeneratorstypesjs6160_RestElement;
$m['babel-generator/lib/generators/types.js#6.16.0'].exports.RestProperty = _babelgeneratorlibgeneratorstypesjs6160_RestElement;
function _babelgeneratorlibgeneratorstypesjs6160_ObjectExpression(node) {
  var props = node.properties;

  this.token("{");
  this.printInnerComments(node);

  if (props.length) {
    this.space();
    this.printList(props, node, { indent: true, statement: true });
    this.space();
  }

  this.token("}");
}

$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ObjectPattern = _babelgeneratorlibgeneratorstypesjs6160_ObjectExpression;
function _babelgeneratorlibgeneratorstypesjs6160_ObjectMethod(node) {
  this.printJoin(node.decorators, node);
  this._method(node);
}

function _babelgeneratorlibgeneratorstypesjs6160_ObjectProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (_babelgeneratorlibgeneratorstypesjs6160_t.isAssignmentPattern(node.value) && _babelgeneratorlibgeneratorstypesjs6160_t.isIdentifier(node.key) && node.key.name === node.value.left.name) {
      this.print(node.value, node);
      return;
    }

    this.print(node.key, node);

    if (node.shorthand && _babelgeneratorlibgeneratorstypesjs6160_t.isIdentifier(node.key) && _babelgeneratorlibgeneratorstypesjs6160_t.isIdentifier(node.value) && node.key.name === node.value.name) {
      return;
    }
  }

  this.token(":");
  this.space();
  this.print(node.value, node);
}

function _babelgeneratorlibgeneratorstypesjs6160_ArrayExpression(node) {
  var elems = node.elements;
  var len = elems.length;

  this.token("[");
  this.printInnerComments(node);

  for (var i = 0; i < elems.length; i++) {
    var elem = elems[i];
    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }

  this.token("]");
}

$m['babel-generator/lib/generators/types.js#6.16.0'].exports.ArrayPattern = _babelgeneratorlibgeneratorstypesjs6160_ArrayExpression;
function _babelgeneratorlibgeneratorstypesjs6160_RegExpLiteral(node) {
  this.word("/" + node.pattern + "/" + node.flags);
}

function _babelgeneratorlibgeneratorstypesjs6160_BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}

function _babelgeneratorlibgeneratorstypesjs6160_NullLiteral() {
  this.word("null");
}

function _babelgeneratorlibgeneratorstypesjs6160_NumericLiteral(node) {
  var raw = this.getPossibleRaw(node);

  this.number(raw == null ? node.value + "" : raw);
}

function _babelgeneratorlibgeneratorstypesjs6160_StringLiteral(node, parent) {
  var raw = this.getPossibleRaw(node);
  if (raw != null) {
    this.token(raw);
    return;
  }

  var val = (0, _babelgeneratorlibgeneratorstypesjs6160__jsesc2.default)(node.value, {
    quotes: _babelgeneratorlibgeneratorstypesjs6160_t.isJSX(parent) ? "double" : this.format.quotes,
    wrap: true
  });

  return this.token(val);
}
/*≠≠ node_modules/babel-generator/lib/generators/types.js ≠≠*/

/*== node_modules/babel-generator/lib/node/parentheses.js ==*/
$m['babel-generator/lib/node/parentheses.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.AwaitExpression = $m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.FunctionTypeAnnotation = undefined;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.NullableTypeAnnotation = _babelgeneratorlibnodeparenthesesjs6160_NullableTypeAnnotation;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.UpdateExpression = _babelgeneratorlibnodeparenthesesjs6160_UpdateExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.ObjectExpression = _babelgeneratorlibnodeparenthesesjs6160_ObjectExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.Binary = _babelgeneratorlibnodeparenthesesjs6160_Binary;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.BinaryExpression = _babelgeneratorlibnodeparenthesesjs6160_BinaryExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.SequenceExpression = _babelgeneratorlibnodeparenthesesjs6160_SequenceExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.YieldExpression = _babelgeneratorlibnodeparenthesesjs6160_YieldExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.ClassExpression = _babelgeneratorlibnodeparenthesesjs6160_ClassExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.UnaryLike = _babelgeneratorlibnodeparenthesesjs6160_UnaryLike;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.FunctionExpression = _babelgeneratorlibnodeparenthesesjs6160_FunctionExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.ArrowFunctionExpression = _babelgeneratorlibnodeparenthesesjs6160_ArrowFunctionExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.ConditionalExpression = _babelgeneratorlibnodeparenthesesjs6160_ConditionalExpression;
$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.AssignmentExpression = _babelgeneratorlibnodeparenthesesjs6160_AssignmentExpression;

var _babelgeneratorlibnodeparenthesesjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibnodeparenthesesjs6160_t = _babelgeneratorlibnodeparenthesesjs6160__interopRequireWildcard(_babelgeneratorlibnodeparenthesesjs6160__babelTypes);

function _babelgeneratorlibnodeparenthesesjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

var _babelgeneratorlibnodeparenthesesjs6160_PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10
};

function _babelgeneratorlibnodeparenthesesjs6160_NullableTypeAnnotation(node, parent) {
  return _babelgeneratorlibnodeparenthesesjs6160_t.isArrayTypeAnnotation(parent);
}

$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.FunctionTypeAnnotation = _babelgeneratorlibnodeparenthesesjs6160_NullableTypeAnnotation;
function _babelgeneratorlibnodeparenthesesjs6160_UpdateExpression(node, parent) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  return false;
}

function _babelgeneratorlibnodeparenthesesjs6160_ObjectExpression(node, parent, printStack) {
  return _babelgeneratorlibnodeparenthesesjs6160_isFirstInStatement(printStack, { considerArrow: true });
}

function _babelgeneratorlibnodeparenthesesjs6160_Binary(node, parent) {
  if ((_babelgeneratorlibnodeparenthesesjs6160_t.isCallExpression(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isNewExpression(parent)) && parent.callee === node) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isUnaryLike(parent)) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isBinary(parent)) {
    var parentOp = parent.operator;
    var parentPos = _babelgeneratorlibnodeparenthesesjs6160_PRECEDENCE[parentOp];

    var nodeOp = node.operator;
    var nodePos = _babelgeneratorlibnodeparenthesesjs6160_PRECEDENCE[nodeOp];

    if (parentPos > nodePos) {
      return true;
    }

    if (parentPos === nodePos && parent.right === node && !_babelgeneratorlibnodeparenthesesjs6160_t.isLogicalExpression(parent)) {
      return true;
    }
  }

  return false;
}

function _babelgeneratorlibnodeparenthesesjs6160_BinaryExpression(node, parent) {
  if (node.operator === "in") {
    if (_babelgeneratorlibnodeparenthesesjs6160_t.isVariableDeclarator(parent)) {
      return true;
    }

    if (_babelgeneratorlibnodeparenthesesjs6160_t.isFor(parent)) {
      return true;
    }
  }

  return false;
}

function _babelgeneratorlibnodeparenthesesjs6160_SequenceExpression(node, parent) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isForStatement(parent)) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isReturnStatement(parent)) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isThrowStatement(parent)) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isSwitchStatement(parent) && parent.discriminant === node) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isWhileStatement(parent) && parent.test === node) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isIfStatement(parent) && parent.test === node) {
    return false;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isForInStatement(parent) && parent.right === node) {
    return false;
  }

  return true;
}

function _babelgeneratorlibnodeparenthesesjs6160_YieldExpression(node, parent) {
  return _babelgeneratorlibnodeparenthesesjs6160_t.isBinary(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isUnaryLike(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isCallExpression(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isMemberExpression(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isNewExpression(parent);
}

$m['babel-generator/lib/node/parentheses.js#6.16.0'].exports.AwaitExpression = _babelgeneratorlibnodeparenthesesjs6160_YieldExpression;
function _babelgeneratorlibnodeparenthesesjs6160_ClassExpression(node, parent, printStack) {
  return _babelgeneratorlibnodeparenthesesjs6160_isFirstInStatement(printStack, { considerDefaultExports: true });
}

function _babelgeneratorlibnodeparenthesesjs6160_UnaryLike(node, parent) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isMemberExpression(parent, { object: node })) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isCallExpression(parent, { callee: node }) || _babelgeneratorlibnodeparenthesesjs6160_t.isNewExpression(parent, { callee: node })) {
    return true;
  }

  return false;
}

function _babelgeneratorlibnodeparenthesesjs6160_FunctionExpression(node, parent, printStack) {
  return _babelgeneratorlibnodeparenthesesjs6160_isFirstInStatement(printStack, { considerDefaultExports: true });
}

function _babelgeneratorlibnodeparenthesesjs6160_ArrowFunctionExpression(node, parent) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isExportDeclaration(parent)) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isBinaryExpression(parent) || _babelgeneratorlibnodeparenthesesjs6160_t.isLogicalExpression(parent)) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isUnaryExpression(parent)) {
    return true;
  }

  return _babelgeneratorlibnodeparenthesesjs6160_UnaryLike(node, parent);
}

function _babelgeneratorlibnodeparenthesesjs6160_ConditionalExpression(node, parent) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isUnaryLike(parent)) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isBinary(parent)) {
    return true;
  }

  if (_babelgeneratorlibnodeparenthesesjs6160_t.isConditionalExpression(parent, { test: node })) {
    return true;
  }

  return _babelgeneratorlibnodeparenthesesjs6160_UnaryLike(node, parent);
}

function _babelgeneratorlibnodeparenthesesjs6160_AssignmentExpression(node) {
  if (_babelgeneratorlibnodeparenthesesjs6160_t.isObjectPattern(node.left)) {
    return true;
  } else {
    return _babelgeneratorlibnodeparenthesesjs6160_ConditionalExpression.apply(undefined, arguments);
  }
}

function _babelgeneratorlibnodeparenthesesjs6160_isFirstInStatement(printStack) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _ref$considerArrow = _ref.considerArrow;
  var considerArrow = _ref$considerArrow === undefined ? false : _ref$considerArrow;
  var _ref$considerDefaultE = _ref.considerDefaultExports;
  var considerDefaultExports = _ref$considerDefaultE === undefined ? false : _ref$considerDefaultE;

  var i = printStack.length - 1;
  var node = printStack[i];
  i--;
  var parent = printStack[i];
  while (i > 0) {
    if (_babelgeneratorlibnodeparenthesesjs6160_t.isExpressionStatement(parent, { expression: node })) {
      return true;
    }

    if (considerDefaultExports && _babelgeneratorlibnodeparenthesesjs6160_t.isExportDefaultDeclaration(parent, { declaration: node })) {
      return true;
    }

    if (considerArrow && _babelgeneratorlibnodeparenthesesjs6160_t.isArrowFunctionExpression(parent, { body: node })) {
      return true;
    }

    if (_babelgeneratorlibnodeparenthesesjs6160_t.isCallExpression(parent, { callee: node }) || _babelgeneratorlibnodeparenthesesjs6160_t.isSequenceExpression(parent) && parent.expressions[0] === node || _babelgeneratorlibnodeparenthesesjs6160_t.isMemberExpression(parent, { object: node }) || _babelgeneratorlibnodeparenthesesjs6160_t.isConditional(parent, { test: node }) || _babelgeneratorlibnodeparenthesesjs6160_t.isBinary(parent, { left: node }) || _babelgeneratorlibnodeparenthesesjs6160_t.isAssignmentExpression(parent, { left: node })) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }

  return false;
}
/*≠≠ node_modules/babel-generator/lib/node/parentheses.js ≠≠*/

/*== node_modules/babel-generator/lib/node/whitespace.js ==*/
$m['babel-generator/lib/node/whitespace.js#6.16.0'] = { exports: {} };
"use strict";

var _babelgeneratorlibnodewhitespacejs6160__isBoolean = $m['lodash/isBoolean.js#4.16.2'].exports;

var _babelgeneratorlibnodewhitespacejs6160__isBoolean2 = _babelgeneratorlibnodewhitespacejs6160__interopRequireDefault(_babelgeneratorlibnodewhitespacejs6160__isBoolean);

var _babelgeneratorlibnodewhitespacejs6160__each = $m['lodash/each.js#4.16.2'].exports;

var _babelgeneratorlibnodewhitespacejs6160__each2 = _babelgeneratorlibnodewhitespacejs6160__interopRequireDefault(_babelgeneratorlibnodewhitespacejs6160__each);

var _babelgeneratorlibnodewhitespacejs6160__map = $m['lodash/map.js#4.16.2'].exports;

var _babelgeneratorlibnodewhitespacejs6160__map2 = _babelgeneratorlibnodewhitespacejs6160__interopRequireDefault(_babelgeneratorlibnodewhitespacejs6160__map);

var _babelgeneratorlibnodewhitespacejs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibnodewhitespacejs6160_t = _babelgeneratorlibnodewhitespacejs6160__interopRequireWildcard(_babelgeneratorlibnodewhitespacejs6160__babelTypes);

function _babelgeneratorlibnodewhitespacejs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibnodewhitespacejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibnodewhitespacejs6160_crawl(node) {
  var state = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (_babelgeneratorlibnodewhitespacejs6160_t.isMemberExpression(node)) {
    _babelgeneratorlibnodewhitespacejs6160_crawl(node.object, state);
    if (node.computed) _babelgeneratorlibnodewhitespacejs6160_crawl(node.property, state);
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isBinary(node) || _babelgeneratorlibnodewhitespacejs6160_t.isAssignmentExpression(node)) {
    _babelgeneratorlibnodewhitespacejs6160_crawl(node.left, state);
    _babelgeneratorlibnodewhitespacejs6160_crawl(node.right, state);
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isCallExpression(node)) {
    state.hasCall = true;
    _babelgeneratorlibnodewhitespacejs6160_crawl(node.callee, state);
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isFunction(node)) {
    state.hasFunction = true;
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isIdentifier(node)) {
    state.hasHelper = state.hasHelper || _babelgeneratorlibnodewhitespacejs6160_isHelper(node.callee);
  }

  return state;
}

function _babelgeneratorlibnodewhitespacejs6160_isHelper(node) {
  if (_babelgeneratorlibnodewhitespacejs6160_t.isMemberExpression(node)) {
    return _babelgeneratorlibnodewhitespacejs6160_isHelper(node.object) || _babelgeneratorlibnodewhitespacejs6160_isHelper(node.property);
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isCallExpression(node)) {
    return _babelgeneratorlibnodewhitespacejs6160_isHelper(node.callee);
  } else if (_babelgeneratorlibnodewhitespacejs6160_t.isBinary(node) || _babelgeneratorlibnodewhitespacejs6160_t.isAssignmentExpression(node)) {
    return _babelgeneratorlibnodewhitespacejs6160_t.isIdentifier(node.left) && _babelgeneratorlibnodewhitespacejs6160_isHelper(node.left) || _babelgeneratorlibnodewhitespacejs6160_isHelper(node.right);
  } else {
    return false;
  }
}

function _babelgeneratorlibnodewhitespacejs6160_isType(node) {
  return _babelgeneratorlibnodewhitespacejs6160_t.isLiteral(node) || _babelgeneratorlibnodewhitespacejs6160_t.isObjectExpression(node) || _babelgeneratorlibnodewhitespacejs6160_t.isArrayExpression(node) || _babelgeneratorlibnodewhitespacejs6160_t.isIdentifier(node) || _babelgeneratorlibnodewhitespacejs6160_t.isMemberExpression(node);
}

$m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes = {
  AssignmentExpression: function AssignmentExpression(node) {
    var state = _babelgeneratorlibnodewhitespacejs6160_crawl(node.right);
    if (state.hasCall && state.hasHelper || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true
      };
    }
  },
  SwitchCase: function SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node
    };
  },
  LogicalExpression: function LogicalExpression(node) {
    if (_babelgeneratorlibnodewhitespacejs6160_t.isFunction(node.left) || _babelgeneratorlibnodewhitespacejs6160_t.isFunction(node.right)) {
      return {
        after: true
      };
    }
  },
  Literal: function Literal(node) {
    if (node.value === "use strict") {
      return {
        after: true
      };
    }
  },
  CallExpression: function CallExpression(node) {
    if (_babelgeneratorlibnodewhitespacejs6160_t.isFunction(node.callee) || _babelgeneratorlibnodewhitespacejs6160_isHelper(node)) {
      return {
        before: true,
        after: true
      };
    }
  },
  VariableDeclaration: function VariableDeclaration(node) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];

      var enabled = _babelgeneratorlibnodewhitespacejs6160_isHelper(declar.id) && !_babelgeneratorlibnodewhitespacejs6160_isType(declar.init);
      if (!enabled) {
        var state = _babelgeneratorlibnodewhitespacejs6160_crawl(declar.init);
        enabled = _babelgeneratorlibnodewhitespacejs6160_isHelper(declar.init) && state.hasCall || state.hasFunction;
      }

      if (enabled) {
        return {
          before: true,
          after: true
        };
      }
    }
  },
  IfStatement: function IfStatement(node) {
    if (_babelgeneratorlibnodewhitespacejs6160_t.isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true
      };
    }
  }
};

$m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes.ObjectProperty = $m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes.ObjectTypeProperty = $m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes.ObjectMethod = $m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes.SpreadProperty = function (node, parent) {
  if (parent.properties[0] === node) {
    return {
      before: true
    };
  }
};

$m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.list = {
  VariableDeclaration: function VariableDeclaration(node) {
    return (0, _babelgeneratorlibnodewhitespacejs6160__map2.default)(node.declarations, "init");
  },
  ArrayExpression: function ArrayExpression(node) {
    return node.elements;
  },
  ObjectExpression: function ObjectExpression(node) {
    return node.properties;
  }
};

(0, _babelgeneratorlibnodewhitespacejs6160__each2.default)({
  Function: true,
  Class: true,
  Loop: true,
  LabeledStatement: true,
  SwitchStatement: true,
  TryStatement: true
}, function (amounts, type) {
  if ((0, _babelgeneratorlibnodewhitespacejs6160__isBoolean2.default)(amounts)) {
    amounts = { after: amounts, before: amounts };
  }

  (0, _babelgeneratorlibnodewhitespacejs6160__each2.default)([type].concat(_babelgeneratorlibnodewhitespacejs6160_t.FLIPPED_ALIAS_KEYS[type] || []), function (type) {
    $m['babel-generator/lib/node/whitespace.js#6.16.0'].exports.nodes[type] = function () {
      return amounts;
    };
  });
});
/*≠≠ node_modules/babel-generator/lib/node/whitespace.js ≠≠*/

/*== node_modules/babel-generator/lib/node/index.js ==*/
$m['babel-generator/lib/node/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/node/index.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibnodeindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelgeneratorlibnodeindexjs6160__getIterator3 = _babelgeneratorlibnodeindexjs6160__interopRequireDefault(_babelgeneratorlibnodeindexjs6160__getIterator2);

var _babelgeneratorlibnodeindexjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babelgeneratorlibnodeindexjs6160__keys2 = _babelgeneratorlibnodeindexjs6160__interopRequireDefault(_babelgeneratorlibnodeindexjs6160__keys);

$m['babel-generator/lib/node/index.js#6.16.0'].exports.needsWhitespace = _babelgeneratorlibnodeindexjs6160_needsWhitespace;
$m['babel-generator/lib/node/index.js#6.16.0'].exports.needsWhitespaceBefore = _babelgeneratorlibnodeindexjs6160_needsWhitespaceBefore;
$m['babel-generator/lib/node/index.js#6.16.0'].exports.needsWhitespaceAfter = _babelgeneratorlibnodeindexjs6160_needsWhitespaceAfter;
$m['babel-generator/lib/node/index.js#6.16.0'].exports.needsParens = _babelgeneratorlibnodeindexjs6160_needsParens;

var _babelgeneratorlibnodeindexjs6160__whitespace = $m['babel-generator/lib/node/whitespace.js#6.16.0'].exports;

var _babelgeneratorlibnodeindexjs6160__whitespace2 = _babelgeneratorlibnodeindexjs6160__interopRequireDefault(_babelgeneratorlibnodeindexjs6160__whitespace);

var _babelgeneratorlibnodeindexjs6160__parentheses = $m['babel-generator/lib/node/parentheses.js#6.16.0'].exports;

var _babelgeneratorlibnodeindexjs6160_parens = _babelgeneratorlibnodeindexjs6160__interopRequireWildcard(_babelgeneratorlibnodeindexjs6160__parentheses);

var _babelgeneratorlibnodeindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibnodeindexjs6160_t = _babelgeneratorlibnodeindexjs6160__interopRequireWildcard(_babelgeneratorlibnodeindexjs6160__babelTypes);

function _babelgeneratorlibnodeindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibnodeindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibnodeindexjs6160_expandAliases(obj) {
  var newObj = {};

  function add(type, func) {
    var fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) {
      var result = fn(node, parent, stack);

      return result == null ? func(node, parent, stack) : result;
    } : func;
  }

  for (var _iterator = (0, _babelgeneratorlibnodeindexjs6160__keys2.default)(obj), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelgeneratorlibnodeindexjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var type = _ref;

    var aliases = _babelgeneratorlibnodeindexjs6160_t.FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (var _iterator2 = aliases, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelgeneratorlibnodeindexjs6160__getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var alias = _ref2;

        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }

  return newObj;
}

var _babelgeneratorlibnodeindexjs6160_expandedParens = _babelgeneratorlibnodeindexjs6160_expandAliases(_babelgeneratorlibnodeindexjs6160_parens);
var _babelgeneratorlibnodeindexjs6160_expandedWhitespaceNodes = _babelgeneratorlibnodeindexjs6160_expandAliases(_babelgeneratorlibnodeindexjs6160__whitespace2.default.nodes);
var _babelgeneratorlibnodeindexjs6160_expandedWhitespaceList = _babelgeneratorlibnodeindexjs6160_expandAliases(_babelgeneratorlibnodeindexjs6160__whitespace2.default.list);

function _babelgeneratorlibnodeindexjs6160_find(obj, node, parent, printStack) {
  var fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}

function _babelgeneratorlibnodeindexjs6160_isOrHasCallExpression(node) {
  if (_babelgeneratorlibnodeindexjs6160_t.isCallExpression(node)) {
    return true;
  }

  if (_babelgeneratorlibnodeindexjs6160_t.isMemberExpression(node)) {
    return _babelgeneratorlibnodeindexjs6160_isOrHasCallExpression(node.object) || !node.computed && _babelgeneratorlibnodeindexjs6160_isOrHasCallExpression(node.property);
  } else {
    return false;
  }
}

function _babelgeneratorlibnodeindexjs6160_needsWhitespace(node, parent, type) {
  if (!node) return 0;

  if (_babelgeneratorlibnodeindexjs6160_t.isExpressionStatement(node)) {
    node = node.expression;
  }

  var linesInfo = _babelgeneratorlibnodeindexjs6160_find(_babelgeneratorlibnodeindexjs6160_expandedWhitespaceNodes, node, parent);

  if (!linesInfo) {
    var items = _babelgeneratorlibnodeindexjs6160_find(_babelgeneratorlibnodeindexjs6160_expandedWhitespaceList, node, parent);
    if (items) {
      for (var i = 0; i < items.length; i++) {
        linesInfo = _babelgeneratorlibnodeindexjs6160_needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }

  return linesInfo && linesInfo[type] || 0;
}

function _babelgeneratorlibnodeindexjs6160_needsWhitespaceBefore(node, parent) {
  return _babelgeneratorlibnodeindexjs6160_needsWhitespace(node, parent, "before");
}

function _babelgeneratorlibnodeindexjs6160_needsWhitespaceAfter(node, parent) {
  return _babelgeneratorlibnodeindexjs6160_needsWhitespace(node, parent, "after");
}

function _babelgeneratorlibnodeindexjs6160_needsParens(node, parent, printStack) {
  if (!parent) return false;

  if (_babelgeneratorlibnodeindexjs6160_t.isNewExpression(parent) && parent.callee === node) {
    if (_babelgeneratorlibnodeindexjs6160_isOrHasCallExpression(node)) return true;
  }

  return _babelgeneratorlibnodeindexjs6160_find(_babelgeneratorlibnodeindexjs6160_expandedParens, node, parent, printStack);
}
/*≠≠ node_modules/babel-generator/lib/node/index.js ≠≠*/

/*== node_modules/lodash/trimEnd.js ==*/
$m['lodash/trimEnd.js#4.16.2'] = { exports: {} };
var _lodashtrimEndjs4162_baseToString = $m['lodash/_baseToString.js#4.16.2'].exports,
    _lodashtrimEndjs4162_castSlice = $m['lodash/_castSlice.js#4.16.2'].exports,
    _lodashtrimEndjs4162_charsEndIndex = $m['lodash/_charsEndIndex.js#4.16.2'].exports,
    _lodashtrimEndjs4162_stringToArray = $m['lodash/_stringToArray.js#4.16.2'].exports,
    _lodashtrimEndjs4162_toString = $m['lodash/toString.js#4.16.2'].exports;

/** Used to match leading and trailing whitespace. */
var _lodashtrimEndjs4162_reTrimEnd = /\s+$/;

/**
 * Removes trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimEnd('  abc  ');
 * // => '  abc'
 *
 * _.trimEnd('-_-abc-_-', '_-');
 * // => '-_-abc'
 */
function _lodashtrimEndjs4162_trimEnd(string, chars, guard) {
  string = _lodashtrimEndjs4162_toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(_lodashtrimEndjs4162_reTrimEnd, '');
  }
  if (!string || !(chars = _lodashtrimEndjs4162_baseToString(chars))) {
    return string;
  }
  var strSymbols = _lodashtrimEndjs4162_stringToArray(string),
      end = _lodashtrimEndjs4162_charsEndIndex(strSymbols, _lodashtrimEndjs4162_stringToArray(chars)) + 1;

  return _lodashtrimEndjs4162_castSlice(strSymbols, 0, end).join('');
}

$m['lodash/trimEnd.js#4.16.2'].exports = _lodashtrimEndjs4162_trimEnd;
/*≠≠ node_modules/lodash/trimEnd.js ≠≠*/

/*== node_modules/lodash/findLastIndex.js ==*/
$m['lodash/findLastIndex.js#4.16.2'] = { exports: {} };
var _lodashfindLastIndexjs4162_baseFindIndex = $m['lodash/_baseFindIndex.js#4.16.2'].exports,
    _lodashfindLastIndexjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashfindLastIndexjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashfindLastIndexjs4162_nativeMax = Math.max,
    _lodashfindLastIndexjs4162_nativeMin = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function _lodashfindLastIndexjs4162_findLastIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = _lodashfindLastIndexjs4162_toInteger(fromIndex);
    index = fromIndex < 0 ? _lodashfindLastIndexjs4162_nativeMax(length + index, 0) : _lodashfindLastIndexjs4162_nativeMin(index, length - 1);
  }
  return _lodashfindLastIndexjs4162_baseFindIndex(array, _lodashfindLastIndexjs4162_baseIteratee(predicate, 3), index, true);
}

$m['lodash/findLastIndex.js#4.16.2'].exports = _lodashfindLastIndexjs4162_findLastIndex;
/*≠≠ node_modules/lodash/findLastIndex.js ≠≠*/

/*== node_modules/lodash/findIndex.js ==*/
$m['lodash/findIndex.js#4.16.2'] = { exports: {} };
var _lodashfindIndexjs4162_baseFindIndex = $m['lodash/_baseFindIndex.js#4.16.2'].exports,
    _lodashfindIndexjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashfindIndexjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashfindIndexjs4162_nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function _lodashfindIndexjs4162_findIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : _lodashfindIndexjs4162_toInteger(fromIndex);
  if (index < 0) {
    index = _lodashfindIndexjs4162_nativeMax(length + index, 0);
  }
  return _lodashfindIndexjs4162_baseFindIndex(array, _lodashfindIndexjs4162_baseIteratee(predicate, 3), index);
}

$m['lodash/findIndex.js#4.16.2'].exports = _lodashfindIndexjs4162_findIndex;
/*≠≠ node_modules/lodash/findIndex.js ≠≠*/

/*== node_modules/lodash/_createFind.js ==*/
$m['lodash/_createFind.js#4.16.2'] = { exports: {} };
var _lodashcreateFindjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashcreateFindjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports,
    _lodashcreateFindjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function _lodashcreateFindjs4162_createFind(findIndexFunc) {
  return function (collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!_lodashcreateFindjs4162_isArrayLike(collection)) {
      var iteratee = _lodashcreateFindjs4162_baseIteratee(predicate, 3);
      collection = _lodashcreateFindjs4162_keys(collection);
      predicate = function (key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

$m['lodash/_createFind.js#4.16.2'].exports = _lodashcreateFindjs4162_createFind;
/*≠≠ node_modules/lodash/_createFind.js ≠≠*/

/*== node_modules/is-finite/index.js ==*/
$m['is-finite/index.js#1.0.2'] = { exports: {} };
'use strict';

var _isfiniteindexjs102_numberIsNan = $m['number-is-nan/index.js#1.0.1'].exports;

$m['is-finite/index.js#1.0.2'].exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || _isfiniteindexjs102_numberIsNan(val) || val === Infinity || val === -Infinity);
};
/*≠≠ node_modules/is-finite/index.js ≠≠*/

/*== node_modules/babel-runtime/core-js/symbol.js ==*/
$m['babel-runtime/core-js/symbol.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/symbol.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/symbol.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/file/index.js ==*/
$m['babel-core/lib/transformation/file/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/index.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/transformation/file/index.js#6.16.0'].exports.File = undefined;

var _babelcorelibtransformationfileindexjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__typeof3 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__typeof2);

var _babelcorelibtransformationfileindexjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__getIterator3 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__getIterator2);

var _babelcorelibtransformationfileindexjs6160__create = $m['babel-runtime/core-js/object/create.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__create2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__create);

var _babelcorelibtransformationfileindexjs6160__assign = $m['babel-runtime/core-js/object/assign.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__assign2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__assign);

var _babelcorelibtransformationfileindexjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__classCallCheck3 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__classCallCheck2);

var _babelcorelibtransformationfileindexjs6160__possibleConstructorReturn2 = $m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__possibleConstructorReturn3 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__possibleConstructorReturn2);

var _babelcorelibtransformationfileindexjs6160__inherits2 = $m['babel-runtime/helpers/inherits.js#6.11.6'].exports;

var _babelcorelibtransformationfileindexjs6160__inherits3 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__inherits2);

var _babelcorelibtransformationfileindexjs6160__babelHelpers = $m['babel-helpers/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__babelHelpers2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__babelHelpers);

var _babelcorelibtransformationfileindexjs6160__metadata = $m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160_metadataVisitor = _babelcorelibtransformationfileindexjs6160__interopRequireWildcard(_babelcorelibtransformationfileindexjs6160__metadata);

var _babelcorelibtransformationfileindexjs6160__convertSourceMap = $m['convert-source-map/index.js#1.3.0'].exports;

var _babelcorelibtransformationfileindexjs6160__convertSourceMap2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__convertSourceMap);

var _babelcorelibtransformationfileindexjs6160__optionManager = require("babel-core/lib/transformation/file/options/option-manager.js#6.16.0");

var _babelcorelibtransformationfileindexjs6160__optionManager2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__optionManager);

var _babelcorelibtransformationfileindexjs6160__pluginPass = require("babel-core/lib/transformation/plugin-pass.js#6.16.0");

var _babelcorelibtransformationfileindexjs6160__pluginPass2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__pluginPass);

var _babelcorelibtransformationfileindexjs6160__shebangRegex = $m['shebang-regex/index.js#1.0.0'].exports;

var _babelcorelibtransformationfileindexjs6160__shebangRegex2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__shebangRegex);

var _babelcorelibtransformationfileindexjs6160__babelTraverse = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__babelTraverse2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__babelTraverse);

var _babelcorelibtransformationfileindexjs6160__sourceMap = $m['source-map/source-map.js#0.5.6'].exports;

var _babelcorelibtransformationfileindexjs6160__sourceMap2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__sourceMap);

var _babelcorelibtransformationfileindexjs6160__babelGenerator = $m['babel-generator/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__babelGenerator2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__babelGenerator);

var _babelcorelibtransformationfileindexjs6160__babelCodeFrame = $m['babel-code-frame/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__babelCodeFrame2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__babelCodeFrame);

var _babelcorelibtransformationfileindexjs6160__defaults = $m['lodash/defaults.js#4.16.2'].exports;

var _babelcorelibtransformationfileindexjs6160__defaults2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__defaults);

var _babelcorelibtransformationfileindexjs6160__logger = $m['babel-core/lib/transformation/file/logger.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__logger2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__logger);

var _babelcorelibtransformationfileindexjs6160__store = $m['babel-core/lib/store.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__store2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__store);

var _babelcorelibtransformationfileindexjs6160__babylon = $m['babylon/lib/index.js#6.11.2'].exports;

var _babelcorelibtransformationfileindexjs6160__util = $m['babel-core/lib/util.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160_util = _babelcorelibtransformationfileindexjs6160__interopRequireWildcard(_babelcorelibtransformationfileindexjs6160__util);

var _babelcorelibtransformationfileindexjs6160__path = require("path");

var _babelcorelibtransformationfileindexjs6160__path2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__path);

var _babelcorelibtransformationfileindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160_t = _babelcorelibtransformationfileindexjs6160__interopRequireWildcard(_babelcorelibtransformationfileindexjs6160__babelTypes);

var _babelcorelibtransformationfileindexjs6160__resolve = $m['babel-core/lib/helpers/resolve.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__resolve2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__resolve);

var _babelcorelibtransformationfileindexjs6160__blockHoist = $m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__blockHoist2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__blockHoist);

var _babelcorelibtransformationfileindexjs6160__shadowFunctions = $m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'].exports;

var _babelcorelibtransformationfileindexjs6160__shadowFunctions2 = _babelcorelibtransformationfileindexjs6160__interopRequireDefault(_babelcorelibtransformationfileindexjs6160__shadowFunctions);

function _babelcorelibtransformationfileindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationfileindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfileindexjs6160_INTERNAL_PLUGINS = [[_babelcorelibtransformationfileindexjs6160__blockHoist2.default], [_babelcorelibtransformationfileindexjs6160__shadowFunctions2.default]];

var _babelcorelibtransformationfileindexjs6160_errorVisitor = {
  enter: function enter(path, state) {
    var loc = path.node.loc;
    if (loc) {
      state.loc = loc;
      path.stop();
    }
  }
};

var _babelcorelibtransformationfileindexjs6160_File = function (_Store) {
  (0, _babelcorelibtransformationfileindexjs6160__inherits3.default)(File, _Store);

  function File() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var pipeline = arguments[1];
    (0, _babelcorelibtransformationfileindexjs6160__classCallCheck3.default)(this, File);

    var _this = (0, _babelcorelibtransformationfileindexjs6160__possibleConstructorReturn3.default)(this, _Store.call(this));

    _this.pipeline = pipeline;

    _this.log = new _babelcorelibtransformationfileindexjs6160__logger2.default(_this, opts.filename || "unknown");
    _this.opts = _this.initOptions(opts);

    _this.parserOpts = {
      highlightCode: _this.opts.highlightCode,
      nonStandard: _this.opts.nonStandard,
      sourceType: _this.opts.sourceType,
      filename: _this.opts.filename,
      sourceFileName: _this.opts.filename,
      plugins: []
    };

    _this.pluginVisitors = [];
    _this.pluginPasses = [];

    _this.buildPluginsForOptions(_this.opts);

    if (_this.opts.passPerPreset) {
      _this.perPresetOpts = [];
      _this.opts.presets.forEach(function (presetOpts) {
        var perPresetOpts = (0, _babelcorelibtransformationfileindexjs6160__assign2.default)((0, _babelcorelibtransformationfileindexjs6160__create2.default)(_this.opts), presetOpts);
        _this.perPresetOpts.push(perPresetOpts);
        _this.buildPluginsForOptions(perPresetOpts);
      });
    }

    _this.metadata = {
      usedHelpers: [],
      marked: [],
      modules: {
        imports: [],
        exports: {
          exported: [],
          specifiers: []
        }
      }
    };

    _this.dynamicImportTypes = {};
    _this.dynamicImportIds = {};
    _this.dynamicImports = [];
    _this.declarations = {};
    _this.usedHelpers = {};

    _this.path = null;
    _this.ast = {};

    _this.code = "";
    _this.shebang = "";

    _this.hub = new _babelcorelibtransformationfileindexjs6160__babelTraverse.Hub(_this);
    return _this;
  }

  File.prototype.getMetadata = function getMetadata() {
    var has = false;
    for (var _iterator = this.ast.program.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibtransformationfileindexjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;

      if (_babelcorelibtransformationfileindexjs6160_t.isModuleDeclaration(node)) {
        has = true;
        break;
      }
    }
    if (has) {
      this.path.traverse(_babelcorelibtransformationfileindexjs6160_metadataVisitor, this);
    }
  };

  File.prototype.initOptions = function initOptions(opts) {
    opts = new _babelcorelibtransformationfileindexjs6160__optionManager2.default(this.log, this.pipeline).init(opts);

    if (opts.inputSourceMap) {
      opts.sourceMaps = true;
    }

    if (opts.moduleId) {
      opts.moduleIds = true;
    }

    opts.basename = _babelcorelibtransformationfileindexjs6160__path2.default.basename(opts.filename, _babelcorelibtransformationfileindexjs6160__path2.default.extname(opts.filename));

    opts.ignore = _babelcorelibtransformationfileindexjs6160_util.arrayify(opts.ignore, _babelcorelibtransformationfileindexjs6160_util.regexify);

    if (opts.only) opts.only = _babelcorelibtransformationfileindexjs6160_util.arrayify(opts.only, _babelcorelibtransformationfileindexjs6160_util.regexify);

    (0, _babelcorelibtransformationfileindexjs6160__defaults2.default)(opts, {
      moduleRoot: opts.sourceRoot
    });

    (0, _babelcorelibtransformationfileindexjs6160__defaults2.default)(opts, {
      sourceRoot: opts.moduleRoot
    });

    (0, _babelcorelibtransformationfileindexjs6160__defaults2.default)(opts, {
      filenameRelative: opts.filename
    });

    var basenameRelative = _babelcorelibtransformationfileindexjs6160__path2.default.basename(opts.filenameRelative);

    (0, _babelcorelibtransformationfileindexjs6160__defaults2.default)(opts, {
      sourceFileName: basenameRelative,
      sourceMapTarget: basenameRelative
    });

    return opts;
  };

  File.prototype.buildPluginsForOptions = function buildPluginsForOptions(opts) {
    if (!Array.isArray(opts.plugins)) {
      return;
    }

    var plugins = opts.plugins.concat(_babelcorelibtransformationfileindexjs6160_INTERNAL_PLUGINS);
    var currentPluginVisitors = [];
    var currentPluginPasses = [];

    for (var _iterator2 = plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelcorelibtransformationfileindexjs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var ref = _ref2;
      var plugin = ref[0];
      var pluginOpts = ref[1];

      currentPluginVisitors.push(plugin.visitor);
      currentPluginPasses.push(new _babelcorelibtransformationfileindexjs6160__pluginPass2.default(this, plugin, pluginOpts));

      if (plugin.manipulateOptions) {
        plugin.manipulateOptions(opts, this.parserOpts, this);
      }
    }

    this.pluginVisitors.push(currentPluginVisitors);
    this.pluginPasses.push(currentPluginPasses);
  };

  File.prototype.getModuleName = function getModuleName() {
    var opts = this.opts;
    if (!opts.moduleIds) {
      return null;
    }

    if (opts.moduleId != null && !opts.getModuleId) {
      return opts.moduleId;
    }

    var filenameRelative = opts.filenameRelative;
    var moduleName = "";

    if (opts.moduleRoot != null) {
      moduleName = opts.moduleRoot + "/";
    }

    if (!opts.filenameRelative) {
      return moduleName + opts.filename.replace(/^\//, "");
    }

    if (opts.sourceRoot != null) {
      var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "\/?");
      filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
    }

    filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");

    moduleName += filenameRelative;

    moduleName = moduleName.replace(/\\/g, "/");

    if (opts.getModuleId) {
      return opts.getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  };

  File.prototype.resolveModuleSource = function resolveModuleSource(source) {
    var resolveModuleSource = this.opts.resolveModuleSource;
    if (resolveModuleSource) source = resolveModuleSource(source, this.opts.filename);
    return source;
  };

  File.prototype.addImport = function addImport(source, imported) {
    var name = arguments.length <= 2 || arguments[2] === undefined ? imported : arguments[2];

    var alias = source + ":" + imported;
    var id = this.dynamicImportIds[alias];

    if (!id) {
      source = this.resolveModuleSource(source);
      id = this.dynamicImportIds[alias] = this.scope.generateUidIdentifier(name);

      var specifiers = [];

      if (imported === "*") {
        specifiers.push(_babelcorelibtransformationfileindexjs6160_t.importNamespaceSpecifier(id));
      } else if (imported === "default") {
        specifiers.push(_babelcorelibtransformationfileindexjs6160_t.importDefaultSpecifier(id));
      } else {
        specifiers.push(_babelcorelibtransformationfileindexjs6160_t.importSpecifier(id, _babelcorelibtransformationfileindexjs6160_t.identifier(imported)));
      }

      var declar = _babelcorelibtransformationfileindexjs6160_t.importDeclaration(specifiers, _babelcorelibtransformationfileindexjs6160_t.stringLiteral(source));
      declar._blockHoist = 3;

      this.path.unshiftContainer("body", declar);
    }

    return id;
  };

  File.prototype.addHelper = function addHelper(name) {
    var declar = this.declarations[name];
    if (declar) return declar;

    if (!this.usedHelpers[name]) {
      this.metadata.usedHelpers.push(name);
      this.usedHelpers[name] = true;
    }

    var generator = this.get("helperGenerator");
    var runtime = this.get("helpersNamespace");
    if (generator) {
      var res = generator(name);
      if (res) return res;
    } else if (runtime) {
      return _babelcorelibtransformationfileindexjs6160_t.memberExpression(runtime, _babelcorelibtransformationfileindexjs6160_t.identifier(name));
    }

    var ref = (0, _babelcorelibtransformationfileindexjs6160__babelHelpers2.default)(name);
    var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);

    if (_babelcorelibtransformationfileindexjs6160_t.isFunctionExpression(ref) && !ref.id) {
      ref.body._compact = true;
      ref._generated = true;
      ref.id = uid;
      ref.type = "FunctionDeclaration";
      this.path.unshiftContainer("body", ref);
    } else {
      ref._compact = true;
      this.scope.push({
        id: uid,
        init: ref,
        unique: true
      });
    }

    return uid;
  };

  File.prototype.addTemplateObject = function addTemplateObject(helperName, strings, raw) {
    var stringIds = raw.elements.map(function (string) {
      return string.value;
    });
    var name = helperName + "_" + raw.elements.length + "_" + stringIds.join(",");

    var declar = this.declarations[name];
    if (declar) return declar;

    var uid = this.declarations[name] = this.scope.generateUidIdentifier("templateObject");

    var helperId = this.addHelper(helperName);
    var init = _babelcorelibtransformationfileindexjs6160_t.callExpression(helperId, [strings, raw]);
    init._compact = true;
    this.scope.push({
      id: uid,
      init: init,
      _blockHoist: 1.9 });
    return uid;
  };

  File.prototype.buildCodeFrameError = function buildCodeFrameError(node, msg) {
    var Error = arguments.length <= 2 || arguments[2] === undefined ? SyntaxError : arguments[2];

    var loc = node && (node.loc || node._loc);

    var err = new Error(msg);

    if (loc) {
      err.loc = loc.start;
    } else {
      (0, _babelcorelibtransformationfileindexjs6160__babelTraverse2.default)(node, _babelcorelibtransformationfileindexjs6160_errorVisitor, this.scope, err);

      err.message += " (This is an error on an internal node. Probably an internal error";

      if (err.loc) {
        err.message += ". Location has been estimated.";
      }

      err.message += ")";
    }

    return err;
  };

  File.prototype.mergeSourceMap = function mergeSourceMap(map) {
    var inputMap = this.opts.inputSourceMap;

    if (inputMap) {
      var _ret = function () {
        var inputMapConsumer = new _babelcorelibtransformationfileindexjs6160__sourceMap2.default.SourceMapConsumer(inputMap);
        var outputMapConsumer = new _babelcorelibtransformationfileindexjs6160__sourceMap2.default.SourceMapConsumer(map);

        var mergedGenerator = new _babelcorelibtransformationfileindexjs6160__sourceMap2.default.SourceMapGenerator({
          file: inputMapConsumer.file,
          sourceRoot: inputMapConsumer.sourceRoot
        });

        var source = outputMapConsumer.sources[0];

        inputMapConsumer.eachMapping(function (mapping) {
          var generatedPosition = outputMapConsumer.generatedPositionFor({
            line: mapping.generatedLine,
            column: mapping.generatedColumn,
            source: source
          });
          if (generatedPosition.column != null) {
            mergedGenerator.addMapping({
              source: mapping.source,

              original: mapping.source == null ? null : {
                line: mapping.originalLine,
                column: mapping.originalColumn
              },

              generated: generatedPosition
            });
          }
        });

        var mergedMap = mergedGenerator.toJSON();
        inputMap.mappings = mergedMap.mappings;
        return {
          v: inputMap
        };
      }();

      if ((typeof _ret === "undefined" ? "undefined" : (0, _babelcorelibtransformationfileindexjs6160__typeof3.default)(_ret)) === "object") return _ret.v;
    } else {
      return map;
    }
  };

  File.prototype.parse = function parse(code) {
    var parseCode = _babelcorelibtransformationfileindexjs6160__babylon.parse;
    var parserOpts = this.opts.parserOpts;

    if (parserOpts) {
      parserOpts = (0, _babelcorelibtransformationfileindexjs6160__assign2.default)({}, this.parserOpts, parserOpts);

      if (parserOpts.parser) {
        if (typeof parserOpts.parser === "string") {
          var dirname = _babelcorelibtransformationfileindexjs6160__path2.default.dirname(this.opts.filename) || process.cwd();
          var parser = (0, _babelcorelibtransformationfileindexjs6160__resolve2.default)(parserOpts.parser, dirname);
          if (parser) {
            parseCode = require(parser).parse;
          } else {
            throw new Error("Couldn't find parser " + parserOpts.parser + " with \"parse\" method relative to directory " + dirname);
          }
        } else {
          parseCode = parserOpts.parser;
        }

        parserOpts.parser = {
          parse: function parse(source) {
            return (0, _babelcorelibtransformationfileindexjs6160__babylon.parse)(source, parserOpts);
          }
        };
      }
    }

    this.log.debug("Parse start");
    var ast = parseCode(code, parserOpts || this.parserOpts);
    this.log.debug("Parse stop");
    return ast;
  };

  File.prototype._addAst = function _addAst(ast) {
    this.path = _babelcorelibtransformationfileindexjs6160__babelTraverse.NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: ast,
      container: ast,
      key: "program"
    }).setContext();
    this.scope = this.path.scope;
    this.ast = ast;
    this.getMetadata();
  };

  File.prototype.addAst = function addAst(ast) {
    this.log.debug("Start set AST");
    this._addAst(ast);
    this.log.debug("End set AST");
  };

  File.prototype.transform = function transform() {
    for (var i = 0; i < this.pluginPasses.length; i++) {
      var pluginPasses = this.pluginPasses[i];
      this.call("pre", pluginPasses);
      this.log.debug("Start transform traverse");

      var visitor = _babelcorelibtransformationfileindexjs6160__babelTraverse2.default.visitors.merge(this.pluginVisitors[i], pluginPasses, this.opts.wrapPluginVisitorMethod);
      (0, _babelcorelibtransformationfileindexjs6160__babelTraverse2.default)(this.ast, visitor, this.scope);

      this.log.debug("End transform traverse");
      this.call("post", pluginPasses);
    }

    return this.generate();
  };

  File.prototype.wrap = function wrap(code, callback) {
    code = code + "";

    try {
      if (this.shouldIgnore()) {
        return this.makeResult({ code: code, ignored: true });
      } else {
        return callback();
      }
    } catch (err) {
      if (err._babel) {
        throw err;
      } else {
        err._babel = true;
      }

      var message = err.message = this.opts.filename + ": " + err.message;

      var loc = err.loc;
      if (loc) {
        err.codeFrame = (0, _babelcorelibtransformationfileindexjs6160__babelCodeFrame2.default)(code, loc.line, loc.column + 1, this.opts);
        message += "\n" + err.codeFrame;
      }

      if (process.browser) {
        err.message = message;
      }

      if (err.stack) {
        var newStack = err.stack.replace(err.message, message);
        err.stack = newStack;
      }

      throw err;
    }
  };

  File.prototype.addCode = function addCode(code) {
    code = (code || "") + "";
    code = this.parseInputSourceMap(code);
    this.code = code;
  };

  File.prototype.parseCode = function parseCode() {
    this.parseShebang();
    var ast = this.parse(this.code);
    this.addAst(ast);
  };

  File.prototype.shouldIgnore = function shouldIgnore() {
    var opts = this.opts;
    return _babelcorelibtransformationfileindexjs6160_util.shouldIgnore(opts.filename, opts.ignore, opts.only);
  };

  File.prototype.call = function call(key, pluginPasses) {
    for (var _iterator3 = pluginPasses, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _babelcorelibtransformationfileindexjs6160__getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var pass = _ref3;

      var plugin = pass.plugin;
      var fn = plugin[key];
      if (fn) fn.call(pass, this);
    }
  };

  File.prototype.parseInputSourceMap = function parseInputSourceMap(code) {
    var opts = this.opts;

    if (opts.inputSourceMap !== false) {
      var inputMap = _babelcorelibtransformationfileindexjs6160__convertSourceMap2.default.fromSource(code);
      if (inputMap) {
        opts.inputSourceMap = inputMap.toObject();
        code = _babelcorelibtransformationfileindexjs6160__convertSourceMap2.default.removeComments(code);
      }
    }

    return code;
  };

  File.prototype.parseShebang = function parseShebang() {
    var shebangMatch = _babelcorelibtransformationfileindexjs6160__shebangRegex2.default.exec(this.code);
    if (shebangMatch) {
      this.shebang = shebangMatch[0];
      this.code = this.code.replace(_babelcorelibtransformationfileindexjs6160__shebangRegex2.default, "");
    }
  };

  File.prototype.makeResult = function makeResult(_ref4) {
    var code = _ref4.code;
    var map = _ref4.map;
    var ast = _ref4.ast;
    var ignored = _ref4.ignored;

    var result = {
      metadata: null,
      options: this.opts,
      ignored: !!ignored,
      code: null,
      ast: null,
      map: map || null
    };

    if (this.opts.code) {
      result.code = code;
    }

    if (this.opts.ast) {
      result.ast = ast;
    }

    if (this.opts.metadata) {
      result.metadata = this.metadata;
    }

    return result;
  };

  File.prototype.generate = function generate() {
    var opts = this.opts;
    var ast = this.ast;

    var result = { ast: ast };
    if (!opts.code) return this.makeResult(result);

    var gen = _babelcorelibtransformationfileindexjs6160__babelGenerator2.default;
    if (opts.generatorOpts.generator) {
      gen = opts.generatorOpts.generator;

      if (typeof gen === "string") {
        var dirname = _babelcorelibtransformationfileindexjs6160__path2.default.dirname(this.opts.filename) || process.cwd();
        var generator = (0, _babelcorelibtransformationfileindexjs6160__resolve2.default)(gen, dirname);
        if (generator) {
          gen = require(generator).print;
        } else {
          throw new Error("Couldn't find generator " + gen + " with \"print\" method relative to directory " + dirname);
        }
      }
    }

    this.log.debug("Generation start");

    var _result = gen(ast, opts.generatorOpts ? (0, _babelcorelibtransformationfileindexjs6160__assign2.default)(opts, opts.generatorOpts) : opts, this.code);
    result.code = _result.code;
    result.map = _result.map;

    this.log.debug("Generation end");

    if (this.shebang) {
      result.code = this.shebang + "\n" + result.code;
    }

    if (result.map) {
      result.map = this.mergeSourceMap(result.map);
    }

    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
      result.code += "\n" + _babelcorelibtransformationfileindexjs6160__convertSourceMap2.default.fromObject(result.map).toComment();
    }

    if (opts.sourceMaps === "inline") {
      result.map = null;
    }

    return this.makeResult(result);
  };

  return File;
}(_babelcorelibtransformationfileindexjs6160__store2.default);

$m['babel-core/lib/transformation/file/index.js#6.16.0'].exports.default = _babelcorelibtransformationfileindexjs6160_File;
$m['babel-core/lib/transformation/file/index.js#6.16.0'].exports.File = _babelcorelibtransformationfileindexjs6160_File;
/*≠≠ node_modules/babel-core/lib/transformation/file/index.js ≠≠*/

/*== node_modules/babel-core/lib/tools/build-external-helpers.js ==*/
$m['babel-core/lib/tools/build-external-helpers.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/tools/build-external-helpers.js#6.16.0'].exports.__esModule = true;

$m['babel-core/lib/tools/build-external-helpers.js#6.16.0'].exports.default = function (whitelist) {
  var outputType = arguments.length <= 1 || arguments[1] === undefined ? "global" : arguments[1];

  var namespace = _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("babelHelpers");

  var builder = function builder(body) {
    return _babelcorelibtoolsbuildexternalhelpersjs6160_buildHelpers(body, namespace, whitelist);
  };

  var tree = void 0;

  var build = {
    global: _babelcorelibtoolsbuildexternalhelpersjs6160_buildGlobal,
    umd: _babelcorelibtoolsbuildexternalhelpersjs6160_buildUmd,
    var: _babelcorelibtoolsbuildexternalhelpersjs6160_buildVar
  }[outputType];

  if (build) {
    tree = build(namespace, builder);
  } else {
    throw new Error(_babelcorelibtoolsbuildexternalhelpersjs6160_messages.get("unsupportedOutputType", outputType));
  }

  return (0, _babelcorelibtoolsbuildexternalhelpersjs6160__babelGenerator2.default)(tree).code;
};

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelHelpers = $m['babel-helpers/lib/index.js#6.16.0'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160_helpers = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireWildcard(_babelcorelibtoolsbuildexternalhelpersjs6160__babelHelpers);

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelGenerator = $m['babel-generator/lib/index.js#6.16.0'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelGenerator2 = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireDefault(_babelcorelibtoolsbuildexternalhelpersjs6160__babelGenerator);

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160_messages = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireWildcard(_babelcorelibtoolsbuildexternalhelpersjs6160__babelMessages);

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelTemplate = $m['babel-template/lib/index.js#6.16.0'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelTemplate2 = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireDefault(_babelcorelibtoolsbuildexternalhelpersjs6160__babelTemplate);

var _babelcorelibtoolsbuildexternalhelpersjs6160__each = $m['lodash/each.js#4.16.2'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160__each2 = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireDefault(_babelcorelibtoolsbuildexternalhelpersjs6160__each);

var _babelcorelibtoolsbuildexternalhelpersjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibtoolsbuildexternalhelpersjs6160_t = _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireWildcard(_babelcorelibtoolsbuildexternalhelpersjs6160__babelTypes);

function _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelcorelibtoolsbuildexternalhelpersjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

var _babelcorelibtoolsbuildexternalhelpersjs6160_buildUmdWrapper = (0, _babelcorelibtoolsbuildexternalhelpersjs6160__babelTemplate2.default)("\n  (function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(AMD_ARGUMENTS, factory);\n    } else if (typeof exports === \"object\") {\n      factory(COMMON_ARGUMENTS);\n    } else {\n      factory(BROWSER_ARGUMENTS);\n    }\n  })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n    FACTORY_BODY\n  });\n");

function _babelcorelibtoolsbuildexternalhelpersjs6160_buildGlobal(namespace, builder) {
  var body = [];
  var container = _babelcorelibtoolsbuildexternalhelpersjs6160_t.functionExpression(null, [_babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("global")], _babelcorelibtoolsbuildexternalhelpersjs6160_t.blockStatement(body));
  var tree = _babelcorelibtoolsbuildexternalhelpersjs6160_t.program([_babelcorelibtoolsbuildexternalhelpersjs6160_t.expressionStatement(_babelcorelibtoolsbuildexternalhelpersjs6160_t.callExpression(container, [_babelcorelibtoolsbuildexternalhelpersjs6160_helpers.get("selfGlobal")]))]);

  body.push(_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclaration("var", [_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclarator(namespace, _babelcorelibtoolsbuildexternalhelpersjs6160_t.assignmentExpression("=", _babelcorelibtoolsbuildexternalhelpersjs6160_t.memberExpression(_babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("global"), namespace), _babelcorelibtoolsbuildexternalhelpersjs6160_t.objectExpression([])))]));

  builder(body);

  return tree;
}

function _babelcorelibtoolsbuildexternalhelpersjs6160_buildUmd(namespace, builder) {
  var body = [];
  body.push(_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclaration("var", [_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclarator(namespace, _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("global"))]));

  builder(body);

  return _babelcorelibtoolsbuildexternalhelpersjs6160_t.program([_babelcorelibtoolsbuildexternalhelpersjs6160_buildUmdWrapper({
    FACTORY_PARAMETERS: _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("global"),
    BROWSER_ARGUMENTS: _babelcorelibtoolsbuildexternalhelpersjs6160_t.assignmentExpression("=", _babelcorelibtoolsbuildexternalhelpersjs6160_t.memberExpression(_babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("root"), namespace), _babelcorelibtoolsbuildexternalhelpersjs6160_t.objectExpression([])),
    COMMON_ARGUMENTS: _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("exports"),
    AMD_ARGUMENTS: _babelcorelibtoolsbuildexternalhelpersjs6160_t.arrayExpression([_babelcorelibtoolsbuildexternalhelpersjs6160_t.stringLiteral("exports")]),
    FACTORY_BODY: body,
    UMD_ROOT: _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier("this")
  })]);
}

function _babelcorelibtoolsbuildexternalhelpersjs6160_buildVar(namespace, builder) {
  var body = [];
  body.push(_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclaration("var", [_babelcorelibtoolsbuildexternalhelpersjs6160_t.variableDeclarator(namespace, _babelcorelibtoolsbuildexternalhelpersjs6160_t.objectExpression([]))]));
  builder(body);
  body.push(_babelcorelibtoolsbuildexternalhelpersjs6160_t.expressionStatement(namespace));
  return _babelcorelibtoolsbuildexternalhelpersjs6160_t.program(body);
}

function _babelcorelibtoolsbuildexternalhelpersjs6160_buildHelpers(body, namespace, whitelist) {
  (0, _babelcorelibtoolsbuildexternalhelpersjs6160__each2.default)(_babelcorelibtoolsbuildexternalhelpersjs6160_helpers.list, function (name) {
    if (whitelist && whitelist.indexOf(name) < 0) return;

    var key = _babelcorelibtoolsbuildexternalhelpersjs6160_t.identifier(name);
    body.push(_babelcorelibtoolsbuildexternalhelpersjs6160_t.expressionStatement(_babelcorelibtoolsbuildexternalhelpersjs6160_t.assignmentExpression("=", _babelcorelibtoolsbuildexternalhelpersjs6160_t.memberExpression(namespace, key), _babelcorelibtoolsbuildexternalhelpersjs6160_helpers.get(name))));
  });
}
$m['babel-core/lib/tools/build-external-helpers.js#6.16.0'].exports = $m['babel-core/lib/tools/build-external-helpers.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/tools/build-external-helpers.js ≠≠*/

/*== node_modules/babel-template/lib/index.js ==*/
$m['babel-template/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-template/lib/index.js#6.16.0'].exports.__esModule = true;

var _babeltemplatelibindexjs6160__symbol = $m['babel-runtime/core-js/symbol.js#6.11.6'].exports;

var _babeltemplatelibindexjs6160__symbol2 = _babeltemplatelibindexjs6160__interopRequireDefault(_babeltemplatelibindexjs6160__symbol);

$m['babel-template/lib/index.js#6.16.0'].exports.default = function (code, opts) {
  var stack = void 0;
  try {
    throw new Error();
  } catch (error) {
    if (error.stack) {
      stack = error.stack.split("\n").slice(1).join("\n");
    }
  }

  opts = (0, _babeltemplatelibindexjs6160__assign2.default)({
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    preserveComments: false
  }, opts);

  var _getAst = function getAst() {
    var ast = void 0;

    try {
      ast = _babeltemplatelibindexjs6160_babylon.parse(code, opts);

      ast = _babeltemplatelibindexjs6160__babelTraverse2.default.removeProperties(ast, { preserveComments: opts.preserveComments });

      _babeltemplatelibindexjs6160__babelTraverse2.default.cheap(ast, function (node) {
        node[_babeltemplatelibindexjs6160_FROM_TEMPLATE] = true;
      });
    } catch (err) {
      err.stack = err.stack + "from\n" + stack;
      throw err;
    }

    _getAst = function getAst() {
      return ast;
    };

    return ast;
  };

  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _babeltemplatelibindexjs6160_useTemplate(_getAst(), args);
  };
};

var _babeltemplatelibindexjs6160__cloneDeep = $m['lodash/cloneDeep.js#4.16.2'].exports;

var _babeltemplatelibindexjs6160__cloneDeep2 = _babeltemplatelibindexjs6160__interopRequireDefault(_babeltemplatelibindexjs6160__cloneDeep);

var _babeltemplatelibindexjs6160__assign = $m['lodash/assign.js#4.16.2'].exports;

var _babeltemplatelibindexjs6160__assign2 = _babeltemplatelibindexjs6160__interopRequireDefault(_babeltemplatelibindexjs6160__assign);

var _babeltemplatelibindexjs6160__has = $m['lodash/has.js#4.16.2'].exports;

var _babeltemplatelibindexjs6160__has2 = _babeltemplatelibindexjs6160__interopRequireDefault(_babeltemplatelibindexjs6160__has);

var _babeltemplatelibindexjs6160__babelTraverse = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babeltemplatelibindexjs6160__babelTraverse2 = _babeltemplatelibindexjs6160__interopRequireDefault(_babeltemplatelibindexjs6160__babelTraverse);

var _babeltemplatelibindexjs6160__babylon = $m['babylon/lib/index.js#6.11.2'].exports;

var _babeltemplatelibindexjs6160_babylon = _babeltemplatelibindexjs6160__interopRequireWildcard(_babeltemplatelibindexjs6160__babylon);

var _babeltemplatelibindexjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babeltemplatelibindexjs6160_t = _babeltemplatelibindexjs6160__interopRequireWildcard(_babeltemplatelibindexjs6160__babelTypes);

function _babeltemplatelibindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babeltemplatelibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babeltemplatelibindexjs6160_FROM_TEMPLATE = "_fromTemplate";
var _babeltemplatelibindexjs6160_TEMPLATE_SKIP = (0, _babeltemplatelibindexjs6160__symbol2.default)();

function _babeltemplatelibindexjs6160_useTemplate(ast, nodes) {
  ast = (0, _babeltemplatelibindexjs6160__cloneDeep2.default)(ast);
  var _ast = ast;
  var program = _ast.program;

  if (nodes.length) {
    (0, _babeltemplatelibindexjs6160__babelTraverse2.default)(ast, _babeltemplatelibindexjs6160_templateVisitor, null, nodes);
  }

  if (program.body.length > 1) {
    return program.body;
  } else {
    return program.body[0];
  }
}

var _babeltemplatelibindexjs6160_templateVisitor = {
  noScope: true,

  enter: function enter(path, args) {
    var node = path.node;

    if (node[_babeltemplatelibindexjs6160_TEMPLATE_SKIP]) return path.skip();

    if (_babeltemplatelibindexjs6160_t.isExpressionStatement(node)) {
      node = node.expression;
    }

    var replacement = void 0;

    if (_babeltemplatelibindexjs6160_t.isIdentifier(node) && node[_babeltemplatelibindexjs6160_FROM_TEMPLATE]) {
      if ((0, _babeltemplatelibindexjs6160__has2.default)(args[0], node.name)) {
        replacement = args[0][node.name];
      } else if (node.name[0] === "$") {
        var i = +node.name.slice(1);
        if (args[i]) replacement = args[i];
      }
    }

    if (replacement === null) {
      path.remove();
    }

    if (replacement) {
      replacement[_babeltemplatelibindexjs6160_TEMPLATE_SKIP] = true;
      path.replaceInline(replacement);
    }
  },
  exit: function exit(_ref) {
    var node = _ref.node;

    if (!node.loc) _babeltemplatelibindexjs6160__babelTraverse2.default.clearNode(node);
  }
};
$m['babel-template/lib/index.js#6.16.0'].exports = $m['babel-template/lib/index.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-template/lib/index.js ≠≠*/

/*== node_modules/lodash/isFunction.js ==*/
$m['lodash/isFunction.js#4.16.2'] = { exports: {} };
var _lodashisFunctionjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashisFunctionjs4162_funcTag = '[object Function]',
    _lodashisFunctionjs4162_genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var _lodashisFunctionjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisFunctionjs4162_objectToString = _lodashisFunctionjs4162_objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function _lodashisFunctionjs4162_isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = _lodashisFunctionjs4162_isObject(value) ? _lodashisFunctionjs4162_objectToString.call(value) : '';
  return tag == _lodashisFunctionjs4162_funcTag || tag == _lodashisFunctionjs4162_genTag;
}

$m['lodash/isFunction.js#4.16.2'].exports = _lodashisFunctionjs4162_isFunction;
/*≠≠ node_modules/lodash/isFunction.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/pipeline.js ==*/
$m['babel-core/lib/transformation/pipeline.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/pipeline.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationpipelinejs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationpipelinejs6160__classCallCheck3 = _babelcorelibtransformationpipelinejs6160__interopRequireDefault(_babelcorelibtransformationpipelinejs6160__classCallCheck2);

var _babelcorelibtransformationpipelinejs6160__normalizeAst = $m['babel-core/lib/helpers/normalize-ast.js#6.16.0'].exports;

var _babelcorelibtransformationpipelinejs6160__normalizeAst2 = _babelcorelibtransformationpipelinejs6160__interopRequireDefault(_babelcorelibtransformationpipelinejs6160__normalizeAst);

var _babelcorelibtransformationpipelinejs6160__plugin = $m['babel-core/lib/transformation/plugin.js#6.16.0'].exports;

var _babelcorelibtransformationpipelinejs6160__plugin2 = _babelcorelibtransformationpipelinejs6160__interopRequireDefault(_babelcorelibtransformationpipelinejs6160__plugin);

var _babelcorelibtransformationpipelinejs6160__file = $m['babel-core/lib/transformation/file/index.js#6.16.0'].exports;

var _babelcorelibtransformationpipelinejs6160__file2 = _babelcorelibtransformationpipelinejs6160__interopRequireDefault(_babelcorelibtransformationpipelinejs6160__file);

function _babelcorelibtransformationpipelinejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationpipelinejs6160_Pipeline = function () {
  function Pipeline() {
    (0, _babelcorelibtransformationpipelinejs6160__classCallCheck3.default)(this, Pipeline);
  }

  Pipeline.prototype.lint = function lint(code) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    opts.code = false;
    opts.mode = "lint";
    return this.transform(code, opts);
  };

  Pipeline.prototype.pretransform = function pretransform(code, opts) {
    var file = new _babelcorelibtransformationpipelinejs6160__file2.default(opts, this);
    return file.wrap(code, function () {
      file.addCode(code);
      file.parseCode(code);
      return file;
    });
  };

  Pipeline.prototype.transform = function transform(code, opts) {
    var file = new _babelcorelibtransformationpipelinejs6160__file2.default(opts, this);
    return file.wrap(code, function () {
      file.addCode(code);
      file.parseCode(code);
      return file.transform();
    });
  };

  Pipeline.prototype.analyse = function analyse(code) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var visitor = arguments[2];

    opts.code = false;
    if (visitor) {
      opts.plugins = opts.plugins || [];
      opts.plugins.push(new _babelcorelibtransformationpipelinejs6160__plugin2.default({ visitor: visitor }));
    }
    return this.transform(code, opts).metadata;
  };

  Pipeline.prototype.transformFromAst = function transformFromAst(ast, code, opts) {
    ast = (0, _babelcorelibtransformationpipelinejs6160__normalizeAst2.default)(ast);

    var file = new _babelcorelibtransformationpipelinejs6160__file2.default(opts, this);
    return file.wrap(code, function () {
      file.addCode(code);
      file.addAst(ast);
      return file.transform();
    });
  };

  return Pipeline;
}();

$m['babel-core/lib/transformation/pipeline.js#6.16.0'].exports.default = _babelcorelibtransformationpipelinejs6160_Pipeline;
$m['babel-core/lib/transformation/pipeline.js#6.16.0'].exports = $m['babel-core/lib/transformation/pipeline.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/transformation/pipeline.js ≠≠*/

/*== node_modules/babel-core/lib/api/node.js ==*/
$m['babel-core/lib/api/node.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/api/node.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/api/node.js#6.16.0'].exports.transformFromAst = $m['babel-core/lib/api/node.js#6.16.0'].exports.transform = $m['babel-core/lib/api/node.js#6.16.0'].exports.analyse = $m['babel-core/lib/api/node.js#6.16.0'].exports.Pipeline = $m['babel-core/lib/api/node.js#6.16.0'].exports.OptionManager = $m['babel-core/lib/api/node.js#6.16.0'].exports.traverse = $m['babel-core/lib/api/node.js#6.16.0'].exports.types = $m['babel-core/lib/api/node.js#6.16.0'].exports.messages = $m['babel-core/lib/api/node.js#6.16.0'].exports.util = $m['babel-core/lib/api/node.js#6.16.0'].exports.version = $m['babel-core/lib/api/node.js#6.16.0'].exports.template = $m['babel-core/lib/api/node.js#6.16.0'].exports.buildExternalHelpers = $m['babel-core/lib/api/node.js#6.16.0'].exports.options = $m['babel-core/lib/api/node.js#6.16.0'].exports.File = undefined;

var _babelcorelibapinodejs6160__file = $m['babel-core/lib/transformation/file/index.js#6.16.0'].exports;

Object.defineProperty($m['babel-core/lib/api/node.js#6.16.0'].exports, "File", {
  enumerable: true,
  get: function get() {
    return _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__file).default;
  }
});

var _babelcorelibapinodejs6160__config = $m['babel-core/lib/transformation/file/options/config.js#6.16.0'].exports;

Object.defineProperty($m['babel-core/lib/api/node.js#6.16.0'].exports, "options", {
  enumerable: true,
  get: function get() {
    return _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__config).default;
  }
});

var _babelcorelibapinodejs6160__buildExternalHelpers = $m['babel-core/lib/tools/build-external-helpers.js#6.16.0'].exports;

Object.defineProperty($m['babel-core/lib/api/node.js#6.16.0'].exports, "buildExternalHelpers", {
  enumerable: true,
  get: function get() {
    return _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__buildExternalHelpers).default;
  }
});

var _babelcorelibapinodejs6160__babelTemplate = $m['babel-template/lib/index.js#6.16.0'].exports;

Object.defineProperty($m['babel-core/lib/api/node.js#6.16.0'].exports, "template", {
  enumerable: true,
  get: function get() {
    return _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__babelTemplate).default;
  }
});

var _babelcorelibapinodejs6160__package = {
  "_args": [[{
    "raw": "babel-core@6.16.0",
    "scope": null,
    "escapedName": "babel-core",
    "name": "babel-core",
    "rawSpec": "6.16.0",
    "spec": "6.16.0",
    "type": "version"
  }, "/Users/alex/PROJECTS/buddy"]],
  "_from": "babel-core@6.16.0",
  "_id": "babel-core@6.16.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/babel-core",
  "_nodeVersion": "5.11.1",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/babel-core-6.16.0.tgz_1475091527641_0.820686154300347"
  },
  "_npmUser": {
    "name": "hzoo",
    "email": "hi@henryzoo.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "babel-core@6.16.0",
    "scope": null,
    "escapedName": "babel-core",
    "name": "babel-core",
    "rawSpec": "6.16.0",
    "spec": "6.16.0",
    "type": "version"
  },
  "_requiredBy": ["#USER", "/"],
  "_resolved": "https://registry.npmjs.org/babel-core/-/babel-core-6.16.0.tgz",
  "_shasum": "cf8bbfdf0097c4146195d80d9ec96d73acf387d5",
  "_shrinkwrap": null,
  "_spec": "babel-core@6.16.0",
  "_where": "/Users/alex/PROJECTS/buddy",
  "author": {
    "name": "Sebastian McKenzie",
    "email": "sebmck@gmail.com"
  },
  "dependencies": {
    "babel-code-frame": "^6.16.0",
    "babel-generator": "^6.16.0",
    "babel-helpers": "^6.16.0",
    "babel-messages": "^6.8.0",
    "babel-register": "^6.16.0",
    "babel-runtime": "^6.9.1",
    "babel-template": "^6.16.0",
    "babel-traverse": "^6.16.0",
    "babel-types": "^6.16.0",
    "babylon": "^6.11.0",
    "convert-source-map": "^1.1.0",
    "debug": "^2.1.1",
    "json5": "^0.4.0",
    "lodash": "^4.2.0",
    "minimatch": "^3.0.2",
    "path-exists": "^1.0.0",
    "path-is-absolute": "^1.0.0",
    "private": "^0.1.6",
    "shebang-regex": "^1.0.0",
    "slash": "^1.0.0",
    "source-map": "^0.5.0"
  },
  "description": "Babel compiler core.",
  "devDependencies": {
    "babel-helper-fixtures": "^6.9.0",
    "babel-helper-transform-fixture-test-runner": "^6.16.0",
    "babel-polyfill": "^6.16.0"
  },
  "directories": {},
  "dist": {
    "shasum": "cf8bbfdf0097c4146195d80d9ec96d73acf387d5",
    "tarball": "https://registry.npmjs.org/babel-core/-/babel-core-6.16.0.tgz"
  },
  "homepage": "https://babeljs.io/",
  "keywords": ["6to5", "babel", "classes", "const", "es6", "harmony", "let", "modules", "transpile", "transpiler", "var"],
  "license": "MIT",
  "maintainers": [{
    "name": "amasad",
    "email": "amjad.masad@gmail.com"
  }, {
    "name": "hzoo",
    "email": "hi@henryzoo.com"
  }, {
    "name": "jmm",
    "email": "npm-public@jessemccarthy.net"
  }, {
    "name": "loganfsmyth",
    "email": "loganfsmyth@gmail.com"
  }, {
    "name": "sebmck",
    "email": "sebmck@gmail.com"
  }, {
    "name": "thejameskyle",
    "email": "me@thejameskyle.com"
  }],
  "name": "babel-core",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel/tree/master/packages/babel-core"
  },
  "scripts": {
    "bench": "make bench",
    "test": "make test"
  },
  "version": "6.16.0"
};

Object.defineProperty($m['babel-core/lib/api/node.js#6.16.0'].exports, "version", {
  enumerable: true,
  get: function get() {
    return _babelcorelibapinodejs6160__package.version;
  }
});
$m['babel-core/lib/api/node.js#6.16.0'].exports.Plugin = _babelcorelibapinodejs6160_Plugin;
$m['babel-core/lib/api/node.js#6.16.0'].exports.transformFile = _babelcorelibapinodejs6160_transformFile;
$m['babel-core/lib/api/node.js#6.16.0'].exports.transformFileSync = _babelcorelibapinodejs6160_transformFileSync;

var _babelcorelibapinodejs6160__isFunction = $m['lodash/isFunction.js#4.16.2'].exports;

var _babelcorelibapinodejs6160__isFunction2 = _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__isFunction);

var _babelcorelibapinodejs6160__fs = require("fs");

var _babelcorelibapinodejs6160__fs2 = _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__fs);

var _babelcorelibapinodejs6160__util = $m['babel-core/lib/util.js#6.16.0'].exports;

var _babelcorelibapinodejs6160_util = _babelcorelibapinodejs6160__interopRequireWildcard(_babelcorelibapinodejs6160__util);

var _babelcorelibapinodejs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babelcorelibapinodejs6160_messages = _babelcorelibapinodejs6160__interopRequireWildcard(_babelcorelibapinodejs6160__babelMessages);

var _babelcorelibapinodejs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibapinodejs6160_t = _babelcorelibapinodejs6160__interopRequireWildcard(_babelcorelibapinodejs6160__babelTypes);

var _babelcorelibapinodejs6160__babelTraverse = $m['babel-traverse/lib/index.js#6.16.0'].exports;

var _babelcorelibapinodejs6160__babelTraverse2 = _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__babelTraverse);

var _babelcorelibapinodejs6160__optionManager = require("babel-core/lib/transformation/file/options/option-manager.js#6.16.0");

var _babelcorelibapinodejs6160__optionManager2 = _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__optionManager);

var _babelcorelibapinodejs6160__pipeline = $m['babel-core/lib/transformation/pipeline.js#6.16.0'].exports;

var _babelcorelibapinodejs6160__pipeline2 = _babelcorelibapinodejs6160__interopRequireDefault(_babelcorelibapinodejs6160__pipeline);

function _babelcorelibapinodejs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibapinodejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-core/lib/api/node.js#6.16.0'].exports.util = _babelcorelibapinodejs6160_util;
$m['babel-core/lib/api/node.js#6.16.0'].exports.messages = _babelcorelibapinodejs6160_messages;
$m['babel-core/lib/api/node.js#6.16.0'].exports.types = _babelcorelibapinodejs6160_t;
$m['babel-core/lib/api/node.js#6.16.0'].exports.traverse = _babelcorelibapinodejs6160__babelTraverse2.default;
$m['babel-core/lib/api/node.js#6.16.0'].exports.OptionManager = _babelcorelibapinodejs6160__optionManager2.default;
function _babelcorelibapinodejs6160_Plugin(alias) {
  throw new Error("The (" + alias + ") Babel 5 plugin is being run with Babel 6.");
}

$m['babel-core/lib/api/node.js#6.16.0'].exports.Pipeline = _babelcorelibapinodejs6160__pipeline2.default;

var _babelcorelibapinodejs6160_pipeline = new _babelcorelibapinodejs6160__pipeline2.default();
var _babelcorelibapinodejs6160_analyse = $m['babel-core/lib/api/node.js#6.16.0'].exports.analyse = _babelcorelibapinodejs6160_pipeline.analyse.bind(_babelcorelibapinodejs6160_pipeline);
var _babelcorelibapinodejs6160_transform = $m['babel-core/lib/api/node.js#6.16.0'].exports.transform = _babelcorelibapinodejs6160_pipeline.transform.bind(_babelcorelibapinodejs6160_pipeline);
var _babelcorelibapinodejs6160_transformFromAst = $m['babel-core/lib/api/node.js#6.16.0'].exports.transformFromAst = _babelcorelibapinodejs6160_pipeline.transformFromAst.bind(_babelcorelibapinodejs6160_pipeline);

function _babelcorelibapinodejs6160_transformFile(filename, opts, callback) {
  if ((0, _babelcorelibapinodejs6160__isFunction2.default)(opts)) {
    callback = opts;
    opts = {};
  }

  opts.filename = filename;

  _babelcorelibapinodejs6160__fs2.default.readFile(filename, function (err, code) {
    var result = void 0;

    if (!err) {
      try {
        result = _babelcorelibapinodejs6160_transform(code, opts);
      } catch (_err) {
        err = _err;
      }
    }

    if (err) {
      callback(err);
    } else {
      callback(null, result);
    }
  });
}

function _babelcorelibapinodejs6160_transformFileSync(filename) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  opts.filename = filename;
  return _babelcorelibapinodejs6160_transform(_babelcorelibapinodejs6160__fs2.default.readFileSync(filename, "utf8"), opts);
}
/*≠≠ node_modules/babel-core/lib/api/node.js ≠≠*/

/*== node_modules/entities/index.js ==*/
$m['entities/index.js#1.1.1'] = { exports: {} };
var _entitiesindexjs111_encode = $m['entities/lib/encode.js#1.1.1'].exports,
    _entitiesindexjs111_decode = $m['entities/lib/decode.js#1.1.1'].exports;

$m['entities/index.js#1.1.1'].exports.decode = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_decode.XML : _entitiesindexjs111_decode.HTML)(data);
};

$m['entities/index.js#1.1.1'].exports.decodeStrict = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_decode.XML : _entitiesindexjs111_decode.HTMLStrict)(data);
};

$m['entities/index.js#1.1.1'].exports.encode = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_encode.XML : _entitiesindexjs111_encode.HTML)(data);
};

$m['entities/index.js#1.1.1'].exports.encodeXML = _entitiesindexjs111_encode.XML;

$m['entities/index.js#1.1.1'].exports.encodeHTML4 = $m['entities/index.js#1.1.1'].exports.encodeHTML5 = $m['entities/index.js#1.1.1'].exports.encodeHTML = _entitiesindexjs111_encode.HTML;

$m['entities/index.js#1.1.1'].exports.decodeXML = $m['entities/index.js#1.1.1'].exports.decodeXMLStrict = _entitiesindexjs111_decode.XML;

$m['entities/index.js#1.1.1'].exports.decodeHTML4 = $m['entities/index.js#1.1.1'].exports.decodeHTML5 = $m['entities/index.js#1.1.1'].exports.decodeHTML = _entitiesindexjs111_decode.HTML;

$m['entities/index.js#1.1.1'].exports.decodeHTML4Strict = $m['entities/index.js#1.1.1'].exports.decodeHTML5Strict = $m['entities/index.js#1.1.1'].exports.decodeHTMLStrict = _entitiesindexjs111_decode.HTMLStrict;

$m['entities/index.js#1.1.1'].exports.escape = _entitiesindexjs111_encode.escape;
/*≠≠ node_modules/entities/index.js ≠≠*/

/*== node_modules/lodash/memoize.js ==*/
$m['lodash/memoize.js#4.16.2'] = { exports: {} };
var _lodashmemoizejs4162_MapCache = $m['lodash/_MapCache.js#4.16.2'].exports;

/** Error message constants. */
var _lodashmemoizejs4162_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function _lodashmemoizejs4162_memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(_lodashmemoizejs4162_FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (_lodashmemoizejs4162_memoize.Cache || _lodashmemoizejs4162_MapCache)();
  return memoized;
}

// Expose `MapCache`.
_lodashmemoizejs4162_memoize.Cache = _lodashmemoizejs4162_MapCache;

$m['lodash/memoize.js#4.16.2'].exports = _lodashmemoizejs4162_memoize;
/*≠≠ node_modules/lodash/memoize.js ≠≠*/

/*== node_modules/lodash/_baseIsRegExp.js ==*/
$m['lodash/_baseIsRegExp.js#4.16.2'] = { exports: {} };
var _lodashbaseIsRegExpjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashbaseIsRegExpjs4162_regexpTag = '[object RegExp]';

/** Used for built-in method references. */
var _lodashbaseIsRegExpjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashbaseIsRegExpjs4162_objectToString = _lodashbaseIsRegExpjs4162_objectProto.toString;

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function _lodashbaseIsRegExpjs4162_baseIsRegExp(value) {
  return _lodashbaseIsRegExpjs4162_isObject(value) && _lodashbaseIsRegExpjs4162_objectToString.call(value) == _lodashbaseIsRegExpjs4162_regexpTag;
}

$m['lodash/_baseIsRegExp.js#4.16.2'].exports = _lodashbaseIsRegExpjs4162_baseIsRegExp;
/*≠≠ node_modules/lodash/_baseIsRegExp.js ≠≠*/

/*== node_modules/lodash/values.js ==*/
$m['lodash/values.js#4.16.2'] = { exports: {} };
var _lodashvaluesjs4162_baseValues = $m['lodash/_baseValues.js#4.16.2'].exports,
    _lodashvaluesjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function _lodashvaluesjs4162_values(object) {
  return object ? _lodashvaluesjs4162_baseValues(object, _lodashvaluesjs4162_keys(object)) : [];
}

$m['lodash/values.js#4.16.2'].exports = _lodashvaluesjs4162_values;
/*≠≠ node_modules/lodash/values.js ≠≠*/

/*== node_modules/esutils/lib/keyword.js ==*/
$m['esutils/lib/keyword.js#2.0.2'] = { exports: {} };
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = $m['esutils/lib/code.js#2.0.2'].exports;

    function isStrictModeReservedWordES6(id) {
        switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'let':
                return true;
            default:
                return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
            case 2:
                return id === 'if' || id === 'in' || id === 'do';
            case 3:
                return id === 'var' || id === 'for' || id === 'new' || id === 'try';
            case 4:
                return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
            case 5:
                return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
            case 6:
                return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
            case 7:
                return id === 'default' || id === 'finally' || id === 'extends';
            case 8:
                return id === 'function' || id === 'continue' || id === 'debugger';
            case 10:
                return id === 'instanceof';
            default:
                return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) {
            return false;
        }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) {
                    return false;
                }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    $m['esutils/lib/keyword.js#2.0.2'].exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
/*≠≠ node_modules/esutils/lib/keyword.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/jsx.js ==*/
$m['babel-generator/lib/generators/jsx.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibgeneratorsjsxjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelgeneratorlibgeneratorsjsxjs6160__getIterator3 = _babelgeneratorlibgeneratorsjsxjs6160__interopRequireDefault(_babelgeneratorlibgeneratorsjsxjs6160__getIterator2);

$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXAttribute = _babelgeneratorlibgeneratorsjsxjs6160_JSXAttribute;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXIdentifier = _babelgeneratorlibgeneratorsjsxjs6160_JSXIdentifier;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXNamespacedName = _babelgeneratorlibgeneratorsjsxjs6160_JSXNamespacedName;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXMemberExpression = _babelgeneratorlibgeneratorsjsxjs6160_JSXMemberExpression;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXSpreadAttribute = _babelgeneratorlibgeneratorsjsxjs6160_JSXSpreadAttribute;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXExpressionContainer = _babelgeneratorlibgeneratorsjsxjs6160_JSXExpressionContainer;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXText = _babelgeneratorlibgeneratorsjsxjs6160_JSXText;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXElement = _babelgeneratorlibgeneratorsjsxjs6160_JSXElement;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXOpeningElement = _babelgeneratorlibgeneratorsjsxjs6160_JSXOpeningElement;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXClosingElement = _babelgeneratorlibgeneratorsjsxjs6160_JSXClosingElement;
$m['babel-generator/lib/generators/jsx.js#6.16.0'].exports.JSXEmptyExpression = _babelgeneratorlibgeneratorsjsxjs6160_JSXEmptyExpression;

function _babelgeneratorlibgeneratorsjsxjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXAttribute(node) {
  this.print(node.name, node);
  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXIdentifier(node) {
  this.word(node.name);
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXText(node) {
  this.token(node.value);
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXElement(node) {
  var open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;

  this.indent();
  for (var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelgeneratorlibgeneratorsjsxjs6160__getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var child = _ref;

    this.print(child, node);
  }
  this.dedent();

  this.print(node.closingElement, node);
}

function _babelgeneratorlibgeneratorsjsxjs6160_spaceSeparator() {
  this.space();
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, { separator: _babelgeneratorlibgeneratorsjsxjs6160_spaceSeparator });
  }
  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}

function _babelgeneratorlibgeneratorsjsxjs6160_JSXEmptyExpression() {}
/*≠≠ node_modules/babel-generator/lib/generators/jsx.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/base.js ==*/
$m['babel-generator/lib/generators/base.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/base.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/base.js#6.16.0'].exports.File = _babelgeneratorlibgeneratorsbasejs6160_File;
$m['babel-generator/lib/generators/base.js#6.16.0'].exports.Program = _babelgeneratorlibgeneratorsbasejs6160_Program;
$m['babel-generator/lib/generators/base.js#6.16.0'].exports.BlockStatement = _babelgeneratorlibgeneratorsbasejs6160_BlockStatement;
$m['babel-generator/lib/generators/base.js#6.16.0'].exports.Noop = _babelgeneratorlibgeneratorsbasejs6160_Noop;
$m['babel-generator/lib/generators/base.js#6.16.0'].exports.Directive = _babelgeneratorlibgeneratorsbasejs6160_Directive;

var _babelgeneratorlibgeneratorsbasejs6160__types = $m['babel-generator/lib/generators/types.js#6.16.0'].exports;

Object.defineProperty($m['babel-generator/lib/generators/base.js#6.16.0'].exports, "DirectiveLiteral", {
  enumerable: true,
  get: function get() {
    return _babelgeneratorlibgeneratorsbasejs6160__types.StringLiteral;
  }
});
function _babelgeneratorlibgeneratorsbasejs6160_File(node) {
  this.print(node.program, node);
}

function _babelgeneratorlibgeneratorsbasejs6160_Program(node) {
  this.printInnerComments(node, false);

  this.printSequence(node.directives, node);
  if (node.directives && node.directives.length) this.newline();

  this.printSequence(node.body, node);
}

function _babelgeneratorlibgeneratorsbasejs6160_BlockStatement(node) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length) {
    this.newline();

    this.printSequence(node.directives, node, { indent: true });
    if (node.directives && node.directives.length) this.newline();

    this.printSequence(node.body, node, { indent: true });
    this.removeTrailingNewline();

    this.source("end", node.loc);

    if (!this.endsWith("\n")) this.newline();

    this.rightBrace();
  } else {
    this.source("end", node.loc);
    this.token("}");
  }
}

function _babelgeneratorlibgeneratorsbasejs6160_Noop() {}

function _babelgeneratorlibgeneratorsbasejs6160_Directive(node) {
  this.print(node.value, node);
  this.semicolon();
}
/*≠≠ node_modules/babel-generator/lib/generators/base.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/flow.js ==*/
$m['babel-generator/lib/generators/flow.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.AnyTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_AnyTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ArrayTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_ArrayTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.BooleanTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_BooleanTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.BooleanLiteralTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_BooleanLiteralTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.NullLiteralTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_NullLiteralTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareClass = _babelgeneratorlibgeneratorsflowjs6160_DeclareClass;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareFunction = _babelgeneratorlibgeneratorsflowjs6160_DeclareFunction;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareInterface = _babelgeneratorlibgeneratorsflowjs6160_DeclareInterface;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareModule = _babelgeneratorlibgeneratorsflowjs6160_DeclareModule;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareModuleExports = _babelgeneratorlibgeneratorsflowjs6160_DeclareModuleExports;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareTypeAlias = _babelgeneratorlibgeneratorsflowjs6160_DeclareTypeAlias;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.DeclareVariable = _babelgeneratorlibgeneratorsflowjs6160_DeclareVariable;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ExistentialTypeParam = _babelgeneratorlibgeneratorsflowjs6160_ExistentialTypeParam;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.FunctionTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_FunctionTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.FunctionTypeParam = _babelgeneratorlibgeneratorsflowjs6160_FunctionTypeParam;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.InterfaceExtends = _babelgeneratorlibgeneratorsflowjs6160_InterfaceExtends;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports._interfaceish = _babelgeneratorlibgeneratorsflowjs6160__interfaceish;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.InterfaceDeclaration = _babelgeneratorlibgeneratorsflowjs6160_InterfaceDeclaration;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.IntersectionTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_IntersectionTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.MixedTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_MixedTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.NullableTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_NullableTypeAnnotation;

var _babelgeneratorlibgeneratorsflowjs6160__types = $m['babel-generator/lib/generators/types.js#6.16.0'].exports;

Object.defineProperty($m['babel-generator/lib/generators/flow.js#6.16.0'].exports, "NumericLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _babelgeneratorlibgeneratorsflowjs6160__types.NumericLiteral;
  }
});
Object.defineProperty($m['babel-generator/lib/generators/flow.js#6.16.0'].exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _babelgeneratorlibgeneratorsflowjs6160__types.StringLiteral;
  }
});
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.NumberTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_NumberTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.StringTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_StringTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ThisTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_ThisTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TupleTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_TupleTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeofTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_TypeofTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeAlias = _babelgeneratorlibgeneratorsflowjs6160_TypeAlias;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_TypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeParameter = _babelgeneratorlibgeneratorsflowjs6160_TypeParameter;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeParameterInstantiation = _babelgeneratorlibgeneratorsflowjs6160_TypeParameterInstantiation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ObjectTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ObjectTypeCallProperty = _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeCallProperty;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ObjectTypeIndexer = _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeIndexer;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ObjectTypeProperty = _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeProperty;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.QualifiedTypeIdentifier = _babelgeneratorlibgeneratorsflowjs6160_QualifiedTypeIdentifier;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.UnionTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_UnionTypeAnnotation;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeCastExpression = _babelgeneratorlibgeneratorsflowjs6160_TypeCastExpression;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.VoidTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_VoidTypeAnnotation;
function _babelgeneratorlibgeneratorsflowjs6160_AnyTypeAnnotation() {
  this.word("any");
}

function _babelgeneratorlibgeneratorsflowjs6160_ArrayTypeAnnotation(node) {
  this.print(node.elementType, node);
  this.token("[");
  this.token("]");
}

function _babelgeneratorlibgeneratorsflowjs6160_BooleanTypeAnnotation() {
  this.word("bool");
}

function _babelgeneratorlibgeneratorsflowjs6160_BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}

function _babelgeneratorlibgeneratorsflowjs6160_NullLiteralTypeAnnotation() {
  this.word("null");
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareClass(node) {
  this.word("declare");
  this.space();
  this.word("class");
  this.space();
  this._interfaceish(node);
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareFunction(node) {
  this.word("declare");
  this.space();
  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.token(".");
  this.word("exports");
  this.print(node.typeAnnotation, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}

function _babelgeneratorlibgeneratorsflowjs6160_DeclareVariable(node) {
  this.word("declare");
  this.space();
  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsflowjs6160_ExistentialTypeParam() {
  this.token("*");
}

function _babelgeneratorlibgeneratorsflowjs6160_FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node);

  if (node.rest) {
    if (node.params.length) {
      this.token(",");
      this.space();
    }
    this.token("...");
    this.print(node.rest, node);
  }

  this.token(")");

  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction") {
    this.token(":");
  } else {
    this.space();
    this.token("=>");
  }

  this.space();
  this.print(node.returnType, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.token("?");
  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_InterfaceExtends(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
}

$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.ClassImplements = _babelgeneratorlibgeneratorsflowjs6160_InterfaceExtends;
$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.GenericTypeAnnotation = _babelgeneratorlibgeneratorsflowjs6160_InterfaceExtends;
function _babelgeneratorlibgeneratorsflowjs6160__interfaceish(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_InterfaceDeclaration(node) {
  this.word("interface");
  this.space();
  this._interfaceish(node);
}

function _babelgeneratorlibgeneratorsflowjs6160_andSeparator() {
  this.space();
  this.token("&");
  this.space();
}

function _babelgeneratorlibgeneratorsflowjs6160_IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, node, { separator: _babelgeneratorlibgeneratorsflowjs6160_andSeparator });
}

function _babelgeneratorlibgeneratorsflowjs6160_MixedTypeAnnotation() {
  this.word("mixed");
}

function _babelgeneratorlibgeneratorsflowjs6160_NullableTypeAnnotation(node) {
  this.token("?");
  this.print(node.typeAnnotation, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_NumberTypeAnnotation() {
  this.word("number");
}

function _babelgeneratorlibgeneratorsflowjs6160_StringTypeAnnotation() {
  this.word("string");
}

function _babelgeneratorlibgeneratorsflowjs6160_ThisTypeAnnotation() {
  this.word("this");
}

function _babelgeneratorlibgeneratorsflowjs6160_TupleTypeAnnotation(node) {
  this.token("[");
  this.printList(node.types, node);
  this.token("]");
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeParameter(node) {
  if (node.variance === "plus") {
    this.token("+");
  } else if (node.variance === "minus") {
    this.token("-");
  }

  this.word(node.name);

  if (node.bound) {
    this.print(node.bound, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

$m['babel-generator/lib/generators/flow.js#6.16.0'].exports.TypeParameterDeclaration = _babelgeneratorlibgeneratorsflowjs6160_TypeParameterInstantiation;
function _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeAnnotation(node) {
  var _this = this;

  if (node.exact) {
    this.token("{|");
  } else {
    this.token("{");
  }

  var props = node.properties.concat(node.callProperties, node.indexers);

  if (props.length) {
    this.space();

    this.printJoin(props, node, {
      indent: true,
      statement: true,
      iterator: function iterator() {
        if (props.length !== 1) {
          _this.semicolon();
          _this.space();
        }
      }
    });

    this.space();
  }

  if (node.exact) {
    this.token("|}");
  } else {
    this.token("}");
  }
}

function _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.value, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.token("[");
  this.print(node.id, node);
  this.token(":");
  this.space();
  this.print(node.key, node);
  this.token("]");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_ObjectTypeProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.key, node);
  if (node.optional) this.token("?");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_QualifiedTypeIdentifier(node) {
  this.print(node.qualification, node);
  this.token(".");
  this.print(node.id, node);
}

function _babelgeneratorlibgeneratorsflowjs6160_orSeparator() {
  this.space();
  this.token("|");
  this.space();
}

function _babelgeneratorlibgeneratorsflowjs6160_UnionTypeAnnotation(node) {
  this.printJoin(node.types, node, { separator: _babelgeneratorlibgeneratorsflowjs6160_orSeparator });
}

function _babelgeneratorlibgeneratorsflowjs6160_TypeCastExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function _babelgeneratorlibgeneratorsflowjs6160_VoidTypeAnnotation() {
  this.word("void");
}
/*≠≠ node_modules/babel-generator/lib/generators/flow.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/modules.js ==*/
$m['babel-generator/lib/generators/modules.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ImportSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ImportSpecifier;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ImportDefaultSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ImportDefaultSpecifier;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportDefaultSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ExportDefaultSpecifier;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ExportSpecifier;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportNamespaceSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ExportNamespaceSpecifier;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportAllDeclaration = _babelgeneratorlibgeneratorsmodulesjs6160_ExportAllDeclaration;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportNamedDeclaration = _babelgeneratorlibgeneratorsmodulesjs6160_ExportNamedDeclaration;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ExportDefaultDeclaration = _babelgeneratorlibgeneratorsmodulesjs6160_ExportDefaultDeclaration;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ImportDeclaration = _babelgeneratorlibgeneratorsmodulesjs6160_ImportDeclaration;
$m['babel-generator/lib/generators/modules.js#6.16.0'].exports.ImportNamespaceSpecifier = _babelgeneratorlibgeneratorsmodulesjs6160_ImportNamespaceSpecifier;

var _babelgeneratorlibgeneratorsmodulesjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorsmodulesjs6160_t = _babelgeneratorlibgeneratorsmodulesjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorsmodulesjs6160__babelTypes);

function _babelgeneratorlibgeneratorsmodulesjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ImportSpecifier(node) {
  this.print(node.imported, node);
  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportSpecifier(node) {
  this.print(node.local, node);
  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportAllDeclaration(node) {
  this.word("export");
  this.space();
  this.token("*");
  if (node.exported) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportNamedDeclaration() {
  this.word("export");
  this.space();
  _babelgeneratorlibgeneratorsmodulesjs6160_ExportDeclaration.apply(this, arguments);
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportDefaultDeclaration() {
  this.word("export");
  this.space();
  this.word("default");
  this.space();
  _babelgeneratorlibgeneratorsmodulesjs6160_ExportDeclaration.apply(this, arguments);
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ExportDeclaration(node) {
  if (node.declaration) {
    var declar = node.declaration;
    this.print(declar, node);
    if (!_babelgeneratorlibgeneratorsmodulesjs6160_t.isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    var specifiers = node.specifiers.slice(0);

    var hasSpecial = false;
    while (true) {
      var first = specifiers[0];
      if (_babelgeneratorlibgeneratorsmodulesjs6160_t.isExportDefaultSpecifier(first) || _babelgeneratorlibgeneratorsmodulesjs6160_t.isExportNamespaceSpecifier(first)) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length || !specifiers.length && !hasSpecial) {
      this.token("{");
      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }
      this.token("}");
    }

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ImportDeclaration(node) {
  this.word("import");
  this.space();

  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  var specifiers = node.specifiers.slice(0);
  if (specifiers && specifiers.length) {
    while (true) {
      var first = specifiers[0];
      if (_babelgeneratorlibgeneratorsmodulesjs6160_t.isImportDefaultSpecifier(first) || _babelgeneratorlibgeneratorsmodulesjs6160_t.isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }

    this.space();
    this.word("from");
    this.space();
  }

  this.print(node.source, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsmodulesjs6160_ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}
/*≠≠ node_modules/babel-generator/lib/generators/modules.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/methods.js ==*/
$m['babel-generator/lib/generators/methods.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/methods.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/methods.js#6.16.0'].exports.FunctionDeclaration = undefined;
$m['babel-generator/lib/generators/methods.js#6.16.0'].exports._params = _babelgeneratorlibgeneratorsmethodsjs6160__params;
$m['babel-generator/lib/generators/methods.js#6.16.0'].exports._method = _babelgeneratorlibgeneratorsmethodsjs6160__method;
$m['babel-generator/lib/generators/methods.js#6.16.0'].exports.FunctionExpression = _babelgeneratorlibgeneratorsmethodsjs6160_FunctionExpression;
$m['babel-generator/lib/generators/methods.js#6.16.0'].exports.ArrowFunctionExpression = _babelgeneratorlibgeneratorsmethodsjs6160_ArrowFunctionExpression;

var _babelgeneratorlibgeneratorsmethodsjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorsmethodsjs6160_t = _babelgeneratorlibgeneratorsmethodsjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorsmethodsjs6160__babelTypes);

function _babelgeneratorlibgeneratorsmethodsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibgeneratorsmethodsjs6160__params(node) {
  var _this = this;

  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node, {
    iterator: function iterator(node) {
      if (node.optional) _this.token("?");
      _this.print(node.typeAnnotation, node);
    }
  });
  this.token(")");

  if (node.returnType) {
    this.print(node.returnType, node);
  }
}

function _babelgeneratorlibgeneratorsmethodsjs6160__method(node) {
  var kind = node.kind;
  var key = node.key;

  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }

  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }

  if (node.async) {
    this.word("async");
    this.space();
  }

  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }

  this._params(node);
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsmethodsjs6160_FunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  this.word("function");
  if (node.generator) this.token("*");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  } else {
    this.space();
  }

  this._params(node);
  this.space();
  this.print(node.body, node);
}

$m['babel-generator/lib/generators/methods.js#6.16.0'].exports.FunctionDeclaration = _babelgeneratorlibgeneratorsmethodsjs6160_FunctionExpression;
function _babelgeneratorlibgeneratorsmethodsjs6160_ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  var firstParam = node.params[0];

  if (node.params.length === 1 && _babelgeneratorlibgeneratorsmethodsjs6160_t.isIdentifier(firstParam) && !_babelgeneratorlibgeneratorsmethodsjs6160_hasTypes(node, firstParam)) {
    this.print(firstParam, node);
  } else {
    this._params(node);
  }

  this.space();
  this.token("=>");
  this.space();

  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsmethodsjs6160_hasTypes(node, param) {
  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
}
/*≠≠ node_modules/babel-generator/lib/generators/methods.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/statements.js ==*/
$m['babel-generator/lib/generators/statements.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ThrowStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.BreakStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ReturnStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ContinueStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForAwaitStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForOfStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForInStatement = undefined;

var _babelgeneratorlibgeneratorsstatementsjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelgeneratorlibgeneratorsstatementsjs6160__getIterator3 = _babelgeneratorlibgeneratorsstatementsjs6160__interopRequireDefault(_babelgeneratorlibgeneratorsstatementsjs6160__getIterator2);

$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.WithStatement = _babelgeneratorlibgeneratorsstatementsjs6160_WithStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.IfStatement = _babelgeneratorlibgeneratorsstatementsjs6160_IfStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForStatement = _babelgeneratorlibgeneratorsstatementsjs6160_ForStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.WhileStatement = _babelgeneratorlibgeneratorsstatementsjs6160_WhileStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.DoWhileStatement = _babelgeneratorlibgeneratorsstatementsjs6160_DoWhileStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.LabeledStatement = _babelgeneratorlibgeneratorsstatementsjs6160_LabeledStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.TryStatement = _babelgeneratorlibgeneratorsstatementsjs6160_TryStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.CatchClause = _babelgeneratorlibgeneratorsstatementsjs6160_CatchClause;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.SwitchStatement = _babelgeneratorlibgeneratorsstatementsjs6160_SwitchStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.SwitchCase = _babelgeneratorlibgeneratorsstatementsjs6160_SwitchCase;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.DebuggerStatement = _babelgeneratorlibgeneratorsstatementsjs6160_DebuggerStatement;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.VariableDeclaration = _babelgeneratorlibgeneratorsstatementsjs6160_VariableDeclaration;
$m['babel-generator/lib/generators/statements.js#6.16.0'].exports.VariableDeclarator = _babelgeneratorlibgeneratorsstatementsjs6160_VariableDeclarator;

var _babelgeneratorlibgeneratorsstatementsjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorsstatementsjs6160_t = _babelgeneratorlibgeneratorsstatementsjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorsstatementsjs6160__babelTypes);

function _babelgeneratorlibgeneratorsstatementsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibgeneratorsstatementsjs6160_WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}

function _babelgeneratorlibgeneratorsstatementsjs6160_IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();

  var needsBlock = node.alternate && _babelgeneratorlibgeneratorsstatementsjs6160_t.isIfStatement(_babelgeneratorlibgeneratorsstatementsjs6160_getLastStatement(node.consequent));
  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }

  this.printAndIndentOnComments(node.consequent, node);

  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }

  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160_getLastStatement(statement) {
  if (!_babelgeneratorlibgeneratorsstatementsjs6160_t.isStatement(statement.body)) return statement;
  return _babelgeneratorlibgeneratorsstatementsjs6160_getLastStatement(statement.body);
}

function _babelgeneratorlibgeneratorsstatementsjs6160_ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");

  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");

  if (node.test) {
    this.space();
    this.print(node.test, node);
  }
  this.token(";");

  if (node.update) {
    this.space();
    this.print(node.update, node);
  }

  this.token(")");
  this.printBlock(node);
}

function _babelgeneratorlibgeneratorsstatementsjs6160_WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}

var _babelgeneratorlibgeneratorsstatementsjs6160_buildForXStatement = function buildForXStatement(op) {
  return function (node) {
    this.word("for");
    this.space();
    if (op === "await") {
      this.word("await");
      this.space();
      op = "of";
    }
    this.token("(");

    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};

var _babelgeneratorlibgeneratorsstatementsjs6160_ForInStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForInStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildForXStatement("in");
var _babelgeneratorlibgeneratorsstatementsjs6160_ForOfStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForOfStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildForXStatement("of");
var _babelgeneratorlibgeneratorsstatementsjs6160_ForAwaitStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ForAwaitStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildForXStatement("await");

function _babelgeneratorlibgeneratorsstatementsjs6160_DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}

function _babelgeneratorlibgeneratorsstatementsjs6160_buildLabelStatement(prefix) {
  var key = arguments.length <= 1 || arguments[1] === undefined ? "label" : arguments[1];

  return function (node) {
    this.word(prefix);

    var label = node[key];
    if (label) {
      this.space();

      var terminatorState = this.startTerminatorless();
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }

    this.semicolon();
  };
}

var _babelgeneratorlibgeneratorsstatementsjs6160_ContinueStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ContinueStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildLabelStatement("continue");
var _babelgeneratorlibgeneratorsstatementsjs6160_ReturnStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ReturnStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildLabelStatement("return", "argument");
var _babelgeneratorlibgeneratorsstatementsjs6160_BreakStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.BreakStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildLabelStatement("break");
var _babelgeneratorlibgeneratorsstatementsjs6160_ThrowStatement = $m['babel-generator/lib/generators/statements.js#6.16.0'].exports.ThrowStatement = _babelgeneratorlibgeneratorsstatementsjs6160_buildLabelStatement("throw", "argument");

function _babelgeneratorlibgeneratorsstatementsjs6160_LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsstatementsjs6160_TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();

  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }

  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160_CatchClause(node) {
  this.word("catch");
  this.space();
  this.token("(");
  this.print(node.param, node);
  this.token(")");
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsstatementsjs6160_SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");

  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines: function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    }
  });

  this.token("}");
}

function _babelgeneratorlibgeneratorsstatementsjs6160_SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }

  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, { indent: true });
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160_DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}

function _babelgeneratorlibgeneratorsstatementsjs6160_variableDeclarationIdent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
    this.space(true);
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160_constDeclarationIdent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
    this.space(true);
  }
}

function _babelgeneratorlibgeneratorsstatementsjs6160_VariableDeclaration(node, parent) {
  this.word(node.kind);
  this.space();

  var hasInits = false;

  if (!_babelgeneratorlibgeneratorsstatementsjs6160_t.isFor(parent)) {
    for (var _iterator = node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelgeneratorlibgeneratorsstatementsjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var declar = _ref;

      if (declar.init) {
        hasInits = true;
      }
    }
  }

  var separator = void 0;
  if (hasInits) {
    separator = node.kind === "const" ? _babelgeneratorlibgeneratorsstatementsjs6160_constDeclarationIdent : _babelgeneratorlibgeneratorsstatementsjs6160_variableDeclarationIdent;
  }

  this.printList(node.declarations, node, { separator: separator });

  if (_babelgeneratorlibgeneratorsstatementsjs6160_t.isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }

  this.semicolon();
}

function _babelgeneratorlibgeneratorsstatementsjs6160_VariableDeclarator(node) {
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}
/*≠≠ node_modules/babel-generator/lib/generators/statements.js ≠≠*/

/*== node_modules/babel-generator/lib/generators/expressions.js ==*/
$m['babel-generator/lib/generators/expressions.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.LogicalExpression = $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.BinaryExpression = $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.AwaitExpression = $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.YieldExpression = undefined;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.UnaryExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_UnaryExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.DoExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_DoExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.ParenthesizedExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_ParenthesizedExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.UpdateExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_UpdateExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.ConditionalExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_ConditionalExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.NewExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_NewExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.SequenceExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_SequenceExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.ThisExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_ThisExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.Super = _babelgeneratorlibgeneratorsexpressionsjs6160_Super;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.Decorator = _babelgeneratorlibgeneratorsexpressionsjs6160_Decorator;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.CallExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_CallExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.EmptyStatement = _babelgeneratorlibgeneratorsexpressionsjs6160_EmptyStatement;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.ExpressionStatement = _babelgeneratorlibgeneratorsexpressionsjs6160_ExpressionStatement;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.AssignmentPattern = _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentPattern;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.AssignmentExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.BindExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_BindExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.MemberExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_MemberExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.MetaProperty = _babelgeneratorlibgeneratorsexpressionsjs6160_MetaProperty;

var _babelgeneratorlibgeneratorsexpressionsjs6160__isNumber = $m['lodash/isNumber.js#4.16.2'].exports;

var _babelgeneratorlibgeneratorsexpressionsjs6160__isNumber2 = _babelgeneratorlibgeneratorsexpressionsjs6160__interopRequireDefault(_babelgeneratorlibgeneratorsexpressionsjs6160__isNumber);

var _babelgeneratorlibgeneratorsexpressionsjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorsexpressionsjs6160_t = _babelgeneratorlibgeneratorsexpressionsjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorsexpressionsjs6160__babelTypes);

var _babelgeneratorlibgeneratorsexpressionsjs6160__node = $m['babel-generator/lib/node/index.js#6.16.0'].exports;

var _babelgeneratorlibgeneratorsexpressionsjs6160_n = _babelgeneratorlibgeneratorsexpressionsjs6160__interopRequireWildcard(_babelgeneratorlibgeneratorsexpressionsjs6160__node);

function _babelgeneratorlibgeneratorsexpressionsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibgeneratorsexpressionsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_UnaryExpression(node) {
  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof") {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }

  this.print(node.argument, node);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.print(node.argument, node);
    this.token(node.operator);
  }
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);
  if (node.arguments.length === 0 && this.format.minified && !_babelgeneratorlibgeneratorsexpressionsjs6160_t.isCallExpression(parent, { callee: node }) && !_babelgeneratorlibgeneratorsexpressionsjs6160_t.isMemberExpression(parent) && !_babelgeneratorlibgeneratorsexpressionsjs6160_t.isNewExpression(parent)) return;

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_SequenceExpression(node) {
  this.printList(node.expressions, node);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_ThisExpression() {
  this.word("this");
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_Super() {
  this.word("super");
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_commaSeparatorNewline() {
  this.token(",");
  this.newline();

  if (!this.endsWith("\n")) this.space();
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_CallExpression(node) {
  this.print(node.callee, node);

  this.token("(");

  var isPrettyCall = node._prettyCall;

  var separator = void 0;
  if (isPrettyCall) {
    separator = _babelgeneratorlibgeneratorsexpressionsjs6160_commaSeparatorNewline;
    this.newline();
    this.indent();
  }

  this.printList(node.arguments, node, { separator: separator });

  if (isPrettyCall) {
    this.newline();
    this.dedent();
  }

  this.token(")");
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);

    if (node.delegate) {
      this.token("*");
    }

    if (node.argument) {
      this.space();
      var terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}

var _babelgeneratorlibgeneratorsexpressionsjs6160_YieldExpression = $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.YieldExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_buildYieldAwait("yield");
var _babelgeneratorlibgeneratorsexpressionsjs6160_AwaitExpression = $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.AwaitExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_buildYieldAwait("await");

function _babelgeneratorlibgeneratorsexpressionsjs6160_EmptyStatement() {
  this.semicolon(true);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentPattern(node) {
  this.print(node.left, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentExpression(node, parent) {
  var parens = this.inForStatementInitCounter && node.operator === "in" && !_babelgeneratorlibgeneratorsexpressionsjs6160_n.needsParens(node, parent);

  if (parens) {
    this.token("(");
  }

  this.print(node.left, node);

  this.space();
  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }
  this.space();

  this.print(node.right, node);

  if (parens) {
    this.token(")");
  }
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}

$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.BinaryExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentExpression;
$m['babel-generator/lib/generators/expressions.js#6.16.0'].exports.LogicalExpression = _babelgeneratorlibgeneratorsexpressionsjs6160_AssignmentExpression;
function _babelgeneratorlibgeneratorsexpressionsjs6160_MemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && _babelgeneratorlibgeneratorsexpressionsjs6160_t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;
  if (_babelgeneratorlibgeneratorsexpressionsjs6160_t.isLiteral(node.property) && (0, _babelgeneratorlibgeneratorsexpressionsjs6160__isNumber2.default)(node.property.value)) {
    computed = true;
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}

function _babelgeneratorlibgeneratorsexpressionsjs6160_MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}
/*≠≠ node_modules/babel-generator/lib/generators/expressions.js ≠≠*/

/*== node_modules/babel-generator/lib/whitespace.js ==*/
$m['babel-generator/lib/whitespace.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/whitespace.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibwhitespacejs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelgeneratorlibwhitespacejs6160__classCallCheck3 = _babelgeneratorlibwhitespacejs6160__interopRequireDefault(_babelgeneratorlibwhitespacejs6160__classCallCheck2);

function _babelgeneratorlibwhitespacejs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelgeneratorlibwhitespacejs6160_Whitespace = function () {
  function Whitespace(tokens) {
    (0, _babelgeneratorlibwhitespacejs6160__classCallCheck3.default)(this, Whitespace);

    this.tokens = tokens;
    this.used = {};
  }

  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {
    var startToken = void 0;
    var endToken = void 0;
    var tokens = this.tokens;

    var index = this._findToken(function (token) {
      return token.start - node.start;
    }, 0, tokens.length);
    if (index >= 0) {
      while (index && node.start === tokens[index - 1].start) {
        --index;
      }startToken = tokens[index - 1];
      endToken = tokens[index];
    }

    return this._getNewlinesBetween(startToken, endToken);
  };

  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {
    var startToken = void 0;
    var endToken = void 0;
    var tokens = this.tokens;

    var index = this._findToken(function (token) {
      return token.end - node.end;
    }, 0, tokens.length);
    if (index >= 0) {
      while (index && node.end === tokens[index - 1].end) {
        --index;
      }startToken = tokens[index];
      endToken = tokens[index + 1];
      if (endToken.type.label === ",") endToken = tokens[index + 2];
    }

    if (endToken && endToken.type.label === "eof") {
      return 1;
    } else {
      return this._getNewlinesBetween(startToken, endToken);
    }
  };

  Whitespace.prototype._getNewlinesBetween = function _getNewlinesBetween(startToken, endToken) {
    if (!endToken || !endToken.loc) return 0;

    var start = startToken ? startToken.loc.end.line : 1;
    var end = endToken.loc.start.line;
    var lines = 0;

    for (var line = start; line < end; line++) {
      if (typeof this.used[line] === "undefined") {
        this.used[line] = true;
        lines++;
      }
    }

    return lines;
  };

  Whitespace.prototype._findToken = function _findToken(test, start, end) {
    if (start >= end) return -1;
    var middle = start + end >>> 1;
    var match = test(this.tokens[middle]);
    if (match < 0) {
      return this._findToken(test, middle + 1, end);
    } else if (match > 0) {
      return this._findToken(test, start, middle);
    } else if (match === 0) {
      return middle;
    }
    return -1;
  };

  return Whitespace;
}();

$m['babel-generator/lib/whitespace.js#6.16.0'].exports.default = _babelgeneratorlibwhitespacejs6160_Whitespace;
$m['babel-generator/lib/whitespace.js#6.16.0'].exports = $m['babel-generator/lib/whitespace.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-generator/lib/whitespace.js ≠≠*/

/*== node_modules/babel-generator/lib/buffer.js ==*/
$m['babel-generator/lib/buffer.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/buffer.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibbufferjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelgeneratorlibbufferjs6160__classCallCheck3 = _babelgeneratorlibbufferjs6160__interopRequireDefault(_babelgeneratorlibbufferjs6160__classCallCheck2);

var _babelgeneratorlibbufferjs6160__trimEnd = $m['lodash/trimEnd.js#4.16.2'].exports;

var _babelgeneratorlibbufferjs6160__trimEnd2 = _babelgeneratorlibbufferjs6160__interopRequireDefault(_babelgeneratorlibbufferjs6160__trimEnd);

function _babelgeneratorlibbufferjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelgeneratorlibbufferjs6160_SPACES_RE = /^[ \t]+$/;

var _babelgeneratorlibbufferjs6160_Buffer = function () {
  function Buffer(map) {
    (0, _babelgeneratorlibbufferjs6160__classCallCheck3.default)(this, Buffer);
    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null
    };

    this._map = map;
  }

  Buffer.prototype.get = function get() {
    this._flush();

    return {
      code: (0, _babelgeneratorlibbufferjs6160__trimEnd2.default)(this._buf.join("")),
      map: this._map ? this._map.get() : null
    };
  };

  Buffer.prototype.append = function append(str) {
    this._flush();
    var _sourcePosition = this._sourcePosition;
    var line = _sourcePosition.line;
    var column = _sourcePosition.column;
    var filename = _sourcePosition.filename;
    var identifierName = _sourcePosition.identifierName;

    this._append(str, line, column, identifierName, filename);
  };

  Buffer.prototype.queue = function queue(str) {
    if (str === "\n") while (this._queue.length > 0 && _babelgeneratorlibbufferjs6160_SPACES_RE.test(this._queue[0][0])) {
      this._queue.shift();
    }var _sourcePosition2 = this._sourcePosition;
    var line = _sourcePosition2.line;
    var column = _sourcePosition2.column;
    var filename = _sourcePosition2.filename;
    var identifierName = _sourcePosition2.identifierName;

    this._queue.unshift([str, line, column, identifierName, filename]);
  };

  Buffer.prototype._flush = function _flush() {
    var item = void 0;
    while (item = this._queue.pop()) {
      this._append.apply(this, item);
    }
  };

  Buffer.prototype._append = function _append(str, line, column, identifierName, filename) {
    if (this._map && str[0] !== "\n") {
      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename);
    }

    this._buf.push(str);
    this._last = str[str.length - 1];

    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  };

  Buffer.prototype.removeTrailingNewline = function removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") this._queue.shift();
  };

  Buffer.prototype.removeLastSemicolon = function removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ";") this._queue.shift();
  };

  Buffer.prototype.endsWith = function endsWith(suffix) {
    if (suffix.length === 1) {
      var last = void 0;
      if (this._queue.length > 0) {
        var str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }

      return last === suffix;
    }

    var end = this._last + this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");
    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }

    return false;
  };

  Buffer.prototype.hasContent = function hasContent() {
    return this._queue.length > 0 || !!this._last;
  };

  Buffer.prototype.source = function source(prop, loc) {
    if (prop && !loc) return;

    var pos = loc ? loc[prop] : null;

    this._sourcePosition.identifierName = loc && loc.identifierName || null;
    this._sourcePosition.line = pos ? pos.line : null;
    this._sourcePosition.column = pos ? pos.column : null;
    this._sourcePosition.filename = loc && loc.filename || null;
  };

  Buffer.prototype.withSource = function withSource(prop, loc, cb) {
    if (!this._map) return cb();

    var originalLine = this._sourcePosition.line;
    var originalColumn = this._sourcePosition.column;
    var originalFilename = this._sourcePosition.filename;
    var originalIdentifierName = this._sourcePosition.identifierName;

    this.source(prop, loc);

    cb();

    this._sourcePosition.line = originalLine;
    this._sourcePosition.column = originalColumn;
    this._sourcePosition.filename = originalFilename;
    this._sourcePosition.identifierName = originalIdentifierName;
  };

  Buffer.prototype.getCurrentColumn = function getCurrentColumn() {
    var extra = this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");
    var lastIndex = extra.lastIndexOf("\n");

    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
  };

  Buffer.prototype.getCurrentLine = function getCurrentLine() {
    var extra = this._queue.reduce(function (acc, item) {
      return item[0] + acc;
    }, "");

    var count = 0;
    for (var i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }

    return this._position.line + count;
  };

  return Buffer;
}();

$m['babel-generator/lib/buffer.js#6.16.0'].exports.default = _babelgeneratorlibbufferjs6160_Buffer;
$m['babel-generator/lib/buffer.js#6.16.0'].exports = $m['babel-generator/lib/buffer.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-generator/lib/buffer.js ≠≠*/

/*== node_modules/lodash/isInteger.js ==*/
$m['lodash/isInteger.js#4.16.2'] = { exports: {} };
var _lodashisIntegerjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports;

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function _lodashisIntegerjs4162_isInteger(value) {
  return typeof value == 'number' && value == _lodashisIntegerjs4162_toInteger(value);
}

$m['lodash/isInteger.js#4.16.2'].exports = _lodashisIntegerjs4162_isInteger;
/*≠≠ node_modules/lodash/isInteger.js ≠≠*/

/*== node_modules/lodash/findLast.js ==*/
$m['lodash/findLast.js#4.16.2'] = { exports: {} };
var _lodashfindLastjs4162_createFind = $m['lodash/_createFind.js#4.16.2'].exports,
    _lodashfindLastjs4162_findLastIndex = $m['lodash/findLastIndex.js#4.16.2'].exports;

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var _lodashfindLastjs4162_findLast = _lodashfindLastjs4162_createFind(_lodashfindLastjs4162_findLastIndex);

$m['lodash/findLast.js#4.16.2'].exports = _lodashfindLastjs4162_findLast;
/*≠≠ node_modules/lodash/findLast.js ≠≠*/

/*== node_modules/lodash/find.js ==*/
$m['lodash/find.js#4.16.2'] = { exports: {} };
var _lodashfindjs4162_createFind = $m['lodash/_createFind.js#4.16.2'].exports,
    _lodashfindjs4162_findIndex = $m['lodash/findIndex.js#4.16.2'].exports;

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var _lodashfindjs4162_find = _lodashfindjs4162_createFind(_lodashfindjs4162_findIndex);

$m['lodash/find.js#4.16.2'].exports = _lodashfindjs4162_find;
/*≠≠ node_modules/lodash/find.js ≠≠*/

/*== node_modules/babel-runtime/core-js/weak-set.js ==*/
$m['babel-runtime/core-js/weak-set.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/weak-set.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/weak-set.js ≠≠*/

/*== node_modules/repeating/index.js ==*/
$m['repeating/index.js#1.1.3'] = { exports: {} };
'use strict';

var _repeatingindexjs113_isFinite = $m['is-finite/index.js#1.0.2'].exports;

$m['repeating/index.js#1.1.3'].exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string as the first argument');
	}

	if (n < 0 || !_repeatingindexjs113_isFinite(n)) {
		throw new TypeError('Expected a finite positive number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while (n = n >> 1);

	return ret;
};
/*≠≠ node_modules/repeating/index.js ≠≠*/

/*== node_modules/source-map/lib/mapping-list.js ==*/
$m['source-map/lib/mapping-list.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibmappinglistjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function _sourcemaplibmappinglistjs056_generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || _sourcemaplibmappinglistjs056_util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function _sourcemaplibmappinglistjs056_MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.add = function MappingList_add(aMapping) {
  if (_sourcemaplibmappinglistjs056_generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(_sourcemaplibmappinglistjs056_util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

$m['source-map/lib/mapping-list.js#0.5.6'].exports.MappingList = _sourcemaplibmappinglistjs056_MappingList;
/*≠≠ node_modules/source-map/lib/mapping-list.js ≠≠*/

/*== node_modules/source-map/lib/array-set.js ==*/
$m['source-map/lib/array-set.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibarraysetjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibarraysetjs056_has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function _sourcemaplibarraysetjs056_ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
_sourcemaplibarraysetjs056_ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new _sourcemaplibarraysetjs056_ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  var isDuplicate = _sourcemaplibarraysetjs056_has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  return _sourcemaplibarraysetjs056_has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  if (_sourcemaplibarraysetjs056_has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

$m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet = _sourcemaplibarraysetjs056_ArraySet;
/*≠≠ node_modules/source-map/lib/array-set.js ≠≠*/

/*== node_modules/source-map/lib/base64-vlq.js ==*/
$m['source-map/lib/base64-vlq.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var _sourcemaplibbase64vlqjs056_base64 = $m['source-map/lib/base64.js#0.5.6'].exports;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT = 5;

// binary: 100000
var _sourcemaplibbase64vlqjs056_VLQ_BASE = 1 << _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;

// binary: 011111
var _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK = _sourcemaplibbase64vlqjs056_VLQ_BASE - 1;

// binary: 100000
var _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT = _sourcemaplibbase64vlqjs056_VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function _sourcemaplibbase64vlqjs056_toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function _sourcemaplibbase64vlqjs056_fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
$m['source-map/lib/base64-vlq.js#0.5.6'].exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = _sourcemaplibbase64vlqjs056_toVLQSigned(aValue);

  do {
    digit = vlq & _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK;
    vlq >>>= _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT;
    }
    encoded += _sourcemaplibbase64vlqjs056_base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
$m['source-map/lib/base64-vlq.js#0.5.6'].exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = _sourcemaplibbase64vlqjs056_base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT);
    digit &= _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = _sourcemaplibbase64vlqjs056_fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
/*≠≠ node_modules/source-map/lib/base64-vlq.js ≠≠*/

/*== node_modules/source-map/lib/source-map-generator.js ==*/
$m['source-map/lib/source-map-generator.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcemapgeneratorjs056_base64VLQ = $m['source-map/lib/base64-vlq.js#0.5.6'].exports;
var _sourcemaplibsourcemapgeneratorjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibsourcemapgeneratorjs056_ArraySet = $m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet;
var _sourcemaplibsourcemapgeneratorjs056_MappingList = $m['source-map/lib/mapping-list.js#0.5.6'].exports.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'file', null);
  this._sourceRoot = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'skipValidation', false);
  this._sources = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  this._names = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  this._mappings = new _sourcemaplibsourcemapgeneratorjs056_MappingList();
  this._sourcesContents = null;
}

_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'generated');
  var original = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'original', null);
  var source = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'source', null);
  var name = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = _sourcemaplibsourcemapgeneratorjs056_util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[_sourcemaplibsourcemapgeneratorjs056_util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[_sourcemaplibsourcemapgeneratorjs056_util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  var newNames = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = _sourcemaplibsourcemapgeneratorjs056_util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!_sourcemaplibsourcemapgeneratorjs056_util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }

    next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;

      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = _sourcemaplibsourcemapgeneratorjs056_util.relative(aSourceRoot, source);
    }
    var key = _sourcemaplibsourcemapgeneratorjs056_util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

$m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator = _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator;
/*≠≠ node_modules/source-map/lib/source-map-generator.js ≠≠*/

/*== node_modules/source-map/lib/source-map-consumer.js ==*/
$m['source-map/lib/source-map-consumer.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcemapconsumerjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_binarySearch = $m['source-map/lib/binary-search.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_ArraySet = $m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet;
var _sourcemaplibsourcemapconsumerjs056_base64VLQ = $m['source-map/lib/base64-vlq.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_quickSort = $m['source-map/lib/quick-sort.js#0.5.6'].exports.quickSort;

function _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null ? new _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer(sourceMap) : new _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer(sourceMap);
}

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.fromSourceMap = function (aSourceMap) {
  return _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.fromSourceMap(aSourceMap);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER = 1;
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.ORIGINAL_ORDER = 2;

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
    case _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    if (source != null && sourceRoot != null) {
      source = _sourcemaplibsourcemapconsumerjs056_util.join(sourceRoot, source);
    }
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column', 0)
  };

  if (this.sourceRoot != null) {
    needle.source = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, needle.source);
  }
  if (!this._sources.has(needle.source)) {
    return [];
  }
  needle.source = this._sources.indexOf(needle.source);

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions, _sourcemaplibsourcemapconsumerjs056_binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
          column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
          lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
          column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
          lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.SourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'version');
  var sources = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'names', []);
  var sourceRoot = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'mappings');
  var file = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(_sourcemaplibsourcemapconsumerjs056_util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && _sourcemaplibsourcemapconsumerjs056_util.isAbsolute(sourceRoot) && _sourcemaplibsourcemapconsumerjs056_util.isAbsolute(source) ? _sourcemaplibsourcemapconsumerjs056_util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(names.map(String), true);
  this._sources = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype = Object.create(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype);
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.consumer = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
  var smc = Object.create(_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype);

  var names = smc._names = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new _sourcemaplibsourcemapconsumerjs056_Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(smc.__originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);

  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? _sourcemaplibsourcemapconsumerjs056_util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function _sourcemaplibsourcemapconsumerjs056_Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new _sourcemaplibsourcemapconsumerjs056_Mapping();
      mapping.generatedLine = generatedLine;

      // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);

      segment = cachedSegments[str];
      if (segment) {
        index += str.length;
      } else {
        segment = [];
        while (index < end) {
          _sourcemaplibsourcemapconsumerjs056_base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(generatedMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  _sourcemaplibsourcemapconsumerjs056_quickSort(originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return _sourcemaplibsourcemapconsumerjs056_binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    generatedColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated, _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'bias', _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        if (this.sourceRoot != null) {
          source = _sourcemaplibsourcemapconsumerjs056_util.join(this.sourceRoot, source);
        }
      }
      var name = _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'originalLine', null),
        column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  if (this.sourceRoot != null) {
    aSource = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, aSource);
  }

  if (this._sources.has(aSource)) {
    return this.sourcesContent[this._sources.indexOf(aSource)];
  }

  var url;
  if (this.sourceRoot != null && (url = _sourcemaplibsourcemapconsumerjs056_util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + aSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source');
  if (this.sourceRoot != null) {
    source = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, source);
  }
  if (!this._sources.has(source)) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  source = this._sources.indexOf(source);

  var needle = {
    source: source,
    originalLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    originalColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions, _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'bias', _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
        column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
        lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.BasicSourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'version');
  var sections = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new _sourcemaplibsourcemapconsumerjs056_ArraySet();
  this._names = new _sourcemaplibsourcemapconsumerjs056_ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = _sourcemaplibsourcemapconsumerjs056_util.getArg(s, 'offset');
    var offsetLine = _sourcemaplibsourcemapconsumerjs056_util.getArg(offset, 'line');
    var offsetColumn = _sourcemaplibsourcemapconsumerjs056_util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer(_sourcemaplibsourcemapconsumerjs056_util.getArg(s, 'map'))
    };
  });
}

_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype = Object.create(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype);
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.constructor = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    generatedColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = _sourcemaplibsourcemapconsumerjs056_binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer.sources.indexOf(_sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);
      if (section.consumer.sourceRoot !== null) {
        source = _sourcemaplibsourcemapconsumerjs056_util.join(section.consumer.sourceRoot, source);
      }
      this._sources.add(source);
      source = this._sources.indexOf(source);

      var name = section.consumer._names.at(mapping.name);
      this._names.add(name);
      name = this._names.indexOf(name);

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(this.__generatedMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated);
  _sourcemaplibsourcemapconsumerjs056_quickSort(this.__originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.IndexedSourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer;
/*≠≠ node_modules/source-map/lib/source-map-consumer.js ≠≠*/

/*== node_modules/source-map/lib/source-node.js ==*/
$m['source-map/lib/source-node.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcenodejs056_SourceMapGenerator = $m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator;
var _sourcemaplibsourcenodejs056_util = $m['source-map/lib/util.js#0.5.6'].exports;

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var _sourcemaplibsourcenodejs056_REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var _sourcemaplibsourcenodejs056_NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var _sourcemaplibsourcenodejs056_isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function _sourcemaplibsourcenodejs056_SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[_sourcemaplibsourcenodejs056_isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
_sourcemaplibsourcenodejs056_SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new _sourcemaplibsourcenodejs056_SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are removed from this array, by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(_sourcemaplibsourcenodejs056_REGEX_NEWLINE);
  var shiftNextLine = function () {
    var lineContents = remainingLines.shift();
    // The last line of a file might not have a newline.
    var newLine = remainingLines.shift() || "";
    return lineContents + newLine;
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[0];
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[0];
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[0] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLines.length > 0) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = _sourcemaplibsourcenodejs056_util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? _sourcemaplibsourcenodejs056_util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new _sourcemaplibsourcenodejs056_SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[_sourcemaplibsourcenodejs056_isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[_sourcemaplibsourcenodejs056_isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[_sourcemaplibsourcenodejs056_isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
          line: this.line,
          column: this.column,
          name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[_sourcemaplibsourcenodejs056_isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[_sourcemaplibsourcenodejs056_util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][_sourcemaplibsourcenodejs056_isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(_sourcemaplibsourcenodejs056_util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new _sourcemaplibsourcenodejs056_SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === _sourcemaplibsourcenodejs056_NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

$m['source-map/lib/source-node.js#0.5.6'].exports.SourceNode = _sourcemaplibsourcenodejs056_SourceNode;
/*≠≠ node_modules/source-map/lib/source-node.js ≠≠*/

/*== node_modules/source-map/source-map.js ==*/
$m['source-map/source-map.js#0.5.6'] = { exports: {} };
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
$m['source-map/source-map.js#0.5.6'].exports.SourceMapGenerator = $m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator;
$m['source-map/source-map.js#0.5.6'].exports.SourceMapConsumer = $m['source-map/lib/source-map-consumer.js#0.5.6'].exports.SourceMapConsumer;
$m['source-map/source-map.js#0.5.6'].exports.SourceNode = $m['source-map/lib/source-node.js#0.5.6'].exports.SourceNode;
/*≠≠ node_modules/source-map/source-map.js ≠≠*/

/*== node_modules/dom-serializer/index.js ==*/
$m['dom-serializer/index.js#0.1.0'] = { exports: {} };
/*
  Module dependencies
*/
var _domserializerindexjs010_ElementType = $m['domelementtype/index.js#1.1.3'].exports;
var _domserializerindexjs010_entities = $m['entities/index.js#1.1.1'].exports;

/*
  Boolean Attributes
*/
var _domserializerindexjs010_booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var _domserializerindexjs010_unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function _domserializerindexjs010_formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (!value && _domserializerindexjs010_booleanAttributes[key]) {
      output += key;
    } else {
      output += key + '="' + (opts.decodeEntities ? _domserializerindexjs010_entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var _domserializerindexjs010_singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var _domserializerindexjs010_render = $m['dom-serializer/index.js#0.1.0'].exports = function (dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += _domserializerindexjs010_render(elem.children, opts);else if (_domserializerindexjs010_ElementType.isTag(elem)) output += _domserializerindexjs010_renderTag(elem, opts);else if (elem.type === _domserializerindexjs010_ElementType.Directive) output += _domserializerindexjs010_renderDirective(elem);else if (elem.type === _domserializerindexjs010_ElementType.Comment) output += _domserializerindexjs010_renderComment(elem);else if (elem.type === _domserializerindexjs010_ElementType.CDATA) output += _domserializerindexjs010_renderCdata(elem);else output += _domserializerindexjs010_renderText(elem, opts);
  }

  return output;
};

function _domserializerindexjs010_renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = { decodeEntities: opts.decodeEntities, xmlMode: true };

  var tag = '<' + elem.name,
      attribs = _domserializerindexjs010_formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += _domserializerindexjs010_render(elem.children, opts);
    }

    if (!_domserializerindexjs010_singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function _domserializerindexjs010_renderDirective(elem) {
  return '<' + elem.data + '>';
}

function _domserializerindexjs010_renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in _domserializerindexjs010_unencodedElements)) {
    data = _domserializerindexjs010_entities.encodeXML(data);
  }

  return data;
}

function _domserializerindexjs010_renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function _domserializerindexjs010_renderComment(elem) {
  return '<!--' + elem.data + '-->';
}
/*≠≠ node_modules/dom-serializer/index.js ≠≠*/

/*== node_modules/htmlparser2/lib/Tokenizer.js ==*/
$m['htmlparser2/lib/Tokenizer.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports = _htmlparser2libTokenizerjs391_Tokenizer;

var _htmlparser2libTokenizerjs391_decodeCodePoint = $m['entities/lib/decode_codepoint.js#1.1.1'].exports,
    _htmlparser2libTokenizerjs391_entityMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" },
    _htmlparser2libTokenizerjs391_legacyMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "AElig": "\u00C6", "aelig": "\u00E6", "Agrave": "\u00C0", "agrave": "\u00E0", "amp": "&", "AMP": "&", "Aring": "\u00C5", "aring": "\u00E5", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "brvbar": "\u00A6", "Ccedil": "\u00C7", "ccedil": "\u00E7", "cedil": "\u00B8", "cent": "\u00A2", "copy": "\u00A9", "COPY": "\u00A9", "curren": "\u00A4", "deg": "\u00B0", "divide": "\u00F7", "Eacute": "\u00C9", "eacute": "\u00E9", "Ecirc": "\u00CA", "ecirc": "\u00EA", "Egrave": "\u00C8", "egrave": "\u00E8", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "frac12": "\u00BD", "frac14": "\u00BC", "frac34": "\u00BE", "gt": ">", "GT": ">", "Iacute": "\u00CD", "iacute": "\u00ED", "Icirc": "\u00CE", "icirc": "\u00EE", "iexcl": "\u00A1", "Igrave": "\u00CC", "igrave": "\u00EC", "iquest": "\u00BF", "Iuml": "\u00CF", "iuml": "\u00EF", "laquo": "\u00AB", "lt": "<", "LT": "<", "macr": "\u00AF", "micro": "\u00B5", "middot": "\u00B7", "nbsp": "\u00A0", "not": "\u00AC", "Ntilde": "\u00D1", "ntilde": "\u00F1", "Oacute": "\u00D3", "oacute": "\u00F3", "Ocirc": "\u00D4", "ocirc": "\u00F4", "Ograve": "\u00D2", "ograve": "\u00F2", "ordf": "\u00AA", "ordm": "\u00BA", "Oslash": "\u00D8", "oslash": "\u00F8", "Otilde": "\u00D5", "otilde": "\u00F5", "Ouml": "\u00D6", "ouml": "\u00F6", "para": "\u00B6", "plusmn": "\u00B1", "pound": "\u00A3", "quot": "\"", "QUOT": "\"", "raquo": "\u00BB", "reg": "\u00AE", "REG": "\u00AE", "sect": "\u00A7", "shy": "\u00AD", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "szlig": "\u00DF", "THORN": "\u00DE", "thorn": "\u00FE", "times": "\u00D7", "Uacute": "\u00DA", "uacute": "\u00FA", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uml": "\u00A8", "Uuml": "\u00DC", "uuml": "\u00FC", "Yacute": "\u00DD", "yacute": "\u00FD", "yen": "\u00A5", "yuml": "\u00FF" },
    _htmlparser2libTokenizerjs391_xmlMap = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" },
    _htmlparser2libTokenizerjs391_i = 0,
    _htmlparser2libTokenizerjs391_TEXT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    //after <
_htmlparser2libTokenizerjs391_IN_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,


//attributes
_htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ = _htmlparser2libTokenizerjs391_i++,
    // "
_htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ = _htmlparser2libTokenizerjs391_i++,
    // '
_htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ = _htmlparser2libTokenizerjs391_i++,


//declarations
_htmlparser2libTokenizerjs391_BEFORE_DECLARATION = _htmlparser2libTokenizerjs391_i++,
    // !
_htmlparser2libTokenizerjs391_IN_DECLARATION = _htmlparser2libTokenizerjs391_i++,


//processing instructions
_htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION = _htmlparser2libTokenizerjs391_i++,
    // ?

//comments
_htmlparser2libTokenizerjs391_BEFORE_COMMENT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_COMMENT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_COMMENT_1 = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_COMMENT_2 = _htmlparser2libTokenizerjs391_i++,


//cdata
_htmlparser2libTokenizerjs391_BEFORE_CDATA_1 = _htmlparser2libTokenizerjs391_i++,
    // [
_htmlparser2libTokenizerjs391_BEFORE_CDATA_2 = _htmlparser2libTokenizerjs391_i++,
    // C
_htmlparser2libTokenizerjs391_BEFORE_CDATA_3 = _htmlparser2libTokenizerjs391_i++,
    // D
_htmlparser2libTokenizerjs391_BEFORE_CDATA_4 = _htmlparser2libTokenizerjs391_i++,
    // A
_htmlparser2libTokenizerjs391_BEFORE_CDATA_5 = _htmlparser2libTokenizerjs391_i++,
    // T
_htmlparser2libTokenizerjs391_BEFORE_CDATA_6 = _htmlparser2libTokenizerjs391_i++,
    // A
_htmlparser2libTokenizerjs391_IN_CDATA = _htmlparser2libTokenizerjs391_i++,
    // [
_htmlparser2libTokenizerjs391_AFTER_CDATA_1 = _htmlparser2libTokenizerjs391_i++,
    // ]
_htmlparser2libTokenizerjs391_AFTER_CDATA_2 = _htmlparser2libTokenizerjs391_i++,
    // ]

//special tags
_htmlparser2libTokenizerjs391_BEFORE_SPECIAL = _htmlparser2libTokenizerjs391_i++,
    //S
_htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END = _htmlparser2libTokenizerjs391_i++,
    //S

_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1 = _htmlparser2libTokenizerjs391_i++,
    //C
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2 = _htmlparser2libTokenizerjs391_i++,
    //R
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3 = _htmlparser2libTokenizerjs391_i++,
    //I
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4 = _htmlparser2libTokenizerjs391_i++,
    //P
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_1 = _htmlparser2libTokenizerjs391_i++,
    //C
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_2 = _htmlparser2libTokenizerjs391_i++,
    //R
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_3 = _htmlparser2libTokenizerjs391_i++,
    //I
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_4 = _htmlparser2libTokenizerjs391_i++,
    //P
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_5 = _htmlparser2libTokenizerjs391_i++,
    //T

_htmlparser2libTokenizerjs391_BEFORE_STYLE_1 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_BEFORE_STYLE_2 = _htmlparser2libTokenizerjs391_i++,
    //Y
_htmlparser2libTokenizerjs391_BEFORE_STYLE_3 = _htmlparser2libTokenizerjs391_i++,
    //L
_htmlparser2libTokenizerjs391_BEFORE_STYLE_4 = _htmlparser2libTokenizerjs391_i++,
    //E
_htmlparser2libTokenizerjs391_AFTER_STYLE_1 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_AFTER_STYLE_2 = _htmlparser2libTokenizerjs391_i++,
    //Y
_htmlparser2libTokenizerjs391_AFTER_STYLE_3 = _htmlparser2libTokenizerjs391_i++,
    //L
_htmlparser2libTokenizerjs391_AFTER_STYLE_4 = _htmlparser2libTokenizerjs391_i++,
    //E

_htmlparser2libTokenizerjs391_BEFORE_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //&
_htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //#
_htmlparser2libTokenizerjs391_IN_NAMED_ENTITY = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_HEX_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //X

_htmlparser2libTokenizerjs391_j = 0,
    _htmlparser2libTokenizerjs391_SPECIAL_NONE = _htmlparser2libTokenizerjs391_j++,
    _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT = _htmlparser2libTokenizerjs391_j++,
    _htmlparser2libTokenizerjs391_SPECIAL_STYLE = _htmlparser2libTokenizerjs391_j++;

function _htmlparser2libTokenizerjs391_whitespace(c) {
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function _htmlparser2libTokenizerjs391_characterState(char, SUCCESS) {
	return function (c) {
		if (c === char) this._state = SUCCESS;
	};
}

function _htmlparser2libTokenizerjs391_ifElseState(upper, SUCCESS, FAILURE) {
	var lower = upper.toLowerCase();

	if (upper === lower) {
		return function (c) {
			if (c === lower) {
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function (c) {
			if (c === lower || c === upper) {
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function _htmlparser2libTokenizerjs391_consumeSpecialNameChar(upper, NEXT_STATE) {
	var lower = upper.toLowerCase();

	return function (c) {
		if (c === lower || c === upper) {
			this._state = NEXT_STATE;
		} else {
			this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function _htmlparser2libTokenizerjs391_Tokenizer(options, cbs) {
	this._state = _htmlparser2libTokenizerjs391_TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = _htmlparser2libTokenizerjs391_TEXT;
	this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateText = function (c) {
	if (c === "<") {
		if (this._index > this._sectionStart) {
			this._cbs.ontext(this._getSection());
		}
		this._state = _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if (this._decodeEntities && this._special === _htmlparser2libTokenizerjs391_SPECIAL_NONE && c === "&") {
		if (this._index > this._sectionStart) {
			this._cbs.ontext(this._getSection());
		}
		this._baseState = _htmlparser2libTokenizerjs391_TEXT;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeTagName = function (c) {
	if (c === "/") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME;
	} else if (c === "<") {
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if (c === ">" || this._special !== _htmlparser2libTokenizerjs391_SPECIAL_NONE || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
	} else if (c === "!") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if (c === "?") {
		this._state = _htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = !this._xmlMode && (c === "s" || c === "S") ? _htmlparser2libTokenizerjs391_BEFORE_SPECIAL : _htmlparser2libTokenizerjs391_IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInTagName = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._emitToken("onopentagname");
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCloseingTagName = function (c) {
	if (_htmlparser2libTokenizerjs391_whitespace(c)) ;else if (c === ">") {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
	} else if (this._special !== _htmlparser2libTokenizerjs391_SPECIAL_NONE) {
		if (c === "s" || c === "S") {
			this._state = _htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END;
		} else {
			this._state = _htmlparser2libTokenizerjs391_TEXT;
			this._index--;
		}
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInCloseingTagName = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._emitToken("onclosetag");
		this._state = _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCloseingTagName = function (c) {
	//skip everything until ">"
	if (c === ">") {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeAttributeName = function (c) {
	if (c === ">") {
		this._cbs.onopentagend();
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c === "/") {
		this._state = _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInSelfClosingTag = function (c) {
	if (c === ">") {
		this._cbs.onselfclosingtag();
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeName = function (c) {
	if (c === "=" || c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterAttributeName = function (c) {
	if (c === "=") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE;
	} else if (c === "/" || c === ">") {
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeAttributeValue = function (c) {
	if (c === "\"") {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if (c === "'") {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {
	if (c === "\"") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {
	if (c === "'") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {
	if (_htmlparser2libTokenizerjs391_whitespace(c) || c === ">") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeDeclaration = function (c) {
	this._state = c === "[" ? _htmlparser2libTokenizerjs391_BEFORE_CDATA_1 : c === "-" ? _htmlparser2libTokenizerjs391_BEFORE_COMMENT : _htmlparser2libTokenizerjs391_IN_DECLARATION;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInDeclaration = function (c) {
	if (c === ">") {
		this._cbs.ondeclaration(this._getSection());
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInProcessingInstruction = function (c) {
	if (c === ">") {
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeComment = function (c) {
	if (c === "-") {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_DECLARATION;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInComment = function (c) {
	if (c === "-") this._state = _htmlparser2libTokenizerjs391_AFTER_COMMENT_1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterComment1 = function (c) {
	if (c === "-") {
		this._state = _htmlparser2libTokenizerjs391_AFTER_COMMENT_2;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterComment2 = function (c) {
	if (c === ">") {
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c !== "-") {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata1 = _htmlparser2libTokenizerjs391_ifElseState("C", _htmlparser2libTokenizerjs391_BEFORE_CDATA_2, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata2 = _htmlparser2libTokenizerjs391_ifElseState("D", _htmlparser2libTokenizerjs391_BEFORE_CDATA_3, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata3 = _htmlparser2libTokenizerjs391_ifElseState("A", _htmlparser2libTokenizerjs391_BEFORE_CDATA_4, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata4 = _htmlparser2libTokenizerjs391_ifElseState("T", _htmlparser2libTokenizerjs391_BEFORE_CDATA_5, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata5 = _htmlparser2libTokenizerjs391_ifElseState("A", _htmlparser2libTokenizerjs391_BEFORE_CDATA_6, _htmlparser2libTokenizerjs391_IN_DECLARATION);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata6 = function (c) {
	if (c === "[") {
		this._state = _htmlparser2libTokenizerjs391_IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_DECLARATION;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInCdata = function (c) {
	if (c === "]") this._state = _htmlparser2libTokenizerjs391_AFTER_CDATA_1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCdata1 = _htmlparser2libTokenizerjs391_characterState("]", _htmlparser2libTokenizerjs391_AFTER_CDATA_2);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCdata2 = function (c) {
	if (c === ">") {
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c !== "]") {
		this._state = _htmlparser2libTokenizerjs391_IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeSpecial = function (c) {
	if (c === "c" || c === "C") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1;
	} else if (c === "t" || c === "T") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_STYLE_1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
	if (this._special === _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT && (c === "c" || c === "C")) {
		this._state = _htmlparser2libTokenizerjs391_AFTER_SCRIPT_1;
	} else if (this._special === _htmlparser2libTokenizerjs391_SPECIAL_STYLE && (c === "t" || c === "T")) {
		this._state = _htmlparser2libTokenizerjs391_AFTER_STYLE_1;
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript1 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("R", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript2 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("I", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript3 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("P", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript4 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("T", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript5 = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT;
	}
	this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
	this._index--; //consume the token again
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript1 = _htmlparser2libTokenizerjs391_ifElseState("R", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_2, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript2 = _htmlparser2libTokenizerjs391_ifElseState("I", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_3, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript3 = _htmlparser2libTokenizerjs391_ifElseState("P", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_4, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript4 = _htmlparser2libTokenizerjs391_ifElseState("T", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_5, _htmlparser2libTokenizerjs391_TEXT);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript5 = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle1 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("Y", _htmlparser2libTokenizerjs391_BEFORE_STYLE_2);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle2 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("L", _htmlparser2libTokenizerjs391_BEFORE_STYLE_3);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle3 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("E", _htmlparser2libTokenizerjs391_BEFORE_STYLE_4);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle4 = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_STYLE;
	}
	this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
	this._index--; //consume the token again
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle1 = _htmlparser2libTokenizerjs391_ifElseState("Y", _htmlparser2libTokenizerjs391_AFTER_STYLE_2, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle2 = _htmlparser2libTokenizerjs391_ifElseState("L", _htmlparser2libTokenizerjs391_AFTER_STYLE_3, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle3 = _htmlparser2libTokenizerjs391_ifElseState("E", _htmlparser2libTokenizerjs391_AFTER_STYLE_4, _htmlparser2libTokenizerjs391_TEXT);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle4 = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeEntity = _htmlparser2libTokenizerjs391_ifElseState("#", _htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY, _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeNumericEntity = _htmlparser2libTokenizerjs391_ifElseState("X", _htmlparser2libTokenizerjs391_IN_HEX_ENTITY, _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
_htmlparser2libTokenizerjs391_Tokenizer.prototype._parseNamedEntityStrict = function () {
	//offset = 1
	if (this._sectionStart + 1 < this._index) {
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? _htmlparser2libTokenizerjs391_xmlMap : _htmlparser2libTokenizerjs391_entityMap;

		if (map.hasOwnProperty(entity)) {
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};

//parses legacy entities (without trailing semicolon)
_htmlparser2libTokenizerjs391_Tokenizer.prototype._parseLegacyEntity = function () {
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if (limit > 6) limit = 6; //the max length of legacy entities is 6

	while (limit >= 2) {
		//the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if (_htmlparser2libTokenizerjs391_legacyMap.hasOwnProperty(entity)) {
			this._emitPartial(_htmlparser2libTokenizerjs391_legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInNamedEntity = function (c) {
	if (c === ";") {
		this._parseNamedEntityStrict();
		if (this._sectionStart + 1 < this._index && !this._xmlMode) {
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
		if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== _htmlparser2libTokenizerjs391_TEXT) {
			if (c !== "=") {
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
	var sectionStart = this._sectionStart + offset;

	if (sectionStart !== this._index) {
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(_htmlparser2libTokenizerjs391_decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInNumericEntity = function (c) {
	if (c === ";") {
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if (c < "0" || c > "9") {
		if (!this._xmlMode) {
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInHexEntity = function (c) {
	if (c === ";") {
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
		if (!this._xmlMode) {
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._cleanup = function () {
	if (this._sectionStart < 0) {
		this._buffer = "";
		this._index = 0;
		this._bufferOffset += this._index;
	} else if (this._running) {
		if (this._state === _htmlparser2libTokenizerjs391_TEXT) {
			if (this._sectionStart !== this._index) {
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if (this._sectionStart === this._index) {
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
_htmlparser2libTokenizerjs391_Tokenizer.prototype.write = function (chunk) {
	if (this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._parse = function () {
	while (this._index < this._buffer.length && this._running) {
		var c = this._buffer.charAt(this._index);
		if (this._state === _htmlparser2libTokenizerjs391_TEXT) {
			this._stateText(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME) {
			this._stateBeforeTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME) {
			this._stateBeforeCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME) {
			this._stateInCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME) {
			this._stateAfterCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG) {
			this._stateInSelfClosingTag(c);
		}

		/*
  *	attributes
  */
		else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME) {
				this._stateBeforeAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME) {
				this._stateInAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME) {
				this._stateAfterAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE) {
				this._stateBeforeAttributeValue(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ) {
				this._stateInAttributeValueDoubleQuotes(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ) {
				this._stateInAttributeValueSingleQuotes(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ) {
				this._stateInAttributeValueNoQuotes(c);
			}

			/*
   *	declarations
   */
			else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_DECLARATION) {
					this._stateBeforeDeclaration(c);
				} else if (this._state === _htmlparser2libTokenizerjs391_IN_DECLARATION) {
					this._stateInDeclaration(c);
				}

				/*
    *	processing instructions
    */
				else if (this._state === _htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION) {
						this._stateInProcessingInstruction(c);
					}

					/*
     *	comments
     */
					else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_COMMENT) {
							this._stateBeforeComment(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_IN_COMMENT) {
							this._stateInComment(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_1) {
							this._stateAfterComment1(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_2) {
							this._stateAfterComment2(c);
						}

						/*
      *	cdata
      */
						else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_1) {
								this._stateBeforeCdata1(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_2) {
								this._stateBeforeCdata2(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_3) {
								this._stateBeforeCdata3(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_4) {
								this._stateBeforeCdata4(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_5) {
								this._stateBeforeCdata5(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_6) {
								this._stateBeforeCdata6(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_IN_CDATA) {
								this._stateInCdata(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_1) {
								this._stateAfterCdata1(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_2) {
								this._stateAfterCdata2(c);
							}

							/*
       * special tags
       */
							else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SPECIAL) {
									this._stateBeforeSpecial(c);
								} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END) {
									this._stateBeforeSpecialEnd(c);
								}

								/*
        * script
        */
								else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1) {
										this._stateBeforeScript1(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2) {
										this._stateBeforeScript2(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3) {
										this._stateBeforeScript3(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4) {
										this._stateBeforeScript4(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5) {
										this._stateBeforeScript5(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_1) {
										this._stateAfterScript1(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_2) {
										this._stateAfterScript2(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_3) {
										this._stateAfterScript3(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_4) {
										this._stateAfterScript4(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_5) {
										this._stateAfterScript5(c);
									}

									/*
         * style
         */
									else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_1) {
											this._stateBeforeStyle1(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_2) {
											this._stateBeforeStyle2(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_3) {
											this._stateBeforeStyle3(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_4) {
											this._stateBeforeStyle4(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_1) {
											this._stateAfterStyle1(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_2) {
											this._stateAfterStyle2(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_3) {
											this._stateAfterStyle3(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_4) {
											this._stateAfterStyle4(c);
										}

										/*
          * entities
          */
										else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ENTITY) {
												this._stateBeforeEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY) {
												this._stateBeforeNumericEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY) {
												this._stateInNamedEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY) {
												this._stateInNumericEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_HEX_ENTITY) {
												this._stateInHexEntity(c);
											} else {
												this._cbs.onerror(Error("unknown _state"), this._state);
											}

		this._index++;
	}

	this._cleanup();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.pause = function () {
	this._running = false;
};
_htmlparser2libTokenizerjs391_Tokenizer.prototype.resume = function () {
	this._running = true;

	if (this._index < this._buffer.length) {
		this._parse();
	}
	if (this._ended) {
		this._finish();
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.end = function (chunk) {
	if (this._ended) this._cbs.onerror(Error(".end() after done!"));
	if (chunk) this.write(chunk);

	this._ended = true;

	if (this._running) this._finish();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._finish = function () {
	//if there is remaining data, emit it in a reasonable way
	if (this._sectionStart < this._index) {
		this._handleTrailingData();
	}

	this._cbs.onend();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._handleTrailingData = function () {
	var data = this._buffer.substr(this._sectionStart);

	if (this._state === _htmlparser2libTokenizerjs391_IN_CDATA || this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_1 || this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_2) {
		this._cbs.oncdata(data);
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_COMMENT || this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_1 || this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_2) {
		this._cbs.oncomment(data);
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY && !this._xmlMode) {
		this._parseLegacyEntity();
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY && !this._xmlMode) {
		this._decodeNumericEntity(2, 10);
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_HEX_ENTITY && !this._xmlMode) {
		this._decodeNumericEntity(3, 16);
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state !== _htmlparser2libTokenizerjs391_IN_TAG_NAME && this._state !== _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE && this._state !== _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ && this._state !== _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME) {
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.reset = function () {
	_htmlparser2libTokenizerjs391_Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.getAbsoluteIndex = function () {
	return this._bufferOffset + this._index;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._getSection = function () {
	return this._buffer.substring(this._sectionStart, this._index);
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._emitToken = function (name) {
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._emitPartial = function (value) {
	if (this._baseState !== _htmlparser2libTokenizerjs391_TEXT) {
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};
/*≠≠ node_modules/htmlparser2/lib/Tokenizer.js ≠≠*/

/*== node_modules/htmlparser2/lib/Parser.js ==*/
$m['htmlparser2/lib/Parser.js#3.9.1'] = { exports: {} };
var _htmlparser2libParserjs391_Tokenizer = $m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports;

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var _htmlparser2libParserjs391_formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var _htmlparser2libParserjs391_openImpliesClose = {
	tr: { tr: true, th: true, td: true },
	th: { th: true },
	td: { thead: true, th: true, td: true },
	body: { head: true, link: true, script: true },
	li: { li: true },
	p: { p: true },
	h1: { p: true },
	h2: { p: true },
	h3: { p: true },
	h4: { p: true },
	h5: { p: true },
	h6: { p: true },
	select: _htmlparser2libParserjs391_formTags,
	input: _htmlparser2libParserjs391_formTags,
	output: _htmlparser2libParserjs391_formTags,
	button: _htmlparser2libParserjs391_formTags,
	datalist: _htmlparser2libParserjs391_formTags,
	textarea: _htmlparser2libParserjs391_formTags,
	option: { option: true },
	optgroup: { optgroup: true }
};

var _htmlparser2libParserjs391_voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var _htmlparser2libParserjs391_re_nameEnd = /\s|\//;

function _htmlparser2libParserjs391_Parser(cbs, options) {
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;

	if (this._options.Tokenizer) {
		_htmlparser2libParserjs391_Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new _htmlparser2libParserjs391_Tokenizer(this._options, this);

	if (this._cbs.onparserinit) this._cbs.onparserinit(this);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libParserjs391_Parser, require("events").EventEmitter);

_htmlparser2libParserjs391_Parser.prototype._updatePosition = function (initialOffset) {
	if (this.endIndex === null) {
		if (this._tokenizer._sectionStart <= initialOffset) {
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	} else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
_htmlparser2libParserjs391_Parser.prototype.ontext = function (data) {
	this._updatePosition(1);
	this.endIndex--;

	if (this._cbs.ontext) this._cbs.ontext(data);
};

_htmlparser2libParserjs391_Parser.prototype.onopentagname = function (name) {
	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	this._tagname = name;

	if (!this._options.xmlMode && name in _htmlparser2libParserjs391_openImpliesClose) {
		for (var el; (el = this._stack[this._stack.length - 1]) in _htmlparser2libParserjs391_openImpliesClose[name]; this.onclosetag(el));
	}

	if (this._options.xmlMode || !(name in _htmlparser2libParserjs391_voidElements)) {
		this._stack.push(name);
	}

	if (this._cbs.onopentagname) this._cbs.onopentagname(name);
	if (this._cbs.onopentag) this._attribs = {};
};

_htmlparser2libParserjs391_Parser.prototype.onopentagend = function () {
	this._updatePosition(1);

	if (this._attribs) {
		if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in _htmlparser2libParserjs391_voidElements) {
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

_htmlparser2libParserjs391_Parser.prototype.onclosetag = function (name) {
	this._updatePosition(1);

	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	if (this._stack.length && (!(name in _htmlparser2libParserjs391_voidElements) || this._options.xmlMode)) {
		var pos = this._stack.lastIndexOf(name);
		if (pos !== -1) {
			if (this._cbs.onclosetag) {
				pos = this._stack.length - pos;
				while (pos--) this._cbs.onclosetag(this._stack.pop());
			} else this._stack.length = pos;
		} else if (name === "p" && !this._options.xmlMode) {
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if (!this._options.xmlMode && (name === "br" || name === "p")) {
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

_htmlparser2libParserjs391_Parser.prototype.onselfclosingtag = function () {
	if (this._options.xmlMode || this._options.recognizeSelfClosing) {
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

_htmlparser2libParserjs391_Parser.prototype._closeCurrentTag = function () {
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if (this._stack[this._stack.length - 1] === name) {
		if (this._cbs.onclosetag) {
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

_htmlparser2libParserjs391_Parser.prototype.onattribname = function (name) {
	if (this._lowerCaseAttributeNames) {
		name = name.toLowerCase();
	}
	this._attribname = name;
};

_htmlparser2libParserjs391_Parser.prototype.onattribdata = function (value) {
	this._attribvalue += value;
};

_htmlparser2libParserjs391_Parser.prototype.onattribend = function () {
	if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

_htmlparser2libParserjs391_Parser.prototype._getInstructionName = function (value) {
	var idx = value.search(_htmlparser2libParserjs391_re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	return name;
};

_htmlparser2libParserjs391_Parser.prototype.ondeclaration = function (value) {
	if (this._cbs.onprocessinginstruction) {
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

_htmlparser2libParserjs391_Parser.prototype.onprocessinginstruction = function (value) {
	if (this._cbs.onprocessinginstruction) {
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

_htmlparser2libParserjs391_Parser.prototype.oncomment = function (value) {
	this._updatePosition(4);

	if (this._cbs.oncomment) this._cbs.oncomment(value);
	if (this._cbs.oncommentend) this._cbs.oncommentend();
};

_htmlparser2libParserjs391_Parser.prototype.oncdata = function (value) {
	this._updatePosition(1);

	if (this._options.xmlMode || this._options.recognizeCDATA) {
		if (this._cbs.oncdatastart) this._cbs.oncdatastart();
		if (this._cbs.ontext) this._cbs.ontext(value);
		if (this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

_htmlparser2libParserjs391_Parser.prototype.onerror = function (err) {
	if (this._cbs.onerror) this._cbs.onerror(err);
};

_htmlparser2libParserjs391_Parser.prototype.onend = function () {
	if (this._cbs.onclosetag) {
		for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));
	}
	if (this._cbs.onend) this._cbs.onend();
};

//Resets the parser to a blank state, ready to parse a new HTML document
_htmlparser2libParserjs391_Parser.prototype.reset = function () {
	if (this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if (this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
_htmlparser2libParserjs391_Parser.prototype.parseComplete = function (data) {
	this.reset();
	this.end(data);
};

_htmlparser2libParserjs391_Parser.prototype.write = function (chunk) {
	this._tokenizer.write(chunk);
};

_htmlparser2libParserjs391_Parser.prototype.end = function (chunk) {
	this._tokenizer.end(chunk);
};

_htmlparser2libParserjs391_Parser.prototype.pause = function () {
	this._tokenizer.pause();
};

_htmlparser2libParserjs391_Parser.prototype.resume = function () {
	this._tokenizer.resume();
};

//alias for backwards compat
_htmlparser2libParserjs391_Parser.prototype.parseChunk = _htmlparser2libParserjs391_Parser.prototype.write;
_htmlparser2libParserjs391_Parser.prototype.done = _htmlparser2libParserjs391_Parser.prototype.end;

$m['htmlparser2/lib/Parser.js#3.9.1'].exports = _htmlparser2libParserjs391_Parser;
/*≠≠ node_modules/htmlparser2/lib/Parser.js ≠≠*/

/*== node_modules/lodash/_memoizeCapped.js ==*/
$m['lodash/_memoizeCapped.js#4.16.2'] = { exports: {} };
var _lodashmemoizeCappedjs4162_memoize = $m['lodash/memoize.js#4.16.2'].exports;

/** Used as the maximum memoize cache size. */
var _lodashmemoizeCappedjs4162_MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function _lodashmemoizeCappedjs4162_memoizeCapped(func) {
  var result = _lodashmemoizeCappedjs4162_memoize(func, function (key) {
    if (cache.size === _lodashmemoizeCappedjs4162_MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

$m['lodash/_memoizeCapped.js#4.16.2'].exports = _lodashmemoizeCappedjs4162_memoizeCapped;
/*≠≠ node_modules/lodash/_memoizeCapped.js ≠≠*/

/*== node_modules/lodash/_nodeUtil.js ==*/
$m['lodash/_nodeUtil.js#4.16.2'] = { exports: {} };
var _lodashnodeUtiljs4162_freeGlobal = $m['lodash/_freeGlobal.js#4.16.2'].exports;

/** Detect free variable `exports`. */
var _lodashnodeUtiljs4162_freeExports = typeof $m['lodash/_nodeUtil.js#4.16.2'].exports == 'object' && $m['lodash/_nodeUtil.js#4.16.2'].exports && !$m['lodash/_nodeUtil.js#4.16.2'].exports.nodeType && $m['lodash/_nodeUtil.js#4.16.2'].exports;

/** Detect free variable `module`. */
var _lodashnodeUtiljs4162_freeModule = _lodashnodeUtiljs4162_freeExports && typeof $m['lodash/_nodeUtil.js#4.16.2'] == 'object' && $m['lodash/_nodeUtil.js#4.16.2'] && !$m['lodash/_nodeUtil.js#4.16.2'].nodeType && $m['lodash/_nodeUtil.js#4.16.2'];

/** Detect the popular CommonJS extension `module.exports`. */
var _lodashnodeUtiljs4162_moduleExports = _lodashnodeUtiljs4162_freeModule && _lodashnodeUtiljs4162_freeModule.exports === _lodashnodeUtiljs4162_freeExports;

/** Detect free variable `process` from Node.js. */
var _lodashnodeUtiljs4162_freeProcess = _lodashnodeUtiljs4162_moduleExports && _lodashnodeUtiljs4162_freeGlobal.process;

/** Used to access faster Node.js helpers. */
var _lodashnodeUtiljs4162_nodeUtil = function () {
  try {
    return _lodashnodeUtiljs4162_freeProcess && _lodashnodeUtiljs4162_freeProcess.binding('util');
  } catch (e) {}
}();

$m['lodash/_nodeUtil.js#4.16.2'].exports = _lodashnodeUtiljs4162_nodeUtil;
/*≠≠ node_modules/lodash/_nodeUtil.js ≠≠*/

/*== node_modules/lodash/_arrayLikeKeys.js ==*/
$m['lodash/_arrayLikeKeys.js#4.16.2'] = { exports: {} };
var _lodasharrayLikeKeysjs4162_baseTimes = $m['lodash/_baseTimes.js#4.16.2'].exports,
    _lodasharrayLikeKeysjs4162_isArguments = $m['lodash/isArguments.js#4.16.2'].exports,
    _lodasharrayLikeKeysjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodasharrayLikeKeysjs4162_isIndex = $m['lodash/_isIndex.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodasharrayLikeKeysjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodasharrayLikeKeysjs4162_hasOwnProperty = _lodasharrayLikeKeysjs4162_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function _lodasharrayLikeKeysjs4162_arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = _lodasharrayLikeKeysjs4162_isArray(value) || _lodasharrayLikeKeysjs4162_isArguments(value) ? _lodasharrayLikeKeysjs4162_baseTimes(value.length, String) : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || _lodasharrayLikeKeysjs4162_hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || _lodasharrayLikeKeysjs4162_isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_arrayLikeKeys.js#4.16.2'].exports = _lodasharrayLikeKeysjs4162_arrayLikeKeys;
/*≠≠ node_modules/lodash/_arrayLikeKeys.js ≠≠*/

/*== node_modules/lodash/keysIn.js ==*/
$m['lodash/keysIn.js#4.16.2'] = { exports: {} };
var _lodashkeysInjs4162_arrayLikeKeys = $m['lodash/_arrayLikeKeys.js#4.16.2'].exports,
    _lodashkeysInjs4162_baseKeysIn = $m['lodash/_baseKeysIn.js#4.16.2'].exports,
    _lodashkeysInjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function _lodashkeysInjs4162_keysIn(object) {
  return _lodashkeysInjs4162_isArrayLike(object) ? _lodashkeysInjs4162_arrayLikeKeys(object, true) : _lodashkeysInjs4162_baseKeysIn(object);
}

$m['lodash/keysIn.js#4.16.2'].exports = _lodashkeysInjs4162_keysIn;
/*≠≠ node_modules/lodash/keysIn.js ≠≠*/

/*== node_modules/lodash/_root.js ==*/
$m['lodash/_root.js#4.16.2'] = { exports: {} };
var _lodashrootjs4162_freeGlobal = $m['lodash/_freeGlobal.js#4.16.2'].exports;

/** Detect free variable `self`. */
var _lodashrootjs4162_freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var _lodashrootjs4162_root = _lodashrootjs4162_freeGlobal || _lodashrootjs4162_freeSelf || Function('return this')();

$m['lodash/_root.js#4.16.2'].exports = _lodashrootjs4162_root;
/*≠≠ node_modules/lodash/_root.js ≠≠*/

/*== node_modules/lodash/_baseIsNative.js ==*/
$m['lodash/_baseIsNative.js#4.16.2'] = { exports: {} };
var _lodashbaseIsNativejs4162_isFunction = $m['lodash/isFunction.js#4.16.2'].exports,
    _lodashbaseIsNativejs4162_isMasked = $m['lodash/_isMasked.js#4.16.2'].exports,
    _lodashbaseIsNativejs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseIsNativejs4162_toSource = $m['lodash/_toSource.js#4.16.2'].exports;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var _lodashbaseIsNativejs4162_reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var _lodashbaseIsNativejs4162_reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _lodashbaseIsNativejs4162_funcProto = Function.prototype,
    _lodashbaseIsNativejs4162_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashbaseIsNativejs4162_funcToString = _lodashbaseIsNativejs4162_funcProto.toString;

/** Used to check objects for own properties. */
var _lodashbaseIsNativejs4162_hasOwnProperty = _lodashbaseIsNativejs4162_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var _lodashbaseIsNativejs4162_reIsNative = RegExp('^' + _lodashbaseIsNativejs4162_funcToString.call(_lodashbaseIsNativejs4162_hasOwnProperty).replace(_lodashbaseIsNativejs4162_reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function _lodashbaseIsNativejs4162_baseIsNative(value) {
  if (!_lodashbaseIsNativejs4162_isObject(value) || _lodashbaseIsNativejs4162_isMasked(value)) {
    return false;
  }
  var pattern = _lodashbaseIsNativejs4162_isFunction(value) ? _lodashbaseIsNativejs4162_reIsNative : _lodashbaseIsNativejs4162_reIsHostCtor;
  return pattern.test(_lodashbaseIsNativejs4162_toSource(value));
}

$m['lodash/_baseIsNative.js#4.16.2'].exports = _lodashbaseIsNativejs4162_baseIsNative;
/*≠≠ node_modules/lodash/_baseIsNative.js ≠≠*/

/*== node_modules/lodash/_getNative.js ==*/
$m['lodash/_getNative.js#4.16.2'] = { exports: {} };
var _lodashgetNativejs4162_baseIsNative = $m['lodash/_baseIsNative.js#4.16.2'].exports,
    _lodashgetNativejs4162_getValue = $m['lodash/_getValue.js#4.16.2'].exports;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function _lodashgetNativejs4162_getNative(object, key) {
  var value = _lodashgetNativejs4162_getValue(object, key);
  return _lodashgetNativejs4162_baseIsNative(value) ? value : undefined;
}

$m['lodash/_getNative.js#4.16.2'].exports = _lodashgetNativejs4162_getNative;
/*≠≠ node_modules/lodash/_getNative.js ≠≠*/

/*== node_modules/debug/node.js ==*/
$m['debug/node.js#2.2.0'] = { exports: {} };

/**
 * Module dependencies.
 */

var _debugnodejs220_tty = require('tty');
var _debugnodejs220_util = require('util');

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

$m['debug/node.js#2.2.0'].exports = $m['debug/node.js#2.2.0'].exports = $m['debug/debug.js#2.2.0'].exports;
$m['debug/node.js#2.2.0'].exports.log = _debugnodejs220_log;
$m['debug/node.js#2.2.0'].exports.formatArgs = _debugnodejs220_formatArgs;
$m['debug/node.js#2.2.0'].exports.save = _debugnodejs220_save;
$m['debug/node.js#2.2.0'].exports.load = _debugnodejs220_load;
$m['debug/node.js#2.2.0'].exports.useColors = _debugnodejs220_useColors;

/**
 * Colors.
 */

$m['debug/node.js#2.2.0'].exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var _debugnodejs220_fd = parseInt(process.env.DEBUG_FD, 10) || 2;
var _debugnodejs220_stream = 1 === _debugnodejs220_fd ? process.stdout : 2 === _debugnodejs220_fd ? process.stderr : _debugnodejs220_createWritableStdioStream(_debugnodejs220_fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function _debugnodejs220_useColors() {
  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
  if (0 === debugColors.length) {
    return _debugnodejs220_tty.isatty(_debugnodejs220_fd);
  } else {
    return '0' !== debugColors && 'no' !== debugColors && 'false' !== debugColors && 'disabled' !== debugColors;
  }
}

/**
 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
 */

var _debugnodejs220_inspect = 4 === _debugnodejs220_util.inspect.length ?
// node <= 0.8.x
function (v, colors) {
  return _debugnodejs220_util.inspect(v, void 0, void 0, colors);
} :
// node > 0.8.x
function (v, colors) {
  return _debugnodejs220_util.inspect(v, { colors: colors });
};

$m['debug/node.js#2.2.0'].exports.formatters.o = function (v) {
  return _debugnodejs220_inspect(v, this.useColors).replace(/\s*\n\s*/g, ' ');
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function _debugnodejs220_formatArgs() {
  var args = arguments;
  var useColors = this.useColors;
  var name = this.namespace;

  if (useColors) {
    var c = this.color;

    args[0] = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m' + args[0] + '\u001b[3' + c + 'm' + ' +' + $m['debug/node.js#2.2.0'].exports.humanize(this.diff) + '\u001b[0m';
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
  return args;
}

/**
 * Invokes `console.error()` with the specified arguments.
 */

function _debugnodejs220_log() {
  return _debugnodejs220_stream.write(_debugnodejs220_util.format.apply(this, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function _debugnodejs220_save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function _debugnodejs220_load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function _debugnodejs220_createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new _debugnodejs220_tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = require('fs');
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require('net');
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

$m['debug/node.js#2.2.0'].exports.enable(_debugnodejs220_load());
/*≠≠ node_modules/debug/node.js ≠≠*/

/*== node_modules/babel-generator/lib/printer.js ==*/
$m['babel-generator/lib/printer.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/printer.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibprinterjs6160__assign = $m['babel-runtime/core-js/object/assign.js#6.11.6'].exports;

var _babelgeneratorlibprinterjs6160__assign2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__assign);

var _babelgeneratorlibprinterjs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelgeneratorlibprinterjs6160__getIterator3 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__getIterator2);

var _babelgeneratorlibprinterjs6160__stringify = $m['babel-runtime/core-js/json/stringify.js#6.11.6'].exports;

var _babelgeneratorlibprinterjs6160__stringify2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__stringify);

var _babelgeneratorlibprinterjs6160__weakSet = $m['babel-runtime/core-js/weak-set.js#6.11.6'].exports;

var _babelgeneratorlibprinterjs6160__weakSet2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__weakSet);

var _babelgeneratorlibprinterjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelgeneratorlibprinterjs6160__classCallCheck3 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__classCallCheck2);

var _babelgeneratorlibprinterjs6160__find = $m['lodash/find.js#4.16.2'].exports;

var _babelgeneratorlibprinterjs6160__find2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__find);

var _babelgeneratorlibprinterjs6160__findLast = $m['lodash/findLast.js#4.16.2'].exports;

var _babelgeneratorlibprinterjs6160__findLast2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__findLast);

var _babelgeneratorlibprinterjs6160__isInteger = $m['lodash/isInteger.js#4.16.2'].exports;

var _babelgeneratorlibprinterjs6160__isInteger2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__isInteger);

var _babelgeneratorlibprinterjs6160__repeat = $m['lodash/repeat.js#4.16.2'].exports;

var _babelgeneratorlibprinterjs6160__repeat2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__repeat);

var _babelgeneratorlibprinterjs6160__buffer = $m['babel-generator/lib/buffer.js#6.16.0'].exports;

var _babelgeneratorlibprinterjs6160__buffer2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__buffer);

var _babelgeneratorlibprinterjs6160__node = $m['babel-generator/lib/node/index.js#6.16.0'].exports;

var _babelgeneratorlibprinterjs6160_n = _babelgeneratorlibprinterjs6160__interopRequireWildcard(_babelgeneratorlibprinterjs6160__node);

var _babelgeneratorlibprinterjs6160__whitespace = $m['babel-generator/lib/whitespace.js#6.16.0'].exports;

var _babelgeneratorlibprinterjs6160__whitespace2 = _babelgeneratorlibprinterjs6160__interopRequireDefault(_babelgeneratorlibprinterjs6160__whitespace);

var _babelgeneratorlibprinterjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelgeneratorlibprinterjs6160_t = _babelgeneratorlibprinterjs6160__interopRequireWildcard(_babelgeneratorlibprinterjs6160__babelTypes);

function _babelgeneratorlibprinterjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibprinterjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelgeneratorlibprinterjs6160_SCIENTIFIC_NOTATION = /e/i;
var _babelgeneratorlibprinterjs6160_ZERO_DECIMAL_INTEGER = /\.0+$/;
var _babelgeneratorlibprinterjs6160_NON_DECIMAL_LITERAL = /^0[box]/;

var _babelgeneratorlibprinterjs6160_Printer = function () {
  function Printer(format, map, tokens) {
    (0, _babelgeneratorlibprinterjs6160__classCallCheck3.default)(this, Printer);
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new _babelgeneratorlibprinterjs6160__weakSet2.default();
    this._endsWithInteger = false;
    this._endsWithWord = false;

    this.format = format || {};
    this._buf = new _babelgeneratorlibprinterjs6160__buffer2.default(map);
    this._whitespace = tokens.length > 0 ? new _babelgeneratorlibprinterjs6160__whitespace2.default(tokens) : null;
  }

  Printer.prototype.generate = function generate(ast) {
    this.print(ast);
    this._maybeAddAuxComment();

    return this._buf.get();
  };

  Printer.prototype.indent = function indent() {
    if (this.format.compact || this.format.concise) return;

    this._indent++;
  };

  Printer.prototype.dedent = function dedent() {
    if (this.format.compact || this.format.concise) return;

    this._indent--;
  };

  Printer.prototype.semicolon = function semicolon() {
    var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

    this._maybeAddAuxComment();
    this._append(";", !force);
  };

  Printer.prototype.rightBrace = function rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }
    this.token("}");
  };

  Printer.prototype.space = function space() {
    var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

    if (this.format.compact) return;

    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
      this._space();
    }
  };

  Printer.prototype.word = function word(str) {
    if (this._endsWithWord) this._space();

    this._maybeAddAuxComment();
    this._append(str);

    this._endsWithWord = true;
  };

  Printer.prototype.number = function number(str) {
    this.word(str);

    this._endsWithInteger = (0, _babelgeneratorlibprinterjs6160__isInteger2.default)(+str) && !_babelgeneratorlibprinterjs6160_NON_DECIMAL_LITERAL.test(str) && !_babelgeneratorlibprinterjs6160_SCIENTIFIC_NOTATION.test(str) && !_babelgeneratorlibprinterjs6160_ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
  };

  Printer.prototype.token = function token(str) {
    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
      this._space();
    }

    this._maybeAddAuxComment();
    this._append(str);
  };

  Printer.prototype.newline = function newline(i) {
    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    if (this.endsWith("\n\n")) return;

    if (typeof i !== "number") i = 1;

    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;

    for (var j = 0; j < i; j++) {
      this._newline();
    }
  };

  Printer.prototype.endsWith = function endsWith(str) {
    return this._buf.endsWith(str);
  };

  Printer.prototype.removeTrailingNewline = function removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  };

  Printer.prototype.source = function source(prop, loc) {
    this._catchUp(prop, loc);

    this._buf.source(prop, loc);
  };

  Printer.prototype.withSource = function withSource(prop, loc, cb) {
    this._catchUp(prop, loc);

    this._buf.withSource(prop, loc, cb);
  };

  Printer.prototype._space = function _space() {
    this._append(" ", true);
  };

  Printer.prototype._newline = function _newline() {
    this._append("\n", true);
  };

  Printer.prototype._append = function _append(str) {
    var queue = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    this._maybeAddParen(str);
    this._maybeIndent(str);

    if (queue) this._buf.queue(str);else this._buf.append(str);

    this._endsWithWord = false;
    this._endsWithInteger = false;
  };

  Printer.prototype._maybeIndent = function _maybeIndent(str) {
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  };

  Printer.prototype._maybeAddParen = function _maybeAddParen(str) {
    var parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;

    var i = void 0;
    for (i = 0; i < str.length && str[i] === " "; i++) {
      continue;
    }if (i === str.length) return;

    var cha = str[i];
    if (cha === "\n" || cha === "/") {
      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    }
  };

  Printer.prototype._catchUp = function _catchUp(prop, loc) {
    if (!this.format.retainLines) return;

    var pos = loc ? loc[prop] : null;
    if (pos && pos.line !== null) {
      var count = pos.line - this._buf.getCurrentLine();

      for (var i = 0; i < count; i++) {
        this._newline();
      }
    }
  };

  Printer.prototype._getIndent = function _getIndent() {
    return (0, _babelgeneratorlibprinterjs6160__repeat2.default)(this.format.indent.style, this._indent);
  };

  Printer.prototype.startTerminatorless = function startTerminatorless() {
    return this._parenPushNewlineState = {
      printed: false
    };
  };

  Printer.prototype.endTerminatorless = function endTerminatorless(state) {
    if (state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  };

  Printer.prototype.print = function print(node, parent) {
    var _this = this;

    if (!node) return;

    var oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }

    var printMethod = this[node.type];
    if (!printMethod) {
      throw new ReferenceError("unknown node of type " + (0, _babelgeneratorlibprinterjs6160__stringify2.default)(node.type) + " with constructor " + (0, _babelgeneratorlibprinterjs6160__stringify2.default)(node && node.constructor.name));
    }

    this._printStack.push(node);

    var oldInAux = this._insideAux;
    this._insideAux = !node.loc;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);

    var needsParens = _babelgeneratorlibprinterjs6160_n.needsParens(node, parent, this._printStack);
    if (needsParens) this.token("(");

    this._printLeadingComments(node, parent);

    var loc = _babelgeneratorlibprinterjs6160_t.isProgram(node) || _babelgeneratorlibprinterjs6160_t.isFile(node) ? null : node.loc;
    this.withSource("start", loc, function () {
      _this[node.type](node, parent);
    });

    this._printTrailingComments(node, parent);

    if (needsParens) this.token(")");

    this._printStack.pop();

    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  };

  Printer.prototype._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  };

  Printer.prototype._printAuxBeforeComment = function _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;

    var comment = this.format.auxiliaryCommentBefore;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  };

  Printer.prototype._printAuxAfterComment = function _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;

    var comment = this.format.auxiliaryCommentAfter;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  };

  Printer.prototype.getPossibleRaw = function getPossibleRaw(node) {
    if (this.format.minified) return;

    var extra = node.extra;
    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
      return extra.raw;
    }
  };

  Printer.prototype.printJoin = function printJoin(nodes, parent) {
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    if (!nodes || !nodes.length) return;

    if (opts.indent) this.indent();

    var newlineOpts = {
      addNewlines: opts.addNewlines
    };

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);

      this.print(node, parent);

      if (opts.iterator) {
        opts.iterator(node, i);
      }

      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }

      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }

    if (opts.indent) this.dedent();
  };

  Printer.prototype.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
    var indent = !!node.leadingComments;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  };

  Printer.prototype.printBlock = function printBlock(parent) {
    var node = parent.body;

    if (!_babelgeneratorlibprinterjs6160_t.isEmptyStatement(node)) {
      this.space();
    }

    this.print(node, parent);
  };

  Printer.prototype._printTrailingComments = function _printTrailingComments(node, parent) {
    this._printComments(this._getComments(false, node, parent));
  };

  Printer.prototype._printLeadingComments = function _printLeadingComments(node, parent) {
    this._printComments(this._getComments(true, node, parent));
  };

  Printer.prototype.printInnerComments = function printInnerComments(node) {
    var indent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    if (!node.innerComments) return;
    if (indent) this.indent();
    this._printComments(node.innerComments);
    if (indent) this.dedent();
  };

  Printer.prototype.printSequence = function printSequence(nodes, parent) {
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  };

  Printer.prototype.printList = function printList(items, parent) {
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    if (opts.separator == null) {
      opts.separator = _babelgeneratorlibprinterjs6160_commaSeparator;
    }

    return this.printJoin(items, parent, opts);
  };

  Printer.prototype._printNewline = function _printNewline(leading, node, parent, opts) {
    var _this2 = this;

    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    var lines = 0;

    if (node.start != null && !node._ignoreUserWhitespace && this._whitespace) {
      if (leading) {
        var _comments = node.leadingComments;
        var _comment = _comments && (0, _babelgeneratorlibprinterjs6160__find2.default)(_comments, function (comment) {
          return !!comment.loc && _this2.format.shouldPrintComment(comment.value);
        });

        lines = this._whitespace.getNewlinesBefore(_comment || node);
      } else {
        var _comments2 = node.trailingComments;
        var _comment2 = _comments2 && (0, _babelgeneratorlibprinterjs6160__findLast2.default)(_comments2, function (comment) {
          return !!comment.loc && _this2.format.shouldPrintComment(comment.value);
        });

        lines = this._whitespace.getNewlinesAfter(_comment2 || node);
      }
    } else {
      if (!leading) lines++;
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;

      var needs = _babelgeneratorlibprinterjs6160_n.needsWhitespaceAfter;
      if (leading) needs = _babelgeneratorlibprinterjs6160_n.needsWhitespaceBefore;
      if (needs(node, parent)) lines++;

      if (!this._buf.hasContent()) lines = 0;
    }

    this.newline(lines);
  };

  Printer.prototype._getComments = function _getComments(leading, node) {
    return node && (leading ? node.leadingComments : node.trailingComments) || [];
  };

  Printer.prototype._printComment = function _printComment(comment) {
    var _this3 = this;

    if (!this.format.shouldPrintComment(comment.value)) return;

    if (comment.ignore) return;

    if (this._printedComments.has(comment)) return;
    this._printedComments.add(comment);

    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }

    this.newline(this._whitespace ? this._whitespace.getNewlinesBefore(comment) : 0);

    if (!this.endsWith("[") && !this.endsWith("{")) this.space();

    var val = comment.type === "CommentLine" ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

    if (comment.type === "CommentBlock" && this.format.indent.adjustMultilineComment) {
      var offset = comment.loc && comment.loc.start.column;
      if (offset) {
        var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }

      var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
      val = val.replace(/\n(?!$)/g, "\n" + (0, _babelgeneratorlibprinterjs6160__repeat2.default)(" ", indentSize));
    }

    this.withSource("start", comment.loc, function () {
      _this3._append(val);
    });

    this.newline((this._whitespace ? this._whitespace.getNewlinesAfter(comment) : 0) + (comment.type === "CommentLine" ? -1 : 0));
  };

  Printer.prototype._printComments = function _printComments(comments) {
    if (!comments || !comments.length) return;

    for (var _iterator = comments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelgeneratorlibprinterjs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _comment3 = _ref;

      this._printComment(_comment3);
    }
  };

  return Printer;
}();

$m['babel-generator/lib/printer.js#6.16.0'].exports.default = _babelgeneratorlibprinterjs6160_Printer;

function _babelgeneratorlibprinterjs6160_commaSeparator() {
  this.token(",");
  this.space();
}

var _babelgeneratorlibprinterjs6160__arr = [$m['babel-generator/lib/generators/template-literals.js#6.16.0'].exports, $m['babel-generator/lib/generators/expressions.js#6.16.0'].exports, $m['babel-generator/lib/generators/statements.js#6.16.0'].exports, $m['babel-generator/lib/generators/classes.js#6.16.0'].exports, $m['babel-generator/lib/generators/methods.js#6.16.0'].exports, $m['babel-generator/lib/generators/modules.js#6.16.0'].exports, $m['babel-generator/lib/generators/types.js#6.16.0'].exports, $m['babel-generator/lib/generators/flow.js#6.16.0'].exports, $m['babel-generator/lib/generators/base.js#6.16.0'].exports, $m['babel-generator/lib/generators/jsx.js#6.16.0'].exports];
for (var _babelgeneratorlibprinterjs6160__i2 = 0; _babelgeneratorlibprinterjs6160__i2 < _babelgeneratorlibprinterjs6160__arr.length; _babelgeneratorlibprinterjs6160__i2++) {
  var _babelgeneratorlibprinterjs6160_generator = _babelgeneratorlibprinterjs6160__arr[_babelgeneratorlibprinterjs6160__i2];
  (0, _babelgeneratorlibprinterjs6160__assign2.default)(_babelgeneratorlibprinterjs6160_Printer.prototype, _babelgeneratorlibprinterjs6160_generator);
}
$m['babel-generator/lib/printer.js#6.16.0'].exports = $m['babel-generator/lib/printer.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-generator/lib/printer.js ≠≠*/

/*== node_modules/babel-generator/lib/source-map.js ==*/
$m['babel-generator/lib/source-map.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/source-map.js#6.16.0'].exports.__esModule = true;

var _babelgeneratorlibsourcemapjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babelgeneratorlibsourcemapjs6160__keys2 = _babelgeneratorlibsourcemapjs6160__interopRequireDefault(_babelgeneratorlibsourcemapjs6160__keys);

var _babelgeneratorlibsourcemapjs6160__typeof2 = $m['babel-runtime/helpers/typeof.js#6.11.6'].exports;

var _babelgeneratorlibsourcemapjs6160__typeof3 = _babelgeneratorlibsourcemapjs6160__interopRequireDefault(_babelgeneratorlibsourcemapjs6160__typeof2);

var _babelgeneratorlibsourcemapjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelgeneratorlibsourcemapjs6160__classCallCheck3 = _babelgeneratorlibsourcemapjs6160__interopRequireDefault(_babelgeneratorlibsourcemapjs6160__classCallCheck2);

var _babelgeneratorlibsourcemapjs6160__sourceMap = $m['source-map/source-map.js#0.5.6'].exports;

var _babelgeneratorlibsourcemapjs6160__sourceMap2 = _babelgeneratorlibsourcemapjs6160__interopRequireDefault(_babelgeneratorlibsourcemapjs6160__sourceMap);

function _babelgeneratorlibsourcemapjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelgeneratorlibsourcemapjs6160_SourceMap = function () {
  function SourceMap(opts, code) {
    var _this = this;

    (0, _babelgeneratorlibsourcemapjs6160__classCallCheck3.default)(this, SourceMap);

    this._opts = opts;
    this._map = new _babelgeneratorlibsourcemapjs6160__sourceMap2.default.SourceMapGenerator({
      file: opts.sourceMapTarget,
      sourceRoot: opts.sourceRoot
    });

    if (typeof code === "string") {
      this._map.setSourceContent(opts.sourceFileName, code);
    } else if ((typeof code === "undefined" ? "undefined" : (0, _babelgeneratorlibsourcemapjs6160__typeof3.default)(code)) === "object") {
      (0, _babelgeneratorlibsourcemapjs6160__keys2.default)(code).forEach(function (sourceFileName) {
        _this._map.setSourceContent(sourceFileName, code[sourceFileName]);
      });
    }
  }

  SourceMap.prototype.get = function get() {
    return this._map.toJSON();
  };

  SourceMap.prototype.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename) {
    if (this._lastGenLine !== generatedLine && line === null) return;

    if (this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
      return;
    }

    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;

    this._map.addMapping({
      name: identifierName,
      generated: {
        line: generatedLine,
        column: generatedColumn
      },
      source: line == null ? null : filename || this._opts.sourceFileName,
      original: line == null ? null : {
        line: line,
        column: column
      }
    });
  };

  return SourceMap;
}();

$m['babel-generator/lib/source-map.js#6.16.0'].exports.default = _babelgeneratorlibsourcemapjs6160_SourceMap;
$m['babel-generator/lib/source-map.js#6.16.0'].exports = $m['babel-generator/lib/source-map.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-generator/lib/source-map.js ≠≠*/

/*== node_modules/detect-indent/index.js ==*/
$m['detect-indent/index.js#3.0.1'] = { exports: {} };
'use strict';

var _detectindentindexjs301_repeating = $m['repeating/index.js#1.1.3'].exports;

// detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment
var _detectindentindexjs301_INDENT_RE = /^(?:( )+|\t+)/;

function _detectindentindexjs301_getMostUsed(indents) {
	var result = 0;
	var maxUsed = 0;
	var maxWeight = 0;

	for (var n in indents) {
		var indent = indents[n];
		var u = indent[0];
		var w = indent[1];

		if (u > maxUsed || u === maxUsed && w > maxWeight) {
			maxUsed = u;
			maxWeight = w;
			result = +n;
		}
	}

	return result;
}

$m['detect-indent/index.js#3.0.1'].exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	// used to see if tabs or spaces are the most used
	var tabs = 0;
	var spaces = 0;

	// remember the size of previous line's indentation
	var prev = 0;

	// remember how many indents/unindents as occurred for a given size
	// and how much lines follow a given indentation
	//
	// indents = {
	//    3: [1, 0],
	//    4: [1, 5],
	//    5: [1, 0],
	//   12: [1, 0],
	// }
	var indents = {};

	// pointer to the array of last used indent
	var current;

	// whether the last action was an indent (opposed to an unindent)
	var isIndent;

	str.split(/\n/g).forEach(function (line) {
		if (!line) {
			// ignore empty lines
			return;
		}

		var indent;
		var matches = line.match(_detectindentindexjs301_INDENT_RE);

		if (!matches) {
			indent = 0;
		} else {
			indent = matches[0].length;

			if (matches[1]) {
				spaces++;
			} else {
				tabs++;
			}
		}

		var diff = indent - prev;
		prev = indent;

		if (diff) {
			// an indent or unindent has been detected

			isIndent = diff > 0;

			current = indents[isIndent ? diff : -diff];

			if (current) {
				current[0]++;
			} else {
				current = indents[diff] = [1, 0];
			}
		} else if (current) {
			// if the last action was an indent, increment the weight
			current[1] += +isIndent;
		}
	});

	var amount = _detectindentindexjs301_getMostUsed(indents);

	var type;
	var actual;
	if (!amount) {
		type = null;
		actual = '';
	} else if (spaces >= tabs) {
		type = 'space';
		actual = _detectindentindexjs301_repeating(' ', amount);
	} else {
		type = 'tab';
		actual = _detectindentindexjs301_repeating('\t', amount);
	}

	return {
		amount: amount,
		type: type,
		indent: actual
	};
};
/*≠≠ node_modules/detect-indent/index.js ≠≠*/

/*== node_modules/babel-helpers/lib/helpers.js ==*/
$m['babel-helpers/lib/helpers.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-helpers/lib/helpers.js#6.16.0'].exports.__esModule = true;

var _babelhelperslibhelpersjs6160__babelTemplate = $m['babel-template/lib/index.js#6.16.0'].exports;

var _babelhelperslibhelpersjs6160__babelTemplate2 = _babelhelperslibhelpersjs6160__interopRequireDefault(_babelhelperslibhelpersjs6160__babelTemplate);

function _babelhelperslibhelpersjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelhelperslibhelpersjs6160_helpers = {};
$m['babel-helpers/lib/helpers.js#6.16.0'].exports.default = _babelhelperslibhelpersjs6160_helpers;

_babelhelperslibhelpersjs6160_helpers.typeof = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\")\n    ? function (obj) { return typeof obj; }\n    : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n");

_babelhelperslibhelpersjs6160_helpers.jsx = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function () {\n    var REACT_ELEMENT_TYPE = (typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\")) || 0xeac7;\n\n    return function createRawReactElement (type, props, key, children) {\n      var defaultProps = type && type.defaultProps;\n      var childrenLength = arguments.length - 3;\n\n      if (!props && childrenLength !== 0) {\n        // If we're going to assign props.children, we create a new object now\n        // to avoid mutating defaultProps.\n        props = {};\n      }\n      if (props && defaultProps) {\n        for (var propName in defaultProps) {\n          if (props[propName] === void 0) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      } else if (!props) {\n        props = defaultProps || {};\n      }\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 3];\n        }\n        props.children = childArray;\n      }\n\n      return {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key === undefined ? null : '' + key,\n        ref: null,\n        props: props,\n        _owner: null,\n      };\n    };\n\n  })()\n");

_babelhelperslibhelpersjs6160_helpers.asyncIterator = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (iterable) {\n    if (typeof Symbol === \"function\") {\n      if (Symbol.asyncIterator) {\n        var method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        return iterable[Symbol.iterator]();\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  })\n");

_babelhelperslibhelpersjs6160_helpers.asyncGenerator = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function () {\n    function AwaitValue(value) {\n      this.value = value;\n    }\n\n    function AsyncGenerator(gen) {\n      var front, back;\n\n      function send(key, arg) {\n        return new Promise(function (resolve, reject) {\n          var request = {\n            key: key,\n            arg: arg,\n            resolve: resolve,\n            reject: reject,\n            next: null\n          };\n\n          if (back) {\n            back = back.next = request;\n          } else {\n            front = back = request;\n            resume(key, arg);\n          }\n        });\n      }\n\n      function resume(key, arg) {\n        try {\n          var result = gen[key](arg)\n          var value = result.value;\n          if (value instanceof AwaitValue) {\n            Promise.resolve(value.value).then(\n              function (arg) { resume(\"next\", arg); },\n              function (arg) { resume(\"throw\", arg); });\n          } else {\n            settle(result.done ? \"return\" : \"normal\", result.value);\n          }\n        } catch (err) {\n          settle(\"throw\", err);\n        }\n      }\n\n      function settle(type, value) {\n        switch (type) {\n          case \"return\":\n            front.resolve({ value: value, done: true });\n            break;\n          case \"throw\":\n            front.reject(value);\n            break;\n          default:\n            front.resolve({ value: value, done: false });\n            break;\n        }\n\n        front = front.next;\n        if (front) {\n          resume(front.key, front.arg);\n        } else {\n          back = null;\n        }\n      }\n\n      this._invoke = send;\n\n      // Hide \"return\" method if generator return is not supported\n      if (typeof gen.return !== \"function\") {\n        this.return = undefined;\n      }\n    }\n\n    if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n      AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n    }\n\n    AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n    AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n    AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n\n    return {\n      wrap: function (fn) {\n        return function () {\n          return new AsyncGenerator(fn.apply(this, arguments));\n        };\n      },\n      await: function (value) {\n        return new AwaitValue(value);\n      }\n    };\n\n  })()\n");

_babelhelperslibhelpersjs6160_helpers.asyncGeneratorDelegate = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.asyncToGenerator = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (fn) {\n    return function () {\n      var gen = fn.apply(this, arguments);\n      return new Promise(function (resolve, reject) {\n        function step(key, arg) {\n          try {\n            var info = gen[key](arg);\n            var value = info.value;\n          } catch (error) {\n            reject(error);\n            return;\n          }\n\n          if (info.done) {\n            resolve(value);\n          } else {\n            return Promise.resolve(value).then(function (value) {\n              step(\"next\", value);\n            }, function (err) {\n              step(\"throw\", err);\n            });\n          }\n        }\n\n        return step(\"next\");\n      });\n    };\n  })\n");

_babelhelperslibhelpersjs6160_helpers.classCallCheck = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  });\n");

_babelhelperslibhelpersjs6160_helpers.createClass = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function() {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i ++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })()\n");

_babelhelperslibhelpersjs6160_helpers.defineEnumerableProperties = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n    return obj;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.defaults = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.defineProperty = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  });\n");

_babelhelperslibhelpersjs6160_helpers.extends = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.get = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  });\n");

_babelhelperslibhelpersjs6160_helpers.inherits = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.instanceof = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  });\n");

_babelhelperslibhelpersjs6160_helpers.interopRequireDefault = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  })\n");

_babelhelperslibhelpersjs6160_helpers.interopRequireWildcard = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n      newObj.default = obj;\n      return newObj;\n    }\n  })\n");

_babelhelperslibhelpersjs6160_helpers.newArrowCheck = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  });\n");

_babelhelperslibhelpersjs6160_helpers.objectDestructuringEmpty = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  });\n");

_babelhelperslibhelpersjs6160_helpers.objectWithoutProperties = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (obj, keys) {\n    var target = {};\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n    return target;\n  })\n");

_babelhelperslibhelpersjs6160_helpers.possibleConstructorReturn = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  });\n");

_babelhelperslibhelpersjs6160_helpers.selfGlobal = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  typeof global === \"undefined\" ? self : global\n");

_babelhelperslibhelpersjs6160_helpers.set = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function set(object, property, value, receiver) {\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent !== null) {\n        set(parent, property, value, receiver);\n      }\n    } else if (\"value\" in desc && desc.writable) {\n      desc.value = value;\n    } else {\n      var setter = desc.set;\n\n      if (setter !== undefined) {\n        setter.call(receiver, value);\n      }\n    }\n\n    return value;\n  });\n");

_babelhelperslibhelpersjs6160_helpers.slicedToArray = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function () {\n    // Broken out into a separate function to avoid deoptimizations due to the try/catch for the\n    // array iterator case.\n    function sliceIterator(arr, i) {\n      // this is an expanded form of `for...of` that properly supports abrupt completions of\n      // iterators etc. variable names have been minimised to reduce the size of this massive\n      // helper. sometimes spec compliancy is annoying :(\n      //\n      // _n = _iteratorNormalCompletion\n      // _d = _didIteratorError\n      // _e = _iteratorError\n      // _i = _iterator\n      // _s = _step\n\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  })();\n");

_babelhelperslibhelpersjs6160_helpers.slicedToArrayLoose = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      var _arr = [];\n      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n        _arr.push(_step.value);\n        if (i && _arr.length === i) break;\n      }\n      return _arr;\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  });\n");

_babelhelperslibhelpersjs6160_helpers.taggedTemplateLiteral = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (strings, raw) {\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  });\n");

_babelhelperslibhelpersjs6160_helpers.taggedTemplateLiteralLoose = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (strings, raw) {\n    strings.raw = raw;\n    return strings;\n  });\n");

_babelhelperslibhelpersjs6160_helpers.temporalRef = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (val, name, undef) {\n    if (val === undef) {\n      throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n    } else {\n      return val;\n    }\n  })\n");

_babelhelperslibhelpersjs6160_helpers.temporalUndefined = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  ({})\n");

_babelhelperslibhelpersjs6160_helpers.toArray = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  });\n");

_babelhelperslibhelpersjs6160_helpers.toConsumableArray = (0, _babelhelperslibhelpersjs6160__babelTemplate2.default)("\n  (function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  });\n");
$m['babel-helpers/lib/helpers.js#6.16.0'].exports = $m['babel-helpers/lib/helpers.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-helpers/lib/helpers.js ≠≠*/

/*== node_modules/babel-runtime/core-js/object/set-prototype-of.js ==*/
$m['babel-runtime/core-js/object/set-prototype-of.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/object/set-prototype-of.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/object/set-prototype-of.js ≠≠*/

/*== node_modules/babel-runtime/core-js/symbol/iterator.js ==*/
$m['babel-runtime/core-js/symbol/iterator.js#6.11.6'] = { exports: {} };
$m['babel-runtime/core-js/symbol/iterator.js#6.11.6'].exports = { "default": {}, __esModule: true };
/*≠≠ node_modules/babel-runtime/core-js/symbol/iterator.js ≠≠*/

/*== node_modules/domutils/lib/legacy.js ==*/
$m['domutils/lib/legacy.js#1.5.1'] = { exports: {} };
var _domutilsliblegacyjs151_ElementType = $m['domelementtype/index.js#1.3.0'].exports;
var _domutilsliblegacyjs151_isTag = $m['domutils/lib/legacy.js#1.5.1'].exports.isTag = _domutilsliblegacyjs151_ElementType.isTag;

$m['domutils/lib/legacy.js#1.5.1'].exports.testElement = function (options, element) {
	for (var key in options) {
		if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {
			if (!_domutilsliblegacyjs151_isTag(element) || !options.tag_name(element.name)) {
				return false;
			}
		} else if (key === "tag_type") {
			if (!options.tag_type(element.type)) return false;
		} else if (key === "tag_contains") {
			if (_domutilsliblegacyjs151_isTag(element) || !options.tag_contains(element.data)) {
				return false;
			}
		} else if (!element.attribs || !options[key](element.attribs[key])) {
			return false;
		}
	}
	return true;
};

var _domutilsliblegacyjs151_Checks = {
	tag_name: function (name) {
		if (typeof name === "function") {
			return function (elem) {
				return _domutilsliblegacyjs151_isTag(elem) && name(elem.name);
			};
		} else if (name === "*") {
			return _domutilsliblegacyjs151_isTag;
		} else {
			return function (elem) {
				return _domutilsliblegacyjs151_isTag(elem) && elem.name === name;
			};
		}
	},
	tag_type: function (type) {
		if (typeof type === "function") {
			return function (elem) {
				return type(elem.type);
			};
		} else {
			return function (elem) {
				return elem.type === type;
			};
		}
	},
	tag_contains: function (data) {
		if (typeof data === "function") {
			return function (elem) {
				return !_domutilsliblegacyjs151_isTag(elem) && data(elem.data);
			};
		} else {
			return function (elem) {
				return !_domutilsliblegacyjs151_isTag(elem) && elem.data === data;
			};
		}
	}
};

function _domutilsliblegacyjs151_getAttribCheck(attrib, value) {
	if (typeof value === "function") {
		return function (elem) {
			return elem.attribs && value(elem.attribs[attrib]);
		};
	} else {
		return function (elem) {
			return elem.attribs && elem.attribs[attrib] === value;
		};
	}
}

function _domutilsliblegacyjs151_combineFuncs(a, b) {
	return function (elem) {
		return a(elem) || b(elem);
	};
}

$m['domutils/lib/legacy.js#1.5.1'].exports.getElements = function (options, element, recurse, limit) {
	var funcs = Object.keys(options).map(function (key) {
		var value = options[key];
		return key in _domutilsliblegacyjs151_Checks ? _domutilsliblegacyjs151_Checks[key](value) : _domutilsliblegacyjs151_getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(funcs.reduce(_domutilsliblegacyjs151_combineFuncs), element, recurse, limit);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementById = function (id, element, recurse) {
	if (!Array.isArray(element)) element = [element];
	return this.findOne(_domutilsliblegacyjs151_getAttribCheck("id", id), element, recurse !== false);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementsByTagName = function (name, element, recurse, limit) {
	return this.filter(_domutilsliblegacyjs151_Checks.tag_name(name), element, recurse, limit);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementsByTagType = function (type, element, recurse, limit) {
	return this.filter(_domutilsliblegacyjs151_Checks.tag_type(type), element, recurse, limit);
};
/*≠≠ node_modules/domutils/lib/legacy.js ≠≠*/

/*== node_modules/domutils/lib/querying.js ==*/
$m['domutils/lib/querying.js#1.5.1'] = { exports: {} };
var _domutilslibqueryingjs151_isTag = $m['domelementtype/index.js#1.3.0'].exports.isTag;

$m['domutils/lib/querying.js#1.5.1'].exports = {
	filter: _domutilslibqueryingjs151_filter,
	find: _domutilslibqueryingjs151_find,
	findOneChild: _domutilslibqueryingjs151_findOneChild,
	findOne: _domutilslibqueryingjs151_findOne,
	existsOne: _domutilslibqueryingjs151_existsOne,
	findAll: _domutilslibqueryingjs151_findAll
};

function _domutilslibqueryingjs151_filter(test, element, recurse, limit) {
	if (!Array.isArray(element)) element = [element];

	if (typeof limit !== "number" || !isFinite(limit)) {
		limit = Infinity;
	}
	return _domutilslibqueryingjs151_find(test, element, recurse !== false, limit);
}

function _domutilslibqueryingjs151_find(test, elems, recurse, limit) {
	var result = [],
	    childs;

	for (var i = 0, j = elems.length; i < j; i++) {
		if (test(elems[i])) {
			result.push(elems[i]);
			if (--limit <= 0) break;
		}

		childs = elems[i].children;
		if (recurse && childs && childs.length > 0) {
			childs = _domutilslibqueryingjs151_find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if (limit <= 0) break;
		}
	}

	return result;
}

function _domutilslibqueryingjs151_findOneChild(test, elems) {
	for (var i = 0, l = elems.length; i < l; i++) {
		if (test(elems[i])) return elems[i];
	}

	return null;
}

function _domutilslibqueryingjs151_findOne(test, elems) {
	var elem = null;

	for (var i = 0, l = elems.length; i < l && !elem; i++) {
		if (!_domutilslibqueryingjs151_isTag(elems[i])) {
			continue;
		} else if (test(elems[i])) {
			elem = elems[i];
		} else if (elems[i].children.length > 0) {
			elem = _domutilslibqueryingjs151_findOne(test, elems[i].children);
		}
	}

	return elem;
}

function _domutilslibqueryingjs151_existsOne(test, elems) {
	for (var i = 0, l = elems.length; i < l; i++) {
		if (_domutilslibqueryingjs151_isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && _domutilslibqueryingjs151_existsOne(test, elems[i].children))) {
			return true;
		}
	}

	return false;
}

function _domutilslibqueryingjs151_findAll(test, elems) {
	var result = [];
	for (var i = 0, j = elems.length; i < j; i++) {
		if (!_domutilslibqueryingjs151_isTag(elems[i])) continue;
		if (test(elems[i])) result.push(elems[i]);

		if (elems[i].children.length > 0) {
			result = result.concat(_domutilslibqueryingjs151_findAll(test, elems[i].children));
		}
	}
	return result;
}
/*≠≠ node_modules/domutils/lib/querying.js ≠≠*/

/*== node_modules/domutils/lib/stringify.js ==*/
$m['domutils/lib/stringify.js#1.5.1'] = { exports: {} };
var _domutilslibstringifyjs151_ElementType = $m['domelementtype/index.js#1.3.0'].exports,
    _domutilslibstringifyjs151_getOuterHTML = $m['dom-serializer/index.js#0.1.0'].exports,
    _domutilslibstringifyjs151_isTag = _domutilslibstringifyjs151_ElementType.isTag;

$m['domutils/lib/stringify.js#1.5.1'].exports = {
	getInnerHTML: _domutilslibstringifyjs151_getInnerHTML,
	getOuterHTML: _domutilslibstringifyjs151_getOuterHTML,
	getText: _domutilslibstringifyjs151_getText
};

function _domutilslibstringifyjs151_getInnerHTML(elem, opts) {
	return elem.children ? elem.children.map(function (elem) {
		return _domutilslibstringifyjs151_getOuterHTML(elem, opts);
	}).join("") : "";
}

function _domutilslibstringifyjs151_getText(elem) {
	if (Array.isArray(elem)) return elem.map(_domutilslibstringifyjs151_getText).join("");
	if (_domutilslibstringifyjs151_isTag(elem) || elem.type === _domutilslibstringifyjs151_ElementType.CDATA) return _domutilslibstringifyjs151_getText(elem.children);
	if (elem.type === _domutilslibstringifyjs151_ElementType.Text) return elem.data;
	return "";
}
/*≠≠ node_modules/domutils/lib/stringify.js ≠≠*/

/*== node_modules/htmlparser2/lib/WritableStream.js ==*/
$m['htmlparser2/lib/WritableStream.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/WritableStream.js#3.9.1'].exports = _htmlparser2libWritableStreamjs391_Stream;

var _htmlparser2libWritableStreamjs391_Parser = $m['htmlparser2/lib/Parser.js#3.9.1'].exports,
    _htmlparser2libWritableStreamjs391_WritableStream = require("stream").Writable || {}.Writable,
    _htmlparser2libWritableStreamjs391_StringDecoder = require("string_decoder").StringDecoder,
    _htmlparser2libWritableStreamjs391_Buffer = require("buffer").Buffer;

function _htmlparser2libWritableStreamjs391_Stream(cbs, options) {
	var parser = this._parser = new _htmlparser2libWritableStreamjs391_Parser(cbs, options);
	var decoder = this._decoder = new _htmlparser2libWritableStreamjs391_StringDecoder();

	_htmlparser2libWritableStreamjs391_WritableStream.call(this, { decodeStrings: false });

	this.once("finish", function () {
		parser.end(decoder.end());
	});
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libWritableStreamjs391_Stream, _htmlparser2libWritableStreamjs391_WritableStream);

_htmlparser2libWritableStreamjs391_WritableStream.prototype._write = function (chunk, encoding, cb) {
	if (chunk instanceof _htmlparser2libWritableStreamjs391_Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};
/*≠≠ node_modules/htmlparser2/lib/WritableStream.js ≠≠*/

/*== node_modules/domhandler/lib/element.js ==*/
$m['domhandler/lib/element.js#2.3.0'] = { exports: {} };
// DOM-Level-1-compliant structure
var _domhandlerlibelementjs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports;
var _domhandlerlibelementjs230_ElementPrototype = $m['domhandler/lib/element.js#2.3.0'].exports = Object.create(_domhandlerlibelementjs230_NodePrototype);

var _domhandlerlibelementjs230_domLvl1 = {
	tagName: "name"
};

Object.keys(_domhandlerlibelementjs230_domLvl1).forEach(function (key) {
	var shorthand = _domhandlerlibelementjs230_domLvl1[key];
	Object.defineProperty(_domhandlerlibelementjs230_ElementPrototype, key, {
		get: function () {
			return this[shorthand] || null;
		},
		set: function (val) {
			this[shorthand] = val;
			return val;
		}
	});
});
/*≠≠ node_modules/domhandler/lib/element.js ≠≠*/

/*== node_modules/domhandler/index.js ==*/
$m['domhandler/index.js#2.3.0'] = { exports: {} };
var _domhandlerindexjs230_ElementType = $m['domelementtype/index.js#1.3.0'].exports;

var _domhandlerindexjs230_re_whitespace = /\s+/g;
var _domhandlerindexjs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports;
var _domhandlerindexjs230_ElementPrototype = $m['domhandler/lib/element.js#2.3.0'].exports;

function _domhandlerindexjs230_DomHandler(callback, options, elementCB) {
	if (typeof callback === "object") {
		elementCB = options;
		options = callback;
		callback = null;
	} else if (typeof options === "function") {
		elementCB = options;
		options = _domhandlerindexjs230_defaultOpts;
	}
	this._callback = callback;
	this._options = options || _domhandlerindexjs230_defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var _domhandlerindexjs230_defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false };

_domhandlerindexjs230_DomHandler.prototype.onparserinit = function (parser) {
	this._parser = parser;
};

//Resets the handler back to starting state
_domhandlerindexjs230_DomHandler.prototype.onreset = function () {
	_domhandlerindexjs230_DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
_domhandlerindexjs230_DomHandler.prototype.onend = function () {
	if (this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

_domhandlerindexjs230_DomHandler.prototype._handleCallback = _domhandlerindexjs230_DomHandler.prototype.onerror = function (error) {
	if (typeof this._callback === "function") {
		this._callback(error, this.dom);
	} else {
		if (error) throw error;
	}
};

_domhandlerindexjs230_DomHandler.prototype.onclosetag = function () {
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	var elem = this._tagStack.pop();
	if (this._elementCB) this._elementCB(elem);
};

_domhandlerindexjs230_DomHandler.prototype._addDomElement = function (element) {
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if (this._options.withStartIndices) {
		element.startIndex = this._parser.startIndex;
	}

	if (this._options.withDomLvl1) {
		element.__proto__ = element.type === "tag" ? _domhandlerindexjs230_ElementPrototype : _domhandlerindexjs230_NodePrototype;
	}

	if (previousSibling) {
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

_domhandlerindexjs230_DomHandler.prototype.onopentag = function (name, attribs) {
	var element = {
		type: name === "script" ? _domhandlerindexjs230_ElementType.Script : name === "style" ? _domhandlerindexjs230_ElementType.Style : _domhandlerindexjs230_ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	this._addDomElement(element);

	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.ontext = function (data) {
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === _domhandlerindexjs230_ElementType.Text) {
		if (normalize) {
			lastTag.data = (lastTag.data + data).replace(_domhandlerindexjs230_re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === _domhandlerindexjs230_ElementType.Text) {
			if (normalize) {
				lastTag.data = (lastTag.data + data).replace(_domhandlerindexjs230_re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if (normalize) {
				data = data.replace(_domhandlerindexjs230_re_whitespace, " ");
			}

			this._addDomElement({
				data: data,
				type: _domhandlerindexjs230_ElementType.Text
			});
		}
	}
};

_domhandlerindexjs230_DomHandler.prototype.oncomment = function (data) {
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if (lastTag && lastTag.type === _domhandlerindexjs230_ElementType.Comment) {
		lastTag.data += data;
		return;
	}

	var element = {
		data: data,
		type: _domhandlerindexjs230_ElementType.Comment
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.oncdatastart = function () {
	var element = {
		children: [{
			data: "",
			type: _domhandlerindexjs230_ElementType.Text
		}],
		type: _domhandlerindexjs230_ElementType.CDATA
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.oncommentend = _domhandlerindexjs230_DomHandler.prototype.oncdataend = function () {
	this._tagStack.pop();
};

_domhandlerindexjs230_DomHandler.prototype.onprocessinginstruction = function (name, data) {
	this._addDomElement({
		name: name,
		data: data,
		type: _domhandlerindexjs230_ElementType.Directive
	});
};

$m['domhandler/index.js#2.3.0'].exports = _domhandlerindexjs230_DomHandler;
/*≠≠ node_modules/domhandler/index.js ≠≠*/

/*== node_modules/domutils/index.js ==*/
$m['domutils/index.js#1.5.1'] = { exports: {} };
var _domutilsindexjs151_DomUtils = $m['domutils/index.js#1.5.1'].exports;

[$m['domutils/lib/stringify.js#1.5.1'].exports, $m['domutils/lib/traversal.js#1.5.1'].exports, $m['domutils/lib/manipulation.js#1.5.1'].exports, $m['domutils/lib/querying.js#1.5.1'].exports, $m['domutils/lib/legacy.js#1.5.1'].exports, $m['domutils/lib/helpers.js#1.5.1'].exports].forEach(function (ext) {
	Object.keys(ext).forEach(function (key) {
		_domutilsindexjs151_DomUtils[key] = ext[key].bind(_domutilsindexjs151_DomUtils);
	});
});
/*≠≠ node_modules/domutils/index.js ≠≠*/

/*== node_modules/htmlparser2/lib/index.js ==*/
$m['htmlparser2/lib/index.js#3.9.1'] = { exports: {} };
var _htmlparser2libindexjs391_Parser = $m['htmlparser2/lib/Parser.js#3.9.1'].exports,
    _htmlparser2libindexjs391_DomHandler = $m['domhandler/index.js#2.3.0'].exports;

function _htmlparser2libindexjs391_defineProp(name, value) {
	delete $m['htmlparser2/lib/index.js#3.9.1'].exports[name];
	$m['htmlparser2/lib/index.js#3.9.1'].exports[name] = value;
	return value;
}

$m['htmlparser2/lib/index.js#3.9.1'].exports = {
	Parser: _htmlparser2libindexjs391_Parser,
	Tokenizer: $m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports,
	ElementType: $m['domelementtype/index.js#1.3.0'].exports,
	DomHandler: _htmlparser2libindexjs391_DomHandler,
	get FeedHandler() {
		return _htmlparser2libindexjs391_defineProp("FeedHandler", require("htmlparser2/lib/FeedHandler.js#3.9.1"));
	},
	get Stream() {
		return _htmlparser2libindexjs391_defineProp("Stream", require("htmlparser2/lib/Stream.js#3.9.1"));
	},
	get WritableStream() {
		return _htmlparser2libindexjs391_defineProp("WritableStream", $m['htmlparser2/lib/WritableStream.js#3.9.1'].exports);
	},
	get ProxyHandler() {
		return _htmlparser2libindexjs391_defineProp("ProxyHandler", require("htmlparser2/lib/ProxyHandler.js#3.9.1"));
	},
	get DomUtils() {
		return _htmlparser2libindexjs391_defineProp("DomUtils", $m['domutils/index.js#1.5.1'].exports);
	},
	get CollectingHandler() {
		return _htmlparser2libindexjs391_defineProp("CollectingHandler", require("htmlparser2/lib/CollectingHandler.js#3.9.1"));
	},
	// For legacy support
	DefaultHandler: _htmlparser2libindexjs391_DomHandler,
	get RssHandler() {
		return _htmlparser2libindexjs391_defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function (data, options) {
		var handler = new _htmlparser2libindexjs391_DomHandler(options);
		new _htmlparser2libindexjs391_Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function (feed, options) {
		var handler = new $m['htmlparser2/lib/index.js#3.9.1'].exports.FeedHandler(options);
		new _htmlparser2libindexjs391_Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function (cb, options, elementCb) {
		var handler = new _htmlparser2libindexjs391_DomHandler(cb, options, elementCb);
		return new _htmlparser2libindexjs391_Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};
/*≠≠ node_modules/htmlparser2/lib/index.js ≠≠*/

/*== node_modules/lodash/_stringToPath.js ==*/
$m['lodash/_stringToPath.js#4.16.2'] = { exports: {} };
var _lodashstringToPathjs4162_memoizeCapped = $m['lodash/_memoizeCapped.js#4.16.2'].exports,
    _lodashstringToPathjs4162_toString = $m['lodash/toString.js#4.16.2'].exports;

/** Used to match property names within property paths. */
var _lodashstringToPathjs4162_reLeadingDot = /^\./,
    _lodashstringToPathjs4162_rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var _lodashstringToPathjs4162_reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var _lodashstringToPathjs4162_stringToPath = _lodashstringToPathjs4162_memoizeCapped(function (string) {
  string = _lodashstringToPathjs4162_toString(string);

  var result = [];
  if (_lodashstringToPathjs4162_reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(_lodashstringToPathjs4162_rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(_lodashstringToPathjs4162_reEscapeChar, '$1') : number || match);
  });
  return result;
});

$m['lodash/_stringToPath.js#4.16.2'].exports = _lodashstringToPathjs4162_stringToPath;
/*≠≠ node_modules/lodash/_stringToPath.js ≠≠*/

/*== node_modules/lodash/_baseFlatten.js ==*/
$m['lodash/_baseFlatten.js#4.16.2'] = { exports: {} };
var _lodashbaseFlattenjs4162_arrayPush = $m['lodash/_arrayPush.js#4.16.2'].exports,
    _lodashbaseFlattenjs4162_isFlattenable = $m['lodash/_isFlattenable.js#4.16.2'].exports;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function _lodashbaseFlattenjs4162_baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _lodashbaseFlattenjs4162_isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        _lodashbaseFlattenjs4162_baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _lodashbaseFlattenjs4162_arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

$m['lodash/_baseFlatten.js#4.16.2'].exports = _lodashbaseFlattenjs4162_baseFlatten;
/*≠≠ node_modules/lodash/_baseFlatten.js ≠≠*/

/*== node_modules/lodash/_baseOrderBy.js ==*/
$m['lodash/_baseOrderBy.js#4.16.2'] = { exports: {} };
var _lodashbaseOrderByjs4162_arrayMap = $m['lodash/_arrayMap.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_baseIteratee = $m['lodash/_baseIteratee.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_baseMap = $m['lodash/_baseMap.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_baseSortBy = $m['lodash/_baseSortBy.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_baseUnary = $m['lodash/_baseUnary.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_compareMultiple = $m['lodash/_compareMultiple.js#4.16.2'].exports,
    _lodashbaseOrderByjs4162_identity = $m['lodash/identity.js#4.16.2'].exports;

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function _lodashbaseOrderByjs4162_baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = _lodashbaseOrderByjs4162_arrayMap(iteratees.length ? iteratees : [_lodashbaseOrderByjs4162_identity], _lodashbaseOrderByjs4162_baseUnary(_lodashbaseOrderByjs4162_baseIteratee));

  var result = _lodashbaseOrderByjs4162_baseMap(collection, function (value, key, collection) {
    var criteria = _lodashbaseOrderByjs4162_arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return _lodashbaseOrderByjs4162_baseSortBy(result, function (object, other) {
    return _lodashbaseOrderByjs4162_compareMultiple(object, other, orders);
  });
}

$m['lodash/_baseOrderBy.js#4.16.2'].exports = _lodashbaseOrderByjs4162_baseOrderBy;
/*≠≠ node_modules/lodash/_baseOrderBy.js ≠≠*/

/*== node_modules/lodash/sortBy.js ==*/
$m['lodash/sortBy.js#4.16.2'] = { exports: {} };
var _lodashsortByjs4162_baseFlatten = $m['lodash/_baseFlatten.js#4.16.2'].exports,
    _lodashsortByjs4162_baseOrderBy = $m['lodash/_baseOrderBy.js#4.16.2'].exports,
    _lodashsortByjs4162_baseRest = $m['lodash/_baseRest.js#4.16.2'].exports,
    _lodashsortByjs4162_isIterateeCall = $m['lodash/_isIterateeCall.js#4.16.2'].exports;

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var _lodashsortByjs4162_sortBy = _lodashsortByjs4162_baseRest(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && _lodashsortByjs4162_isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && _lodashsortByjs4162_isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return _lodashsortByjs4162_baseOrderBy(collection, _lodashsortByjs4162_baseFlatten(iteratees, 1), []);
});

$m['lodash/sortBy.js#4.16.2'].exports = _lodashsortByjs4162_sortBy;
/*≠≠ node_modules/lodash/sortBy.js ≠≠*/

/*== node_modules/lodash/isArrayLikeObject.js ==*/
$m['lodash/isArrayLikeObject.js#4.16.2'] = { exports: {} };
var _lodashisArrayLikeObjectjs4162_isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports,
    _lodashisArrayLikeObjectjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function _lodashisArrayLikeObjectjs4162_isArrayLikeObject(value) {
  return _lodashisArrayLikeObjectjs4162_isObjectLike(value) && _lodashisArrayLikeObjectjs4162_isArrayLike(value);
}

$m['lodash/isArrayLikeObject.js#4.16.2'].exports = _lodashisArrayLikeObjectjs4162_isArrayLikeObject;
/*≠≠ node_modules/lodash/isArrayLikeObject.js ≠≠*/

/*== node_modules/lodash/_nativeCreate.js ==*/
$m['lodash/_nativeCreate.js#4.16.2'] = { exports: {} };
var _lodashnativeCreatejs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashnativeCreatejs4162_nativeCreate = _lodashnativeCreatejs4162_getNative(Object, 'create');

$m['lodash/_nativeCreate.js#4.16.2'].exports = _lodashnativeCreatejs4162_nativeCreate;
/*≠≠ node_modules/lodash/_nativeCreate.js ≠≠*/

/*== node_modules/lodash/_coreJsData.js ==*/
$m['lodash/_coreJsData.js#4.16.2'] = { exports: {} };
var _lodashcoreJsDatajs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/** Used to detect overreaching core-js shims. */
var _lodashcoreJsDatajs4162_coreJsData = _lodashcoreJsDatajs4162_root['__core-js_shared__'];

$m['lodash/_coreJsData.js#4.16.2'].exports = _lodashcoreJsDatajs4162_coreJsData;
/*≠≠ node_modules/lodash/_coreJsData.js ≠≠*/

/*== node_modules/babel-core/lib/helpers/normalize-ast.js ==*/
$m['babel-core/lib/helpers/normalize-ast.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/helpers/normalize-ast.js#6.16.0'].exports.__esModule = true;

$m['babel-core/lib/helpers/normalize-ast.js#6.16.0'].exports.default = function (ast, comments, tokens) {
  if (ast) {
    if (ast.type === "Program") {
      return _babelcorelibhelpersnormalizeastjs6160_t.file(ast, comments || [], tokens || []);
    } else if (ast.type === "File") {
      return ast;
    }
  }

  throw new Error("Not a valid ast?");
};

var _babelcorelibhelpersnormalizeastjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibhelpersnormalizeastjs6160_t = _babelcorelibhelpersnormalizeastjs6160__interopRequireWildcard(_babelcorelibhelpersnormalizeastjs6160__babelTypes);

function _babelcorelibhelpersnormalizeastjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

$m['babel-core/lib/helpers/normalize-ast.js#6.16.0'].exports = $m['babel-core/lib/helpers/normalize-ast.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/helpers/normalize-ast.js ≠≠*/

/*== node_modules/babel-core/lib/tr...al-plugins/shadow-functions.js ==*/
$m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__symbol = $m['babel-runtime/core-js/symbol.js#6.11.6'].exports;

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__symbol2 = _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__interopRequireDefault(_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__symbol);

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__plugin = $m['babel-core/lib/transformation/plugin.js#6.16.0'].exports;

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__plugin2 = _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__interopRequireDefault(_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__plugin);

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_t = _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__interopRequireWildcard(_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__babelTypes);

function _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_SUPER_THIS_BOUND = (0, _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__symbol2.default)("super this bound");

var _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_superVisitor = {
  CallExpression: function CallExpression(path) {
    if (!path.get("callee").isSuper()) return;

    var node = path.node;

    if (node[_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_SUPER_THIS_BOUND]) return;
    node[_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_SUPER_THIS_BOUND] = true;

    path.replaceWith(_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_t.assignmentExpression("=", this.id, node));
  }
};

$m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'].exports.default = new _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160__plugin2.default({
  name: "internal.shadowFunctions",

  visitor: {
    ThisExpression: function ThisExpression(path) {
      _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_remap(path, "this");
    },
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      if (path.node.name === "arguments") {
        _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_remap(path, "arguments");
      }
    }
  }
});

function _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_shouldShadow(path, shadowPath) {
  if (path.is("_forceShadow")) {
    return true;
  } else {
    return shadowPath;
  }
}

function _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_remap(path, key) {
  var shadowPath = path.inShadow(key);
  if (!_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_shouldShadow(path, shadowPath)) return;

  var shadowFunction = path.node._shadowedFunctionLiteral;

  var currentFunction = void 0;
  var passedShadowFunction = false;

  var fnPath = path.findParent(function (path) {
    if (path.isProgram() || path.isFunction()) {
      currentFunction = currentFunction || path;
    }

    if (path.isProgram()) {
      passedShadowFunction = true;

      return true;
    } else if (path.isFunction() && !path.isArrowFunctionExpression()) {
      if (shadowFunction) {
        if (path === shadowFunction || path.node === shadowFunction.node) return true;
      } else {
        if (!path.is("shadow")) return true;
      }

      passedShadowFunction = true;
      return false;
    }

    return false;
  });

  if (shadowFunction && fnPath.isProgram() && !shadowFunction.isProgram()) {
    fnPath = path.findParent(function (p) {
      return p.isProgram() || p.isFunction();
    });
  }

  if (fnPath === currentFunction) return;

  if (!passedShadowFunction) return;

  var cached = fnPath.getData(key);
  if (cached) return path.replaceWith(cached);

  var id = path.scope.generateUidIdentifier(key);

  fnPath.setData(key, id);

  var classPath = fnPath.findParent(function (p) {
    return p.isClass();
  });
  var hasSuperClass = !!(classPath && classPath.node && classPath.node.superClass);

  if (key === "this" && fnPath.isMethod({ kind: "constructor" }) && hasSuperClass) {
    fnPath.scope.push({ id: id });

    fnPath.traverse(_babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_superVisitor, { id: id });
  } else {
    var init = key === "this" ? _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_t.thisExpression() : _babelcorelibtransformationinternalpluginsshadowfunctionsjs6160_t.identifier(key);

    fnPath.scope.push({ id: id, init: init });
  }

  return path.replaceWith(id);
}
$m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'].exports = $m['babel-core/lib/transformation/internal-plugins/shadow-functions.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/tr...al-plugins/shadow-functions.js ≠≠*/

/*== node_modules/babel-core/lib/tr...nternal-plugins/block-hoist.js ==*/
$m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationinternalpluginsblockhoistjs6160__plugin = $m['babel-core/lib/transformation/plugin.js#6.16.0'].exports;

var _babelcorelibtransformationinternalpluginsblockhoistjs6160__plugin2 = _babelcorelibtransformationinternalpluginsblockhoistjs6160__interopRequireDefault(_babelcorelibtransformationinternalpluginsblockhoistjs6160__plugin);

var _babelcorelibtransformationinternalpluginsblockhoistjs6160__sortBy = $m['lodash/sortBy.js#4.16.2'].exports;

var _babelcorelibtransformationinternalpluginsblockhoistjs6160__sortBy2 = _babelcorelibtransformationinternalpluginsblockhoistjs6160__interopRequireDefault(_babelcorelibtransformationinternalpluginsblockhoistjs6160__sortBy);

function _babelcorelibtransformationinternalpluginsblockhoistjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

$m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'].exports.default = new _babelcorelibtransformationinternalpluginsblockhoistjs6160__plugin2.default({

  name: "internal.blockHoist",

  visitor: {
    Block: {
      exit: function exit(_ref) {
        var node = _ref.node;

        var hasChange = false;
        for (var i = 0; i < node.body.length; i++) {
          var bodyNode = node.body[i];
          if (bodyNode && bodyNode._blockHoist != null) {
            hasChange = true;
            break;
          }
        }
        if (!hasChange) return;

        node.body = (0, _babelcorelibtransformationinternalpluginsblockhoistjs6160__sortBy2.default)(node.body, function (bodyNode) {
          var priority = bodyNode && bodyNode._blockHoist;
          if (priority == null) priority = 1;
          if (priority === true) priority = 2;

          return -1 * priority;
        });
      }
    }
  }
});
$m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'].exports = $m['babel-core/lib/transformation/internal-plugins/block-hoist.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/tr...nternal-plugins/block-hoist.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/file/logger.js ==*/
$m['babel-core/lib/transformation/file/logger.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/logger.js#6.16.0'].exports.__esModule = true;

var _babelcorelibtransformationfileloggerjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelcorelibtransformationfileloggerjs6160__classCallCheck3 = _babelcorelibtransformationfileloggerjs6160__interopRequireDefault(_babelcorelibtransformationfileloggerjs6160__classCallCheck2);

var _babelcorelibtransformationfileloggerjs6160__node = $m['debug/node.js#2.2.0'].exports;

var _babelcorelibtransformationfileloggerjs6160__node2 = _babelcorelibtransformationfileloggerjs6160__interopRequireDefault(_babelcorelibtransformationfileloggerjs6160__node);

function _babelcorelibtransformationfileloggerjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfileloggerjs6160_verboseDebug = (0, _babelcorelibtransformationfileloggerjs6160__node2.default)("babel:verbose");
var _babelcorelibtransformationfileloggerjs6160_generalDebug = (0, _babelcorelibtransformationfileloggerjs6160__node2.default)("babel");

var _babelcorelibtransformationfileloggerjs6160_seenDeprecatedMessages = [];

var _babelcorelibtransformationfileloggerjs6160_Logger = function () {
  function Logger(file, filename) {
    (0, _babelcorelibtransformationfileloggerjs6160__classCallCheck3.default)(this, Logger);

    this.filename = filename;
    this.file = file;
  }

  Logger.prototype._buildMessage = function _buildMessage(msg) {
    var parts = "[BABEL] " + this.filename;
    if (msg) parts += ": " + msg;
    return parts;
  };

  Logger.prototype.warn = function warn(msg) {
    console.warn(this._buildMessage(msg));
  };

  Logger.prototype.error = function error(msg) {
    var Constructor = arguments.length <= 1 || arguments[1] === undefined ? Error : arguments[1];

    throw new Constructor(this._buildMessage(msg));
  };

  Logger.prototype.deprecate = function deprecate(msg) {
    if (this.file.opts && this.file.opts.suppressDeprecationMessages) return;

    msg = this._buildMessage(msg);

    if (_babelcorelibtransformationfileloggerjs6160_seenDeprecatedMessages.indexOf(msg) >= 0) return;

    _babelcorelibtransformationfileloggerjs6160_seenDeprecatedMessages.push(msg);

    console.error(msg);
  };

  Logger.prototype.verbose = function verbose(msg) {
    if (_babelcorelibtransformationfileloggerjs6160_verboseDebug.enabled) _babelcorelibtransformationfileloggerjs6160_verboseDebug(this._buildMessage(msg));
  };

  Logger.prototype.debug = function debug(msg) {
    if (_babelcorelibtransformationfileloggerjs6160_generalDebug.enabled) _babelcorelibtransformationfileloggerjs6160_generalDebug(this._buildMessage(msg));
  };

  Logger.prototype.deopt = function deopt(node, msg) {
    this.debug(msg);
  };

  return Logger;
}();

$m['babel-core/lib/transformation/file/logger.js#6.16.0'].exports.default = _babelcorelibtransformationfileloggerjs6160_Logger;
$m['babel-core/lib/transformation/file/logger.js#6.16.0'].exports = $m['babel-core/lib/transformation/file/logger.js#6.16.0'].exports["default"];
/*≠≠ node_modules/babel-core/lib/transformation/file/logger.js ≠≠*/

/*== node_modules/babel-generator/lib/index.js ==*/
$m['babel-generator/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-generator/lib/index.js#6.16.0'].exports.__esModule = true;
$m['babel-generator/lib/index.js#6.16.0'].exports.CodeGenerator = undefined;

var _babelgeneratorlibindexjs6160__classCallCheck2 = $m['babel-runtime/helpers/classCallCheck.js#6.11.6'].exports;

var _babelgeneratorlibindexjs6160__classCallCheck3 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__classCallCheck2);

var _babelgeneratorlibindexjs6160__possibleConstructorReturn2 = $m['babel-runtime/helpers/possibleConstructorReturn.js#6.11.6'].exports;

var _babelgeneratorlibindexjs6160__possibleConstructorReturn3 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__possibleConstructorReturn2);

var _babelgeneratorlibindexjs6160__inherits2 = $m['babel-runtime/helpers/inherits.js#6.11.6'].exports;

var _babelgeneratorlibindexjs6160__inherits3 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__inherits2);

$m['babel-generator/lib/index.js#6.16.0'].exports.default = function (ast, opts, code) {
  var gen = new _babelgeneratorlibindexjs6160_Generator(ast, opts, code);
  return gen.generate();
};

var _babelgeneratorlibindexjs6160__detectIndent = $m['detect-indent/index.js#3.0.1'].exports;

var _babelgeneratorlibindexjs6160__detectIndent2 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__detectIndent);

var _babelgeneratorlibindexjs6160__sourceMap = $m['babel-generator/lib/source-map.js#6.16.0'].exports;

var _babelgeneratorlibindexjs6160__sourceMap2 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__sourceMap);

var _babelgeneratorlibindexjs6160__babelMessages = $m['babel-messages/lib/index.js#6.8.0'].exports;

var _babelgeneratorlibindexjs6160_messages = _babelgeneratorlibindexjs6160__interopRequireWildcard(_babelgeneratorlibindexjs6160__babelMessages);

var _babelgeneratorlibindexjs6160__printer = $m['babel-generator/lib/printer.js#6.16.0'].exports;

var _babelgeneratorlibindexjs6160__printer2 = _babelgeneratorlibindexjs6160__interopRequireDefault(_babelgeneratorlibindexjs6160__printer);

function _babelgeneratorlibindexjs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelgeneratorlibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelgeneratorlibindexjs6160_Generator = function (_Printer) {
  (0, _babelgeneratorlibindexjs6160__inherits3.default)(Generator, _Printer);

  function Generator(ast, opts, code) {
    (0, _babelgeneratorlibindexjs6160__classCallCheck3.default)(this, Generator);

    opts = opts || {};

    var tokens = ast.tokens || [];
    var format = _babelgeneratorlibindexjs6160_normalizeOptions(code, opts, tokens);
    var map = opts.sourceMaps ? new _babelgeneratorlibindexjs6160__sourceMap2.default(opts, code) : null;

    var _this = (0, _babelgeneratorlibindexjs6160__possibleConstructorReturn3.default)(this, _Printer.call(this, format, map, tokens));

    _this.ast = ast;
    return _this;
  }

  Generator.prototype.generate = function generate() {
    return _Printer.prototype.generate.call(this, this.ast);
  };

  return Generator;
}(_babelgeneratorlibindexjs6160__printer2.default);

function _babelgeneratorlibindexjs6160_normalizeOptions(code, opts, tokens) {
  var style = "  ";
  if (code && typeof code === "string") {
    var indent = (0, _babelgeneratorlibindexjs6160__detectIndent2.default)(code).indent;
    if (indent && indent !== " ") style = indent;
  }

  var format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    quotes: opts.quotes || _babelgeneratorlibindexjs6160_findCommonStringDelimiter(code, tokens),
    indent: {
      adjustMultilineComment: true,
      style: style,
      base: 0
    }
  };

  if (format.minified) {
    format.compact = true;

    format.shouldPrintComment = format.shouldPrintComment || function () {
      return format.comments;
    };
  } else {
    format.shouldPrintComment = format.shouldPrintComment || function (value) {
      return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
    };
  }

  if (format.compact === "auto") {
    format.compact = code.length > 100000;

    if (format.compact) {
      console.error("[BABEL] " + _babelgeneratorlibindexjs6160_messages.get("codeGeneratorDeopt", opts.filename, "100KB"));
    }
  }

  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }

  return format;
}

function _babelgeneratorlibindexjs6160_findCommonStringDelimiter(code, tokens) {
  var DEFAULT_STRING_DELIMITER = "double";
  if (!code) {
    return DEFAULT_STRING_DELIMITER;
  }

  var occurences = {
    single: 0,
    double: 0
  };

  var checked = 0;

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.type.label !== "string") continue;

    var raw = code.slice(token.start, token.end);
    if (raw[0] === "'") {
      occurences.single++;
    } else {
      occurences.double++;
    }

    checked++;
    if (checked >= 3) break;
  }
  if (occurences.single > occurences.double) {
    return "single";
  } else {
    return "double";
  }
}

var _babelgeneratorlibindexjs6160_CodeGenerator = $m['babel-generator/lib/index.js#6.16.0'].exports.CodeGenerator = function () {
  function CodeGenerator(ast, opts, code) {
    (0, _babelgeneratorlibindexjs6160__classCallCheck3.default)(this, CodeGenerator);

    this._generator = new _babelgeneratorlibindexjs6160_Generator(ast, opts, code);
  }

  CodeGenerator.prototype.generate = function generate() {
    return this._generator.generate();
  };

  return CodeGenerator;
}();
/*≠≠ node_modules/babel-generator/lib/index.js ≠≠*/

/*== node_modules/convert-source-map/index.js ==*/
$m['convert-source-map/index.js#1.3.0'] = { exports: {} };
'use strict';

var _convertsourcemapindexjs130_fs = require('fs');
var _convertsourcemapindexjs130_path = require('path');

var _convertsourcemapindexjs130_commentRx = /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+;)?base64,(.*)$/mg;
var _convertsourcemapindexjs130_mapFileCommentRx =
//Example (Extra space between slashes added to solve Safari bug. Exclude space in production):
//     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */
/(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;

function _convertsourcemapindexjs130_decodeBase64(base64) {
  return new Buffer(base64, 'base64').toString();
}

function _convertsourcemapindexjs130_stripComment(sm) {
  return sm.split(',').pop();
}

function _convertsourcemapindexjs130_readFromFileMap(sm, dir) {
  // NOTE: this will only work on the server since it attempts to read the map file

  var r = _convertsourcemapindexjs130_mapFileCommentRx.exec(sm);
  _convertsourcemapindexjs130_mapFileCommentRx.lastIndex = 0;

  // for some odd reason //# .. captures in 1 and /* .. */ in 2
  var filename = r[1] || r[2];
  var filepath = _convertsourcemapindexjs130_path.resolve(dir, filename);

  try {
    return _convertsourcemapindexjs130_fs.readFileSync(filepath, 'utf8');
  } catch (e) {
    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
  }
}

function _convertsourcemapindexjs130_Converter(sm, opts) {
  opts = opts || {};

  if (opts.isFileComment) sm = _convertsourcemapindexjs130_readFromFileMap(sm, opts.commentFileDir);
  if (opts.hasComment) sm = _convertsourcemapindexjs130_stripComment(sm);
  if (opts.isEncoded) sm = _convertsourcemapindexjs130_decodeBase64(sm);
  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);

  this.sourcemap = sm;
}

function _convertsourcemapindexjs130_convertFromLargeSource(content) {
  var lines = content.split('\n');
  var line;
  // find first line which contains a source map starting at end of content
  for (var i = lines.length - 1; i > 0; i--) {
    line = lines[i];
    if (~line.indexOf('sourceMappingURL=data:')) return $m['convert-source-map/index.js#1.3.0'].exports.fromComment(line);
  }
}

_convertsourcemapindexjs130_Converter.prototype.toJSON = function (space) {
  return JSON.stringify(this.sourcemap, null, space);
};

_convertsourcemapindexjs130_Converter.prototype.toBase64 = function () {
  var json = this.toJSON();
  return new Buffer(json).toString('base64');
};

_convertsourcemapindexjs130_Converter.prototype.toComment = function (options) {
  var base64 = this.toBase64();
  var data = 'sourceMappingURL=data:application/json;base64,' + base64;
  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
};

// returns copy instead of original
_convertsourcemapindexjs130_Converter.prototype.toObject = function () {
  return JSON.parse(this.toJSON());
};

_convertsourcemapindexjs130_Converter.prototype.addProperty = function (key, value) {
  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');
  return this.setProperty(key, value);
};

_convertsourcemapindexjs130_Converter.prototype.setProperty = function (key, value) {
  this.sourcemap[key] = value;
  return this;
};

_convertsourcemapindexjs130_Converter.prototype.getProperty = function (key) {
  return this.sourcemap[key];
};

$m['convert-source-map/index.js#1.3.0'].exports.fromObject = function (obj) {
  return new _convertsourcemapindexjs130_Converter(obj);
};

$m['convert-source-map/index.js#1.3.0'].exports.fromJSON = function (json) {
  return new _convertsourcemapindexjs130_Converter(json, { isJSON: true });
};

$m['convert-source-map/index.js#1.3.0'].exports.fromBase64 = function (base64) {
  return new _convertsourcemapindexjs130_Converter(base64, { isEncoded: true });
};

$m['convert-source-map/index.js#1.3.0'].exports.fromComment = function (comment) {
  comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');

  return new _convertsourcemapindexjs130_Converter(comment, { isEncoded: true, hasComment: true });
};

$m['convert-source-map/index.js#1.3.0'].exports.fromMapFileComment = function (comment, dir) {
  return new _convertsourcemapindexjs130_Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
};

// Finds last sourcemap comment in file or returns null if none was found
$m['convert-source-map/index.js#1.3.0'].exports.fromSource = function (content, largeSource) {
  if (largeSource) {
    var res = _convertsourcemapindexjs130_convertFromLargeSource(content);
    return res ? res : null;
  }

  var m = content.match(_convertsourcemapindexjs130_commentRx);
  _convertsourcemapindexjs130_commentRx.lastIndex = 0;
  return m ? $m['convert-source-map/index.js#1.3.0'].exports.fromComment(m.pop()) : null;
};

// Finds last sourcemap comment in file or returns null if none was found
$m['convert-source-map/index.js#1.3.0'].exports.fromMapFileSource = function (content, dir) {
  var m = content.match(_convertsourcemapindexjs130_mapFileCommentRx);
  _convertsourcemapindexjs130_mapFileCommentRx.lastIndex = 0;
  return m ? $m['convert-source-map/index.js#1.3.0'].exports.fromMapFileComment(m.pop(), dir) : null;
};

$m['convert-source-map/index.js#1.3.0'].exports.removeComments = function (src) {
  _convertsourcemapindexjs130_commentRx.lastIndex = 0;
  return src.replace(_convertsourcemapindexjs130_commentRx, '');
};

$m['convert-source-map/index.js#1.3.0'].exports.removeMapFileComments = function (src) {
  _convertsourcemapindexjs130_mapFileCommentRx.lastIndex = 0;
  return src.replace(_convertsourcemapindexjs130_mapFileCommentRx, '');
};

$m['convert-source-map/index.js#1.3.0'].exports.generateMapFileComment = function (file, options) {
  var data = 'sourceMappingURL=' + file;
  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
};

Object.defineProperty($m['convert-source-map/index.js#1.3.0'].exports, 'commentRegex', {
  get: function getCommentRegex() {
    _convertsourcemapindexjs130_commentRx.lastIndex = 0;
    return _convertsourcemapindexjs130_commentRx;
  }
});

Object.defineProperty($m['convert-source-map/index.js#1.3.0'].exports, 'mapFileCommentRegex', {
  get: function getMapFileCommentRegex() {
    _convertsourcemapindexjs130_mapFileCommentRx.lastIndex = 0;
    return _convertsourcemapindexjs130_mapFileCommentRx;
  }
});
/*≠≠ node_modules/convert-source-map/index.js ≠≠*/

/*== node_modules/babel-core/lib/transformation/file/metadata.js ==*/
$m['babel-core/lib/transformation/file/metadata.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.__esModule = true;
$m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.ImportDeclaration = $m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.ModuleDeclaration = undefined;

var _babelcorelibtransformationfilemetadatajs6160__getIterator2 = $m['babel-runtime/core-js/get-iterator.js#6.11.6'].exports;

var _babelcorelibtransformationfilemetadatajs6160__getIterator3 = _babelcorelibtransformationfilemetadatajs6160__interopRequireDefault(_babelcorelibtransformationfilemetadatajs6160__getIterator2);

$m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.ExportDeclaration = _babelcorelibtransformationfilemetadatajs6160_ExportDeclaration;
$m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.Scope = _babelcorelibtransformationfilemetadatajs6160_Scope;

var _babelcorelibtransformationfilemetadatajs6160__babelTypes = $m['babel-types/lib/index.js#6.16.0'].exports;

var _babelcorelibtransformationfilemetadatajs6160_t = _babelcorelibtransformationfilemetadatajs6160__interopRequireWildcard(_babelcorelibtransformationfilemetadatajs6160__babelTypes);

function _babelcorelibtransformationfilemetadatajs6160__interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _babelcorelibtransformationfilemetadatajs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _babelcorelibtransformationfilemetadatajs6160_ModuleDeclaration = $m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.ModuleDeclaration = {
  enter: function enter(path, file) {
    var node = path.node;

    if (node.source) {
      node.source.value = file.resolveModuleSource(node.source.value);
    }
  }
};

var _babelcorelibtransformationfilemetadatajs6160_ImportDeclaration = $m['babel-core/lib/transformation/file/metadata.js#6.16.0'].exports.ImportDeclaration = {
  exit: function exit(path, file) {
    var node = path.node;

    var specifiers = [];
    var imported = [];
    file.metadata.modules.imports.push({
      source: node.source.value,
      imported: imported,
      specifiers: specifiers
    });

    for (var _iterator = path.get("specifiers"), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _babelcorelibtransformationfilemetadatajs6160__getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var specifier = _ref;

      var local = specifier.node.local.name;

      if (specifier.isImportDefaultSpecifier()) {
        imported.push("default");
        specifiers.push({
          kind: "named",
          imported: "default",
          local: local
        });
      }

      if (specifier.isImportSpecifier()) {
        var importedName = specifier.node.imported.name;
        imported.push(importedName);
        specifiers.push({
          kind: "named",
          imported: importedName,
          local: local
        });
      }

      if (specifier.isImportNamespaceSpecifier()) {
        imported.push("*");
        specifiers.push({
          kind: "namespace",
          local: local
        });
      }
    }
  }
};

function _babelcorelibtransformationfilemetadatajs6160_ExportDeclaration(path, file) {
  var node = path.node;

  var source = node.source ? node.source.value : null;
  var exports = file.metadata.modules.exports;

  var declar = path.get("declaration");
  if (declar.isStatement()) {
    var bindings = declar.getBindingIdentifiers();

    for (var name in bindings) {
      exports.exported.push(name);
      exports.specifiers.push({
        kind: "local",
        local: name,
        exported: path.isExportDefaultDeclaration() ? "default" : name
      });
    }
  }

  if (path.isExportNamedDeclaration() && node.specifiers) {
    for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _babelcorelibtransformationfilemetadatajs6160__getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var specifier = _ref2;

      var exported = specifier.exported.name;
      exports.exported.push(exported);

      if (_babelcorelibtransformationfilemetadatajs6160_t.isExportDefaultSpecifier(specifier)) {
        exports.specifiers.push({
          kind: "external",
          local: exported,
          exported: exported,
          source: source
        });
      }

      if (_babelcorelibtransformationfilemetadatajs6160_t.isExportNamespaceSpecifier(specifier)) {
        exports.specifiers.push({
          kind: "external-namespace",
          exported: exported,
          source: source
        });
      }

      var local = specifier.local;
      if (!local) continue;

      if (source) {
        exports.specifiers.push({
          kind: "external",
          local: local.name,
          exported: exported,
          source: source
        });
      }

      if (!source) {
        exports.specifiers.push({
          kind: "local",
          local: local.name,
          exported: exported
        });
      }
    }
  }

  if (path.isExportAllDeclaration()) {
    exports.specifiers.push({
      kind: "external-all",
      source: source
    });
  }
}

function _babelcorelibtransformationfilemetadatajs6160_Scope(path) {
  path.skip();
}
/*≠≠ node_modules/babel-core/lib/transformation/file/metadata.js ≠≠*/

/*== node_modules/babel-helpers/lib/index.js ==*/
$m['babel-helpers/lib/index.js#6.16.0'] = { exports: {} };
"use strict";

$m['babel-helpers/lib/index.js#6.16.0'].exports.__esModule = true;
$m['babel-helpers/lib/index.js#6.16.0'].exports.list = undefined;

var _babelhelperslibindexjs6160__keys = $m['babel-runtime/core-js/object/keys.js#6.11.6'].exports;

var _babelhelperslibindexjs6160__keys2 = _babelhelperslibindexjs6160__interopRequireDefault(_babelhelperslibindexjs6160__keys);

$m['babel-helpers/lib/index.js#6.16.0'].exports.get = _babelhelperslibindexjs6160_get;

var _babelhelperslibindexjs6160__helpers = $m['babel-helpers/lib/helpers.js#6.16.0'].exports;

var _babelhelperslibindexjs6160__helpers2 = _babelhelperslibindexjs6160__interopRequireDefault(_babelhelperslibindexjs6160__helpers);

function _babelhelperslibindexjs6160__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _babelhelperslibindexjs6160_get(name) {
  var fn = _babelhelperslibindexjs6160__helpers2.default[name];
  if (!fn) throw new ReferenceError("Unknown helper " + name);

  return fn().expression;
}

var _babelhelperslibindexjs6160_list = $m['babel-helpers/lib/index.js#6.16.0'].exports.list = (0, _babelhelperslibindexjs6160__keys2.default)(_babelhelperslibindexjs6160__helpers2.default).map(function (name) {
  return name[0] === "_" ? name.slice(1) : name;
}).filter(function (name) {
  return name !== "__esModule";
});

$m['babel-helpers/lib/index.js#6.16.0'].exports.default = _babelhelperslibindexjs6160_get;
/*≠≠ node_modules/babel-helpers/lib/index.js ≠≠*/

/*== node_modules/lodash/_nativeKeys.js ==*/
$m['lodash/_nativeKeys.js#4.16.2'] = { exports: {} };
var _lodashnativeKeysjs4162_overArg = $m['lodash/_overArg.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashnativeKeysjs4162_nativeKeys = _lodashnativeKeysjs4162_overArg(Object.keys, Object);

$m['lodash/_nativeKeys.js#4.16.2'].exports = _lodashnativeKeysjs4162_nativeKeys;
/*≠≠ node_modules/lodash/_nativeKeys.js ≠≠*/

/*== node_modules/lodash/_hashSet.js ==*/
$m['lodash/_hashSet.js#4.16.2'] = { exports: {} };
var _lodashhashSetjs4162_nativeCreate = $m['lodash/_nativeCreate.js#4.16.2'].exports;

/** Used to stand-in for `undefined` hash values. */
var _lodashhashSetjs4162_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function _lodashhashSetjs4162_hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _lodashhashSetjs4162_nativeCreate && value === undefined ? _lodashhashSetjs4162_HASH_UNDEFINED : value;
  return this;
}

$m['lodash/_hashSet.js#4.16.2'].exports = _lodashhashSetjs4162_hashSet;
/*≠≠ node_modules/lodash/_hashSet.js ≠≠*/

/*== node_modules/lodash/_hashHas.js ==*/
$m['lodash/_hashHas.js#4.16.2'] = { exports: {} };
var _lodashhashHasjs4162_nativeCreate = $m['lodash/_nativeCreate.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashhashHasjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashhashHasjs4162_hasOwnProperty = _lodashhashHasjs4162_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashhashHasjs4162_hashHas(key) {
  var data = this.__data__;
  return _lodashhashHasjs4162_nativeCreate ? data[key] !== undefined : _lodashhashHasjs4162_hasOwnProperty.call(data, key);
}

$m['lodash/_hashHas.js#4.16.2'].exports = _lodashhashHasjs4162_hashHas;
/*≠≠ node_modules/lodash/_hashHas.js ≠≠*/

/*== node_modules/lodash/_hashGet.js ==*/
$m['lodash/_hashGet.js#4.16.2'] = { exports: {} };
var _lodashhashGetjs4162_nativeCreate = $m['lodash/_nativeCreate.js#4.16.2'].exports;

/** Used to stand-in for `undefined` hash values. */
var _lodashhashGetjs4162_HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _lodashhashGetjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashhashGetjs4162_hasOwnProperty = _lodashhashGetjs4162_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashhashGetjs4162_hashGet(key) {
  var data = this.__data__;
  if (_lodashhashGetjs4162_nativeCreate) {
    var result = data[key];
    return result === _lodashhashGetjs4162_HASH_UNDEFINED ? undefined : result;
  }
  return _lodashhashGetjs4162_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

$m['lodash/_hashGet.js#4.16.2'].exports = _lodashhashGetjs4162_hashGet;
/*≠≠ node_modules/lodash/_hashGet.js ≠≠*/

/*== node_modules/lodash/_hashClear.js ==*/
$m['lodash/_hashClear.js#4.16.2'] = { exports: {} };
var _lodashhashClearjs4162_nativeCreate = $m['lodash/_nativeCreate.js#4.16.2'].exports;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function _lodashhashClearjs4162_hashClear() {
  this.__data__ = _lodashhashClearjs4162_nativeCreate ? _lodashhashClearjs4162_nativeCreate(null) : {};
  this.size = 0;
}

$m['lodash/_hashClear.js#4.16.2'].exports = _lodashhashClearjs4162_hashClear;
/*≠≠ node_modules/lodash/_hashClear.js ≠≠*/

/*== node_modules/lodash/_isMasked.js ==*/
$m['lodash/_isMasked.js#4.16.2'] = { exports: {} };
var _lodashisMaskedjs4162_coreJsData = $m['lodash/_coreJsData.js#4.16.2'].exports;

/** Used to detect methods masquerading as native. */
var _lodashisMaskedjs4162_maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_lodashisMaskedjs4162_coreJsData && _lodashisMaskedjs4162_coreJsData.keys && _lodashisMaskedjs4162_coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function _lodashisMaskedjs4162_isMasked(func) {
  return !!_lodashisMaskedjs4162_maskSrcKey && _lodashisMaskedjs4162_maskSrcKey in func;
}

$m['lodash/_isMasked.js#4.16.2'].exports = _lodashisMaskedjs4162_isMasked;
/*≠≠ node_modules/lodash/_isMasked.js ≠≠*/

/*== node_modules/inline-source/lib/utils.js ==*/
$m['inline-source/lib/utils.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibutilsjs511_isPlainObject = $m['is-plain-obj/index.js#1.1.0'].exports;
const _inlinesourcelibutilsjs511_path = require('path');

const _inlinesourcelibutilsjs511_ATTRIBUTE_BLACKLIST = ['href', 'rel', 'src', 'data', 'xmlns', 'xmlns:xlink', 'version', 'baseprofile'];
const _inlinesourcelibutilsjs511_RE_ESCAPE = /[-\/\\^$*+?.()|[\]{}]/g;
// Multiline, tags
const _inlinesourcelibutilsjs511_RE_NOT_FILEPATH = /[\r\n<>]/gm;

$m['inline-source/lib/utils.js#5.1.1'].exports = {
  /**
   * Determine if 'str' is likely a filepath
   * @param {String} str
   * @returns {Boolean}
   */
  isFilepath(str) {
    _inlinesourcelibutilsjs511_RE_NOT_FILEPATH.lastIndex = 0;
    if (str) return !_inlinesourcelibutilsjs511_RE_NOT_FILEPATH.test(str);
    return false;
  },

  /**
   * Retrieve tag regexp for 'attribute'
   * @param {String} attribute
   * @returns {RegExp}
   */
  getTagRegExp(attribute) {
    // <([a-zA-Z]+)\b[^>]*?\s(?:inline [^>]*?|inline|inline=([\'\"]).*?\2[^>]*?)>(?:<\/\1\s?>)?
    return new RegExp('<([a-zA-Z]+)\\b[^>]*?\\s(?:' + attribute + ' [^>]*?|' + attribute + '|' + attribute + '=([\\\'\\\"])(?:true|' + attribute + ')\\2[^>]*?)>(?:<\\/\\1\\s?>)?', 'gm');
  },

  /**
   * Parse 'attributes'
   * @param {Object} attributes
   * @returns {Object}
   */
  parseAttributes(attributes) {
    for (const prop in attributes) {
      // Parse boolean values
      if (attributes[prop] === '') attributes[prop] = true;
    }

    return attributes;
  },

  /**
   * Parse props with 'prefix' from 'attributes'
   * @param {Object} attributes
   * @param {String} prefix
   * @returns {Object}
   */
  parseProps(attributes, prefix) {
    prefix += '-';

    let props = {};

    for (const prop in attributes) {
      // Strip 'inline-' and store
      if (prop.indexOf(prefix) == 0) {
        props[prop.slice(prefix.length)] = attributes[prop];
      }
    }

    return props;
  },

  /**
   * Retrieve resolved 'filepath' and optional anchor
   * @param {String} filepath
   * @param {String} htmlpath
   * @param {String} rootpath
   * @returns {Array}
   */
  getSourcepath(filepath, htmlpath, rootpath) {
    if (filepath) {
      // Relative path
      if (htmlpath && filepath.indexOf('./') == 0 || filepath.indexOf('../') == 0) {
        filepath = _inlinesourcelibutilsjs511_path.resolve(_inlinesourcelibutilsjs511_path.dirname(htmlpath), filepath);
      } else {
        // Strip leading '/'
        if (filepath.indexOf('/') == 0) filepath = filepath.slice(1);
      }
      if (~filepath.indexOf('#')) filepath = filepath.split('#');

      return Array.isArray(filepath) ? [_inlinesourcelibutilsjs511_path.resolve(rootpath, filepath[0]), filepath[1]] : [_inlinesourcelibutilsjs511_path.resolve(rootpath, filepath), ''];
    }

    return ['', ''];
  },

  /**
   * Retrieve type based on 'type'
   * @param {String} type
   * @returns {String}
   */
  getTypeFromType(type) {
    if (type) {
      switch (type) {
        case 'application/javascript':
        case 'application/x-javascript':
        case 'application/ecmascript':
        case 'text/javascript':
        case 'text/ecmascript':
        case 'javascript':
        case 'js':
        case 'ecmascript':
          return 'js';
        case 'text/css':
        case 'css':
          return 'css';
        case 'image/png':
        case 'image/gif':
        case 'image/jpeg':
        case 'image/jpg':
        case 'image/svg+xml':
        case 'image/svg':
        case 'png':
        case 'gif':
        case 'jpeg':
        case 'jpg':
        case 'svg':
        case 'image':
          return 'image';
        case 'application/json':
        case 'text/json':
        case 'json':
          return 'json';
        default:
          return type;
      }
    }
  },

  /**
   * Retrieve type based on 'tag'
   * @param {String} tag
   * @returns {String}
   */
  getTypeFromTag(tag) {
    if (tag) {
      switch (tag) {
        case 'script':
          return 'js';
        case 'link':
          return 'css';
        case 'img':
        case 'object':
          return 'image';
        default:
          return '';
      }
    }
  },

  /**
   * Retrieve format based on 'extension'
   * @param {String} extension
   * @returns {String}
   */
  getFormatFromExtension(extension) {
    if (extension) {
      switch (extension) {
        case 'js':
          return 'js';
        case 'json':
          return 'json';
        case 'css':
          return 'css';
        case 'gif':
          return 'gif';
        case 'png':
          return 'png';
        case 'jpeg':
        case 'jpg':
          return 'jpeg';
        case 'svg':
          return 'svg+xml';
        default:
          return extension;
      }
    }
  },

  /**
   * Retrieve leading whitespace for 'source' in 'html'
   * @param {String} source
   * @param {String} html
   * @returns {String}
   */
  getPadding(source, html) {
    const re = new RegExp('^([\\t ]+)' + this.escape(source), 'gm');
    const match = re.exec(html);

    return match ? match[1] : '';
  },

  /**
   * Retrieve stringified attributes
   * @param {Object} attributes
   * @param {String} prefix
   * @param {Boolean} strict
   * @returns {String}
   */
  getAttributeString(attributes, prefix, strict) {
    let str = '';

    for (const prop in attributes) {
      // Ignore blacklisted and prefixed attributes
      const include = strict ? prop.indexOf(prefix) != 0 && !~_inlinesourcelibutilsjs511_ATTRIBUTE_BLACKLIST.indexOf(prop) : prop.indexOf(prefix) != 0;

      if (include) {
        str += attributes[prop] === true ? ' ' + prop : ' ' + prop + '="' + attributes[prop] + '"';
      }
    }

    return str;
  },

  /**
   * Retrieve ignored state for 'tag' or 'type' or 'format'
   * @param {String | Array} ignore
   * @param {String} tag
   * @param {String} type
   * @param {String} format
   * @returns {Boolean}
   */
  isIgnored(ignore, tag, type, format) {
    // Clean svg+xml ==> svg
    const formatAlt = format && format.indexOf('+') ? format.split('+')[0] : null;

    // Backwards compat for 3.x style format
    if (_inlinesourcelibutilsjs511_isPlainObject(ignore)) {
      let ig = [];

      for (const prop in ignore) {
        if (Array.isArray(ignore[prop])) {
          ig = ig.concat(ignore[prop]);
        } else {
          ig.push(ignore[prop]);
        }
      }
      ignore = ig;
    }

    if (!Array.isArray(ignore)) ignore = [ignore];

    return !!(~ignore.indexOf(tag) || ~ignore.indexOf(type) || ~ignore.indexOf(format) || ~ignore.indexOf(formatAlt));
  },

  /**
   * Escape 'str' for use in RegExp constructor
   * @param {String} str
   * @returns {String}
   */
  escape(str) {
    return str.replace(_inlinesourcelibutilsjs511_RE_ESCAPE, '\\$&');
  },

  /**
   * No op
   * @param {Error} [err]
   */
  noop(err) {
    if (err) throw err;
  }
};
/*≠≠ node_modules/inline-source/lib/utils.js ≠≠*/

/*== node_modules/lodash/_baseFor.js ==*/
$m['lodash/_baseFor.js#4.16.2'] = { exports: {} };
var _lodashbaseForjs4162_createBaseFor = $m['lodash/_createBaseFor.js#4.16.2'].exports;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var _lodashbaseForjs4162_baseFor = _lodashbaseForjs4162_createBaseFor();

$m['lodash/_baseFor.js#4.16.2'].exports = _lodashbaseForjs4162_baseFor;
/*≠≠ node_modules/lodash/_baseFor.js ≠≠*/

/*== node_modules/lodash/_baseGet.js ==*/
$m['lodash/_baseGet.js#4.16.2'] = { exports: {} };
var _lodashbaseGetjs4162_castPath = $m['lodash/_castPath.js#4.16.2'].exports,
    _lodashbaseGetjs4162_isKey = $m['lodash/_isKey.js#4.16.2'].exports,
    _lodashbaseGetjs4162_toKey = $m['lodash/_toKey.js#4.16.2'].exports;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function _lodashbaseGetjs4162_baseGet(object, path) {
  path = _lodashbaseGetjs4162_isKey(path, object) ? [path] : _lodashbaseGetjs4162_castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_lodashbaseGetjs4162_toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

$m['lodash/_baseGet.js#4.16.2'].exports = _lodashbaseGetjs4162_baseGet;
/*≠≠ node_modules/lodash/_baseGet.js ≠≠*/

/*== node_modules/lodash/_isStrictComparable.js ==*/
$m['lodash/_isStrictComparable.js#4.16.2'] = { exports: {} };
var _lodashisStrictComparablejs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports;

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function _lodashisStrictComparablejs4162_isStrictComparable(value) {
  return value === value && !_lodashisStrictComparablejs4162_isObject(value);
}

$m['lodash/_isStrictComparable.js#4.16.2'].exports = _lodashisStrictComparablejs4162_isStrictComparable;
/*≠≠ node_modules/lodash/_isStrictComparable.js ≠≠*/

/*== node_modules/once/once.js ==*/
$m['once/once.js#1.4.0'] = { exports: {} };
var _onceoncejs140_wrappy = $m['wrappy/wrappy.js#1.0.2'].exports;
$m['once/once.js#1.4.0'].exports = _onceoncejs140_wrappy(_onceoncejs140_once);
$m['once/once.js#1.4.0'].exports.strict = _onceoncejs140_wrappy(_onceoncejs140_onceStrict);

_onceoncejs140_once.proto = _onceoncejs140_once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return _onceoncejs140_once(this);
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return _onceoncejs140_onceStrict(this);
    },
    configurable: true
  });
});

function _onceoncejs140_once(fn) {
  var f = function () {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}

function _onceoncejs140_onceStrict(fn) {
  var f = function () {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
/*≠≠ node_modules/once/once.js ≠≠*/

/*== node_modules/brace-expansion/index.js ==*/
$m['brace-expansion/index.js#1.1.6'] = { exports: {} };
var _braceexpansionindexjs116_concatMap = $m['concat-map/index.js#0.0.1'].exports;
var _braceexpansionindexjs116_balanced = $m['balanced-match/index.js#0.4.2'].exports;

$m['brace-expansion/index.js#1.1.6'].exports = _braceexpansionindexjs116_expandTop;

var _braceexpansionindexjs116_escSlash = '\0SLASH' + Math.random() + '\0';
var _braceexpansionindexjs116_escOpen = '\0OPEN' + Math.random() + '\0';
var _braceexpansionindexjs116_escClose = '\0CLOSE' + Math.random() + '\0';
var _braceexpansionindexjs116_escComma = '\0COMMA' + Math.random() + '\0';
var _braceexpansionindexjs116_escPeriod = '\0PERIOD' + Math.random() + '\0';

function _braceexpansionindexjs116_numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function _braceexpansionindexjs116_escapeBraces(str) {
  return str.split('\\\\').join(_braceexpansionindexjs116_escSlash).split('\\{').join(_braceexpansionindexjs116_escOpen).split('\\}').join(_braceexpansionindexjs116_escClose).split('\\,').join(_braceexpansionindexjs116_escComma).split('\\.').join(_braceexpansionindexjs116_escPeriod);
}

function _braceexpansionindexjs116_unescapeBraces(str) {
  return str.split(_braceexpansionindexjs116_escSlash).join('\\').split(_braceexpansionindexjs116_escOpen).join('{').split(_braceexpansionindexjs116_escClose).join('}').split(_braceexpansionindexjs116_escComma).join(',').split(_braceexpansionindexjs116_escPeriod).join('.');
}

// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function _braceexpansionindexjs116_parseCommaParts(str) {
  if (!str) return [''];

  var parts = [];
  var m = _braceexpansionindexjs116_balanced('{', '}', str);

  if (!m) return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length - 1] += '{' + body + '}';
  var postParts = _braceexpansionindexjs116_parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function _braceexpansionindexjs116_expandTop(str) {
  if (!str) return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return _braceexpansionindexjs116_expand(_braceexpansionindexjs116_escapeBraces(str), true).map(_braceexpansionindexjs116_unescapeBraces);
}

function _braceexpansionindexjs116_identity(e) {
  return e;
}

function _braceexpansionindexjs116_embrace(str) {
  return '{' + str + '}';
}
function _braceexpansionindexjs116_isPadded(el) {
  return (/^-?0\d/.test(el)
  );
}

function _braceexpansionindexjs116_lte(i, y) {
  return i <= y;
}
function _braceexpansionindexjs116_gte(i, y) {
  return i >= y;
}

function _braceexpansionindexjs116_expand(str, isTop) {
  var expansions = [];

  var m = _braceexpansionindexjs116_balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + _braceexpansionindexjs116_escClose + m.post;
      return _braceexpansionindexjs116_expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = _braceexpansionindexjs116_parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = _braceexpansionindexjs116_expand(n[0], false).map(_braceexpansionindexjs116_embrace);
      if (n.length === 1) {
        var post = m.post.length ? _braceexpansionindexjs116_expand(m.post, false) : [''];
        return post.map(function (p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length ? _braceexpansionindexjs116_expand(m.post, false) : [''];

  var N;

  if (isSequence) {
    var x = _braceexpansionindexjs116_numeric(n[0]);
    var y = _braceexpansionindexjs116_numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(_braceexpansionindexjs116_numeric(n[2])) : 1;
    var test = _braceexpansionindexjs116_lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = _braceexpansionindexjs116_gte;
    }
    var pad = n.some(_braceexpansionindexjs116_isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\') c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = _braceexpansionindexjs116_concatMap(n, function (el) {
      return _braceexpansionindexjs116_expand(el, false);
    });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion) expansions.push(expansion);
    }
  }

  return expansions;
}
/*≠≠ node_modules/brace-expansion/index.js ≠≠*/

/*== node_modules/fs.realpath/old.js ==*/
$m['fs.realpath/old.js#1.0.0'] = { exports: {} };
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var _fsrealpatholdjs100_pathModule = require('path');
var _fsrealpatholdjs100_isWindows = process.platform === 'win32';
var _fsrealpatholdjs100_fs = require('fs');

// JavaScript implementation of realpath, ported from node pre-v6

var _fsrealpatholdjs100_DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function _fsrealpatholdjs100_rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (_fsrealpatholdjs100_DEBUG) {
    var backtrace = new Error();
    callback = debugCallback;
  } else callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process.traceDeprecation) console.trace(msg);else console.error(msg);
        }
    }
  }
}

function _fsrealpatholdjs100_maybeCallback(cb) {
  return typeof cb === 'function' ? cb : _fsrealpatholdjs100_rethrow();
}

var _fsrealpatholdjs100_normalize = _fsrealpatholdjs100_pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (_fsrealpatholdjs100_isWindows) {
  var _fsrealpatholdjs100_nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var _fsrealpatholdjs100_nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (_fsrealpatholdjs100_isWindows) {
  var _fsrealpatholdjs100_splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var _fsrealpatholdjs100_splitRootRe = /^[\/]*/;
}

$m['fs.realpath/old.js#1.0.0'].exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = _fsrealpatholdjs100_pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = _fsrealpatholdjs100_splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (_fsrealpatholdjs100_isWindows && !knownHard[base]) {
      _fsrealpatholdjs100_fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    _fsrealpatholdjs100_nextPartRe.lastIndex = pos;
    var result = _fsrealpatholdjs100_nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = _fsrealpatholdjs100_nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || cache && cache[base] === base) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = _fsrealpatholdjs100_fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!_fsrealpatholdjs100_isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        _fsrealpatholdjs100_fs.statSync(base);
        linkTarget = _fsrealpatholdjs100_fs.readlinkSync(base);
      }
      resolvedLink = _fsrealpatholdjs100_pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!_fsrealpatholdjs100_isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = _fsrealpatholdjs100_pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};

$m['fs.realpath/old.js#1.0.0'].exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = _fsrealpatholdjs100_maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = _fsrealpatholdjs100_pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = _fsrealpatholdjs100_splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (_fsrealpatholdjs100_isWindows && !knownHard[base]) {
      _fsrealpatholdjs100_fs.lstat(base, function (err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    _fsrealpatholdjs100_nextPartRe.lastIndex = pos;
    var result = _fsrealpatholdjs100_nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = _fsrealpatholdjs100_nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || cache && cache[base] === base) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return _fsrealpatholdjs100_fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!_fsrealpatholdjs100_isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    _fsrealpatholdjs100_fs.stat(base, function (err) {
      if (err) return cb(err);

      _fsrealpatholdjs100_fs.readlink(base, function (err, target) {
        if (!_fsrealpatholdjs100_isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = _fsrealpatholdjs100_pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = _fsrealpatholdjs100_pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
/*≠≠ node_modules/fs.realpath/old.js ≠≠*/

/*== node_modules/fs.realpath/index.js ==*/
$m['fs.realpath/index.js#1.0.0'] = { exports: {} };
$m['fs.realpath/index.js#1.0.0'].exports = _fsrealpathindexjs100_realpath;
_fsrealpathindexjs100_realpath.realpath = _fsrealpathindexjs100_realpath;
_fsrealpathindexjs100_realpath.sync = _fsrealpathindexjs100_realpathSync;
_fsrealpathindexjs100_realpath.realpathSync = _fsrealpathindexjs100_realpathSync;
_fsrealpathindexjs100_realpath.monkeypatch = _fsrealpathindexjs100_monkeypatch;
_fsrealpathindexjs100_realpath.unmonkeypatch = _fsrealpathindexjs100_unmonkeypatch;

var _fsrealpathindexjs100_fs = require('fs');
var _fsrealpathindexjs100_origRealpath = _fsrealpathindexjs100_fs.realpath;
var _fsrealpathindexjs100_origRealpathSync = _fsrealpathindexjs100_fs.realpathSync;

var _fsrealpathindexjs100_version = process.version;
var _fsrealpathindexjs100_ok = /^v[0-5]\./.test(_fsrealpathindexjs100_version);
var _fsrealpathindexjs100_old = $m['fs.realpath/old.js#1.0.0'].exports;

function _fsrealpathindexjs100_newError(er) {
  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
}

function _fsrealpathindexjs100_realpath(p, cache, cb) {
  if (_fsrealpathindexjs100_ok) {
    return _fsrealpathindexjs100_origRealpath(p, cache, cb);
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }
  _fsrealpathindexjs100_origRealpath(p, cache, function (er, result) {
    if (_fsrealpathindexjs100_newError(er)) {
      _fsrealpathindexjs100_old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function _fsrealpathindexjs100_realpathSync(p, cache) {
  if (_fsrealpathindexjs100_ok) {
    return _fsrealpathindexjs100_origRealpathSync(p, cache);
  }

  try {
    return _fsrealpathindexjs100_origRealpathSync(p, cache);
  } catch (er) {
    if (_fsrealpathindexjs100_newError(er)) {
      return _fsrealpathindexjs100_old.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}

function _fsrealpathindexjs100_monkeypatch() {
  _fsrealpathindexjs100_fs.realpath = _fsrealpathindexjs100_realpath;
  _fsrealpathindexjs100_fs.realpathSync = _fsrealpathindexjs100_realpathSync;
}

function _fsrealpathindexjs100_unmonkeypatch() {
  _fsrealpathindexjs100_fs.realpath = _fsrealpathindexjs100_origRealpath;
  _fsrealpathindexjs100_fs.realpathSync = _fsrealpathindexjs100_origRealpathSync;
}
/*≠≠ node_modules/fs.realpath/index.js ≠≠*/

/*== node_modules/inflight/inflight.js ==*/
$m['inflight/inflight.js#1.0.5'] = { exports: {} };
var _inflightinflightjs105_wrappy = $m['wrappy/wrappy.js#1.0.2'].exports;
var _inflightinflightjs105_reqs = Object.create(null);
var _inflightinflightjs105_once = $m['once/once.js#1.4.0'].exports;

$m['inflight/inflight.js#1.0.5'].exports = _inflightinflightjs105_wrappy(_inflightinflightjs105_inflight);

function _inflightinflightjs105_inflight(key, cb) {
  if (_inflightinflightjs105_reqs[key]) {
    _inflightinflightjs105_reqs[key].push(cb);
    return null;
  } else {
    _inflightinflightjs105_reqs[key] = [cb];
    return _inflightinflightjs105_makeres(key);
  }
}

function _inflightinflightjs105_makeres(key) {
  return _inflightinflightjs105_once(function RES() {
    var cbs = _inflightinflightjs105_reqs[key];
    var len = cbs.length;
    var args = _inflightinflightjs105_slice(arguments);
    for (var i = 0; i < len; i++) {
      cbs[i].apply(null, args);
    }
    if (cbs.length > len) {
      // added more in the interim.
      // de-zalgo, just in case, but don't call again.
      cbs.splice(0, len);
      process.nextTick(function () {
        RES.apply(null, args);
      });
    } else {
      delete _inflightinflightjs105_reqs[key];
    }
  });
}

function _inflightinflightjs105_slice(args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];
  return array;
}
/*≠≠ node_modules/inflight/inflight.js ≠≠*/

/*== node_modules/glob/glob.js ==*/
$m['glob/glob.js#7.1.0'] = { exports: {} };
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

$m['glob/glob.js#7.1.0'].exports = _globglobjs710_glob;

var _globglobjs710_fs = require('fs');
var _globglobjs710_rp = $m['fs.realpath/index.js#1.0.0'].exports;
var _globglobjs710_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globglobjs710_Minimatch = _globglobjs710_minimatch.Minimatch;
var _globglobjs710_inherits = $m['inherits/inherits_browser.js#2.0.3'].exports;
var _globglobjs710_EE = require('events').EventEmitter;
var _globglobjs710_path = require('path');
var _globglobjs710_assert = require('assert');
var _globglobjs710_isAbsolute = $m['path-is-absolute/index.js#1.0.1'].exports;
var _globglobjs710_globSync = require('glob/sync.js#7.1.0');
var _globglobjs710_common = $m['glob/common.js#7.1.0'].exports;
var _globglobjs710_alphasort = _globglobjs710_common.alphasort;
var _globglobjs710_alphasorti = _globglobjs710_common.alphasorti;
var _globglobjs710_setopts = _globglobjs710_common.setopts;
var _globglobjs710_ownProp = _globglobjs710_common.ownProp;
var _globglobjs710_inflight = $m['inflight/inflight.js#1.0.5'].exports;
var _globglobjs710_util = require('util');
var _globglobjs710_childrenIgnored = _globglobjs710_common.childrenIgnored;
var _globglobjs710_isIgnored = _globglobjs710_common.isIgnored;

var _globglobjs710_once = $m['once/once.js#1.4.0'].exports;

function _globglobjs710_glob(pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return _globglobjs710_globSync(pattern, options);
  }

  return new _globglobjs710_Glob(pattern, options, cb);
}

_globglobjs710_glob.sync = _globglobjs710_globSync;
var _globglobjs710_GlobSync = _globglobjs710_glob.GlobSync = _globglobjs710_globSync.GlobSync;

// old api surface
_globglobjs710_glob.glob = _globglobjs710_glob;

function _globglobjs710_extend(origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin;
  }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

_globglobjs710_glob.hasMagic = function (pattern, options_) {
  var options = _globglobjs710_extend({}, options_);
  options.noprocess = true;

  var g = new _globglobjs710_Glob(pattern, options);
  var set = g.minimatch.set;

  if (!pattern) return false;

  if (set.length > 1) return true;

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string') return true;
  }

  return false;
};

_globglobjs710_glob.Glob = _globglobjs710_Glob;
_globglobjs710_inherits(_globglobjs710_Glob, _globglobjs710_EE);
function _globglobjs710_Glob(pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return new _globglobjs710_GlobSync(pattern, options);
  }

  if (!(this instanceof _globglobjs710_Glob)) return new _globglobjs710_Glob(pattern, options, cb);

  _globglobjs710_setopts(this, pattern, options);
  this._didRealPath = false;

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length;

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = _globglobjs710_once(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  var n = this.minimatch.set.length;
  this._processing = 0;
  this.matches = new Array(n);

  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;

  if (this.noprocess) return this;

  if (n === 0) return done();

  var sync = true;
  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false, done);
  }
  sync = false;

  function done() {
    --self._processing;
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

_globglobjs710_Glob.prototype._finish = function () {
  _globglobjs710_assert(this instanceof _globglobjs710_Glob);
  if (this.aborted) return;

  if (this.realpath && !this._didRealpath) return this._realpath();

  _globglobjs710_common.finish(this);
  this.emit('end', this.found);
};

_globglobjs710_Glob.prototype._realpath = function () {
  if (this._didRealpath) return;

  this._didRealpath = true;

  var n = this.matches.length;
  if (n === 0) return this._finish();

  var self = this;
  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);

  function next() {
    if (--n === 0) self._finish();
  }
};

_globglobjs710_Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset) return cb();

  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;

  if (n === 0) return cb();

  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    _globglobjs710_rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

_globglobjs710_Glob.prototype._mark = function (p) {
  return _globglobjs710_common.mark(this, p);
};

_globglobjs710_Glob.prototype._makeAbs = function (f) {
  return _globglobjs710_common.makeAbs(this, f);
};

_globglobjs710_Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

_globglobjs710_Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

_globglobjs710_Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);
      this._emitQueue.length = 0;
      for (var i = 0; i < eq.length; i++) {
        var e = eq[i];
        this._emitMatch(e[0], e[1]);
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);
      this._processQueue.length = 0;
      for (var i = 0; i < pq.length; i++) {
        var p = pq[i];
        this._processing--;
        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

_globglobjs710_Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  _globglobjs710_assert(this instanceof _globglobjs710_Glob);
  _globglobjs710_assert(typeof cb === 'function');

  if (this.aborted) return;

  this._processing++;
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);
    return;
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n++;
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);
      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null) read = '.';else if (_globglobjs710_isAbsolute(prefix) || _globglobjs710_isAbsolute(pattern.join('/'))) {
    if (!prefix || !_globglobjs710_isAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip _processing
  if (_globglobjs710_childrenIgnored(this, read)) return cb();

  var isGlobStar = remain[0] === _globglobjs710_minimatch.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

_globglobjs710_Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

_globglobjs710_Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries) return cb();

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m) matchedEntries.push(e);
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0) return cb();

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = _globglobjs710_path.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return cb();
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) {
      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
    }
    this._process([e].concat(remain), index, inGlobStar, cb);
  }
  cb();
};

_globglobjs710_Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted) return;

  if (_globglobjs710_isIgnored(this, e)) return;

  if (this.paused) {
    this._emitQueue.push([index, e]);
    return;
  }

  var abs = this._makeAbs(e);

  if (this.mark) e = this._mark(e);

  if (this.absolute) e = abs;

  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;

  var st = this.statCache[abs];
  if (st) this.emit('stat', e, st);

  this.emit('match', e);
};

_globglobjs710_Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted) return;

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow) return this._readdir(abs, false, cb);

  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = _globglobjs710_inflight(lstatkey, lstatcb_);

  if (lstatcb) _globglobjs710_fs.lstat(abs, lstatcb);

  function lstatcb_(er, lstat) {
    if (er) return cb();

    var isSym = lstat.isSymbolicLink();
    self.symlinks[abs] = isSym;

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else self._readdir(abs, false, cb);
  }
};

_globglobjs710_Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted) return;

  cb = _globglobjs710_inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
  if (!cb) return;

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !_globglobjs710_ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

  if (_globglobjs710_ownProp(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return cb();

    if (Array.isArray(c)) return cb(null, c);
  }

  var self = this;
  _globglobjs710_fs.readdir(abs, _globglobjs710_readdirCb(this, abs, cb));
};

function _globglobjs710_readdirCb(self, abs, cb) {
  return function (er, entries) {
    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
  };
}

_globglobjs710_Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted) return;

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries);
};

_globglobjs710_Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted) return;

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }
      break;

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) {
        this.emit('error', er);
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort();
      }
      if (!this.silent) console.error('glob error', er);
      break;
  }

  return cb();
};

_globglobjs710_Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

_globglobjs710_Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return cb();

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length;

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar) return cb();

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue;

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true, cb);
  }

  cb();
};

_globglobjs710_Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};
_globglobjs710_Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index]) this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists) return cb();

  if (prefix && _globglobjs710_isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = _globglobjs710_path.join(this.root, prefix);
    } else {
      prefix = _globglobjs710_path.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
  cb();
};

// Returns either 'DIR', 'FILE', or false
_globglobjs710_Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength) return cb();

  if (!this.stat && _globglobjs710_ownProp(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c)) c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR') return cb(null, c);

    if (needDir && c === 'FILE') return cb();

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (stat !== undefined) {
    if (stat === false) return cb(null, stat);else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
    }
  }

  var self = this;
  var statcb = _globglobjs710_inflight('stat\0' + abs, lstatcb_);
  if (statcb) _globglobjs710_fs.lstat(abs, statcb);

  function lstatcb_(er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return _globglobjs710_fs.stat(abs, function (er, stat) {
        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
      });
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

_globglobjs710_Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er) {
    this.statCache[abs] = false;
    return cb();
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;

  if (abs.slice(-1) === '/' && !stat.isDirectory()) return cb(null, false, stat);

  var c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c !== 'DIR') return cb();

  return cb(null, c, stat);
};
/*≠≠ node_modules/glob/glob.js ≠≠*/

/*== node_modules/lodash/_SetCache.js ==*/
$m['lodash/_SetCache.js#4.16.2'] = { exports: {} };
var _lodashSetCachejs4162_MapCache = $m['lodash/_MapCache.js#4.16.2'].exports,
    _lodashSetCachejs4162_setCacheAdd = $m['lodash/_setCacheAdd.js#4.16.2'].exports,
    _lodashSetCachejs4162_setCacheHas = $m['lodash/_setCacheHas.js#4.16.2'].exports;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function _lodashSetCachejs4162_SetCache(values) {
    var index = -1,
        length = values ? values.length : 0;

    this.__data__ = new _lodashSetCachejs4162_MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}

// Add methods to `SetCache`.
_lodashSetCachejs4162_SetCache.prototype.add = _lodashSetCachejs4162_SetCache.prototype.push = _lodashSetCachejs4162_setCacheAdd;
_lodashSetCachejs4162_SetCache.prototype.has = _lodashSetCachejs4162_setCacheHas;

$m['lodash/_SetCache.js#4.16.2'].exports = _lodashSetCachejs4162_SetCache;
/*≠≠ node_modules/lodash/_SetCache.js ≠≠*/

/*== node_modules/lodash/_equalArrays.js ==*/
$m['lodash/_equalArrays.js#4.16.2'] = { exports: {} };
var _lodashequalArraysjs4162_SetCache = $m['lodash/_SetCache.js#4.16.2'].exports,
    _lodashequalArraysjs4162_arraySome = $m['lodash/_arraySome.js#4.16.2'].exports,
    _lodashequalArraysjs4162_cacheHas = $m['lodash/_cacheHas.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalArraysjs4162_UNORDERED_COMPARE_FLAG = 1,
    _lodashequalArraysjs4162_PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function _lodashequalArraysjs4162_equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & _lodashequalArraysjs4162_PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & _lodashequalArraysjs4162_UNORDERED_COMPARE_FLAG ? new _lodashequalArraysjs4162_SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_lodashequalArraysjs4162_arraySome(other, function (othValue, othIndex) {
        if (!_lodashequalArraysjs4162_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

$m['lodash/_equalArrays.js#4.16.2'].exports = _lodashequalArraysjs4162_equalArrays;
/*≠≠ node_modules/lodash/_equalArrays.js ≠≠*/

/*== node_modules/lodash/_baseIsEqualDeep.js ==*/
$m['lodash/_baseIsEqualDeep.js#4.16.2'] = { exports: {} };
var _lodashbaseIsEqualDeepjs4162_Stack = $m['lodash/_Stack.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_equalArrays = $m['lodash/_equalArrays.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_equalByTag = $m['lodash/_equalByTag.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_equalObjects = $m['lodash/_equalObjects.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_getTag = $m['lodash/_getTag.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports,
    _lodashbaseIsEqualDeepjs4162_isTypedArray = $m['lodash/isTypedArray.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashbaseIsEqualDeepjs4162_PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var _lodashbaseIsEqualDeepjs4162_argsTag = '[object Arguments]',
    _lodashbaseIsEqualDeepjs4162_arrayTag = '[object Array]',
    _lodashbaseIsEqualDeepjs4162_objectTag = '[object Object]';

/** Used for built-in method references. */
var _lodashbaseIsEqualDeepjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseIsEqualDeepjs4162_hasOwnProperty = _lodashbaseIsEqualDeepjs4162_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashbaseIsEqualDeepjs4162_baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = _lodashbaseIsEqualDeepjs4162_isArray(object),
      othIsArr = _lodashbaseIsEqualDeepjs4162_isArray(other),
      objTag = _lodashbaseIsEqualDeepjs4162_arrayTag,
      othTag = _lodashbaseIsEqualDeepjs4162_arrayTag;

  if (!objIsArr) {
    objTag = _lodashbaseIsEqualDeepjs4162_getTag(object);
    objTag = objTag == _lodashbaseIsEqualDeepjs4162_argsTag ? _lodashbaseIsEqualDeepjs4162_objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = _lodashbaseIsEqualDeepjs4162_getTag(other);
    othTag = othTag == _lodashbaseIsEqualDeepjs4162_argsTag ? _lodashbaseIsEqualDeepjs4162_objectTag : othTag;
  }
  var objIsObj = objTag == _lodashbaseIsEqualDeepjs4162_objectTag,
      othIsObj = othTag == _lodashbaseIsEqualDeepjs4162_objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new _lodashbaseIsEqualDeepjs4162_Stack());
    return objIsArr || _lodashbaseIsEqualDeepjs4162_isTypedArray(object) ? _lodashbaseIsEqualDeepjs4162_equalArrays(object, other, equalFunc, customizer, bitmask, stack) : _lodashbaseIsEqualDeepjs4162_equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & _lodashbaseIsEqualDeepjs4162_PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && _lodashbaseIsEqualDeepjs4162_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _lodashbaseIsEqualDeepjs4162_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _lodashbaseIsEqualDeepjs4162_Stack());
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _lodashbaseIsEqualDeepjs4162_Stack());
  return _lodashbaseIsEqualDeepjs4162_equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

$m['lodash/_baseIsEqualDeep.js#4.16.2'].exports = _lodashbaseIsEqualDeepjs4162_baseIsEqualDeep;
/*≠≠ node_modules/lodash/_baseIsEqualDeep.js ≠≠*/

/*== node_modules/lodash/_baseIsEqual.js ==*/
$m['lodash/_baseIsEqual.js#4.16.2'] = { exports: {} };
var _lodashbaseIsEqualjs4162_baseIsEqualDeep = $m['lodash/_baseIsEqualDeep.js#4.16.2'].exports,
    _lodashbaseIsEqualjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashbaseIsEqualjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function _lodashbaseIsEqualjs4162_baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !_lodashbaseIsEqualjs4162_isObject(value) && !_lodashbaseIsEqualjs4162_isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return _lodashbaseIsEqualjs4162_baseIsEqualDeep(value, other, _lodashbaseIsEqualjs4162_baseIsEqual, customizer, bitmask, stack);
}

$m['lodash/_baseIsEqual.js#4.16.2'].exports = _lodashbaseIsEqualjs4162_baseIsEqual;
/*≠≠ node_modules/lodash/_baseIsEqual.js ≠≠*/

/*== node_modules/lodash/toNumber.js ==*/
$m['lodash/toNumber.js#4.16.2'] = { exports: {} };
var _lodashtoNumberjs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports,
    _lodashtoNumberjs4162_isSymbol = $m['lodash/isSymbol.js#4.16.2'].exports;

/** Used as references for various `Number` constants. */
var _lodashtoNumberjs4162_NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var _lodashtoNumberjs4162_reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var _lodashtoNumberjs4162_reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var _lodashtoNumberjs4162_reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var _lodashtoNumberjs4162_reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var _lodashtoNumberjs4162_freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function _lodashtoNumberjs4162_toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (_lodashtoNumberjs4162_isSymbol(value)) {
    return _lodashtoNumberjs4162_NAN;
  }
  if (_lodashtoNumberjs4162_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = _lodashtoNumberjs4162_isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(_lodashtoNumberjs4162_reTrim, '');
  var isBinary = _lodashtoNumberjs4162_reIsBinary.test(value);
  return isBinary || _lodashtoNumberjs4162_reIsOctal.test(value) ? _lodashtoNumberjs4162_freeParseInt(value.slice(2), isBinary ? 2 : 8) : _lodashtoNumberjs4162_reIsBadHex.test(value) ? _lodashtoNumberjs4162_NAN : +value;
}

$m['lodash/toNumber.js#4.16.2'].exports = _lodashtoNumberjs4162_toNumber;
/*≠≠ node_modules/lodash/toNumber.js ≠≠*/

/*== node_modules/lodash/_baseKeys.js ==*/
$m['lodash/_baseKeys.js#4.16.2'] = { exports: {} };
var _lodashbaseKeysjs4162_isPrototype = $m['lodash/_isPrototype.js#4.16.2'].exports,
    _lodashbaseKeysjs4162_nativeKeys = $m['lodash/_nativeKeys.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashbaseKeysjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseKeysjs4162_hasOwnProperty = _lodashbaseKeysjs4162_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashbaseKeysjs4162_baseKeys(object) {
  if (!_lodashbaseKeysjs4162_isPrototype(object)) {
    return _lodashbaseKeysjs4162_nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (_lodashbaseKeysjs4162_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_baseKeys.js#4.16.2'].exports = _lodashbaseKeysjs4162_baseKeys;
/*≠≠ node_modules/lodash/_baseKeys.js ≠≠*/

/*== node_modules/lodash/_Uint8Array.js ==*/
$m['lodash/_Uint8Array.js#4.16.2'] = { exports: {} };
var _lodashUint8Arrayjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/** Built-in value references. */
var _lodashUint8Arrayjs4162_Uint8Array = _lodashUint8Arrayjs4162_root.Uint8Array;

$m['lodash/_Uint8Array.js#4.16.2'].exports = _lodashUint8Arrayjs4162_Uint8Array;
/*≠≠ node_modules/lodash/_Uint8Array.js ≠≠*/

/*== node_modules/lodash/_cloneArrayBuffer.js ==*/
$m['lodash/_cloneArrayBuffer.js#4.16.2'] = { exports: {} };
var _lodashcloneArrayBufferjs4162_Uint8Array = $m['lodash/_Uint8Array.js#4.16.2'].exports;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function _lodashcloneArrayBufferjs4162_cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _lodashcloneArrayBufferjs4162_Uint8Array(result).set(new _lodashcloneArrayBufferjs4162_Uint8Array(arrayBuffer));
  return result;
}

$m['lodash/_cloneArrayBuffer.js#4.16.2'].exports = _lodashcloneArrayBufferjs4162_cloneArrayBuffer;
/*≠≠ node_modules/lodash/_cloneArrayBuffer.js ≠≠*/

/*== node_modules/lodash/_getMapData.js ==*/
$m['lodash/_getMapData.js#4.16.2'] = { exports: {} };
var _lodashgetMapDatajs4162_isKeyable = $m['lodash/_isKeyable.js#4.16.2'].exports;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function _lodashgetMapDatajs4162_getMapData(map, key) {
  var data = map.__data__;
  return _lodashgetMapDatajs4162_isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

$m['lodash/_getMapData.js#4.16.2'].exports = _lodashgetMapDatajs4162_getMapData;
/*≠≠ node_modules/lodash/_getMapData.js ≠≠*/

/*== node_modules/lodash/_Hash.js ==*/
$m['lodash/_Hash.js#4.16.2'] = { exports: {} };
var _lodashHashjs4162_hashClear = $m['lodash/_hashClear.js#4.16.2'].exports,
    _lodashHashjs4162_hashDelete = $m['lodash/_hashDelete.js#4.16.2'].exports,
    _lodashHashjs4162_hashGet = $m['lodash/_hashGet.js#4.16.2'].exports,
    _lodashHashjs4162_hashHas = $m['lodash/_hashHas.js#4.16.2'].exports,
    _lodashHashjs4162_hashSet = $m['lodash/_hashSet.js#4.16.2'].exports;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashHashjs4162_Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `Hash`.
_lodashHashjs4162_Hash.prototype.clear = _lodashHashjs4162_hashClear;
_lodashHashjs4162_Hash.prototype['delete'] = _lodashHashjs4162_hashDelete;
_lodashHashjs4162_Hash.prototype.get = _lodashHashjs4162_hashGet;
_lodashHashjs4162_Hash.prototype.has = _lodashHashjs4162_hashHas;
_lodashHashjs4162_Hash.prototype.set = _lodashHashjs4162_hashSet;

$m['lodash/_Hash.js#4.16.2'].exports = _lodashHashjs4162_Hash;
/*≠≠ node_modules/lodash/_Hash.js ≠≠*/

/*== node_modules/lodash/_Map.js ==*/
$m['lodash/_Map.js#4.16.2'] = { exports: {} };
var _lodashMapjs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports,
    _lodashMapjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashMapjs4162_Map = _lodashMapjs4162_getNative(_lodashMapjs4162_root, 'Map');

$m['lodash/_Map.js#4.16.2'].exports = _lodashMapjs4162_Map;
/*≠≠ node_modules/lodash/_Map.js ≠≠*/

/*== node_modules/lodash/_listCacheDelete.js ==*/
$m['lodash/_listCacheDelete.js#4.16.2'] = { exports: {} };
var _lodashlistCacheDeletejs4162_assocIndexOf = $m['lodash/_assocIndexOf.js#4.16.2'].exports;

/** Used for built-in method references. */
var _lodashlistCacheDeletejs4162_arrayProto = Array.prototype;

/** Built-in value references. */
var _lodashlistCacheDeletejs4162_splice = _lodashlistCacheDeletejs4162_arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashlistCacheDeletejs4162_listCacheDelete(key) {
  var data = this.__data__,
      index = _lodashlistCacheDeletejs4162_assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    _lodashlistCacheDeletejs4162_splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

$m['lodash/_listCacheDelete.js#4.16.2'].exports = _lodashlistCacheDeletejs4162_listCacheDelete;
/*≠≠ node_modules/lodash/_listCacheDelete.js ≠≠*/

/*== node_modules/lodash/_listCacheGet.js ==*/
$m['lodash/_listCacheGet.js#4.16.2'] = { exports: {} };
var _lodashlistCacheGetjs4162_assocIndexOf = $m['lodash/_assocIndexOf.js#4.16.2'].exports;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashlistCacheGetjs4162_listCacheGet(key) {
  var data = this.__data__,
      index = _lodashlistCacheGetjs4162_assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

$m['lodash/_listCacheGet.js#4.16.2'].exports = _lodashlistCacheGetjs4162_listCacheGet;
/*≠≠ node_modules/lodash/_listCacheGet.js ≠≠*/

/*== node_modules/lodash/_listCacheHas.js ==*/
$m['lodash/_listCacheHas.js#4.16.2'] = { exports: {} };
var _lodashlistCacheHasjs4162_assocIndexOf = $m['lodash/_assocIndexOf.js#4.16.2'].exports;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashlistCacheHasjs4162_listCacheHas(key) {
  return _lodashlistCacheHasjs4162_assocIndexOf(this.__data__, key) > -1;
}

$m['lodash/_listCacheHas.js#4.16.2'].exports = _lodashlistCacheHasjs4162_listCacheHas;
/*≠≠ node_modules/lodash/_listCacheHas.js ≠≠*/

/*== node_modules/lodash/_listCacheSet.js ==*/
$m['lodash/_listCacheSet.js#4.16.2'] = { exports: {} };
var _lodashlistCacheSetjs4162_assocIndexOf = $m['lodash/_assocIndexOf.js#4.16.2'].exports;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function _lodashlistCacheSetjs4162_listCacheSet(key, value) {
  var data = this.__data__,
      index = _lodashlistCacheSetjs4162_assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

$m['lodash/_listCacheSet.js#4.16.2'].exports = _lodashlistCacheSetjs4162_listCacheSet;
/*≠≠ node_modules/lodash/_listCacheSet.js ≠≠*/

/*== node_modules/lodash/_ListCache.js ==*/
$m['lodash/_ListCache.js#4.16.2'] = { exports: {} };
var _lodashListCachejs4162_listCacheClear = $m['lodash/_listCacheClear.js#4.16.2'].exports,
    _lodashListCachejs4162_listCacheDelete = $m['lodash/_listCacheDelete.js#4.16.2'].exports,
    _lodashListCachejs4162_listCacheGet = $m['lodash/_listCacheGet.js#4.16.2'].exports,
    _lodashListCachejs4162_listCacheHas = $m['lodash/_listCacheHas.js#4.16.2'].exports,
    _lodashListCachejs4162_listCacheSet = $m['lodash/_listCacheSet.js#4.16.2'].exports;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashListCachejs4162_ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `ListCache`.
_lodashListCachejs4162_ListCache.prototype.clear = _lodashListCachejs4162_listCacheClear;
_lodashListCachejs4162_ListCache.prototype['delete'] = _lodashListCachejs4162_listCacheDelete;
_lodashListCachejs4162_ListCache.prototype.get = _lodashListCachejs4162_listCacheGet;
_lodashListCachejs4162_ListCache.prototype.has = _lodashListCachejs4162_listCacheHas;
_lodashListCachejs4162_ListCache.prototype.set = _lodashListCachejs4162_listCacheSet;

$m['lodash/_ListCache.js#4.16.2'].exports = _lodashListCachejs4162_ListCache;
/*≠≠ node_modules/lodash/_ListCache.js ≠≠*/

/*== node_modules/inline-source/lib/imgSVG.js ==*/
$m['inline-source/lib/imgSVG.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibimgSVGjs511_htmlparser = $m['htmlparser2/lib/index.js#3.9.1'].exports;
const _inlinesourcelibimgSVGjs511_objectAssign = $m['object-assign/index.js#4.1.0'].exports;
const _inlinesourcelibimgSVGjs511_utils = $m['inline-source/lib/utils.js#5.1.1'].exports;

const _inlinesourcelibimgSVGjs511_DEFAULT_SVG_ATTR = {
  x: '0',
  y: '0',
  viewBox: '0 0 100 100'
};
const _inlinesourcelibimgSVGjs511_RE_SVG_CONTENT = /<svg[^>]+>([\S\s]*?)<\/\s?svg>/gm;
const _inlinesourcelibimgSVGjs511_RE_SYMBOL = /<symbol\sid=['"](.+)['"]>[\S\s]*?<\/\s?symbol>/gm;

/**
 * Handle IMG content
 * @param {Object} source
 * @param {Object} context
 * @param {Object} svgo
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/imgSVG.js#5.1.1'].exports = function imgSVG(source, context, svgo, next) {
  _inlinesourcelibimgSVGjs511_RE_SVG_CONTENT.lastIndex = 0;
  _inlinesourcelibimgSVGjs511_RE_SYMBOL.lastIndex = 0;

  const svgContent = _inlinesourcelibimgSVGjs511_RE_SVG_CONTENT.exec(source.fileContent) || source.fileContent;
  // Use default attributes if no outer <svg> tag
  const defaultAttributes = Array.isArray(svgContent) ? {} : _inlinesourcelibimgSVGjs511_DEFAULT_SVG_ATTR;
  let attributes = {};
  const parser = new _inlinesourcelibimgSVGjs511_htmlparser.Parser(new _inlinesourcelibimgSVGjs511_htmlparser.DomHandler((err, dom) => {
    if (err) return next(err);

    dom = dom.filter(item => {
      return item.type == 'tag' && item.name == 'svg';
    });

    if (dom.length) {
      attributes = _inlinesourcelibimgSVGjs511_utils.parseAttributes(dom[0].attribs);
      // Fix lowercasing
      if ('viewbox' in attributes) {
        attributes.viewBox = attributes.viewbox;
        delete attributes.viewbox;
      }
    }
  }));

  // Strip xml tag
  parser.parseComplete(source.fileContent);
  source.content = Array.isArray(svgContent) ? svgContent[1] : svgContent;
  source.attributes = _inlinesourcelibimgSVGjs511_objectAssign({}, defaultAttributes, attributes, source.attributes);
  source.tag = 'svg';
  // Handle subset of symbols as specified with filepath anchor (foo.svg#foo,bar)
  if (source.filepathAnchor) {
    const includedIds = source.filepathAnchor.split(',');
    let content = source.content;
    let match;

    while (match = _inlinesourcelibimgSVGjs511_RE_SYMBOL.exec(source.content)) {
      if (!~includedIds.indexOf(match[1])) {
        content = content.replace(match[0], '');
      }
    }

    source.content = content;
  }
  if (source.compress) {
    // svgo sometiemes throws errors if content not wrapped in <svg>, so wrap here
    const attrs = _inlinesourcelibimgSVGjs511_utils.getAttributeString(source.attributes, context.attribute, false);
    const content = '<svg' + attrs + '>' + source.content + '</svg>';

    // Sync api call
    svgo.optimize(content, content => {
      _inlinesourcelibimgSVGjs511_RE_SVG_CONTENT.lastIndex = 0;
      var rematch = _inlinesourcelibimgSVGjs511_RE_SVG_CONTENT.exec(content.data);

      if (rematch) {
        source.content = rematch[1];
      } else {
        // Error re-parsing, leave as is;
        source.replace = content.data;
      }
    });
  }
  return next();
};
/*≠≠ node_modules/inline-source/lib/imgSVG.js ≠≠*/

/*== node_modules/lodash/_basePropertyDeep.js ==*/
$m['lodash/_basePropertyDeep.js#4.16.2'] = { exports: {} };
var _lodashbasePropertyDeepjs4162_baseGet = $m['lodash/_baseGet.js#4.16.2'].exports;

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function _lodashbasePropertyDeepjs4162_basePropertyDeep(path) {
  return function (object) {
    return _lodashbasePropertyDeepjs4162_baseGet(object, path);
  };
}

$m['lodash/_basePropertyDeep.js#4.16.2'].exports = _lodashbasePropertyDeepjs4162_basePropertyDeep;
/*≠≠ node_modules/lodash/_basePropertyDeep.js ≠≠*/

/*== node_modules/lodash/hasIn.js ==*/
$m['lodash/hasIn.js#4.16.2'] = { exports: {} };
var _lodashhasInjs4162_baseHasIn = $m['lodash/_baseHasIn.js#4.16.2'].exports,
    _lodashhasInjs4162_hasPath = $m['lodash/_hasPath.js#4.16.2'].exports;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function _lodashhasInjs4162_hasIn(object, path) {
  return object != null && _lodashhasInjs4162_hasPath(object, path, _lodashhasInjs4162_baseHasIn);
}

$m['lodash/hasIn.js#4.16.2'].exports = _lodashhasInjs4162_hasIn;
/*≠≠ node_modules/lodash/hasIn.js ≠≠*/

/*== node_modules/lodash/get.js ==*/
$m['lodash/get.js#4.16.2'] = { exports: {} };
var _lodashgetjs4162_baseGet = $m['lodash/_baseGet.js#4.16.2'].exports;

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function _lodashgetjs4162_get(object, path, defaultValue) {
  var result = object == null ? undefined : _lodashgetjs4162_baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

$m['lodash/get.js#4.16.2'].exports = _lodashgetjs4162_get;
/*≠≠ node_modules/lodash/get.js ≠≠*/

/*== node_modules/lodash/_getMatchData.js ==*/
$m['lodash/_getMatchData.js#4.16.2'] = { exports: {} };
var _lodashgetMatchDatajs4162_isStrictComparable = $m['lodash/_isStrictComparable.js#4.16.2'].exports,
    _lodashgetMatchDatajs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function _lodashgetMatchDatajs4162_getMatchData(object) {
    var result = _lodashgetMatchDatajs4162_keys(object),
        length = result.length;

    while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, _lodashgetMatchDatajs4162_isStrictComparable(value)];
    }
    return result;
}

$m['lodash/_getMatchData.js#4.16.2'].exports = _lodashgetMatchDatajs4162_getMatchData;
/*≠≠ node_modules/lodash/_getMatchData.js ≠≠*/

/*== node_modules/lodash/_baseIsMatch.js ==*/
$m['lodash/_baseIsMatch.js#4.16.2'] = { exports: {} };
var _lodashbaseIsMatchjs4162_Stack = $m['lodash/_Stack.js#4.16.2'].exports,
    _lodashbaseIsMatchjs4162_baseIsEqual = $m['lodash/_baseIsEqual.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashbaseIsMatchjs4162_UNORDERED_COMPARE_FLAG = 1,
    _lodashbaseIsMatchjs4162_PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function _lodashbaseIsMatchjs4162_baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _lodashbaseIsMatchjs4162_Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? _lodashbaseIsMatchjs4162_baseIsEqual(srcValue, objValue, customizer, _lodashbaseIsMatchjs4162_UNORDERED_COMPARE_FLAG | _lodashbaseIsMatchjs4162_PARTIAL_COMPARE_FLAG, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

$m['lodash/_baseIsMatch.js#4.16.2'].exports = _lodashbaseIsMatchjs4162_baseIsMatch;
/*≠≠ node_modules/lodash/_baseIsMatch.js ≠≠*/

/*== node_modules/lodash/_isFlattenable.js ==*/
$m['lodash/_isFlattenable.js#4.16.2'] = { exports: {} };
var _lodashisFlattenablejs4162_Symbol = $m['lodash/_Symbol.js#4.16.2'].exports,
    _lodashisFlattenablejs4162_isArguments = $m['lodash/isArguments.js#4.16.2'].exports,
    _lodashisFlattenablejs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports;

/** Built-in value references. */
var _lodashisFlattenablejs4162_spreadableSymbol = _lodashisFlattenablejs4162_Symbol ? _lodashisFlattenablejs4162_Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function _lodashisFlattenablejs4162_isFlattenable(value) {
    return _lodashisFlattenablejs4162_isArray(value) || _lodashisFlattenablejs4162_isArguments(value) || !!(_lodashisFlattenablejs4162_spreadableSymbol && value && value[_lodashisFlattenablejs4162_spreadableSymbol]);
}

$m['lodash/_isFlattenable.js#4.16.2'].exports = _lodashisFlattenablejs4162_isFlattenable;
/*≠≠ node_modules/lodash/_isFlattenable.js ≠≠*/

/*== node_modules/lodash/_equalObjects.js ==*/
$m['lodash/_equalObjects.js#4.16.2'] = { exports: {} };
var _lodashequalObjectsjs4162_keys = $m['lodash/keys.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalObjectsjs4162_PARTIAL_COMPARE_FLAG = 2;

/** Used for built-in method references. */
var _lodashequalObjectsjs4162_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashequalObjectsjs4162_hasOwnProperty = _lodashequalObjectsjs4162_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashequalObjectsjs4162_equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & _lodashequalObjectsjs4162_PARTIAL_COMPARE_FLAG,
      objProps = _lodashequalObjectsjs4162_keys(object),
      objLength = objProps.length,
      othProps = _lodashequalObjectsjs4162_keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : _lodashequalObjectsjs4162_hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

$m['lodash/_equalObjects.js#4.16.2'].exports = _lodashequalObjectsjs4162_equalObjects;
/*≠≠ node_modules/lodash/_equalObjects.js ≠≠*/

/*== node_modules/lodash/_equalByTag.js ==*/
$m['lodash/_equalByTag.js#4.16.2'] = { exports: {} };
var _lodashequalByTagjs4162_Symbol = $m['lodash/_Symbol.js#4.16.2'].exports,
    _lodashequalByTagjs4162_Uint8Array = $m['lodash/_Uint8Array.js#4.16.2'].exports,
    _lodashequalByTagjs4162_eq = $m['lodash/eq.js#4.16.2'].exports,
    _lodashequalByTagjs4162_equalArrays = $m['lodash/_equalArrays.js#4.16.2'].exports,
    _lodashequalByTagjs4162_mapToArray = $m['lodash/_mapToArray.js#4.16.2'].exports,
    _lodashequalByTagjs4162_setToArray = $m['lodash/_setToArray.js#4.16.2'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalByTagjs4162_UNORDERED_COMPARE_FLAG = 1,
    _lodashequalByTagjs4162_PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var _lodashequalByTagjs4162_boolTag = '[object Boolean]',
    _lodashequalByTagjs4162_dateTag = '[object Date]',
    _lodashequalByTagjs4162_errorTag = '[object Error]',
    _lodashequalByTagjs4162_mapTag = '[object Map]',
    _lodashequalByTagjs4162_numberTag = '[object Number]',
    _lodashequalByTagjs4162_regexpTag = '[object RegExp]',
    _lodashequalByTagjs4162_setTag = '[object Set]',
    _lodashequalByTagjs4162_stringTag = '[object String]',
    _lodashequalByTagjs4162_symbolTag = '[object Symbol]';

var _lodashequalByTagjs4162_arrayBufferTag = '[object ArrayBuffer]',
    _lodashequalByTagjs4162_dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var _lodashequalByTagjs4162_symbolProto = _lodashequalByTagjs4162_Symbol ? _lodashequalByTagjs4162_Symbol.prototype : undefined,
    _lodashequalByTagjs4162_symbolValueOf = _lodashequalByTagjs4162_symbolProto ? _lodashequalByTagjs4162_symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashequalByTagjs4162_equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case _lodashequalByTagjs4162_dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case _lodashequalByTagjs4162_arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new _lodashequalByTagjs4162_Uint8Array(object), new _lodashequalByTagjs4162_Uint8Array(other))) {
        return false;
      }
      return true;

    case _lodashequalByTagjs4162_boolTag:
    case _lodashequalByTagjs4162_dateTag:
    case _lodashequalByTagjs4162_numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return _lodashequalByTagjs4162_eq(+object, +other);

    case _lodashequalByTagjs4162_errorTag:
      return object.name == other.name && object.message == other.message;

    case _lodashequalByTagjs4162_regexpTag:
    case _lodashequalByTagjs4162_stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case _lodashequalByTagjs4162_mapTag:
      var convert = _lodashequalByTagjs4162_mapToArray;

    case _lodashequalByTagjs4162_setTag:
      var isPartial = bitmask & _lodashequalByTagjs4162_PARTIAL_COMPARE_FLAG;
      convert || (convert = _lodashequalByTagjs4162_setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= _lodashequalByTagjs4162_UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _lodashequalByTagjs4162_equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case _lodashequalByTagjs4162_symbolTag:
      if (_lodashequalByTagjs4162_symbolValueOf) {
        return _lodashequalByTagjs4162_symbolValueOf.call(object) == _lodashequalByTagjs4162_symbolValueOf.call(other);
      }
  }
  return false;
}

$m['lodash/_equalByTag.js#4.16.2'].exports = _lodashequalByTagjs4162_equalByTag;
/*≠≠ node_modules/lodash/_equalByTag.js ≠≠*/

/*== node_modules/lodash/isEqual.js ==*/
$m['lodash/isEqual.js#4.16.2'] = { exports: {} };
var _lodashisEqualjs4162_baseIsEqual = $m['lodash/_baseIsEqual.js#4.16.2'].exports;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function _lodashisEqualjs4162_isEqual(value, other) {
  return _lodashisEqualjs4162_baseIsEqual(value, other);
}

$m['lodash/isEqual.js#4.16.2'].exports = _lodashisEqualjs4162_isEqual;
/*≠≠ node_modules/lodash/isEqual.js ≠≠*/

/*== node_modules/lodash/uniqWith.js ==*/
$m['lodash/uniqWith.js#4.16.2'] = { exports: {} };
var _lodashuniqWithjs4162_baseUniq = $m['lodash/_baseUniq.js#4.16.2'].exports;

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function _lodashuniqWithjs4162_uniqWith(array, comparator) {
  return array && array.length ? _lodashuniqWithjs4162_baseUniq(array, undefined, comparator) : [];
}

$m['lodash/uniqWith.js#4.16.2'].exports = _lodashuniqWithjs4162_uniqWith;
/*≠≠ node_modules/lodash/uniqWith.js ≠≠*/

/*== lib/utils/string.js ==*/
$m['lib/utils/string.js'] = { exports: {} };
'use strict';

const _libutilsstringjs_isEqual = $m['lodash/isEqual.js#4.16.2'].exports;
const _libutilsstringjs_unique = $m['lodash/uniqWith.js#4.16.2'].exports;

const _libutilsstringjs_COLUMN = ' ';
// Line starting with '//'
const _libutilsstringjs_RE_COMMENT_SINGLE_LINE = /^\s*(?:\/\/|#).+$/gm;
// Multi line block '/** ... */'
const _libutilsstringjs_RE_COMMENT_MULTI_LINES = /((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/))$/gm;
const _libutilsstringjs_RE_LINE_BEGIN = /^/gm;
const _libutilsstringjs_SEG_LENGTH = 30;

$m['lib/utils/string.js'].exports = {
  /**
   * Strip comments from 'str'
   * @param {String} str
   * @returns {String}
   */
  commentStrip(str) {
    // Remove commented lines
    str = str.replace(_libutilsstringjs_RE_COMMENT_SINGLE_LINE, '');
    str = str.replace(_libutilsstringjs_RE_COMMENT_MULTI_LINES, '');
    return str;
  },

  /**
   * Wrap 'str' in comment based on 'type'
   * @param {String} str
   * @param {String} type
   * @returns {String}
   */
  commentWrap(str, type) {
    let open, close;

    if (type == 'html') {
      open = '<!-- ';
      close = ' -->';
    } else {
      open = '/* ';
      close = ' */';
    }

    return open + str + close;
  },

  /**
   * Indent the given 'str' a specific number of columns
   * @param {String} str
   * @param {Int} column
   * @returns {String}
   */
  indent(str, column) {
    const spaces = new Array(++column).join(_libutilsstringjs_COLUMN);

    return str.replace(_libutilsstringjs_RE_LINE_BEGIN, spaces);
  },

  /**
   * Match unique occurrences in 'str'
   * @param {String} str
   * @param {RegExp} regexp
   * @returns {Array}
   */
  uniqueMatch(str, regexp) {
    let results = [];
    let match;

    while (match = regexp.exec(str)) {
      results.push({
        context: match[0],
        match: match[1] || ''
      });
    }

    // Filter duplicates
    return _libutilsstringjs_unique(results, _libutilsstringjs_isEqual);
  },

  /**
   * Escape 'str' for use in RegExp constructor
   * @param {String} str
   * @returns {String}
   */
  regexpEscape(str) {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  },

  /**
   * Truncate 'str'
   * @param {String} str
   * @returns {String}
   */
  truncate(str) {
    if (str.length > _libutilsstringjs_SEG_LENGTH * 2 + 3) {
      return str.slice(0, _libutilsstringjs_SEG_LENGTH) + '...' + str.slice(-_libutilsstringjs_SEG_LENGTH);
    }

    return str;
  }
};
/*≠≠ lib/utils/string.js ≠≠*/

/*== node_modules/lodash/toFinite.js ==*/
$m['lodash/toFinite.js#4.16.2'] = { exports: {} };
var _lodashtoFinitejs4162_toNumber = $m['lodash/toNumber.js#4.16.2'].exports;

/** Used as references for various `Number` constants. */
var _lodashtoFinitejs4162_INFINITY = 1 / 0,
    _lodashtoFinitejs4162_MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function _lodashtoFinitejs4162_toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = _lodashtoFinitejs4162_toNumber(value);
  if (value === _lodashtoFinitejs4162_INFINITY || value === -_lodashtoFinitejs4162_INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * _lodashtoFinitejs4162_MAX_INTEGER;
  }
  return value === value ? value : 0;
}

$m['lodash/toFinite.js#4.16.2'].exports = _lodashtoFinitejs4162_toFinite;
/*≠≠ node_modules/lodash/toFinite.js ≠≠*/

/*== node_modules/lodash/_nativeDefineProperty.js ==*/
$m['lodash/_nativeDefineProperty.js#4.16.2'] = { exports: {} };
var _lodashnativeDefinePropertyjs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashnativeDefinePropertyjs4162_nativeDefineProperty = _lodashnativeDefinePropertyjs4162_getNative(Object, 'defineProperty');

$m['lodash/_nativeDefineProperty.js#4.16.2'].exports = _lodashnativeDefinePropertyjs4162_nativeDefineProperty;
/*≠≠ node_modules/lodash/_nativeDefineProperty.js ≠≠*/

/*== node_modules/lodash/_baseCreate.js ==*/
$m['lodash/_baseCreate.js#4.16.2'] = { exports: {} };
var _lodashbaseCreatejs4162_isObject = $m['lodash/isObject.js#4.16.2'].exports;

/** Built-in value references. */
var _lodashbaseCreatejs4162_objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var _lodashbaseCreatejs4162_baseCreate = function () {
  function object() {}
  return function (proto) {
    if (!_lodashbaseCreatejs4162_isObject(proto)) {
      return {};
    }
    if (_lodashbaseCreatejs4162_objectCreate) {
      return _lodashbaseCreatejs4162_objectCreate(proto);
    }
    object.prototype = prototype;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

$m['lodash/_baseCreate.js#4.16.2'].exports = _lodashbaseCreatejs4162_baseCreate;
/*≠≠ node_modules/lodash/_baseCreate.js ≠≠*/

/*== node_modules/lodash/_cloneTypedArray.js ==*/
$m['lodash/_cloneTypedArray.js#4.16.2'] = { exports: {} };
var _lodashcloneTypedArrayjs4162_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.16.2'].exports;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function _lodashcloneTypedArrayjs4162_cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _lodashcloneTypedArrayjs4162_cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

$m['lodash/_cloneTypedArray.js#4.16.2'].exports = _lodashcloneTypedArrayjs4162_cloneTypedArray;
/*≠≠ node_modules/lodash/_cloneTypedArray.js ≠≠*/

/*== node_modules/lodash/_cloneSymbol.js ==*/
$m['lodash/_cloneSymbol.js#4.16.2'] = { exports: {} };
var _lodashcloneSymboljs4162_Symbol = $m['lodash/_Symbol.js#4.16.2'].exports;

/** Used to convert symbols to primitives and strings. */
var _lodashcloneSymboljs4162_symbolProto = _lodashcloneSymboljs4162_Symbol ? _lodashcloneSymboljs4162_Symbol.prototype : undefined,
    _lodashcloneSymboljs4162_symbolValueOf = _lodashcloneSymboljs4162_symbolProto ? _lodashcloneSymboljs4162_symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function _lodashcloneSymboljs4162_cloneSymbol(symbol) {
  return _lodashcloneSymboljs4162_symbolValueOf ? Object(_lodashcloneSymboljs4162_symbolValueOf.call(symbol)) : {};
}

$m['lodash/_cloneSymbol.js#4.16.2'].exports = _lodashcloneSymboljs4162_cloneSymbol;
/*≠≠ node_modules/lodash/_cloneSymbol.js ≠≠*/

/*== node_modules/lodash/_cloneSet.js ==*/
$m['lodash/_cloneSet.js#4.16.2'] = { exports: {} };
var _lodashcloneSetjs4162_addSetEntry = $m['lodash/_addSetEntry.js#4.16.2'].exports,
    _lodashcloneSetjs4162_arrayReduce = $m['lodash/_arrayReduce.js#4.16.2'].exports,
    _lodashcloneSetjs4162_setToArray = $m['lodash/_setToArray.js#4.16.2'].exports;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function _lodashcloneSetjs4162_cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(_lodashcloneSetjs4162_setToArray(set), true) : _lodashcloneSetjs4162_setToArray(set);
  return _lodashcloneSetjs4162_arrayReduce(array, _lodashcloneSetjs4162_addSetEntry, new set.constructor());
}

$m['lodash/_cloneSet.js#4.16.2'].exports = _lodashcloneSetjs4162_cloneSet;
/*≠≠ node_modules/lodash/_cloneSet.js ≠≠*/

/*== node_modules/lodash/_cloneMap.js ==*/
$m['lodash/_cloneMap.js#4.16.2'] = { exports: {} };
var _lodashcloneMapjs4162_addMapEntry = $m['lodash/_addMapEntry.js#4.16.2'].exports,
    _lodashcloneMapjs4162_arrayReduce = $m['lodash/_arrayReduce.js#4.16.2'].exports,
    _lodashcloneMapjs4162_mapToArray = $m['lodash/_mapToArray.js#4.16.2'].exports;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function _lodashcloneMapjs4162_cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(_lodashcloneMapjs4162_mapToArray(map), true) : _lodashcloneMapjs4162_mapToArray(map);
  return _lodashcloneMapjs4162_arrayReduce(array, _lodashcloneMapjs4162_addMapEntry, new map.constructor());
}

$m['lodash/_cloneMap.js#4.16.2'].exports = _lodashcloneMapjs4162_cloneMap;
/*≠≠ node_modules/lodash/_cloneMap.js ≠≠*/

/*== node_modules/lodash/_cloneDataView.js ==*/
$m['lodash/_cloneDataView.js#4.16.2'] = { exports: {} };
var _lodashcloneDataViewjs4162_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.16.2'].exports;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function _lodashcloneDataViewjs4162_cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _lodashcloneDataViewjs4162_cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

$m['lodash/_cloneDataView.js#4.16.2'].exports = _lodashcloneDataViewjs4162_cloneDataView;
/*≠≠ node_modules/lodash/_cloneDataView.js ≠≠*/

/*== node_modules/lodash/_WeakMap.js ==*/
$m['lodash/_WeakMap.js#4.16.2'] = { exports: {} };
var _lodashWeakMapjs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports,
    _lodashWeakMapjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashWeakMapjs4162_WeakMap = _lodashWeakMapjs4162_getNative(_lodashWeakMapjs4162_root, 'WeakMap');

$m['lodash/_WeakMap.js#4.16.2'].exports = _lodashWeakMapjs4162_WeakMap;
/*≠≠ node_modules/lodash/_WeakMap.js ≠≠*/

/*== node_modules/lodash/_Set.js ==*/
$m['lodash/_Set.js#4.16.2'] = { exports: {} };
var _lodashSetjs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports,
    _lodashSetjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashSetjs4162_Set = _lodashSetjs4162_getNative(_lodashSetjs4162_root, 'Set');

$m['lodash/_Set.js#4.16.2'].exports = _lodashSetjs4162_Set;
/*≠≠ node_modules/lodash/_Set.js ≠≠*/

/*== node_modules/lodash/_Promise.js ==*/
$m['lodash/_Promise.js#4.16.2'] = { exports: {} };
var _lodashPromisejs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports,
    _lodashPromisejs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashPromisejs4162_Promise = _lodashPromisejs4162_getNative(_lodashPromisejs4162_root, 'Promise');

$m['lodash/_Promise.js#4.16.2'].exports = _lodashPromisejs4162_Promise;
/*≠≠ node_modules/lodash/_Promise.js ≠≠*/

/*== node_modules/lodash/_DataView.js ==*/
$m['lodash/_DataView.js#4.16.2'] = { exports: {} };
var _lodashDataViewjs4162_getNative = $m['lodash/_getNative.js#4.16.2'].exports,
    _lodashDataViewjs4162_root = $m['lodash/_root.js#4.16.2'].exports;

/* Built-in method references that are verified to be native. */
var _lodashDataViewjs4162_DataView = _lodashDataViewjs4162_getNative(_lodashDataViewjs4162_root, 'DataView');

$m['lodash/_DataView.js#4.16.2'].exports = _lodashDataViewjs4162_DataView;
/*≠≠ node_modules/lodash/_DataView.js ≠≠*/

/*== node_modules/lodash/_baseGetAllKeys.js ==*/
$m['lodash/_baseGetAllKeys.js#4.16.2'] = { exports: {} };
var _lodashbaseGetAllKeysjs4162_arrayPush = $m['lodash/_arrayPush.js#4.16.2'].exports,
    _lodashbaseGetAllKeysjs4162_isArray = $m['lodash/isArray.js#4.16.2'].exports;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function _lodashbaseGetAllKeysjs4162_baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return _lodashbaseGetAllKeysjs4162_isArray(object) ? result : _lodashbaseGetAllKeysjs4162_arrayPush(result, symbolsFunc(object));
}

$m['lodash/_baseGetAllKeys.js#4.16.2'].exports = _lodashbaseGetAllKeysjs4162_baseGetAllKeys;
/*≠≠ node_modules/lodash/_baseGetAllKeys.js ≠≠*/

/*== node_modules/lodash/_getSymbols.js ==*/
$m['lodash/_getSymbols.js#4.16.2'] = { exports: {} };
var _lodashgetSymbolsjs4162_overArg = $m['lodash/_overArg.js#4.16.2'].exports,
    _lodashgetSymbolsjs4162_stubArray = $m['lodash/stubArray.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashgetSymbolsjs4162_nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var _lodashgetSymbolsjs4162_getSymbols = _lodashgetSymbolsjs4162_nativeGetSymbols ? _lodashgetSymbolsjs4162_overArg(_lodashgetSymbolsjs4162_nativeGetSymbols, Object) : _lodashgetSymbolsjs4162_stubArray;

$m['lodash/_getSymbols.js#4.16.2'].exports = _lodashgetSymbolsjs4162_getSymbols;
/*≠≠ node_modules/lodash/_getSymbols.js ≠≠*/

/*== node_modules/lodash/_assocIndexOf.js ==*/
$m['lodash/_assocIndexOf.js#4.16.2'] = { exports: {} };
var _lodashassocIndexOfjs4162_eq = $m['lodash/eq.js#4.16.2'].exports;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashassocIndexOfjs4162_assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (_lodashassocIndexOfjs4162_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

$m['lodash/_assocIndexOf.js#4.16.2'].exports = _lodashassocIndexOfjs4162_assocIndexOf;
/*≠≠ node_modules/lodash/_assocIndexOf.js ≠≠*/

/*== lib/plugins/js/replaceEnvironment.js ==*/
$m['lib/plugins/js/replaceEnvironment.js'] = { exports: {} };
'use strict';

const { regexpEscape: _libpluginsjsreplaceEnvironmentjs_regexpEscape } = $m['lib/utils/string.js'].exports;

const _libpluginsjsreplaceEnvironmentjs_ENV_RUNTIME = 'RUNTIME';
// Match process.env.FOO, process.env['FOO'], or process.env["FOO"]
const _libpluginsjsreplaceEnvironmentjs_RE_ENV = /process\.env(?:(?:\[['"])|\.)(\w+)(?:['"]\])?/gm;

/**
 * Replace process.env references with values
 * @param {String} content
 * @param {Boolean} browser
 * @returns {String}
 */
$m['lib/plugins/js/replaceEnvironment.js'].exports = function replaceEnvironment(content, browser = true) {
  let matches = {};
  let match;

  // Find all matches
  while (match = _libpluginsjsreplaceEnvironmentjs_RE_ENV.exec(content)) {
    const env = process.env[match[1]];
    // Do not stringify empty values
    let value = env != undefined ? `'${ env }'` : env;

    // Force RUNTIME to "browser/server"
    if (match[1] == _libpluginsjsreplaceEnvironmentjs_ENV_RUNTIME) {
      value = browser ? "'browser'" : "'server'";
      // Ignore all others on server
    } else if (!browser) {
      value = '';
    }
    // Don't replace if undefined
    if (value) matches[match[0]] = value;
  }

  // Replace all references
  for (const context in matches) {
    // Create new RegExp so that flags work properly
    content = content.replace(new RegExp(_libpluginsjsreplaceEnvironmentjs_regexpEscape(context), 'gm'), matches[context]);
  }

  return content;
};
/*≠≠ lib/plugins/js/replaceEnvironment.js ≠≠*/

/*== node_modules/babel-core/index.js ==*/
$m['babel-core/index.js#6.16.0'] = { exports: {} };
$m['babel-core/index.js#6.16.0'].exports = $m['babel-core/lib/api/node.js#6.16.0'].exports;
/*≠≠ node_modules/babel-core/index.js ≠≠*/

/*== node_modules/inline-source/lib/wrap.js ==*/
$m['inline-source/lib/wrap.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibwrapjs511_utils = $m['inline-source/lib/utils.js#5.1.1'].exports;

const _inlinesourcelibwrapjs511_RE_BEGIN_LINE = /^./gm;

/**
 * Wrap source content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 */
$m['inline-source/lib/wrap.js#5.1.1'].exports = function wrap(source, context, next) {
  if (source.content != null && !source.replace) {
    const attrs = _inlinesourcelibwrapjs511_utils.getAttributeString(source.attributes, context.attribute, !source.errored);
    // link tags are not closed
    const closing = source.tag != 'link' ? '</' + source.tag + '>' : '';
    const content = context.pretty ? '\n' + source.content.replace(_inlinesourcelibwrapjs511_RE_BEGIN_LINE, source.padding + '$&') + '\n' + source.padding : source.content;

    source.replace = '<' + source.tag + attrs + '>' + content + closing;
  }

  if (next) next();
};
/*≠≠ node_modules/inline-source/lib/wrap.js ≠≠*/

/*== node_modules/inline-source/lib/img.js ==*/
$m['inline-source/lib/img.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibimgjs511_imgSVG = $m['inline-source/lib/imgSVG.js#5.1.1'].exports;
const _inlinesourcelibimgjs511_utils = $m['inline-source/lib/utils.js#5.1.1'].exports;

const _inlinesourcelibimgjs511_RE_XML_TAG = /<\?xml.+?\?>\s+/g;

let _inlinesourcelibimgjs511_svgo;

/**
 * Handle IMG content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/img.js#5.1.1'].exports = function img(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibimgjs511_utils.noop;

  if (source.fileContent && !source.content && source.type == 'image') {
    const attributeType = source.attributes.type;
    let strict = !source.errored;
    let sourceProp = 'src';
    let data, encoding;

    delete source.attributes.type;

    // svg
    if (source.format == 'svg+xml') {
      // Init compressor
      if (source.compress && !_inlinesourcelibimgjs511_svgo) {
        const Svgo = {};

        _inlinesourcelibimgjs511_svgo = new Svgo({
          plugins: [
          // Prevent removal of unused <symbol> elements
          { cleanupIDs: false },
          // Prevent removal of xlink:href on <image> elements
          { removeEmptyAttrs: false }, { removeUselessDefs: false },
          // Prevent removal of <image> src attribute
          { removeUnknownsAndDefaults: false }]
        });
      }
      if (!source.svgAsImage) return _inlinesourcelibimgjs511_imgSVG(source, context, _inlinesourcelibimgjs511_svgo, next);

      source.tag = 'img';
      // Strip xml tag
      source.content = source.fileContent.replace(_inlinesourcelibimgjs511_RE_XML_TAG, '');
      if (source.compress) {
        // Sync api call
        _inlinesourcelibimgjs511_svgo.optimize(source.content, content => {
          source.content = content.data;
        });
      }
      data = encodeURIComponent(source.content);
      encoding = 'utf8';

      // gif/png/jpeg
    } else {
      data = new Buffer(source.fileContent).toString('base64');
      encoding = 'base64';

      // Favicon
      if (source.tag == 'link') {
        source.attributes.type = attributeType;
        sourceProp = 'href';
        strict = false;
        delete source.attributes.href;
      }
    }

    const src = 'data:image/' + source.format + ';' + encoding + ',' + data;
    let attrs = _inlinesourcelibimgjs511_utils.getAttributeString(source.attributes, context.attribute, strict);

    attrs += ' ' + sourceProp + '="' + src + '"';
    source.content = src;
    source.replace = '<' + source.tag + attrs + ' />';

    next();
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/img.js ≠≠*/

/*== node_modules/inline-source/lib/js.js ==*/
$m['inline-source/lib/js.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibjsjs511_noop = $m['inline-source/lib/utils.js#5.1.1'].exports.noop;

const _inlinesourcelibjsjs511_RE_SCRIPT = /(<)(\/script>)/g;

/**
 * Handle JavaScript content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/js.js#5.1.1'].exports = function js(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibjsjs511_noop;

  if (source.fileContent && !source.content && source.type == 'js') {
    try {
      source.content = source.compress ? {}.minify(source.fileContent, { fromString: true }).code : source.fileContent;

      // Escape closing </script>
      if (_inlinesourcelibjsjs511_RE_SCRIPT.test(source.content)) {
        source.content = source.content.replace(_inlinesourcelibjsjs511_RE_SCRIPT, '\\x3C$2');
      }

      next();
    } catch (err) {
      return next(err);
    }
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/js.js ≠≠*/

/*== node_modules/inline-source/lib/css.js ==*/
$m['inline-source/lib/css.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibcssjs511_noop = $m['inline-source/lib/utils.js#5.1.1'].exports.noop;

/**
 * Handle CSS content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/css.js#5.1.1'].exports = function css(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibcssjs511_noop;

  if (source.fileContent && !source.content && source.type == 'css') {
    try {
      source.content = source.compress ? {}.minify(source.fileContent).css : source.fileContent;
      // Change tag type
      source.tag = 'style';
      next();
    } catch (err) {
      return next(err);
    }
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/css.js ≠≠*/

/*== node_modules/lodash/_compareAscending.js ==*/
$m['lodash/_compareAscending.js#4.16.2'] = { exports: {} };
var _lodashcompareAscendingjs4162_isSymbol = $m['lodash/isSymbol.js#4.16.2'].exports;

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function _lodashcompareAscendingjs4162_compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = _lodashcompareAscendingjs4162_isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = _lodashcompareAscendingjs4162_isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

$m['lodash/_compareAscending.js#4.16.2'].exports = _lodashcompareAscendingjs4162_compareAscending;
/*≠≠ node_modules/lodash/_compareAscending.js ≠≠*/

/*== lib/dependency-resolver/alias.js ==*/
$m['lib/dependency-resolver/alias.js'] = { exports: {} };
'use strict';

const { isFilepath: _libdependencyresolveraliasjs_isFilepath, isRelativeFilepath: _libdependencyresolveraliasjs_isRelativeFilepath } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolveraliasjs_fs = require('fs');
const _libdependencyresolveraliasjs_path = require('path');

/**
 * Parse 'aliases' relative to 'pkgpath'
 * @param {String} pkgpath
 * @param {Object} aliases
 * @returns {Object}
 */
$m['lib/dependency-resolver/alias.js'].exports = {
  parse(pkgpath, aliases) {
    let parsedAliases = {};

    for (const key in aliases) {
      const value = aliases[key];
      let rKey = _libdependencyresolveraliasjs_path.resolve(pkgpath, key);
      let rValue;

      // Fix for missing relative path prefix
      if (!_libdependencyresolveraliasjs_isRelativeFilepath(key) && !_libdependencyresolveraliasjs_fs.existsSync(rKey)) rKey = key;
      if ('string' == typeof value) {
        rValue = _libdependencyresolveraliasjs_path.resolve(pkgpath, value);
        if (!_libdependencyresolveraliasjs_isRelativeFilepath(value) && !_libdependencyresolveraliasjs_fs.existsSync(rValue)) rValue = value;
      } else {
        rValue = value;
      }

      parsedAliases[key] = value;
      // Resolve relative
      if (key != rKey || value != rValue) parsedAliases[rKey] = rValue;
    }

    return parsedAliases;
  },

  /**
   * Resolve alias for 'id'
   * @param {Object} pkgDetails
   * @param {String} id
   * @returns {String}
   */
  resolve(pkgDetails, id) {
    if (!pkgDetails || !id) return id;

    const { aliases } = pkgDetails;

    if (id in aliases) return aliases[id];

    // Match packages
    if (!_libdependencyresolveraliasjs_isFilepath(id)) {
      const parts = id.split(_libdependencyresolveraliasjs_path.sep);
      // Handle scoped
      const pkg = parts.slice(0, parts[0].charAt(0) == '@' ? 2 : 1).join(_libdependencyresolveraliasjs_path.sep);

      // Disable whole package
      if (aliases[pkg] === false) return false;
    }

    return id;
  }
};
/*≠≠ lib/dependency-resolver/alias.js ≠≠*/

/*== lib/dependency-resolver/nativeModules.js ==*/
$m['lib/dependency-resolver/nativeModules.js'] = { exports: {} };
'use strict';

$m['lib/dependency-resolver/nativeModules.js'].exports = require('repl')._builtinLibs.concat('repl', 'module');
/*≠≠ lib/dependency-resolver/nativeModules.js ≠≠*/

/*== node_modules/lodash/union.js ==*/
$m['lodash/union.js#4.16.2'] = { exports: {} };
var _lodashunionjs4162_baseFlatten = $m['lodash/_baseFlatten.js#4.16.2'].exports,
    _lodashunionjs4162_baseRest = $m['lodash/_baseRest.js#4.16.2'].exports,
    _lodashunionjs4162_baseUniq = $m['lodash/_baseUniq.js#4.16.2'].exports,
    _lodashunionjs4162_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.16.2'].exports;

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var _lodashunionjs4162_union = _lodashunionjs4162_baseRest(function (arrays) {
  return _lodashunionjs4162_baseUniq(_lodashunionjs4162_baseFlatten(arrays, 1, _lodashunionjs4162_isArrayLikeObject, true));
});

$m['lodash/union.js#4.16.2'].exports = _lodashunionjs4162_union;
/*≠≠ node_modules/lodash/union.js ≠≠*/

/*== lib/dependency-resolver/config.js ==*/
$m['lib/dependency-resolver/config.js'] = { exports: {} };
'use strict';

const { execSync: _libdependencyresolverconfigjs_exec } = require('child_process');
const _libdependencyresolverconfigjs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverconfigjs_nativeModules = $m['lib/dependency-resolver/nativeModules.js'].exports;
const _libdependencyresolverconfigjs_path = require('path');
const _libdependencyresolverconfigjs_union = $m['lodash/union.js#4.16.2'].exports;

const _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS = {
  js: ['js', 'json'],
  css: ['css'],
  html: ['html']
};

/**
 * Parse and format 'options'
 * @param {Object} [options]
 *  - {Object} fileExtensions
 *  - {Object} globalAliases
 * @returns {Object}
 */
$m['lib/dependency-resolver/config.js'].exports = function config(options) {
  options = options || {};
  options.fileExtensions = options.fileExtensions || {};

  return {
    fileExtensions: {
      js: _libdependencyresolverconfigjs_union(options.fileExtensions.js || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.js),
      css: _libdependencyresolverconfigjs_union(options.fileExtensions.css || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.css),
      html: _libdependencyresolverconfigjs_union(options.fileExtensions.html || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.html)
    },
    globalAliases: _libdependencyresolverconfigjs_alias.parse(process.cwd(), options.globalAliases || {}),
    globalSources: $m['lib/dependency-resolver/config.js'].exports.globalSources,
    nativeModules: _libdependencyresolverconfigjs_nativeModules,
    sources: $m['lib/dependency-resolver/config.js'].exports.sources
  };
};

// Expose
$m['lib/dependency-resolver/config.js'].exports.globalSources = _libdependencyresolverconfigjs_resolveSources(true);
$m['lib/dependency-resolver/config.js'].exports.sources = _libdependencyresolverconfigjs_resolveSources(false);
$m['lib/dependency-resolver/config.js'].exports.VERSION_DELIMITER = '#';

/**
 * Resolve sources
 * @param {Boolean} global
 * @returns {Array}
 */
function _libdependencyresolverconfigjs_resolveSources(global) {
  const sources = global
  // Get global path from npm config
  ? [_libdependencyresolverconfigjs_path.join(process.env.npm_config_prefix || _libdependencyresolverconfigjs_exec('npm config get prefix', { encoding: 'utf8' }), 'lib/node_modules')] : [..._libdependencyresolverconfigjs_resolveEnvSources('NODE_PATH'), ..._libdependencyresolverconfigjs_resolveEnvSources('BROWSER_PATH')];

  return sources.map(source => _libdependencyresolverconfigjs_path.resolve(source));
}

/**
 * Resolve environment variable sources for 'env'
 * @param {String} env
 * @returns {Array}
 */
function _libdependencyresolverconfigjs_resolveEnvSources(env) {
  let paths = [];

  if (process.env[env]) {
    paths = ~process.env[env].indexOf(':') ? process.env[env].split(':') : [process.env[env]];
  }

  return paths;
}
/*≠≠ lib/dependency-resolver/config.js ≠≠*/

/*== lib/dependency-resolver/utils.js ==*/
$m['lib/dependency-resolver/utils.js'] = { exports: {} };
'use strict';

const _libdependencyresolverutilsjs_fs = require('fs');
const _libdependencyresolverutilsjs_path = require('path');

/**
 * Determine if 'filepath' is relative
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isRelativeFilepath = function (filepath) {
  return 'string' == typeof filepath && filepath.charAt(0) == '.';
};

/**
 * Determine if 'filepath' is absolute
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isAbsoluteFilepath = function (filepath) {
  return 'string' == typeof filepath && _libdependencyresolverutilsjs_path.resolve(filepath) == filepath;
};

/**
 * Determine if 'str' is a filepath or package reference
 * @param {String} str
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isFilepath = function (str) {
  return $m['lib/dependency-resolver/utils.js'].exports.isAbsoluteFilepath(str) || $m['lib/dependency-resolver/utils.js'].exports.isRelativeFilepath(str);
};

/**
 * Determine file type for 'filepath'
 * @param {String} filepath
 * @param {Object} fileExtensions
 * @returns {String}
 */
$m['lib/dependency-resolver/utils.js'].exports.deriveType = function (filepath, fileExtensions) {
  const ext = _libdependencyresolverutilsjs_path.extname(filepath).slice(1);

  // Match input extension to type
  for (const type in fileExtensions) {
    const exts = fileExtensions[type];

    for (let i = 0, n = exts.length; i < n; i++) {
      if (ext == exts[i]) return type;
    }
  }
};

/**
 * Check the location of 'filepath'
 * @param {String} filepath
 * @param {String} type
 * @param {Array} fileExtensions
 * @returns {String}
 */
$m['lib/dependency-resolver/utils.js'].exports.findFile = function (filepath, type, fileExtensions) {
  if ('string' == typeof filepath) {
    // Already have full filepath
    if (_libdependencyresolverutilsjs_path.extname(filepath)) {
      try {
        if (_libdependencyresolverutilsjs_fs.statSync(filepath).isFile()) return filepath;
      } catch (err) {/* File doesn't exist */}
    }

    let ext, fp;

    // Loop through fileExtensions and locate file
    for (let i = 0, n = fileExtensions[type].length; i < n; i++) {
      ext = fileExtensions[type][i];
      // Add extension
      fp = filepath + '.' + ext;
      if (_libdependencyresolverutilsjs_fs.existsSync(fp)) return fp;
      // Try 'index' + extension
      fp = _libdependencyresolverutilsjs_path.resolve(filepath, 'index.' + ext);
      if (_libdependencyresolverutilsjs_fs.existsSync(fp)) return fp;
    }

    return '';
  }

  return filepath;
};
/*≠≠ lib/dependency-resolver/utils.js ≠≠*/

/*== node_modules/lodash/_createSet.js ==*/
$m['lodash/_createSet.js#4.16.2'] = { exports: {} };
var _lodashcreateSetjs4162_Set = $m['lodash/_Set.js#4.16.2'].exports,
    _lodashcreateSetjs4162_noop = $m['lodash/noop.js#4.16.2'].exports,
    _lodashcreateSetjs4162_setToArray = $m['lodash/_setToArray.js#4.16.2'].exports;

/** Used as references for various `Number` constants. */
var _lodashcreateSetjs4162_INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var _lodashcreateSetjs4162_createSet = !(_lodashcreateSetjs4162_Set && 1 / _lodashcreateSetjs4162_setToArray(new _lodashcreateSetjs4162_Set([, -0]))[1] == _lodashcreateSetjs4162_INFINITY) ? _lodashcreateSetjs4162_noop : function (values) {
  return new _lodashcreateSetjs4162_Set(values);
};

$m['lodash/_createSet.js#4.16.2'].exports = _lodashcreateSetjs4162_createSet;
/*≠≠ node_modules/lodash/_createSet.js ≠≠*/

/*== node_modules/lodash/_arrayIncludes.js ==*/
$m['lodash/_arrayIncludes.js#4.16.2'] = { exports: {} };
var _lodasharrayIncludesjs4162_baseIndexOf = $m['lodash/_baseIndexOf.js#4.16.2'].exports;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function _lodasharrayIncludesjs4162_arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && _lodasharrayIncludesjs4162_baseIndexOf(array, value, 0) > -1;
}

$m['lodash/_arrayIncludes.js#4.16.2'].exports = _lodasharrayIncludesjs4162_arrayIncludes;
/*≠≠ node_modules/lodash/_arrayIncludes.js ≠≠*/

/*== node_modules/lodash/_baseUniq.js ==*/
$m['lodash/_baseUniq.js#4.16.2'] = { exports: {} };
var _lodashbaseUniqjs4162_SetCache = $m['lodash/_SetCache.js#4.16.2'].exports,
    _lodashbaseUniqjs4162_arrayIncludes = $m['lodash/_arrayIncludes.js#4.16.2'].exports,
    _lodashbaseUniqjs4162_arrayIncludesWith = $m['lodash/_arrayIncludesWith.js#4.16.2'].exports,
    _lodashbaseUniqjs4162_cacheHas = $m['lodash/_cacheHas.js#4.16.2'].exports,
    _lodashbaseUniqjs4162_createSet = $m['lodash/_createSet.js#4.16.2'].exports,
    _lodashbaseUniqjs4162_setToArray = $m['lodash/_setToArray.js#4.16.2'].exports;

/** Used as the size to enable large array optimizations. */
var _lodashbaseUniqjs4162_LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function _lodashbaseUniqjs4162_baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _lodashbaseUniqjs4162_arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _lodashbaseUniqjs4162_arrayIncludesWith;
  } else if (length >= _lodashbaseUniqjs4162_LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : _lodashbaseUniqjs4162_createSet(array);
    if (set) {
      return _lodashbaseUniqjs4162_setToArray(set);
    }
    isCommon = false;
    includes = _lodashbaseUniqjs4162_cacheHas;
    seen = new _lodashbaseUniqjs4162_SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

$m['lodash/_baseUniq.js#4.16.2'].exports = _lodashbaseUniqjs4162_baseUniq;
/*≠≠ node_modules/lodash/_baseUniq.js ≠≠*/

/*== node_modules/async/internal/iterator.js ==*/
$m['async/internal/iterator.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/iterator.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/iterator.js#2.0.1'].exports.default = _asyncinternaliteratorjs201_iterator;

var _asyncinternaliteratorjs201__isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

var _asyncinternaliteratorjs201__isArrayLike2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__isArrayLike);

var _asyncinternaliteratorjs201__getIterator = $m['async/internal/getIterator.js#2.0.1'].exports;

var _asyncinternaliteratorjs201__getIterator2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__getIterator);

var _asyncinternaliteratorjs201__keys = $m['lodash/keys.js#4.16.2'].exports;

var _asyncinternaliteratorjs201__keys2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__keys);

function _asyncinternaliteratorjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternaliteratorjs201_createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function _asyncinternaliteratorjs201_createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function _asyncinternaliteratorjs201_createObjectIterator(obj) {
    var okeys = (0, _asyncinternaliteratorjs201__keys2.default)(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key: key } : null;
    };
}

function _asyncinternaliteratorjs201_iterator(coll) {
    if ((0, _asyncinternaliteratorjs201__isArrayLike2.default)(coll)) {
        return _asyncinternaliteratorjs201_createArrayIterator(coll);
    }

    var iterator = (0, _asyncinternaliteratorjs201__getIterator2.default)(coll);
    return iterator ? _asyncinternaliteratorjs201_createES2015Iterator(iterator) : _asyncinternaliteratorjs201_createObjectIterator(coll);
}
$m['async/internal/iterator.js#2.0.1'].exports = $m['async/internal/iterator.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/iterator.js ≠≠*/

/*== node_modules/lodash/_baseSetToString.js ==*/
$m['lodash/_baseSetToString.js#4.16.2'] = { exports: {} };
var _lodashbaseSetToStringjs4162_constant = $m['lodash/constant.js#4.16.2'].exports,
    _lodashbaseSetToStringjs4162_identity = $m['lodash/identity.js#4.16.2'].exports,
    _lodashbaseSetToStringjs4162_nativeDefineProperty = $m['lodash/_nativeDefineProperty.js#4.16.2'].exports;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var _lodashbaseSetToStringjs4162_baseSetToString = !_lodashbaseSetToStringjs4162_nativeDefineProperty ? _lodashbaseSetToStringjs4162_identity : function (func, string) {
  return _lodashbaseSetToStringjs4162_nativeDefineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': _lodashbaseSetToStringjs4162_constant(string),
    'writable': true
  });
};

$m['lodash/_baseSetToString.js#4.16.2'].exports = _lodashbaseSetToStringjs4162_baseSetToString;
/*≠≠ node_modules/lodash/_baseSetToString.js ≠≠*/

/*== node_modules/lodash/_baseIsTypedArray.js ==*/
$m['lodash/_baseIsTypedArray.js#4.16.2'] = { exports: {} };
var _lodashbaseIsTypedArrayjs4162_isLength = $m['lodash/isLength.js#4.16.2'].exports,
    _lodashbaseIsTypedArrayjs4162_isObjectLike = $m['lodash/isObjectLike.js#4.16.2'].exports;

/** `Object#toString` result references. */
var _lodashbaseIsTypedArrayjs4162_argsTag = '[object Arguments]',
    _lodashbaseIsTypedArrayjs4162_arrayTag = '[object Array]',
    _lodashbaseIsTypedArrayjs4162_boolTag = '[object Boolean]',
    _lodashbaseIsTypedArrayjs4162_dateTag = '[object Date]',
    _lodashbaseIsTypedArrayjs4162_errorTag = '[object Error]',
    _lodashbaseIsTypedArrayjs4162_funcTag = '[object Function]',
    _lodashbaseIsTypedArrayjs4162_mapTag = '[object Map]',
    _lodashbaseIsTypedArrayjs4162_numberTag = '[object Number]',
    _lodashbaseIsTypedArrayjs4162_objectTag = '[object Object]',
    _lodashbaseIsTypedArrayjs4162_regexpTag = '[object RegExp]',
    _lodashbaseIsTypedArrayjs4162_setTag = '[object Set]',
    _lodashbaseIsTypedArrayjs4162_stringTag = '[object String]',
    _lodashbaseIsTypedArrayjs4162_weakMapTag = '[object WeakMap]';

var _lodashbaseIsTypedArrayjs4162_arrayBufferTag = '[object ArrayBuffer]',
    _lodashbaseIsTypedArrayjs4162_dataViewTag = '[object DataView]',
    _lodashbaseIsTypedArrayjs4162_float32Tag = '[object Float32Array]',
    _lodashbaseIsTypedArrayjs4162_float64Tag = '[object Float64Array]',
    _lodashbaseIsTypedArrayjs4162_int8Tag = '[object Int8Array]',
    _lodashbaseIsTypedArrayjs4162_int16Tag = '[object Int16Array]',
    _lodashbaseIsTypedArrayjs4162_int32Tag = '[object Int32Array]',
    _lodashbaseIsTypedArrayjs4162_uint8Tag = '[object Uint8Array]',
    _lodashbaseIsTypedArrayjs4162_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashbaseIsTypedArrayjs4162_uint16Tag = '[object Uint16Array]',
    _lodashbaseIsTypedArrayjs4162_uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var _lodashbaseIsTypedArrayjs4162_typedArrayTags = {};
_lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_float32Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_float64Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_int8Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_int16Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_int32Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_uint8Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_uint8ClampedTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_uint16Tag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_uint32Tag] = true;
_lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_argsTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_arrayTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_arrayBufferTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_boolTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_dataViewTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_dateTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_errorTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_funcTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_mapTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_numberTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_objectTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_regexpTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_setTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_stringTag] = _lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_weakMapTag] = false;

/** Used for built-in method references. */
var _lodashbaseIsTypedArrayjs4162_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashbaseIsTypedArrayjs4162_objectToString = _lodashbaseIsTypedArrayjs4162_objectProto.toString;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function _lodashbaseIsTypedArrayjs4162_baseIsTypedArray(value) {
    return _lodashbaseIsTypedArrayjs4162_isObjectLike(value) && _lodashbaseIsTypedArrayjs4162_isLength(value.length) && !!_lodashbaseIsTypedArrayjs4162_typedArrayTags[_lodashbaseIsTypedArrayjs4162_objectToString.call(value)];
}

$m['lodash/_baseIsTypedArray.js#4.16.2'].exports = _lodashbaseIsTypedArrayjs4162_baseIsTypedArray;
/*≠≠ node_modules/lodash/_baseIsTypedArray.js ≠≠*/

/*== lib/plugins/js/transpile.js ==*/
$m['lib/plugins/js/transpile.js'] = { exports: {} };
'use strict';

const _libpluginsjstranspilejs_babel = $m['babel-core/index.js#6.16.0'].exports;

/**
 * Transpile 'content' based on Babel 'options'
 * @param {JSFile} file
 * @param {Object} options
 */
$m['lib/plugins/js/transpile.js'].exports = function transpile(file, options) {
  if (!options.plugins.length || options.presets && !options.presets.length) return;

  options = Object.assign({ filename: file.filename }, options);

  const transform = file.ast ? _libpluginsjstranspilejs_babel.transformFromAst(file.ast, file.content, options) : _libpluginsjstranspilejs_babel.transform(file.content, options);

  file.content = transform.code;
  file.ast = transform.ast;
};
/*≠≠ lib/plugins/js/transpile.js ≠≠*/

/*== lib/plugins/js/replaceReferences.js ==*/
$m['lib/plugins/js/replaceReferences.js'] = { exports: {} };
'use strict';

const { regexpEscape: _libpluginsjsreplaceReferencesjs_regexpEscape } = $m['lib/utils/string.js'].exports;

/**
 * Replace 'references' in 'content'
 * @param {String} content
 * @param {Set} dependencyReferences
 * @param {Boolean} browser
 * @returns {String}
 */
$m['lib/plugins/js/replaceReferences.js'].exports = function replaceReferences(content, dependencyReferences) {
  for (const reference of dependencyReferences) {
    // Ignore inlineable references
    if (!reference.isDisabled && reference.file && reference.file.type != 'json') {
      // Don't inline 'require' call if ignored, circular, or locked
      const context = !reference.isIgnored && !reference.file.isCircularDependency ? `$m['${ reference.file.id }'].exports` : reference.context.replace(reference.id, reference.file.id);

      // Create new RegExp so that flags work properly
      content = content.replace(new RegExp(_libpluginsjsreplaceReferencesjs_regexpEscape(reference.context), 'gm'), context);
    }
  }

  return content;
};
/*≠≠ lib/plugins/js/replaceReferences.js ≠≠*/

/*== lib/plugins/js/inline.js ==*/
$m['lib/plugins/js/inline.js'] = { exports: {} };
'use strict';

const { regexpEscape: _libpluginsjsinlinejs_regexpEscape } = $m['lib/utils/string.js'].exports;

/**
 * Inline json/disabled dependency content
 * @param {String} content
 * @param {Set} dependencyReferences
 * @param {Boolean} browser
 * @returns {String}
 */
$m['lib/plugins/js/inline.js'].exports = function inline(content, dependencyReferences, browser) {
  for (const reference of dependencyReferences) {
    let inlineContent = '';

    // Handle disabled
    if (reference.isDisabled) {
      inlineContent = '{}';
      // Inline json
    } else if (reference.file && reference.file.type == 'json') {
      inlineContent = reference.file.content || '{}';
    }
    // Replace require(*) with inlined content
    if (inlineContent) content = content.replace(new RegExp(_libpluginsjsinlinejs_regexpEscape(reference.context), 'mg'), inlineContent);
  }

  return content;
};
/*≠≠ lib/plugins/js/inline.js ≠≠*/

/*== lib/plugins/js/flatten.js ==*/
$m['lib/plugins/js/flatten.js'] = { exports: {} };
'use strict';

const _libpluginsjsflattenjs_babel = $m['babel-core/index.js#6.16.0'].exports;
const _libpluginsjsflattenjs_namespaceRootDeclarations = $m['lib/plugins/js/babel-plugin-transform-namespace-root-declarations/index.js'].exports;
const _libpluginsjsflattenjs_replaceModuleExports = $m['lib/plugins/js/babel-plugin-transform-replace-module-exports/index.js'].exports;

/**
 * Flatten 'content' scope
 * @param {JSFile} file
 * @param {Boolean} replace
 * @param {Object} options
 */
$m['lib/plugins/js/flatten.js'].exports = function flatten(file, replace) {
  let plugins = [[_libpluginsjsflattenjs_namespaceRootDeclarations, { source: `_${ file.idSafe }_` }], [_libpluginsjsflattenjs_replaceModuleExports, { source: `$m['${ file.id }']` }]];

  if (!replace) plugins.pop();

  const options = {
    filename: file.filename,
    plugins
  };
  const transform = file.ast ? _libpluginsjsflattenjs_babel.transformFromAst(file.ast, file.content, options) : _libpluginsjsflattenjs_babel.transform(file.content, options);

  file.content = transform.code;
  file.ast = transform.ast;
};
/*≠≠ lib/plugins/js/flatten.js ≠≠*/

/*== lib/plugins/js/concat.js ==*/
$m['lib/plugins/js/concat.js'] = { exports: {} };
'use strict';

const { buildExternalHelpers: _libpluginsjsconcatjs_buildExternalHelpers } = $m['babel-core/index.js#6.16.0'].exports;
const _libpluginsjsconcatjs_replaceEnvironment = $m['lib/plugins/js/replaceEnvironment.js'].exports;

const _libpluginsjsconcatjs_REQUIRE_BOILERPLATE = `if ('undefined' === typeof self) var self = this;
if ('undefined' === typeof global) var global = self;
if ('undefined' === typeof process) var process = { env: {} };
var $m = self.$m = self.$m || {};
var require = self.require || function require (id) {
  if ($m[id]) {
    if ('function' == typeof $m[id]) $m[id]();
    return $m[id].exports;
  }

  if (process.env.NODE_ENV == 'development') {
    console.warn('module ' + id + ' not found');
  }
};`;
const _libpluginsjsconcatjs_REQUIRE_NODE_BOILERPLATE = `var $m = {};
var originalRequire = require;
require = function buddyRequire (id) {
  if (!$m[id]) return originalRequire(id);
  if ('function' == typeof $m[id]) $m[id]();
  return $m[id].exports;
};`;

/**
 * Concatenate dependency content for 'file'
 * @param {JSFile} file
 * @param {String} header
 * @param {Object} buildOptions
 *  - {Boolean} bootstrap
 *  - {Boolean} boilerplate
 *  - {Boolean} browser
 *  - {Boolean} bundle
 *  - {Boolean} compress
 *  - {Array} ignoredFiles
 *  - {Boolean} helpers
 *  - {Boolean} watchOnly
 * @returns {String}
 */
$m['lib/plugins/js/concat.js'].exports = function concat(file, header, buildOptions) {
  const { boilerplate, bootstrap, browser, helpers } = buildOptions;
  const contents = [];
  // Ignore inlined json
  const dependencies = file.getAllDependencies().filter(dependency => dependency.type != 'json');

  // Add header
  contents.push(header);

  // Add require boilerplate
  if (boilerplate) {
    contents.push(browser
    // Replace process.env.NODE_ENV
    ? _libpluginsjsconcatjs_replaceEnvironment(_libpluginsjsconcatjs_REQUIRE_BOILERPLATE) : _libpluginsjsconcatjs_REQUIRE_NODE_BOILERPLATE);
  }

  // Add helpers
  if (helpers) {
    const allHelpers = file.getAllHelpers();

    if (allHelpers.length) contents.push(_libpluginsjsconcatjs_buildExternalHelpers(allHelpers));
  }

  // Add wrapper open
  if (browser) {
    contents.push(bootstrap ? '!(function () {' : `$m['${ file.id }'] = function () {`);
  }

  // Add dependencies
  dependencies.forEach(dependency => {
    contents.push(`/*== ${ dependency.relpath } ==*/`, `$m['${ dependency.id }'] = ${ dependency.isCircularDependency ? 'function () {\n$m[\'' + dependency.id + '\'] = ' : '' }{ exports: {} };`, dependency.content, `${ dependency.isCircularDependency ? '};\n' : '' }/*≠≠ ${ dependency.relpath } ≠≠*/\n`);
  });

  // Add file contents
  contents.push(`/*== ${ file.relpath } ==*/`, `$m['${ file.id }'] = { exports: {} };`, file.content, `/*≠≠ ${ file.relpath } ≠≠*/`);

  // Add wrapper close
  if (browser) {
    contents.push(`}${ bootstrap ? ')()' : '' }`);
  }

  return contents.join('\n');
};

/**
 * Undo wrapping for 'file'
 * @param {JSFile} file
 * @returns {String}
 */
$m['lib/plugins/js/concat.js'].exports.unwrap = function unwrap(file) {
  // TODO: fix this
  const content = file.content.replace(`$m['${ file.id }'] = { exports: {} };\n`, '').replace(`/*== ${ file.relpath } ==*/\n`, '').replace(`/*≠≠ ${ file.relpath } ≠≠*/\n`, '');
  const start = content.indexOf('!(function () {');
  const end = content.lastIndexOf('})()');

  return content.slice(start + 16, end - 1);
};
/*≠≠ lib/plugins/js/concat.js ≠≠*/

/*== node_modules/inline-source/lib/parse.js ==*/
$m['inline-source/lib/parse.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibparsejs511_htmlparser = $m['htmlparser2/lib/index.js#3.9.1'].exports;
const _inlinesourcelibparsejs511_path = require('path');
const _inlinesourcelibparsejs511_utils = $m['inline-source/lib/utils.js#5.1.1'].exports;

const _inlinesourcelibparsejs511_RE_COMMENT = /(<!--[^[i][\S\s]+?--\s?>)/gm;

/**
 * Parse inlineable sources, modifying passed 'context'
 * @param {Object} context
 * @param {Function} [fn]
 */
$m['inline-source/lib/parse.js#5.1.1'].exports = function parse(context, fn) {
  fn = fn || _inlinesourcelibparsejs511_utils.noop;

  const html = context.html.replace(_inlinesourcelibparsejs511_RE_COMMENT, '');
  // This api uses a synchronous callback handler, so order and definition of 'match' is preserved
  const parser = new _inlinesourcelibparsejs511_htmlparser.Parser(new _inlinesourcelibparsejs511_htmlparser.DomHandler(function (err, dom) {
    if (err) return fn(err);

    const parsed = dom[0];
    const attributes = _inlinesourcelibparsejs511_utils.parseAttributes(parsed.attribs);
    const props = _inlinesourcelibparsejs511_utils.parseProps(attributes, context.attribute);
    const tag = match[1];
    const type = _inlinesourcelibparsejs511_utils.getTypeFromType(attributes.type) || _inlinesourcelibparsejs511_utils.getTypeFromTag(match[1]);
    const filepath = _inlinesourcelibparsejs511_utils.getSourcepath(attributes.src || attributes.href || attributes.data, context.htmlpath, context.rootpath);
    const extension = _inlinesourcelibparsejs511_path.extname(filepath[0]).slice(1);
    const format = _inlinesourcelibparsejs511_utils.getFormatFromExtension(extension);

    // Ignore based on tag or type
    if (!_inlinesourcelibparsejs511_utils.isIgnored(context.ignore, tag, type, format)) {
      context.sources.push({
        attributes,
        compress: 'compress' in props ? props.compress : context.compress,
        content: null,
        errored: false,
        extension,
        fileContent: '',
        filepath: filepath[0],
        filepathAnchor: filepath[1],
        format,
        match: match[0],
        padding: context.pretty ? _inlinesourcelibparsejs511_utils.getPadding(match[0], context.html) : '',
        parentContext: context,
        props,
        replace: '',
        stack: context.stack,
        svgAsImage: 'svgasimage' in props ? props.svgasimage : context.svgAsImage,
        tag: match[1],
        type
      });
    }
  }));
  let match;

  while (match = context.re.exec(html)) {
    parser.parseComplete(match);
  }

  fn();
};
/*≠≠ node_modules/inline-source/lib/parse.js ≠≠*/

/*== node_modules/inline-source/lib/context.js ==*/
$m['inline-source/lib/context.js#5.1.1'] = { exports: {} };
'use strict';

const _inlinesourcelibcontextjs511_css = $m['inline-source/lib/css.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_fs = require('fs');
const _inlinesourcelibcontextjs511_inline = $m['inline-source/lib/inline.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_js = $m['inline-source/lib/js.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_img = $m['inline-source/lib/img.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_load = $m['inline-source/lib/load.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_objectAssign = $m['object-assign/index.js#4.1.0'].exports;
const _inlinesourcelibcontextjs511_path = require('path');
const _inlinesourcelibcontextjs511_utils = $m['inline-source/lib/utils.js#5.1.1'].exports;
const _inlinesourcelibcontextjs511_wrap = $m['inline-source/lib/wrap.js#5.1.1'].exports;

const _inlinesourcelibcontextjs511_DEFAULT = {
  attribute: 'inline',
  compress: true,
  ignore: [],
  pretty: false,
  swallowErrors: false,
  svgAsImage: false
};

/**
 * Retrieve context from 'options'
 * @param {Object} options
 *  - {String} attribute
 *  - {Boolean} compress
 *  - {Object} fs
 *  - {Array} handlers
 *  - {Array} ignore
 *  - {Boolean} pretty
 *  - {String} rootpath
 *  - {Boolean} swallowErrors
 *  - {Boolean} saveAsImage
 * @returns {Object}
 */
$m['inline-source/lib/context.js#5.1.1'].exports.create = function create(options) {
  options = options || {};

  let context = _inlinesourcelibcontextjs511_objectAssign({
    // Allow overriding 'fs' implementation
    fs: _inlinesourcelibcontextjs511_fs,
    html: '',
    htmlpath: '',
    rootpath: process.cwd(),
    sources: []
  }, _inlinesourcelibcontextjs511_DEFAULT, options);

  if (options.rootpath) context.rootpath = _inlinesourcelibcontextjs511_path.resolve(options.rootpath);
  if (options.pretty == true && context.compress == false) context.pretty = true;
  context.re = _inlinesourcelibcontextjs511_utils.getTagRegExp(context.attribute);
  // Prepare stack
  context.stack = [_inlinesourcelibcontextjs511_load];
  if (options.handlers) context.stack = context.stack.concat(options.handlers);
  context.stack.push(_inlinesourcelibcontextjs511_js, _inlinesourcelibcontextjs511_css, _inlinesourcelibcontextjs511_img, _inlinesourcelibcontextjs511_wrap, _inlinesourcelibcontextjs511_inline);

  return context;
};
/*≠≠ node_modules/inline-source/lib/context.js ≠≠*/

/*== node_modules/lodash/_compareMultiple.js ==*/
$m['lodash/_compareMultiple.js#4.16.2'] = { exports: {} };
var _lodashcompareMultiplejs4162_compareAscending = $m['lodash/_compareAscending.js#4.16.2'].exports;

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function _lodashcompareMultiplejs4162_compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = _lodashcompareMultiplejs4162_compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

$m['lodash/_compareMultiple.js#4.16.2'].exports = _lodashcompareMultiplejs4162_compareMultiple;
/*≠≠ node_modules/lodash/_compareMultiple.js ≠≠*/

/*== lib/dependency-resolver/cache.js ==*/
$m['lib/dependency-resolver/cache.js'] = { exports: {} };
'use strict';

const { VERSION_DELIMITER: _libdependencyresolvercachejs_VERSION_DELIMITER } = $m['lib/dependency-resolver/config.js'].exports;
let _libdependencyresolvercachejs_cwd = '';
let _libdependencyresolvercachejs_fileCache = new Map();
let _libdependencyresolvercachejs_packageCache = new Map();
let _libdependencyresolvercachejs_versionedFileCache = new Map();

$m['lib/dependency-resolver/cache.js'].exports = {
  /**
   * Retrieve id or filepath for 'key'
   * @param {String} key
   * @returns {String}
   */
  getCWD() {
    if (!_libdependencyresolvercachejs_cwd) _libdependencyresolvercachejs_cwd = process.cwd();
    return _libdependencyresolvercachejs_cwd;
  },

  /**
   * Retrieve id or filepath for 'key'
   * @param {String} key
   * @returns {String}
   */
  getFile(key) {
    return _libdependencyresolvercachejs_fileCache.get(key);
  },

  /**
   * Add 'file' to cache
   * @param {Object} file
   */
  setFile(file) {
    // Make sure not to overwrite
    if (file.path && file.id && !_libdependencyresolvercachejs_fileCache.has(file.path) && !_libdependencyresolvercachejs_fileCache.has(file.id)) {
      _libdependencyresolvercachejs_fileCache.set(file.path, file.id);
      _libdependencyresolvercachejs_fileCache.set(file.id, file.path);
      // Store in versioned cash to enable multiple version check
      if (~file.id.indexOf(_libdependencyresolvercachejs_VERSION_DELIMITER)) {
        const name = file.id.split(_libdependencyresolvercachejs_VERSION_DELIMITER)[0];

        if (!_libdependencyresolvercachejs_versionedFileCache.has(name)) {
          _libdependencyresolvercachejs_versionedFileCache.set(name, 1);
        } else {
          _libdependencyresolvercachejs_versionedFileCache.set(name, _libdependencyresolvercachejs_versionedFileCache.get(name) + 1);
        }
      }
    }
  },

  /**
   * Retrieve package details for 'key',
   * where 'key' is one of pakcage id or path
   * @param {String} key
   * @returns {Object}
   */
  getPackage(key) {
    return _libdependencyresolvercachejs_packageCache.get(key);
  },

  /**
   * Add 'pkg' to cache
   * @param {Object} pkg
   */
  setPackage(pkg) {
    // Make sure not to overwrite
    if (!_libdependencyresolvercachejs_packageCache.has(pkg.pkgpath) && !_libdependencyresolvercachejs_packageCache.has(pkg.id)) {
      _libdependencyresolvercachejs_packageCache.set(pkg.pkgpath, pkg);
      _libdependencyresolvercachejs_packageCache.set(pkg.id, pkg);
    }
  },

  /**
   * Determine if there is more than one version of 'id'
   * @param {String} id
   * @returns {Boolean}
   */
  hasMultipleVersions(id) {
    if (~id.indexOf(_libdependencyresolvercachejs_VERSION_DELIMITER)) {
      return _libdependencyresolvercachejs_versionedFileCache.get(id.split(_libdependencyresolvercachejs_VERSION_DELIMITER)[0]) > 1;
    }
    return false;
  },

  /**
   * Clear the cache
   */
  clear() {
    _libdependencyresolvercachejs_cwd = '';
    _libdependencyresolvercachejs_fileCache.clear();
    _libdependencyresolvercachejs_packageCache.clear();
    _libdependencyresolvercachejs_versionedFileCache.clear();
  }
};
/*≠≠ lib/dependency-resolver/cache.js ≠≠*/

/*== node_modules/recur-fs/node_modules/rimraf/rimraf.js ==*/
$m['rimraf/rimraf.js#2.5.2'] = { exports: {} };
$m['rimraf/rimraf.js#2.5.2'].exports = _rimrafrimrafjs252_rimraf;
_rimrafrimrafjs252_rimraf.sync = _rimrafrimrafjs252_rimrafSync;

var _rimrafrimrafjs252_assert = require("assert");
var _rimrafrimrafjs252_path = require("path");
var _rimrafrimrafjs252_fs = require("fs");
var _rimrafrimrafjs252_glob = $m['glob/glob.js#7.1.0'].exports;

var _rimrafrimrafjs252_defaultGlobOpts = {
  nosort: true,
  silent: true
};

// for EMFILE handling
var _rimrafrimrafjs252_timeout = 0;

var _rimrafrimrafjs252_isWindows = process.platform === "win32";

function _rimrafrimrafjs252_defaults(options) {
  var methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
  methods.forEach(function (m) {
    options[m] = options[m] || _rimrafrimrafjs252_fs[m];
    m = m + 'Sync';
    options[m] = options[m] || _rimrafrimrafjs252_fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
  options.emfileWait = options.emfileWait || 1000;
  if (options.glob === false) {
    options.disableGlob = true;
  }
  options.disableGlob = options.disableGlob || false;
  options.glob = options.glob || _rimrafrimrafjs252_defaultGlobOpts;
}

function _rimrafrimrafjs252_rimraf(p, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  _rimrafrimrafjs252_assert(p, 'rimraf: missing path');
  _rimrafrimrafjs252_assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  _rimrafrimrafjs252_assert(options, 'rimraf: missing options');
  _rimrafrimrafjs252_assert.equal(typeof options, 'object', 'rimraf: options should be object');
  _rimrafrimrafjs252_assert.equal(typeof cb, 'function', 'rimraf: callback function required');

  _rimrafrimrafjs252_defaults(options);

  var busyTries = 0;
  var errState = null;
  var n = 0;

  if (options.disableGlob || !_rimrafrimrafjs252_glob.hasMagic(p)) return afterGlob(null, [p]);

  _rimrafrimrafjs252_fs.lstat(p, function (er, stat) {
    if (!er) return afterGlob(null, [p]);

    _rimrafrimrafjs252_glob(p, options.glob, afterGlob);
  });

  function next(er) {
    errState = errState || er;
    if (--n === 0) cb(errState);
  }

  function afterGlob(er, results) {
    if (er) return cb(er);

    n = results.length;
    if (n === 0) return cb();

    results.forEach(function (p) {
      _rimrafrimrafjs252_rimraf_(p, options, function CB(er) {
        if (er) {
          if (_rimrafrimrafjs252_isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            var time = busyTries * 100;
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              _rimrafrimrafjs252_rimraf_(p, options, CB);
            }, time);
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && _rimrafrimrafjs252_timeout < options.emfileWait) {
            return setTimeout(function () {
              _rimrafrimrafjs252_rimraf_(p, options, CB);
            }, _rimrafrimrafjs252_timeout++);
          }

          // already gone
          if (er.code === "ENOENT") er = null;
        }

        _rimrafrimrafjs252_timeout = 0;
        next(er);
      });
    });
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function _rimrafrimrafjs252_rimraf_(p, options, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT") return cb(null);

    if (st && st.isDirectory()) return _rimrafrimrafjs252_rmdir(p, options, er, cb);

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT") return cb(null);
        if (er.code === "EPERM") return _rimrafrimrafjs252_isWindows ? _rimrafrimrafjs252_fixWinEPERM(p, options, er, cb) : _rimrafrimrafjs252_rmdir(p, options, er, cb);
        if (er.code === "EISDIR") return _rimrafrimrafjs252_rmdir(p, options, er, cb);
      }
      return cb(er);
    });
  });
}

function _rimrafrimrafjs252_fixWinEPERM(p, options, er, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');
  if (er) _rimrafrimrafjs252_assert(er instanceof Error);

  options.chmod(p, 666, function (er2) {
    if (er2) cb(er2.code === "ENOENT" ? null : er);else options.stat(p, function (er3, stats) {
      if (er3) cb(er3.code === "ENOENT" ? null : er);else if (stats.isDirectory()) _rimrafrimrafjs252_rmdir(p, options, er, cb);else options.unlink(p, cb);
    });
  });
}

function _rimrafrimrafjs252_fixWinEPERMSync(p, options, er) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (er) _rimrafrimrafjs252_assert(er instanceof Error);

  try {
    options.chmodSync(p, 666);
  } catch (er2) {
    if (er2.code === "ENOENT") return;else throw er;
  }

  try {
    var stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") return;else throw er;
  }

  if (stats.isDirectory()) _rimrafrimrafjs252_rmdirSync(p, options, er);else options.unlinkSync(p);
}

function _rimrafrimrafjs252_rmdir(p, options, originalEr, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (originalEr) _rimrafrimrafjs252_assert(originalEr instanceof Error);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) _rimrafrimrafjs252_rmkids(p, options, cb);else if (er && er.code === "ENOTDIR") cb(originalEr);else cb(er);
  });
}

function _rimrafrimrafjs252_rmkids(p, options, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  options.readdir(p, function (er, files) {
    if (er) return cb(er);
    var n = files.length;
    if (n === 0) return options.rmdir(p, cb);
    var errState;
    files.forEach(function (f) {
      _rimrafrimrafjs252_rimraf(_rimrafrimrafjs252_path.join(p, f), options, function (er) {
        if (errState) return;
        if (er) return cb(errState = er);
        if (--n === 0) options.rmdir(p, cb);
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function _rimrafrimrafjs252_rimrafSync(p, options) {
  options = options || {};
  _rimrafrimrafjs252_defaults(options);

  _rimrafrimrafjs252_assert(p, 'rimraf: missing path');
  _rimrafrimrafjs252_assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  _rimrafrimrafjs252_assert(options, 'rimraf: missing options');
  _rimrafrimrafjs252_assert.equal(typeof options, 'object', 'rimraf: options should be object');

  var results;

  if (options.disableGlob || !_rimrafrimrafjs252_glob.hasMagic(p)) {
    results = [p];
  } else {
    try {
      _rimrafrimrafjs252_fs.lstatSync(p);
      results = [p];
    } catch (er) {
      results = _rimrafrimrafjs252_glob.sync(p, options.glob);
    }
  }

  if (!results.length) return;

  for (var i = 0; i < results.length; i++) {
    var p = results[i];

    try {
      var st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") return;
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory()) _rimrafrimrafjs252_rmdirSync(p, options, null);else options.unlinkSync(p);
    } catch (er) {
      if (er.code === "ENOENT") return;
      if (er.code === "EPERM") return _rimrafrimrafjs252_isWindows ? _rimrafrimrafjs252_fixWinEPERMSync(p, options, er) : _rimrafrimrafjs252_rmdirSync(p, options, er);
      if (er.code !== "EISDIR") throw er;
      _rimrafrimrafjs252_rmdirSync(p, options, er);
    }
  }
}

function _rimrafrimrafjs252_rmdirSync(p, options, originalEr) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (originalEr) _rimrafrimrafjs252_assert(originalEr instanceof Error);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT") return;
    if (er.code === "ENOTDIR") throw originalEr;
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") _rimrafrimrafjs252_rmkidsSync(p, options);
  }
}

function _rimrafrimrafjs252_rmkidsSync(p, options) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  options.readdirSync(p).forEach(function (f) {
    _rimrafrimrafjs252_rimrafSync(_rimrafrimrafjs252_path.join(p, f), options);
  });
  options.rmdirSync(p, options);
}
/*≠≠ node_modules/recur-fs/node_modules/rimraf/rimraf.js ≠≠*/

/*== node_modules/mkdirp/index.js ==*/
$m['mkdirp/index.js#0.5.1'] = { exports: {} };
var _mkdirpindexjs051_path = require('path');
var _mkdirpindexjs051_fs = require('fs');
var _mkdirpindexjs051__0777 = parseInt('0777', 8);

$m['mkdirp/index.js#0.5.1'].exports = _mkdirpindexjs051_mkdirP.mkdirp = _mkdirpindexjs051_mkdirP.mkdirP = _mkdirpindexjs051_mkdirP;

function _mkdirpindexjs051_mkdirP(p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    } else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || _mkdirpindexjs051_fs;

    if (mode === undefined) {
        mode = _mkdirpindexjs051__0777 & ~process.umask();
    }
    if (!made) made = null;

    var cb = f || function () {};
    p = _mkdirpindexjs051_path.resolve(p);

    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                _mkdirpindexjs051_mkdirP(_mkdirpindexjs051_path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);else _mkdirpindexjs051_mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made);else cb(null, made);
                });
                break;
        }
    });
}

_mkdirpindexjs051_mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || _mkdirpindexjs051_fs;

    if (mode === undefined) {
        mode = _mkdirpindexjs051__0777 & ~process.umask();
    }
    if (!made) made = null;

    p = _mkdirpindexjs051_path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    } catch (err0) {
        switch (err0.code) {
            case 'ENOENT':
                made = sync(_mkdirpindexjs051_path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                } catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};
/*≠≠ node_modules/mkdirp/index.js ≠≠*/

/*== lib/utils/cnsl.js ==*/
$m['lib/utils/cnsl.js'] = { exports: {} };
'use strict';

const { indent: _libutilscnsljs_indent } = $m['lib/utils/string.js'].exports;
const _libutilscnsljs_chalk = $m['chalk/index.js#1.1.3'].exports;

const _libutilscnsljs_TOO_LONG = 10;

const _libutilscnsljs_start = process.hrtime();
let _libutilscnsljs_last = null;
let _libutilscnsljs_timers = {};

$m['lib/utils/cnsl.js'].exports.BELL = '\x07';
// Silent during testing by default
$m['lib/utils/cnsl.js'].exports.silent = process.env.NODE_ENV == 'test';
$m['lib/utils/cnsl.js'].exports.verbose = false;

/**
 * Start tracking duration of event 'id'
 * @param {String} id
 */
$m['lib/utils/cnsl.js'].exports.start = function (id) {
  _libutilscnsljs_timers[id] = process.hrtime();
};

/**
 * Stop tracking duration of event 'id'
 * @param {String} id
 * @returns {Number}
 */
$m['lib/utils/cnsl.js'].exports.stop = function (id) {
  const ms = _libutilscnsljs_msDiff(process.hrtime(), _libutilscnsljs_timers[id]);

  delete _libutilscnsljs_timers[id];

  return ms;
};

/**
 * Print 'msg' to console, with indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.print = function (msg, column) {
  if (column == null) column = 0;
  if (!$m['lib/utils/cnsl.js'].exports.silent) console.log(_libutilscnsljs_indent(msg, column));
};

/**
 * Print 'err' to console, with error colour and indentation level
 * @param {Object|String} err
 * @param {Int} column
 * @param {Boolean} throws
 */
$m['lib/utils/cnsl.js'].exports.error = function (err, column, throws) {
  if (column == null) column = 0;
  if (throws == null) throws = true;
  if ('string' == typeof err) err = new Error(err);
  // Add beep when not throwing
  if (!throws) err.message += $m['lib/utils/cnsl.js'].exports.BELL;
  $m['lib/utils/cnsl.js'].exports.print(_libutilscnsljs_chalk.bold.red('error ') + err.message + (err.filepath ? ' in ' + _libutilscnsljs_chalk.bold.grey(err.filepath) : ''), column);
  if (throws && !$m['lib/utils/cnsl.js'].exports.silent) throw err;
};

/**
 * Print 'msg' to console, with warning colour and indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.warn = function (msg, column) {
  if (column == null) column = 0;
  if ('string' instanceof Error) msg = msg.message;
  $m['lib/utils/cnsl.js'].exports.print(_libutilscnsljs_chalk.bold.yellow('warning ') + msg, column);
};

/**
 * Print 'msg' to console, with debug colour and indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.debug = function (msg, column) {
  const now = process.hrtime();

  if (!_libutilscnsljs_last) _libutilscnsljs_last = now;

  const ellapsed = _libutilscnsljs_msDiff(now, _libutilscnsljs_last);

  if (column == null) column = 0;
  if ($m['lib/utils/cnsl.js'].exports.verbose) {
    msg = _libutilscnsljs_chalk.cyan('+') + _libutilscnsljs_chalk.bold.grey((ellapsed > _libutilscnsljs_TOO_LONG ? _libutilscnsljs_chalk.red(ellapsed) : ellapsed) + 'ms') + _libutilscnsljs_chalk.cyan('::') + _libutilscnsljs_chalk.bold.grey(_libutilscnsljs_msDiff(now, _libutilscnsljs_start) + 'ms') + _libutilscnsljs_chalk.cyan('=') + msg;
    $m['lib/utils/cnsl.js'].exports.print(msg, column);
  }
  _libutilscnsljs_last = now;
};

/**
 * Colourize 'string' for emphasis
 * @param {String} string
 * @returns {String}
 */
$m['lib/utils/cnsl.js'].exports.strong = function (string) {
  return _libutilscnsljs_chalk.bold.grey(string);
};

/**
 * Retrieve difference in ms
 * @param {Array} t1
 * @param {Array} t2
 * @returns {Number}
 */
function _libutilscnsljs_msDiff(t1, t2) {
  t1 = (t1[0] * 1e9 + t1[1]) / 1e6;
  t2 = (t2[0] * 1e9 + t2[1]) / 1e6;
  return Math.ceil((t1 - t2) * 100) / 100;
}
/*≠≠ lib/utils/cnsl.js ≠≠*/

/*== node_modules/lodash/before.js ==*/
$m['lodash/before.js#4.16.2'] = { exports: {} };
var _lodashbeforejs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports;

/** Error message constants. */
var _lodashbeforejs4162_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function _lodashbeforejs4162_before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(_lodashbeforejs4162_FUNC_ERROR_TEXT);
  }
  n = _lodashbeforejs4162_toInteger(n);
  return function () {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

$m['lodash/before.js#4.16.2'].exports = _lodashbeforejs4162_before;
/*≠≠ node_modules/lodash/before.js ≠≠*/

/*== node_modules/async/internal/eachOfLimit.js ==*/
$m['async/internal/eachOfLimit.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/eachOfLimit.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/eachOfLimit.js#2.0.1'].exports.default = _asyncinternaleachOfLimitjs201__eachOfLimit;

var _asyncinternaleachOfLimitjs201__noop = $m['lodash/noop.js#4.16.2'].exports;

var _asyncinternaleachOfLimitjs201__noop2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__noop);

var _asyncinternaleachOfLimitjs201__once = $m['async/internal/once.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__once2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__once);

var _asyncinternaleachOfLimitjs201__iterator = $m['async/internal/iterator.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__iterator2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__iterator);

var _asyncinternaleachOfLimitjs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__onlyOnce2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__onlyOnce);

function _asyncinternaleachOfLimitjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternaleachOfLimitjs201__eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = (0, _asyncinternaleachOfLimitjs201__once2.default)(callback || _asyncinternaleachOfLimitjs201__noop2.default);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = (0, _asyncinternaleachOfLimitjs201__iterator2.default)(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (done && running <= 0) {
                return callback(null);
            } else {
                replenish();
            }
        }

        function replenish() {
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _asyncinternaleachOfLimitjs201__onlyOnce2.default)(iterateeCallback));
            }
        }

        replenish();
    };
}
$m['async/internal/eachOfLimit.js#2.0.1'].exports = $m['async/internal/eachOfLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/eachOfLimit.js ≠≠*/

/*== node_modules/async/eachOfLimit.js ==*/
$m['async/eachOfLimit.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOfLimit.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/eachOfLimit.js#2.0.1'].exports.default = _asynceachOfLimitjs201_eachOfLimit;

var _asynceachOfLimitjs201__eachOfLimit2 = $m['async/internal/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfLimitjs201__eachOfLimit3 = _asynceachOfLimitjs201__interopRequireDefault(_asynceachOfLimitjs201__eachOfLimit2);

function _asynceachOfLimitjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function _asynceachOfLimitjs201_eachOfLimit(coll, limit, iteratee, callback) {
  (0, _asynceachOfLimitjs201__eachOfLimit3.default)(limit)(coll, iteratee, callback);
}
$m['async/eachOfLimit.js#2.0.1'].exports = $m['async/eachOfLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOfLimit.js ≠≠*/

/*== node_modules/lodash/_setToString.js ==*/
$m['lodash/_setToString.js#4.16.2'] = { exports: {} };
var _lodashsetToStringjs4162_baseSetToString = $m['lodash/_baseSetToString.js#4.16.2'].exports,
    _lodashsetToStringjs4162_shortOut = $m['lodash/_shortOut.js#4.16.2'].exports;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var _lodashsetToStringjs4162_setToString = _lodashsetToStringjs4162_shortOut(_lodashsetToStringjs4162_baseSetToString);

$m['lodash/_setToString.js#4.16.2'].exports = _lodashsetToStringjs4162_setToString;
/*≠≠ node_modules/lodash/_setToString.js ≠≠*/

/*== node_modules/lodash/_overRest.js ==*/
$m['lodash/_overRest.js#4.16.2'] = { exports: {} };
var _lodashoverRestjs4162_apply = $m['lodash/_apply.js#4.16.2'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashoverRestjs4162_nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function _lodashoverRestjs4162_overRest(func, start, transform) {
  start = _lodashoverRestjs4162_nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = _lodashoverRestjs4162_nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _lodashoverRestjs4162_apply(func, this, otherArgs);
  };
}

$m['lodash/_overRest.js#4.16.2'].exports = _lodashoverRestjs4162_overRest;
/*≠≠ node_modules/lodash/_overRest.js ≠≠*/

/*== node_modules/lodash/toPlainObject.js ==*/
$m['lodash/toPlainObject.js#4.16.2'] = { exports: {} };
var _lodashtoPlainObjectjs4162_copyObject = $m['lodash/_copyObject.js#4.16.2'].exports,
    _lodashtoPlainObjectjs4162_keysIn = $m['lodash/keysIn.js#4.16.2'].exports;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function _lodashtoPlainObjectjs4162_toPlainObject(value) {
  return _lodashtoPlainObjectjs4162_copyObject(value, _lodashtoPlainObjectjs4162_keysIn(value));
}

$m['lodash/toPlainObject.js#4.16.2'].exports = _lodashtoPlainObjectjs4162_toPlainObject;
/*≠≠ node_modules/lodash/toPlainObject.js ≠≠*/

/*== node_modules/lodash/_stackSet.js ==*/
$m['lodash/_stackSet.js#4.16.2'] = { exports: {} };
var _lodashstackSetjs4162_ListCache = $m['lodash/_ListCache.js#4.16.2'].exports,
    _lodashstackSetjs4162_Map = $m['lodash/_Map.js#4.16.2'].exports,
    _lodashstackSetjs4162_MapCache = $m['lodash/_MapCache.js#4.16.2'].exports;

/** Used as the size to enable large array optimizations. */
var _lodashstackSetjs4162_LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function _lodashstackSetjs4162_stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _lodashstackSetjs4162_ListCache) {
    var pairs = data.__data__;
    if (!_lodashstackSetjs4162_Map || pairs.length < _lodashstackSetjs4162_LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _lodashstackSetjs4162_MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

$m['lodash/_stackSet.js#4.16.2'].exports = _lodashstackSetjs4162_stackSet;
/*≠≠ node_modules/lodash/_stackSet.js ≠≠*/

/*== node_modules/lodash/_stackClear.js ==*/
$m['lodash/_stackClear.js#4.16.2'] = { exports: {} };
var _lodashstackClearjs4162_ListCache = $m['lodash/_ListCache.js#4.16.2'].exports;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function _lodashstackClearjs4162_stackClear() {
  this.__data__ = new _lodashstackClearjs4162_ListCache();
  this.size = 0;
}

$m['lodash/_stackClear.js#4.16.2'].exports = _lodashstackClearjs4162_stackClear;
/*≠≠ node_modules/lodash/_stackClear.js ≠≠*/

/*== node_modules/async/eachOfSeries.js ==*/
$m['async/eachOfSeries.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOfSeries.js#2.0.1'].exports, "__esModule", {
  value: true
});

var _asynceachOfSeriesjs201__eachOfLimit = $m['async/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfSeriesjs201__eachOfLimit2 = _asynceachOfSeriesjs201__interopRequireDefault(_asynceachOfSeriesjs201__eachOfLimit);

var _asynceachOfSeriesjs201__doLimit = $m['async/internal/doLimit.js#2.0.1'].exports;

var _asynceachOfSeriesjs201__doLimit2 = _asynceachOfSeriesjs201__interopRequireDefault(_asynceachOfSeriesjs201__doLimit);

function _asynceachOfSeriesjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each item in `coll`. The
 * `key` is the item's key, or index in the case of an array. The iteratee is
 * passed a `callback(err)` which must be called once it has completed. If no
 * error has occurred, the callback should be run without arguments or with an
 * explicit `null` argument. Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
$m['async/eachOfSeries.js#2.0.1'].exports.default = (0, _asynceachOfSeriesjs201__doLimit2.default)(_asynceachOfSeriesjs201__eachOfLimit2.default, 1);
$m['async/eachOfSeries.js#2.0.1'].exports = $m['async/eachOfSeries.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOfSeries.js ≠≠*/

/*== lib/plugins/js/index.js ==*/
$m['lib/plugins/js/index.js'] = { exports: {} };
'use strict';

const { commentStrip: _libpluginsjsindexjs_commentStrip, uniqueMatch: _libpluginsjsindexjs_uniqueMatch } = $m['lib/utils/string.js'].exports;
const { debug: _libpluginsjsindexjs_debug, strong: _libpluginsjsindexjs_strong } = $m['lib/utils/cnsl.js'].exports;
const _libpluginsjsindexjs_concat = $m['lib/plugins/js/concat.js'].exports;
const _libpluginsjsindexjs_flatten = $m['lib/plugins/js/flatten.js'].exports;
const _libpluginsjsindexjs_inline = $m['lib/plugins/js/inline.js'].exports;
const _libpluginsjsindexjs_replaceEnvironment = $m['lib/plugins/js/replaceEnvironment.js'].exports;
const _libpluginsjsindexjs_replaceReferences = $m['lib/plugins/js/replaceReferences.js'].exports;
const _libpluginsjsindexjs_transpile = $m['lib/plugins/js/transpile.js'].exports;

const _libpluginsjsindexjs_FILE_EXTENSIONS = ['js'];
const _libpluginsjsindexjs_HEADER = '/** BUDDY BUILT **/';
const _libpluginsjsindexjs_RE_BUDDY_BUILT = /^\/\*\* BUDDY BUILT \*\*\//;
const _libpluginsjsindexjs_RE_BROWSERIFY_BUILT = /function\(require,\s?module,\s?exports\)/;
const _libpluginsjsindexjs_RE_HELPER = /babelHelpers\.([a-zA-Z]+)\(/gm;
const _libpluginsjsindexjs_RE_REQUIRE = /require\(['"]([^'"]+)[^)]+\)/g;
const _libpluginsjsindexjs_RE_WEBPACK_BUILT = /__we[a-z]ack_require__/;
const _libpluginsjsindexjs_WORKFLOW_STANDARD = ['runWorkflowForDependencies', '!watchOnly:replaceEnvironment', '!watchOnly:bundle:replaceReferences', '!watchOnly:inline', '!watchOnly:transpile', '!watchOnly:bundle:flatten'];
const _libpluginsjsindexjs_WORKFLOW_INLINEABLE = ['load', 'replaceEnvironment', 'compress:compress'];
const _libpluginsjsindexjs_WORKFLOW_WRITEABLE = ['bundle:concat', 'compress:compress'];

$m['lib/plugins/js/index.js'].exports = {
  name: 'js',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginsjsindexjs_define, _libpluginsjsindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsjsindexjs_define(File, utils) {
  return class JSFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'js', options);

      this.workflows.standard.push(_libpluginsjsindexjs_WORKFLOW_STANDARD);
      this.workflows.inlineable = [_libpluginsjsindexjs_WORKFLOW_INLINEABLE];
      this.workflows.writeable = [_libpluginsjsindexjs_WORKFLOW_WRITEABLE];

      this.ast = null;
      this.isBuddyBuilt = false;
      this.isBuilt = false;
      this.isNpmModule = this.options.npmModulepaths ? this.options.npmModulepaths.some(modulepath => ~this.filepath.indexOf(modulepath)) : false;
      this.transpiled = false;
      this.flattened = false;

      if (this.isBuddyBuilt) this.content = _libpluginsjsindexjs_concat.unconcat(this);
    }

    /**
     * Read and store file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    load(buildOptions, fn) {
      super.load(buildOptions, err => {
        if (err && fn) return fn(err);

        this.isBuddyBuilt = _libpluginsjsindexjs_RE_BUDDY_BUILT.test(this.content);
        this.isBuilt = _libpluginsjsindexjs_RE_BROWSERIFY_BUILT.test(this.content) || _libpluginsjsindexjs_RE_WEBPACK_BUILT.test(this.content);
        if (this.isBuddyBuilt) this.content = _libpluginsjsindexjs_concat.unwrap(this, buildOptions);

        if (fn) fn();
      });
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    parse(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      const content = _libpluginsjsindexjs_commentStrip(this.content);

      super.addDependencies(_libpluginsjsindexjs_uniqueMatch(content, _libpluginsjsindexjs_RE_REQUIRE).map(match => {
        match.id = match.match;
        return match;
      }), buildOptions);

      fn();
    }

    /**
     * Replace process.env references with values
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    replaceEnvironment(buildOptions, fn) {
      this.content = _libpluginsjsindexjs_replaceEnvironment(this.content, buildOptions.browser);
      _libpluginsjsindexjs_debug(`replace environment vars: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Replace relative dependency references with fully resolved
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    replaceReferences(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      this.content = _libpluginsjsindexjs_replaceReferences(this.content, this.dependencyReferences, buildOptions.browser);
      _libpluginsjsindexjs_debug(`replace dependency references: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Inline json/disabled dependency content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    inline(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      this.content = _libpluginsjsindexjs_inline(this.content, this.dependencyReferences, buildOptions.browser);
      _libpluginsjsindexjs_debug(`inline: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Transpile file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    transpile(buildOptions, fn) {
      // Skip pre-built & node_modules files
      if (!this.transpiled && !this.isBuddyBuilt && !this.isBuilt && !this.isNpmModule) {
        try {
          _libpluginsjsindexjs_transpile(this, this.options.pluginOptions.babel);

          _libpluginsjsindexjs_debug(`transpile: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
          this.transpiled = true;
        } catch (err) {
          return fn(err);
        }
      }

      // Always parse helpers
      this.helpers = _libpluginsjsindexjs_uniqueMatch(this.content, _libpluginsjsindexjs_RE_HELPER).map(item => item.match);

      fn();
    }

    /**
     * Flatten file scope
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    flatten(buildOptions, fn) {
      // Built files should be flattened
      if (this.flattened || this.isBuddyBuilt) return fn();

      try {
        // Do not replace 'module.exports' for writeable Node files
        _libpluginsjsindexjs_flatten(this, buildOptions.browser ? true : !this.isWriteable(buildOptions.batch));

        _libpluginsjsindexjs_debug(`flatten: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
        this.flattened = true;
      } catch (err) {
        return fn(err);
      }

      fn();
    }

    /**
     * Concatenate file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    concat(buildOptions, fn) {
      this.content = _libpluginsjsindexjs_concat(this, _libpluginsjsindexjs_HEADER, buildOptions);
      _libpluginsjsindexjs_debug(`concat: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Reset content
     * @param {Boolean} hard
     */
    reset(hard) {
      this.ast = null;
      this.flattened = false;
      this.transpiled = false;
      super.reset(hard);
    }
  };
}
/*≠≠ lib/plugins/js/index.js ≠≠*/

/*== lib/plugins/html/index.js ==*/
$m['lib/plugins/html/index.js'] = { exports: {} };
'use strict';

const { debug: _libpluginshtmlindexjs_debug, strong: _libpluginshtmlindexjs_strong, warn: _libpluginshtmlindexjs_warn } = $m['lib/utils/cnsl.js'].exports;
const _libpluginshtmlindexjs_fs = require('fs');
const _libpluginshtmlindexjs_inlineContext = $m['inline-source/lib/context.js#5.1.1'].exports;
const _libpluginshtmlindexjs_inlineParse = $m['inline-source/lib/parse.js#5.1.1'].exports;
const _libpluginshtmlindexjs_inlineRun = $m['inline-source/lib/run.js#5.1.1'].exports;
const _libpluginshtmlindexjs_path = require('path');

const _libpluginshtmlindexjs_FILE_EXTENSIONS = ['html', 'htm'];
const _libpluginshtmlindexjs_WORKFLOW_WRITEABLE = ['inline'];

$m['lib/plugins/html/index.js'].exports = {
  name: 'html',
  type: 'html',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginshtmlindexjs_define, _libpluginshtmlindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginshtmlindexjs_define(File, utils) {
  return class HTMLFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'html', options);

      this.workflows.writeable = [_libpluginshtmlindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    parse(buildOptions, fn) {
      let context = _libpluginshtmlindexjs_inlineContext.create({ compress: false });

      context.html = this.content;
      context.htmlpath = this.filepath;
      _libpluginshtmlindexjs_inlineParse(context, err => {
        if (err) return fn(err);

        super.addDependencies(context.sources.slice(), buildOptions);
        fn();
      });
    }

    /**
     * Parse sidecar data file
     * @returns {Object}
     */
    parseSidecarDependency() {
      const filepath = _libpluginshtmlindexjs_path.resolve(_libpluginshtmlindexjs_path.dirname(this.filepath), this.name.replace(`.${ this.extension }`, '.json'));

      if (_libpluginshtmlindexjs_fs.existsSync(filepath)) return { context: '', filepath, match: '' };
    }

    /**
     * Retrieve sidecar data dependency
     * @returns {Object}
     */
    findSidecarDependency() {
      let data = {};

      // Find sidecar data
      for (const dependency of this.dependencies) {
        if (dependency.type == 'json') {
          try {
            data = JSON.parse(dependency.content);
          } catch (err) {
            _libpluginshtmlindexjs_warn(`malformed json file: ${ _libpluginshtmlindexjs_strong(dependency.filepath) }`);
          }
        }
      };

      return data;
    }

    /**
     * Inline css/img/js dependency content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    inline(buildOptions, fn) {
      const inlineDependencyReferences = [...this.dependencyReferences].filter(reference => reference.file.isInline);
      const inlineDependencies = inlineDependencyReferences.map(reference => reference.file);

      this.runForDependencies('inlineable', buildOptions, inlineDependencies, err => {
        if (err) return fn(err);
        if (!inlineDependencyReferences.length) return fn();

        // Prepare for inline-source
        inlineDependencyReferences.forEach(reference => {
          // Copy to override inline-source behaviour
          reference.fileContent = reference.file.content;
          reference.compress = buildOptions.compress;
        });

        // Update transformed html content
        let context = inlineDependencyReferences[0].parentContext;

        context.html = this.content;
        _libpluginshtmlindexjs_inlineRun(context, inlineDependencyReferences, false, (err, content) => {
          if (err) return fn(err);

          _libpluginshtmlindexjs_debug(`inline: ${ _libpluginshtmlindexjs_strong(this.relpath) }`, 4);
          this.content = content;
          fn();
        });
      });
    }
  };
}
/*≠≠ lib/plugins/html/index.js ≠≠*/

/*== lib/plugins/css/index.js ==*/
$m['lib/plugins/css/index.js'] = { exports: {} };
'use strict';

const { commentStrip: _libpluginscssindexjs_commentStrip, uniqueMatch: _libpluginscssindexjs_uniqueMatch } = $m['lib/utils/string.js'].exports;
const { debug: _libpluginscssindexjs_debug, strong: _libpluginscssindexjs_strong } = $m['lib/utils/cnsl.js'].exports;

const _libpluginscssindexjs_FILE_EXTENSIONS = ['css'];
// TODO: add support for 'url(*)' syntax
const _libpluginscssindexjs_RE_IMPORT = /@import\s['"]([^'"]+)['"];?/g;
const _libpluginscssindexjs_WORKFLOW_INLINEABLE = ['load', 'compress:compress'];
const _libpluginscssindexjs_WORKFLOW_WRITEABLE = ['inline', 'compress:compress'];

$m['lib/plugins/css/index.js'].exports = {
  name: 'css',
  type: 'css',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginscssindexjs_define, _libpluginscssindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginscssindexjs_define(File, utils) {
  return class CSSFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'css', options);

      this.workflows.inlineable = [_libpluginscssindexjs_WORKFLOW_INLINEABLE];
      this.workflows.writeable = [_libpluginscssindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    parse(buildOptions, fn) {
      super.addDependencies(_libpluginscssindexjs_uniqueMatch(_libpluginscssindexjs_commentStrip(this.content), _libpluginscssindexjs_RE_IMPORT).map(match => {
        match.id = match.match;
        return match;
      }), buildOptions);
      fn();
    }

    /**
     * Inline '@import' content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    inline(buildOptions, fn) {
      super.inlineDependencyReferences();
      _libpluginscssindexjs_debug(`inline: ${ _libpluginscssindexjs_strong(this.relpath) }`, 4);
      fn();
    }
  };
}
/*≠≠ lib/plugins/css/index.js ≠≠*/

/*== lib/dependency-resolver/package.js ==*/
$m['lib/dependency-resolver/package.js'] = { exports: {} };
'use strict';

const { VERSION_DELIMITER: _libdependencyresolverpackagejs_VERSION_DELIMITER } = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolverpackagejs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverpackagejs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolverpackagejs_fs = require('fs');
const _libdependencyresolverpackagejs_path = require('path');

const _libdependencyresolverpackagejs_MAX_FS_DEPTH = 10;
const _libdependencyresolverpackagejs_RE_TRAILING = /\/+$|\\+$/g;

$m['lib/dependency-resolver/package.js'].exports = {
  resolveId: _libdependencyresolverpackagejs_resolveId,
  resolveName: _libdependencyresolverpackagejs_resolveName,
  resolvePath: _libdependencyresolverpackagejs_resolvePath,

  /**
   * Retrieve package details for 'filepath'
   * @param {String} filepath
   * @param {Object} options
   *  - {Object} fileExtensions
   *  - {Object} globalAliases
   *  - {Array} globalSources
   *  - {Array} nativeModules
   *  - {Array} sources
   * @returns {Object}
   */
  getDetails(filepath, options) {
    options = options || {};

    const pkgpath = _libdependencyresolverpackagejs_resolvePath(filepath);
    const pkgname = _libdependencyresolverpackagejs_resolveName(pkgpath);
    const manifestpath = _libdependencyresolverpackagejs_path.resolve(pkgpath, 'package.json');
    let details, existingPkg, json;

    if (!_libdependencyresolverpackagejs_fs.existsSync(pkgpath)) return;

    // Pull from cache
    if (details = _libdependencyresolverpackagejs_cache.getPackage(pkgpath)) return details;

    details = {
      aliases: Object.assign({}, options.globalAliases),
      dirname: _libdependencyresolverpackagejs_path.dirname(pkgpath),
      id: '',
      isRoot: pkgpath == _libdependencyresolverpackagejs_cache.getCWD(),
      manifestpath: '',
      main: '',
      name: pkgname,
      paths: [],
      pkgpath: pkgpath,
      version: ''
    };

    // Parse manifest
    if (_libdependencyresolverpackagejs_fs.existsSync(manifestpath)) {
      try {
        json = require(manifestpath);
      } catch (err) {/* no file */}

      if (json) {
        details.manifestpath = manifestpath;
        details.name = json.name || pkgname;
        details.version = json.version;
        if (json.main) {
          details.main = _libdependencyresolverpackagejs_path.resolve(pkgpath, json.main);
        } else {
          const fp = _libdependencyresolverpackagejs_path.join(pkgpath, 'index.js');

          if (_libdependencyresolverpackagejs_fs.existsSync(fp)) details.main = fp;
        }
        // Resolve json.browser aliasing
        if (json.browser) {
          if ('string' == typeof json.browser) {
            details.main = _libdependencyresolverpackagejs_path.resolve(pkgpath, json.browser);
          } else {
            details.aliases = Object.assign(details.aliases, _libdependencyresolverpackagejs_alias.parse(pkgpath, json.browser));
            // Handle 'main' aliasing
            for (const key in details.aliases) {
              if (key == details.main) details.main = details.aliases[key];
            }
          }
        }
        // Store main as alias
        if (details.main) details.aliases[pkgpath] = details.main;
      }
    }

    // Set id
    // Ignore version if root package
    details.id = details.name + (!details.isRoot && details.version ? _libdependencyresolverpackagejs_VERSION_DELIMITER + details.version : '');

    // Retrieve existing pkg with same id
    if (existingPkg = _libdependencyresolverpackagejs_cache.getPackage(details.id)) return existingPkg;

    // Handle scoped
    if (_libdependencyresolverpackagejs_path.basename(details.dirname).indexOf('@') == 0) details.dirname = _libdependencyresolverpackagejs_path.dirname(details.dirname);

    // Gather all reachable paths
    // Adding 'pkgpath' breaks Node semantics
    details.paths = [..._libdependencyresolverpackagejs_resolveNodeModules(pkgpath), ...options.sources, pkgpath, ...options.globalSources];

    // Cache
    _libdependencyresolverpackagejs_cache.setPackage(details);

    return details;
  }
};

/**
 * Resolve package path from 'filepath'
 * @param {String} filepath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolvePath(filepath) {
  filepath = filepath.replace(_libdependencyresolverpackagejs_RE_TRAILING, '');

  const cwd = _libdependencyresolverpackagejs_cache.getCWD();

  if (~filepath.indexOf('node_modules')) {
    const parts = filepath.split(_libdependencyresolverpackagejs_path.sep);
    let idx = parts.lastIndexOf('node_modules');

    if (idx < parts.length - 1) idx += 2;
    // Handle scoped
    if (parts[idx - 1].charAt(0) == '@') idx++;

    return parts.slice(0, idx).join(_libdependencyresolverpackagejs_path.sep);
  } else if (~filepath.indexOf(cwd)) {
    return cwd;
  }

  // TODO: handle files from outside project path?
  return filepath;
}

/**
 * Resolve package name from 'pkgpath'
 * @param {String} pkgpath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolveName(pkgpath) {
  pkgpath = pkgpath.replace(_libdependencyresolverpackagejs_RE_TRAILING, '');

  const parts = pkgpath.split(_libdependencyresolverpackagejs_path.sep);
  const len = parts.length;

  // Handle scoped
  const idx = parts[len - 2].charAt(0) == '@' ? 2 : 1;

  return parts.slice(len - idx).join(_libdependencyresolverpackagejs_path.sep);
}

/**
 * Resolve id for 'filepath'
 * @param {Object} details
 * @param {String} filepath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolveId(details, filepath) {
  let name = '';

  if ('string' == typeof filepath) {
    if (details.isRoot && filepath == details.main) return details.id;

    const version = !details.isRoot && details.version ? _libdependencyresolverpackagejs_VERSION_DELIMITER + details.version : '';

    details.paths.some(sourcepath => {
      if (~filepath.indexOf(sourcepath)) {
        name = _libdependencyresolverpackagejs_path.relative(sourcepath, filepath);
        return true;
      }
    });

    name = (process.platform == 'win32' ? name.replace(/\\/g, '/') : name) + version;
  }

  return name;
}

/**
 * Gather all node_modules directories reachable from 'pkgpath'
 * @param {String} pkgpath
 * @returns {Array}
 */
function _libdependencyresolverpackagejs_resolveNodeModules(pkgpath) {
  let dir = pkgpath;
  let dirs = [];
  let depth = _libdependencyresolverpackagejs_MAX_FS_DEPTH;
  let parent, nodeModulespath;

  while (true) {
    parent = _libdependencyresolverpackagejs_path.dirname(dir);
    // Stop if we hit max file system depth or root
    // Convert to lowercase to fix problems on Windows
    if (! --depth || parent.toLowerCase() === dir.toLowerCase()) {
      break;
    }

    nodeModulespath = _libdependencyresolverpackagejs_path.resolve(dir, 'node_modules');
    if (_libdependencyresolverpackagejs_fs.existsSync(nodeModulespath)) dirs.push(nodeModulespath);

    // Walk
    dir = parent;
  }

  return dirs;
}
/*≠≠ lib/dependency-resolver/package.js ≠≠*/

/*== node_modules/recur-fs/node_modules/minimatch/minimatch.js ==*/
$m['minimatch/minimatch.js#3.0.2'] = { exports: {} };
$m['minimatch/minimatch.js#3.0.2'].exports = _minimatchminimatchjs302_minimatch;
_minimatchminimatchjs302_minimatch.Minimatch = _minimatchminimatchjs302_Minimatch;

var _minimatchminimatchjs302_path = { sep: '/' };
try {
  _minimatchminimatchjs302_path = require('path');
} catch (er) {}

var _minimatchminimatchjs302_GLOBSTAR = _minimatchminimatchjs302_minimatch.GLOBSTAR = _minimatchminimatchjs302_Minimatch.GLOBSTAR = {};
var _minimatchminimatchjs302_expand = $m['brace-expansion/index.js#1.1.6'].exports;

// any single thing other than /
// don't need to escape / when using new RegExp()
var _minimatchminimatchjs302_qmark = '[^/]';

// * => any number of characters
var _minimatchminimatchjs302_star = _minimatchminimatchjs302_qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var _minimatchminimatchjs302_twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var _minimatchminimatchjs302_twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var _minimatchminimatchjs302_reSpecials = _minimatchminimatchjs302_charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function _minimatchminimatchjs302_charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var _minimatchminimatchjs302_slashSplit = /\/+/;

_minimatchminimatchjs302_minimatch.filter = _minimatchminimatchjs302_filter;
function _minimatchminimatchjs302_filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return _minimatchminimatchjs302_minimatch(p, pattern, options);
  };
}

function _minimatchminimatchjs302_ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t;
}

_minimatchminimatchjs302_minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs302_minimatch;

  var orig = _minimatchminimatchjs302_minimatch;

  var m = function minimatch(p, pattern, options) {
    return orig.minimatch(p, pattern, _minimatchminimatchjs302_ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, _minimatchminimatchjs302_ext(def, options));
  };

  return m;
};

_minimatchminimatchjs302_Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs302_Minimatch;
  return _minimatchminimatchjs302_minimatch.defaults(def).Minimatch;
};

function _minimatchminimatchjs302_minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === '';

  return new _minimatchminimatchjs302_Minimatch(pattern, options).match(p);
}

function _minimatchminimatchjs302_Minimatch(pattern, options) {
  if (!(this instanceof _minimatchminimatchjs302_Minimatch)) {
    return new _minimatchminimatchjs302_Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (_minimatchminimatchjs302_path.sep !== '/') {
    pattern = pattern.split(_minimatchminimatchjs302_path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

_minimatchminimatchjs302_Minimatch.prototype.debug = function () {};

_minimatchminimatchjs302_Minimatch.prototype.make = _minimatchminimatchjs302_make;
function _minimatchminimatchjs302_make() {
  // don't do it more than once.
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(_minimatchminimatchjs302_slashSplit);
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

_minimatchminimatchjs302_Minimatch.prototype.parseNegate = _minimatchminimatchjs302_parseNegate;
function _minimatchminimatchjs302_parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
_minimatchminimatchjs302_minimatch.braceExpand = function (pattern, options) {
  return _minimatchminimatchjs302_braceExpand(pattern, options);
};

_minimatchminimatchjs302_Minimatch.prototype.braceExpand = _minimatchminimatchjs302_braceExpand;

function _minimatchminimatchjs302_braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof _minimatchminimatchjs302_Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern];
  }

  return _minimatchminimatchjs302_expand(pattern);
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
_minimatchminimatchjs302_Minimatch.prototype.parse = _minimatchminimatchjs302_parse;
var _minimatchminimatchjs302_SUBPARSE = {};
function _minimatchminimatchjs302_parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long');
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return _minimatchminimatchjs302_GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var plType;
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += _minimatchminimatchjs302_star;
          hasMagic = true;
          break;
        case '?':
          re += _minimatchminimatchjs302_qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && _minimatchminimatchjs302_reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false;

      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;

      case '(':
        if (inClass) {
          re += '(';
          continue;
        }

        if (!stateChar) {
          re += '\\(';
          continue;
        }

        plType = stateChar;
        patternListStack.push({
          type: plType,
          start: i - 1,
          reStart: re.length
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }

        clearStateChar();
        hasMagic = true;
        re += ')';
        var pl = patternListStack.pop();
        plType = pl.type;
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case '!':
            negativeLists.push(pl);
            re += ')[^/]*?)';
            pl.reEnd = re.length;
            break;
          case '?':
          case '+':
          case '*':
            re += plType;
            break;
          case '@':
            break; // the default anyway
        }
        continue;

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }

        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue;
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, _minimatchminimatchjs302_SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (_minimatchminimatchjs302_reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, _minimatchminimatchjs302_SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });

    this.debug('tail=%j\n   %s', tail, tail);
    var t = pl.type === '*' ? _minimatchminimatchjs302_star : pl.type === '?' ? _minimatchminimatchjs302_qmark : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== _minimatchminimatchjs302_SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === _minimatchminimatchjs302_SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return _minimatchminimatchjs302_globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

_minimatchminimatchjs302_minimatch.makeRe = function (pattern, options) {
  return new _minimatchminimatchjs302_Minimatch(pattern, options || {}).makeRe();
};

_minimatchminimatchjs302_Minimatch.prototype.makeRe = _minimatchminimatchjs302_makeRe;
function _minimatchminimatchjs302_makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? _minimatchminimatchjs302_star : options.dot ? _minimatchminimatchjs302_twoStarDot : _minimatchminimatchjs302_twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === _minimatchminimatchjs302_GLOBSTAR ? twoStar : typeof p === 'string' ? _minimatchminimatchjs302_regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}

_minimatchminimatchjs302_minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new _minimatchminimatchjs302_Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};

_minimatchminimatchjs302_Minimatch.prototype.match = _minimatchminimatchjs302_match;
function _minimatchminimatchjs302_match(f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;

  // windows: need to use /, not \
  if (_minimatchminimatchjs302_path.sep !== '/') {
    f = f.split(_minimatchminimatchjs302_path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(_minimatchminimatchjs302_slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
_minimatchminimatchjs302_Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false;

    if (p === _minimatchminimatchjs302_GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
    return emptyFileEnd;
  }

  // should be unreachable.
  throw new Error('wtf?');
};

// replace stuff like \* with *
function _minimatchminimatchjs302_globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function _minimatchminimatchjs302_regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/*≠≠ node_modules/recur-fs/node_modules/minimatch/minimatch.js ≠≠*/

/*== node_modules/recur-fs/lib/walk.js ==*/
$m['recur-fs/lib/walk.js#2.2.3'] = { exports: {} };
var _recurfslibwalkjs223_fs = require('fs'),
    _recurfslibwalkjs223_path = require('path');

/**
 * Walk directory tree from 'dir', passing all resources to 'visitor'.
 * Stops walking if 'visitor' calls next(true), or root directory reached.
 * @param {String} dir
 * @param {Function} visitor(resource, stat, next)
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/walk.js#2.2.3'].exports = function walk(dir, visitor, fn) {
	dir = _recurfslibwalkjs223_path.resolve(dir);

	function visit(dir) {
		function next(finished) {
			var parent = _recurfslibwalkjs223_path.resolve(dir, '..');

			// Stop if finished or we can no longer go up a level
			if (finished || parent.toLowerCase() === dir.toLowerCase()) return fn();

			// Up one level
			visit(parent);
		}

		_recurfslibwalkjs223_fs.readdir(dir, function (err, files) {
			if (err) return fn(err);

			var outstanding = files.length,
			    finished = false;

			files.forEach(function (file) {
				file = _recurfslibwalkjs223_path.join(dir, file);
				_recurfslibwalkjs223_fs.stat(file, function (err, stat) {
					if (!finished) {
						// Skip on error
						if (err) return ! --outstanding ? next(finished) : null;

						visitor(file, stat, function (stop) {
							if (stop === true) finished = true;

							if (! --outstanding) next(finished);
						});

						// Already finished
					} else {
						if (! --outstanding) return fn();
					}
				});
			});
		});
	}

	visit(dir);
};

/**
 * Synchronously walk directory tree from 'directory', passing all resources to 'visitor'.
 * Stops walking when root directory reached or `true` is returned from 'visitor'.
 * @param {String} dir
 * @param {Function} visitor(resource)
 */
$m['recur-fs/lib/walk.js#2.2.3'].exports.sync = function walkSync(directory, visitor) {
	directory = _recurfslibwalkjs223_path.resolve(directory);

	function visit(dir) {
		function next() {
			var parent = _recurfslibwalkjs223_path.resolve(dir, '..');

			// Stop if we can no longer go up a level
			if (parent.toLowerCase() === dir.toLowerCase()) return;

			// Up one level
			visit(parent);
		}

		var files = _recurfslibwalkjs223_fs.readdirSync(dir),
		    outstanding = files.length,
		    finished = false;

		files.forEach(function (file) {
			file = _recurfslibwalkjs223_path.join(dir, file);
			try {
				var stat = _recurfslibwalkjs223_fs.statSync(file);
			} catch (err) {
				// Skip if error
				return ! --outstanding ? next() : null;
			}

			if (!finished) {
				var stop = visitor(file, stat);
				if (stop === true) finished = true;
				if (! --outstanding && !finished) return next();
			}
		});
	}

	visit(directory);
};
/*≠≠ node_modules/recur-fs/lib/walk.js ≠≠*/

/*== node_modules/recur-fs/lib/rm.js ==*/
$m['recur-fs/lib/rm.js#2.2.3'] = { exports: {} };
var _recurfslibrmjs223_fs = require('fs'),
    _recurfslibrmjs223_rimraf = $m['rimraf/rimraf.js#2.5.2'].exports;

/**
 * Recursive remove file or directory
 * Makes sure only project sources are removed
 * @param {String} source
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/rm.js#2.2.3'].exports = function rm(source, fn) {
	if (_recurfslibrmjs223_fs.existsSync(source)) {
		if (~source.indexOf(process.cwd())) {
			_recurfslibrmjs223_rimraf(source, function (err) {
				if (err) return fn(err);else return fn();
			});
		} else {
			fn(new Error('cannot rm source outside of project path: ' + source));
		}
	} else {
		fn(new Error('cannot rm non-existant source: ' + source));
	}
};

/**
 * Synchronously recursive remove file or directory
 * Makes sure only project sources are removed
 * @param {String} source
 */
$m['recur-fs/lib/rm.js#2.2.3'].exports.sync = function rmSync(source) {
	if (_recurfslibrmjs223_fs.existsSync(source)) {
		if (~source.indexOf(process.cwd())) {
			_recurfslibrmjs223_rimraf.sync(source);
		} else {
			throw new Error('cannot rm source outside of project path: ' + source);
		}
	} else {
		throw new Error('cannot rm non-existant source: ' + source);
	}
};
/*≠≠ node_modules/recur-fs/lib/rm.js ≠≠*/

/*== node_modules/recur-fs/lib/mkdir.js ==*/
$m['recur-fs/lib/mkdir.js#2.2.3'] = { exports: {} };
var _recurfslibmkdirjs223_fs = require('fs'),
    _recurfslibmkdirjs223_mkdirp = $m['mkdirp/index.js#0.5.1'].exports,
    _recurfslibmkdirjs223_path = require('path');

/**
 * Recursively create 'directory'
 * @param {String} directory
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/mkdir.js#2.2.3'].exports = function mkdir(directory, fn) {
	// Resolve directory name if passed a file
	directory = _recurfslibmkdirjs223_path.extname(directory) ? _recurfslibmkdirjs223_path.dirname(directory) : directory;

	if (!_recurfslibmkdirjs223_fs.existsSync(directory)) {
		_recurfslibmkdirjs223_mkdirp(directory, function (err) {
			if (err) return fn(err);
			return fn();
		});
	} else {
		return fn();
	}
};

/**
 * Synchronously create 'directory'
 * @param {String} directory
 */
$m['recur-fs/lib/mkdir.js#2.2.3'].exports.sync = function mkdirSync(directory) {
	// Resolve directory name if passed a file
	directory = _recurfslibmkdirjs223_path.extname(directory) ? _recurfslibmkdirjs223_path.dirname(directory) : directory;

	if (!_recurfslibmkdirjs223_fs.existsSync(directory)) {
		_recurfslibmkdirjs223_mkdirp.sync(directory);
	}
};
/*≠≠ node_modules/recur-fs/lib/mkdir.js ≠≠*/

/*== node_modules/lodash/rest.js ==*/
$m['lodash/rest.js#4.16.2'] = { exports: {} };
var _lodashrestjs4162_baseRest = $m['lodash/_baseRest.js#4.16.2'].exports,
    _lodashrestjs4162_toInteger = $m['lodash/toInteger.js#4.16.2'].exports;

/** Error message constants. */
var _lodashrestjs4162_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function _lodashrestjs4162_rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(_lodashrestjs4162_FUNC_ERROR_TEXT);
  }
  start = start === undefined ? start : _lodashrestjs4162_toInteger(start);
  return _lodashrestjs4162_baseRest(func, start);
}

$m['lodash/rest.js#4.16.2'].exports = _lodashrestjs4162_rest;
/*≠≠ node_modules/lodash/rest.js ≠≠*/

/*== node_modules/async/internal/parallel.js ==*/
$m['async/internal/parallel.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/parallel.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/parallel.js#2.0.1'].exports.default = _asyncinternalparalleljs201__parallel;

var _asyncinternalparalleljs201__noop = $m['lodash/noop.js#4.16.2'].exports;

var _asyncinternalparalleljs201__noop2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__noop);

var _asyncinternalparalleljs201__isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

var _asyncinternalparalleljs201__isArrayLike2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__isArrayLike);

var _asyncinternalparalleljs201__rest = $m['lodash/rest.js#4.16.2'].exports;

var _asyncinternalparalleljs201__rest2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__rest);

function _asyncinternalparalleljs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternalparalleljs201__parallel(eachfn, tasks, callback) {
    callback = callback || _asyncinternalparalleljs201__noop2.default;
    var results = (0, _asyncinternalparalleljs201__isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        task((0, _asyncinternalparalleljs201__rest2.default)(function (err, args) {
            if (args.length <= 1) {
                args = args[0];
            }
            results[key] = args;
            callback(err);
        }));
    }, function (err) {
        callback(err, results);
    });
}
$m['async/internal/parallel.js#2.0.1'].exports = $m['async/internal/parallel.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/parallel.js ≠≠*/

/*== node_modules/lodash/once.js ==*/
$m['lodash/once.js#4.16.2'] = { exports: {} };
var _lodashoncejs4162_before = $m['lodash/before.js#4.16.2'].exports;

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function _lodashoncejs4162_once(func) {
  return _lodashoncejs4162_before(2, func);
}

$m['lodash/once.js#4.16.2'].exports = _lodashoncejs4162_once;
/*≠≠ node_modules/lodash/once.js ≠≠*/

/*== node_modules/async/series.js ==*/
$m['async/series.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/series.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/series.js#2.0.1'].exports.default = _asyncseriesjs201_series;

var _asyncseriesjs201__parallel = $m['async/internal/parallel.js#2.0.1'].exports;

var _asyncseriesjs201__parallel2 = _asyncseriesjs201__interopRequireDefault(_asyncseriesjs201__parallel);

var _asyncseriesjs201__eachOfSeries = $m['async/eachOfSeries.js#2.0.1'].exports;

var _asyncseriesjs201__eachOfSeries2 = _asyncseriesjs201__interopRequireDefault(_asyncseriesjs201__eachOfSeries);

function _asyncseriesjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run, each
 * function is passed a `callback(err, result)` it must call on completion with
 * an error `err` (which can be `null`) and an optional `result` value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function _asyncseriesjs201_series(tasks, callback) {
  (0, _asyncseriesjs201__parallel2.default)(_asyncseriesjs201__eachOfSeries2.default, tasks, callback);
}
$m['async/series.js#2.0.1'].exports = $m['async/series.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/series.js ≠≠*/

/*== lib/config/pluginLoader.js ==*/
$m['lib/config/pluginLoader.js'] = { exports: {} };
'use strict';

const { error: _libconfigpluginLoaderjs_error, print: _libconfigpluginLoaderjs_print, strong: _libconfigpluginLoaderjs_strong, warn: _libconfigpluginLoaderjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { execSync: _libconfigpluginLoaderjs_exec } = require('child_process');
const _libconfigpluginLoaderjs_fs = require('fs');
const _libconfigpluginLoaderjs_path = require('path');

const _libconfigpluginLoaderjs_BABEL_PRESET_2016 = ['babel-plugin-syntax-trailing-function-commas', 'babel-plugin-transform-async-to-generator'];
const _libconfigpluginLoaderjs_BABEL_PRESET_2015 = ['babel-plugin-transform-exponentiation-operator'];
const _libconfigpluginLoaderjs_BABEL_PRESET_ES5 = ['babel-plugin-transform-es5-property-mutators', 'babel-plugin-transform-es2015-arrow-functions', 'babel-plugin-transform-es2015-block-scoped-functions', 'babel-plugin-transform-es2015-block-scoping', ['babel-plugin-transform-es2015-classes', { loose: true }], ['babel-plugin-transform-es2015-computed-properties', { loose: true }], ['babel-plugin-transform-es2015-destructuring', { loose: true }], 'babel-plugin-transform-es2015-duplicate-keys', ['babel-plugin-transform-es2015-for-of', { loose: true }], 'babel-plugin-transform-es2015-function-name', 'babel-plugin-transform-es2015-literals', ['babel-plugin-transform-es2015-modules-commonjs', { loose: true }], 'babel-plugin-transform-es2015-object-super', 'babel-plugin-transform-es2015-parameters', 'babel-plugin-transform-es2015-shorthand-properties', ['babel-plugin-transform-es2015-spread', { loose: true }], 'babel-plugin-transform-es2015-sticky-regex', ['babel-plugin-transform-es2015-template-literals', { loose: true }],
// babel-plugin-transform-es2015-typeof-symbol,
'babel-plugin-transform-es2015-unicode-regex'
// babel-plugin-transform-regenerator
];
const _libconfigpluginLoaderjs_BABEL_PRESET_NODE6 = [['babel-plugin-transform-es2015-modules-commonjs', { loose: true }]];
const _libconfigpluginLoaderjs_BABEL_PRESET_NODE4 = [['babel-plugin-transform-es2015-destructuring', { loose: true }], 'babel-plugin-transform-es2015-function-name', ['babel-plugin-transform-es2015-modules-commonjs', { loose: true }], 'babel-plugin-transform-es2015-parameters', 'babel-plugin-transform-es2015-shorthand-properties', ['babel-plugin-transform-es2015-spread', { loose: true }], 'babel-plugin-transform-es2015-sticky-regex', 'babel-plugin-transform-es2015-unicode-regex'];
// const BABEL_PRESET_DEFAULT = ['babel-plugin-external-helpers'];
const _libconfigpluginLoaderjs_BABEL_PRESET_DEFAULT = [];
// Require here to allow for bundling
const _libconfigpluginLoaderjs_DEFAULT_PLUGINS = [$m['lib/plugins/css/index.js'].exports, $m['lib/plugins/flow/index.js'].exports, $m['lib/plugins/html/index.js'].exports, $m['lib/plugins/img/index.js'].exports, $m['lib/plugins/js/index.js'].exports, $m['lib/plugins/json/index.js'].exports, $m['lib/plugins/react/index.js'].exports];
const _libconfigpluginLoaderjs_POSTCSS_PRESET_DEFAULT = [];
const _libconfigpluginLoaderjs_RE_JS_FILE = /\.js$/;
const _libconfigpluginLoaderjs_RE_NODE_VERSION = /^node|^server/;
const _libconfigpluginLoaderjs_RE_PLUGIN = /^buddy-plugin-/;

const _libconfigpluginLoaderjs_babel = {
  default: _libconfigpluginLoaderjs_BABEL_PRESET_DEFAULT,
  es5: _libconfigpluginLoaderjs_BABEL_PRESET_ES5.concat(_libconfigpluginLoaderjs_BABEL_PRESET_2015, _libconfigpluginLoaderjs_BABEL_PRESET_2016),
  es2015: _libconfigpluginLoaderjs_BABEL_PRESET_2015.concat(_libconfigpluginLoaderjs_BABEL_PRESET_2016),
  es2016: _libconfigpluginLoaderjs_BABEL_PRESET_2016,
  node4: _libconfigpluginLoaderjs_BABEL_PRESET_NODE4,
  node6: _libconfigpluginLoaderjs_BABEL_PRESET_NODE6
};
const _libconfigpluginLoaderjs_postcss = {
  default: _libconfigpluginLoaderjs_POSTCSS_PRESET_DEFAULT
};

// Alias
_libconfigpluginLoaderjs_babel.es6 = _libconfigpluginLoaderjs_babel.es2015;
_libconfigpluginLoaderjs_babel.es7 = _libconfigpluginLoaderjs_babel.es2016;

$m['lib/config/pluginLoader.js'].exports = {
  /**
   * Add 'preset' definition for 'type'
   * @param {String} type
   * @param {String} name
   * @param {Array} preset
   */
  addPreset(type, name, preset) {
    if (type == 'babel') {
      _libconfigpluginLoaderjs_babel[name] = preset;
    } else if (type == 'postcss') {
      _libconfigpluginLoaderjs_postcss[name] = preset;
    }
  },

  /**
   * Load default/global buddy plugins
   * @param {Object} config
   * @param {Array} [additionalPluginModules]
   */
  loadPluginModules(config, additionalPluginModules = []) {
    const cwd = process.cwd();
    const projectModules = _libconfigpluginLoaderjs_path.join(cwd, 'node_modules');
    const projectPluginModules = _libconfigpluginLoaderjs_path.join(cwd, 'buddy-plugins');

    // Load default and additional modules
    _libconfigpluginLoaderjs_DEFAULT_PLUGINS.concat(additionalPluginModules).forEach(module => {
      _libconfigpluginLoaderjs_registerPluginModule(module, config, true);
    });
    // Load from project node_modules dir
    _libconfigpluginLoaderjs_loadPluginModulesFromDir(projectModules, config);
    // Load from project buddy-plugins dir
    if (_libconfigpluginLoaderjs_fs.existsSync(projectPluginModules)) _libconfigpluginLoaderjs_loadPluginModulesFromDir(projectPluginModules, config);
  },

  /**
   * Load external plugins based on build target 'version' and 'options'
   * @param {Object} options
   * @param {Array} version
   * @returns {Boolean}
   */
  loadBuildPlugins(options, version = []) {
    if (!Array.isArray(version)) version = [version];
    options.babel = options.babel || {};
    options.babel.plugins = options.babel.plugins || [];

    let browser = true;
    // Add Babel plugins based on version preset
    let plugins = version.reduce((plugins, preset) => {
      preset = preset.toLowerCase();
      // Flag node builds
      if (_libconfigpluginLoaderjs_RE_NODE_VERSION.test(preset)) browser = false;
      // Ignore generic without warning
      if (preset == 'node' || preset == 'server') return plugins;
      if (!_libconfigpluginLoaderjs_babel[preset]) {
        _libconfigpluginLoaderjs_warn(`${ _libconfigpluginLoaderjs_strong(preset) } is not a recognised build target version. Additional versions can be installed with npm`);
        return plugins;
      }
      return plugins.concat(_libconfigpluginLoaderjs_babel[preset]);
    }, _libconfigpluginLoaderjs_babel.default.slice());

    options.babel.plugins.forEach(plugin => {
      const pluginName = Array.isArray(plugin) ? plugin[0] : plugin;
      let exists = false;

      plugins.some((existingPlugin, idx) => {
        const existingPluginName = Array.isArray(existingPlugin) ? existingPlugin[0] : existingPlugin;

        // Overwrite if exists
        if (pluginName == existingPluginName) {
          plugins[idx] = plugin;
          exists = true;
        }

        return exists;
      });

      if (!exists) plugins.push(plugin);
    });
    options.babel.plugins = plugins;

    let dependencies = [];

    for (const prop in options) {
      dependencies = dependencies.concat(_libconfigpluginLoaderjs_extractDependencyStrings(options[prop]));
    }

    const missingDependenciesString = dependencies.filter(dependency => {
      try {
        require.resolve(dependency);
        return false;
      } catch (err) {
        return true;
      }
    }).join(' ');

    if (missingDependenciesString) {
      try {
        _libconfigpluginLoaderjs_print(`installing the following missing dependencies: ${ _libconfigpluginLoaderjs_strong(missingDependenciesString) }`);
        _libconfigpluginLoaderjs_exec(`npm --save-dev --save-exact install ${ missingDependenciesString }`);
      } catch (err) {
        _libconfigpluginLoaderjs_error(err);
      }
    }

    for (const prop in options) {
      _libconfigpluginLoaderjs_resolveDependecyStrings(options[prop]);
    }

    return browser;
  }
};

/**
 * Load plugins in 'dir'
 * @param {String} dir
 * @param {Object} config
 */
function _libconfigpluginLoaderjs_loadPluginModulesFromDir(dir, config) {
  if (!_libconfigpluginLoaderjs_fs.existsSync(dir)) return;

  _libconfigpluginLoaderjs_fs.readdirSync(dir).filter(resource => {
    if (_libconfigpluginLoaderjs_path.basename(dir) != 'plugins') return _libconfigpluginLoaderjs_RE_PLUGIN.test(resource);
    return _libconfigpluginLoaderjs_RE_JS_FILE.test(resource) || _libconfigpluginLoaderjs_fs.statSync(_libconfigpluginLoaderjs_path.join(dir, resource)).isDirectory();
  }).forEach(resource => {
    _libconfigpluginLoaderjs_registerPluginModule(_libconfigpluginLoaderjs_path.join(dir, resource), config);
  });
}

/**
 * Register plugin 'resource'
 * @param {String} resource
 * @param {Object} config
 * @param {Boolean} [silent]
 * @returns {null}
 */
function _libconfigpluginLoaderjs_registerPluginModule(resource, config, silent) {
  let module;

  try {
    module = 'string' == typeof resource ? require(resource) : resource;
  } catch (err) {
    return _libconfigpluginLoaderjs_warn(`unable to load plugin ${ _libconfigpluginLoaderjs_strong(resource) }`);
  }

  if (!('register' in module)) return _libconfigpluginLoaderjs_warn(`invalid plugin ${ _libconfigpluginLoaderjs_strong(resource) }`);

  module.register(config);
  if (!silent) _libconfigpluginLoaderjs_print(`registered plugin ${ _libconfigpluginLoaderjs_strong(module.name) }`, 0);
}

/**
 * Extract dependency strings from 'optionsItem'
 * @param {Object} optionsItem
 * @returns {Array}
 */
function _libconfigpluginLoaderjs_extractDependencyStrings(optionsItem) {
  let dependencies = [];

  function extract(items) {
    // Invalid if not Array
    if (Array.isArray(items)) {
      items.reduce((dependencies, item) => {
        // Items can be Array with depedency as first param
        const dep = Array.isArray(item) ? item[0] : item;

        // Only gather string references, not functions/modules
        if ('string' == typeof dep) dependencies.push(dep);
        return dependencies;
      }, dependencies);
    }
  }

  if (optionsItem.plugins) extract(optionsItem.plugins);
  if (optionsItem.presets) extract(optionsItem.presets);

  return dependencies;
}

/**
 * Resolve dependency strings in 'optionsItem' to modules
 * @param {Object} optionsItem
 */
function _libconfigpluginLoaderjs_resolveDependecyStrings(optionsItem) {
  function resolve(items) {
    // Invalid if not Array
    if (Array.isArray(items)) {
      items.forEach((item, idx, items) => {
        if (Array.isArray(item) && 'string' == typeof item[0]) {
          item[0] = require(item[0]);
        } else if ('string' == typeof item) {
          items[idx] = require(item);
        }
      });
    }
  }

  if (optionsItem.plugins) resolve(optionsItem.plugins);
  if (optionsItem.presets) resolve(optionsItem.presets);
}
/*≠≠ lib/config/pluginLoader.js ≠≠*/

/*== node_modules/yaw/index.js ==*/
$m['yaw/index.js#0.1.1'] = { exports: {} };
var _yawindexjs011_fs = require('fs'),
    _yawindexjs011_path = require('path'),
    _yawindexjs011_util = require("util"),
    _yawindexjs011_EventEmitter = require('events').EventEmitter,
    _yawindexjs011_existsSync = _yawindexjs011_fs.existsSync || _yawindexjs011_path.existsSync,
    _yawindexjs011_RE_IGNORE = /^[.~]|~$/,
    _yawindexjs011_THROTTLE_TIMEOUT = 100;

$m['yaw/index.js#0.1.1'].exports = _yawindexjs011_Watcher;

/**
 * Constructor
 */
function _yawindexjs011_Watcher() {
	_yawindexjs011_EventEmitter.call(this);

	this.watchers = {};
	this._throttling = {
		'create': 0,
		'delete': 0,
		'change': 0
	};
}

// Inherit
_yawindexjs011_util.inherits(_yawindexjs011_Watcher, _yawindexjs011_EventEmitter);

/**
 * Watch a 'source' file or directory for changes
 * @param {String} source
 */
_yawindexjs011_Watcher.prototype.watch = function (source) {
	var self = this;

	if (!_yawindexjs011_RE_IGNORE.test(_yawindexjs011_path.basename(source))) {
		_yawindexjs011_fs.stat(source, function (err, stats) {
			var lastChange;
			if (err) {
				self.emit('error', err);
			} else {
				lastChange = stats.mtime.getTime();
				// Recursively parse items in directory
				if (stats.isDirectory()) {
					_yawindexjs011_fs.readdir(source, function (err, files) {
						if (err) self.emit('error', err);
						files.forEach(function (file) {
							self.watch(_yawindexjs011_path.resolve(source, file));
						});
					});
				}
			}

			// Store watcher objects
			self.watchers[source] = _yawindexjs011_fs.watch(source, function (evt, filename) {
				if (_yawindexjs011_existsSync(source)) {
					_yawindexjs011_fs.stat(source, function (err, stats) {
						if (err) {
							self.emit('error', err);
						} else {
							if (stats.isFile()) {
								// Notify if changed
								if (stats.mtime.getTime() !== lastChange) {
									self._throttleEvent('change', source, stats);
								}
								lastChange = stats.mtime.getTime();
							} else if (stats.isDirectory()) {
								_yawindexjs011_fs.readdir(source, function (err, files) {
									if (err) {
										self.emit('error', err);
									} else {
										files.forEach(function (file) {
											var item = _yawindexjs011_path.resolve(source, file);
											// New file or directory
											if (!_yawindexjs011_RE_IGNORE.test(_yawindexjs011_path.basename(item)) && !self.watchers[item]) {
												_yawindexjs011_fs.stat(item, function (err, stats) {
													self._throttleEvent('create', item, stats);
													self.watch(item);
												});
											}
										});
									}
								});
							}
						}
					});
					// Deleted
				} else {
					self.unwatch(source);
					self._throttleEvent('delete', source);
				}
			});
		});
	}
};

/**
 * Stop watching a 'source' file or directory for changes
 * @param {String} source
 */
_yawindexjs011_Watcher.prototype.unwatch = function (source) {
	var watcher = this.watchers[source];
	if (watcher) {
		delete this.watchers[source];
		try {
			watcher.close();
		} catch (err) {}
	}
};

/**
 * Stop watching all sources for changes
 */
_yawindexjs011_Watcher.prototype.clean = function () {
	for (var source in this.watchers) {
		this.unwatch(source);
	}
	for (var type in this._throttling) {
		clearInterval(this._throttling[type]);
		this._throttling[type] = 0;
	}
};

/**
 * Protect against mutiple event emits
 * @param {String} type
 * @param [props]
 */
_yawindexjs011_Watcher.prototype._throttleEvent = function (type) {
	var self = this,
	    props = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
	if (!this._throttling[type]) {
		this.emit.apply(this, [type].concat(props));
		this._throttling[type] = setTimeout(function () {
			self._throttling[type] = 0;
		}, _yawindexjs011_THROTTLE_TIMEOUT);
	}
};
/*≠≠ node_modules/yaw/index.js ≠≠*/

/*== lib/config/filetype.js ==*/
$m['lib/config/filetype.js'] = { exports: {} };
'use strict';

const _libconfigfiletypejs_path = require('path');

/**
 * Determine type of 'filepath'
 * @param {String} filepath
 * @param {Object} fileExtensions
 * @returns {String}
 */
$m['lib/config/filetype.js'].exports = function filetype(filepath, fileExtensions) {
  const ext = _libconfigfiletypejs_path.extname(filepath).slice(1);

  // Match input extension to type
  for (const t in fileExtensions) {
    const exts = fileExtensions[t];

    for (let i = 0, n = exts.length; i < n; i++) {
      if (ext == exts[i]) return t;
    }
  }

  return 'unknown';
};
/*≠≠ lib/config/filetype.js ≠≠*/

/*== lib/dependency-resolver/resolve.js ==*/
$m['lib/dependency-resolver/resolve.js'] = { exports: {} };
'use strict';

const { deriveType: _libdependencyresolverresolvejs_deriveType, isAbsoluteFilepath: _libdependencyresolverresolvejs_isAbsoluteFilepath, isRelativeFilepath: _libdependencyresolverresolvejs_isRelativeFilepath, findFile: _libdependencyresolverresolvejs_findFile } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolverresolvejs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverresolvejs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolverresolvejs_config = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolverresolvejs_fs = require('fs');
const _libdependencyresolverresolvejs_pkg = $m['lib/dependency-resolver/package.js'].exports;
const _libdependencyresolverresolvejs_path = require('path');

/**
 * Resolve the path for 'id' from 'sourcepath'
 * @param {String} sourcepath
 * @param {String} id
 * @param {Object} [options]
 *  - {Object} fileExtensions
 * @returns {String|Boolean}
 */
$m['lib/dependency-resolver/resolve.js'].exports = function resolve(sourcepath, id, options) {
  if (!_libdependencyresolverresolvejs_fs.existsSync(sourcepath)) return '';

  options = _libdependencyresolverresolvejs_config(options);

  const type = _libdependencyresolverresolvejs_deriveType(sourcepath, options.fileExtensions);
  const sourcedir = _libdependencyresolverresolvejs_path.dirname(sourcepath);
  let filepath = '';

  // Implied relative path for css/html
  if (type != 'js' && !_libdependencyresolverresolvejs_isRelativeFilepath(id)) {
    filepath = _libdependencyresolverresolvejs_find(`./${ id }`, type, sourcedir, options);
  }

  if (filepath === '') filepath = _libdependencyresolverresolvejs_find(id, type, sourcedir, options);

  return filepath;
};

/**
 * Find filepath for 'id' in 'sourcedir' directory
 * @param {String} id
 * @param {String} type
 * @param {String} sourcedir
 * @param {Object} options
 *  - {Object} fileExtensions
 *  - {Array} nativeModules
 *  - {Array} sources
 * @returns {String|Boolean}
 */
function _libdependencyresolverresolvejs_find(id, type, sourcedir, options) {
  const pkgDetails = _libdependencyresolverresolvejs_pkg.getDetails(sourcedir, options);
  let filepath;

  // Resolve relative paths,
  if (_libdependencyresolverresolvejs_isRelativeFilepath(id)) id = _libdependencyresolverresolvejs_path.resolve(sourcedir, id);

  // Redirect if cached version
  if (pkgDetails && !~sourcedir.indexOf(pkgDetails.pkgpath)) {
    // Replace source path root with details root
    id = _libdependencyresolverresolvejs_path.resolve(pkgDetails.dirname, _libdependencyresolverresolvejs_path.relative(_libdependencyresolverresolvejs_path.dirname(_libdependencyresolverresolvejs_pkg.resolvePath(sourcedir)), sourcedir));
  }

  // Handle aliases
  id = _libdependencyresolverresolvejs_alias.resolve(pkgDetails, id);
  // Handle root package shortcut id
  if (pkgDetails && pkgDetails.isRoot && pkgDetails.id == id) return pkgDetails.main;
  // Handle disabled or native modules
  if (id === false || options.nativeModules.includes(id)) return false;

  if (_libdependencyresolverresolvejs_isAbsoluteFilepath(id)) {
    filepath = _libdependencyresolverresolvejs_findFile(id, type, options.fileExtensions);
    filepath = _libdependencyresolverresolvejs_alias.resolve(pkgDetails, filepath);
    // File doesn't exist or is disabled
    if (filepath == '' || filepath === false) return filepath;
    // File found
    if (_libdependencyresolverresolvejs_isAbsoluteFilepath(filepath)) {
      // Cache
      _libdependencyresolverresolvejs_cache.setFile({
        path: filepath,
        id: _libdependencyresolverresolvejs_pkg.resolveId(pkgDetails, filepath)
      });

      return filepath;
    }

    // Continue
    id = filepath;
  }

  // Search source paths for matches
  let fp;

  pkgDetails.paths.some(sourcepath => {
    if (id && sourcedir != sourcepath) {
      fp = _libdependencyresolverresolvejs_path.resolve(sourcepath, id);
      fp = _libdependencyresolverresolvejs_find(fp, type, fp, options);
      if (fp !== '') {
        filepath = fp;
        return true;
      }
      filepath = '';
    }
  });

  return filepath;
}
/*≠≠ lib/dependency-resolver/resolve.js ≠≠*/

/*== lib/dependency-resolver/identify.js ==*/
$m['lib/dependency-resolver/identify.js'] = { exports: {} };
'use strict';

const { isAbsoluteFilepath: _libdependencyresolveridentifyjs_isAbsoluteFilepath } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolveridentifyjs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolveridentifyjs_config = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolveridentifyjs_fs = require('fs');
const _libdependencyresolveridentifyjs_pkg = $m['lib/dependency-resolver/package.js'].exports;

/**
 * Retrieve id for 'filepath'
 * @param {String} filepath
 * @param {Object} [options]
 * @returns {String}
 */
$m['lib/dependency-resolver/identify.js'].exports = function indentify(filepath, options) {
  options = _libdependencyresolveridentifyjs_config(options);

  let id = '';

  if (!_libdependencyresolveridentifyjs_fs.existsSync(filepath) || !_libdependencyresolveridentifyjs_isAbsoluteFilepath(filepath)) return id;

  // Return from cache
  if (id = _libdependencyresolveridentifyjs_cache.getFile(filepath)) return id;

  const pkgDetails = _libdependencyresolveridentifyjs_pkg.getDetails(filepath, options);

  // Handle aliases
  if (filepath in pkgDetails.aliases) {
    const fp = pkgDetails.aliases[filepath];

    // Only follow alias if not disabled
    if (fp !== false) filepath = fp;
  }

  if (id = _libdependencyresolveridentifyjs_pkg.resolveId(pkgDetails, filepath)) {
    if (process.platform == 'win32') id = id.replace(/\\/g, '/');
    // Cache
    _libdependencyresolveridentifyjs_cache.setFile({ path: filepath, id });
  }

  return id;
};
/*≠≠ lib/dependency-resolver/identify.js ≠≠*/

/*== lib/dependency-resolver/index.js ==*/
$m['lib/dependency-resolver/index.js'] = { exports: {} };
'use strict';

const { clear: _libdependencyresolverindexjs_clear, hasMultipleVersions: _libdependencyresolverindexjs_hasMultipleVersions } = $m['lib/dependency-resolver/cache.js'].exports;

$m['lib/dependency-resolver/index.js'].exports.identify = $m['lib/dependency-resolver/identify.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.resolve = $m['lib/dependency-resolver/resolve.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.nativeModules = $m['lib/dependency-resolver/nativeModules.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.hasMultipleVersions = _libdependencyresolverindexjs_hasMultipleVersions;
$m['lib/dependency-resolver/index.js'].exports.clearCache = _libdependencyresolverindexjs_clear;
/*≠≠ lib/dependency-resolver/index.js ≠≠*/

/*== node_modules/recur-fs/lib/hunt.js ==*/
$m['recur-fs/lib/hunt.js#2.2.3'] = { exports: {} };
var _recurfslibhuntjs223_fs = require('fs'),
    _recurfslibhuntjs223_Minimatch = $m['minimatch/minimatch.js#3.0.2'].exports.Minimatch,
    _recurfslibhuntjs223_path = require('path'),
    _recurfslibhuntjs223_walk = $m['recur-fs/lib/walk.js#2.2.3'].exports;

/**
 * Walk directory tree from 'directory', returning all resources matching 'matcher'.
 * 'matcher' can be glob string, or function that returns 'isMatch'.
 * Stops walking when root directory reached, on first match if 'stopOnFirstMatch',
 * or if "true" is returned as second argument from 'next'.
 * @param {String} directory
 * @param {String|Function} matcher(resource, stat, next)
 * @param {Boolean} stopOnFirstMatch
 * @param {Function} fn(err, matches)
 */
$m['recur-fs/lib/hunt.js#2.2.3'].exports = function hunt(directory, matcher, stopOnFirstMatch, fn) {
	directory = _recurfslibhuntjs223_path.resolve(directory);

	// Convert glob string to async matcher function
	if ('string' == typeof matcher) {
		var match = new _recurfslibhuntjs223_Minimatch(matcher, { matchBase: true });
		matcher = function matcher(resource, stat, done) {
			done(match.match(resource));
		};
	}

	var matches = [],
	    finished = false;

	// Walk and match each resource
	_recurfslibhuntjs223_walk(directory, function (resource, stat, next) {
		if (!finished) {
			matcher(resource, stat, function (isMatch, stop) {
				if (isMatch) {
					matches.push(resource);
					finished = stopOnFirstMatch;
				}

				if (stop === true) finished = true;

				// Stop walking if finished
				next(finished);
			});
		}
	}, function (err) {
		if (err) return fn(err);
		return fn(null, stopOnFirstMatch ? matches[0] : matches);
	});
};

/**
 * Synchronously walk directory tree from 'directory', returning all resources matching 'matcher'.
 * 'matcher' can be glob string, or function that returns 'isMatch'.
 * Stops walking when root directory reached, or on first match if 'stopOnFirstMatch'.
 * @param {String} directory
 * @param {String|Function} matcher(resource, next)
 * @param {Boolean} stopOnFirstMatch
 * @returns (Array|String}
 */
$m['recur-fs/lib/hunt.js#2.2.3'].exports.sync = function huntSync(directory, matcher, stopOnFirstMatch) {
	directory = _recurfslibhuntjs223_path.resolve(directory);

	if ('string' == typeof matcher) {
		var match = new _recurfslibhuntjs223_Minimatch(matcher, { matchBase: true });
		matcher = function matcher(resource) {
			return match.match(resource);
		};
	}

	var matches = [],
	    finished = false;

	// Walk and match each resource
	_recurfslibhuntjs223_walk.sync(directory, function (resource, stat) {
		if (!finished) {
			var isMatch = matcher(resource, stat);
			if (isMatch) {
				matches.push(resource);
				finished = stopOnFirstMatch;
				if (finished) return true;
			}
		}
	});

	return stopOnFirstMatch ? matches[0] : matches;
};
/*≠≠ node_modules/recur-fs/lib/hunt.js ≠≠*/

/*== node_modules/recur-fs/lib/readdir.js ==*/
$m['recur-fs/lib/readdir.js#2.2.3'] = { exports: {} };
var _recurfslibreaddirjs223_fs = require('fs'),
    _recurfslibreaddirjs223_path = require('path');

/**
 * Read the contents of 'directory', returning all resources.
 * 'visitor' is optional function called on each resource,
 * and resource is skipped if next() returns "false"
 * @param {String} dir
 * @param {Function} [visitor(resource, stat, next)]
 * @param {Function} fn(err, resources)
 */
$m['recur-fs/lib/readdir.js#2.2.3'].exports = function readdir(directory, visitor, fn) {
	if (arguments.length == 2) {
		fn = visitor;
		// Noop
		visitor = function (resource, stat, next) {
			next();
		};
	}

	var resources = [],
	    outstanding = 0,
	    done = function () {
		if (! --outstanding) fn(null, resources);
	};

	function visit(dir) {
		outstanding++;

		_recurfslibreaddirjs223_fs.readdir(dir, function (err, files) {
			if (err) {
				// Skip if not found, otherwise exit
				if (err.code === 'ENOENT') return done();
				return fn(err);
			}

			// Include dir
			outstanding += files.length - 1;

			files.forEach(function (file) {
				file = _recurfslibreaddirjs223_path.join(dir, file);
				_recurfslibreaddirjs223_fs.stat(file, function (err, stat) {
					if (err) {
						// Skip if not found, otherwise exit
						if (err.code === 'ENOENT') return done();
						return fn(err);
					}

					visitor(file, stat, function next(include) {
						// Store
						if (include !== false) resources.push(file);
						// Recurse child directory
						if (stat.isDirectory()) visit(file);
						done();
					});
				});
			});
		});
	}

	visit(directory);
};

/**
 * Synchronously read the contents of 'directory', returning all resources.
 * 'visitor' is optional function called on each resource,
 * and resource is skipped if visitor returns "false"
 * @param {String} dir
 * @param {Function} [visitor(resource, stat)]
 * @returns {Array}
 */
$m['recur-fs/lib/readdir.js#2.2.3'].exports.sync = function readdirSync(directory, visitor) {
	visitor = visitor || function (resource, stat, next) {};

	var resources = [];

	function visit(dir) {
		if (_recurfslibreaddirjs223_fs.existsSync(dir)) {
			_recurfslibreaddirjs223_fs.readdirSync(dir).forEach(function (file) {
				file = _recurfslibreaddirjs223_path.resolve(dir, file);
				try {
					var stat = _recurfslibreaddirjs223_fs.statSync(file);
				} catch (err) {
					// Skip if file not found, otherwise throw
					if (err.code === 'ENOENT') {
						return;
					} else {
						throw err;
					}
				}

				// Store
				var include = visitor(file, stat);
				if (include !== false) resources.push(file);

				// Recurse child directory
				if (stat.isDirectory()) visit(file);
			});
		}
	}

	visit(directory);

	return resources;
};
/*≠≠ node_modules/recur-fs/lib/readdir.js ≠≠*/

/*== node_modules/recur-fs/lib/mv.js ==*/
$m['recur-fs/lib/mv.js#2.2.3'] = { exports: {} };
var _recurfslibmvjs223_fs = require('fs'),
    _recurfslibmvjs223_mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports,
    _recurfslibmvjs223_path = require('path'),
    _recurfslibmvjs223_rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;

/**
 * Move file or directory 'source' to 'destination'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @param {Function} fn(err, filepath)
 */
$m['recur-fs/lib/mv.js#2.2.3'].exports = function mv(source, destination, force, fn) {
	if (force == null) force = false;

	_recurfslibmvjs223_mkdir(destination, function (err) {
		if (err) {
			return fn(err);
		} else {
			var filepath = _recurfslibmvjs223_path.resolve(destination, _recurfslibmvjs223_path.basename(source));

			if (!force && _recurfslibmvjs223_fs.existsSync(filepath)) {
				return fn(null, filepath);
			} else {
				_recurfslibmvjs223_rm(filepath, function (err) {
					// Ignore rm errors
					_recurfslibmvjs223_fs.rename(source, filepath, function (err) {
						if (err) return fn(err);
						return fn(null, filepath);
					});
				});
			}
		}
	});
};

/**
 * Synchronously move file or directory 'source' to 'destination'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @returns {String}
 */
$m['recur-fs/lib/mv.js#2.2.3'].exports.sync = function mvSync(source, destination, force) {
	if (force == null) force = false;

	if (!_recurfslibmvjs223_fs.existsSync(destination)) _recurfslibmvjs223_mkdir.sync(destination);

	var filepath = _recurfslibmvjs223_path.resolve(destination, _recurfslibmvjs223_path.basename(source));

	if (_recurfslibmvjs223_fs.existsSync(filepath)) {
		if (!force) return filepath;
		_recurfslibmvjs223_rm.sync(filepath);
	}
	_recurfslibmvjs223_fs.renameSync(source, filepath);

	return filepath;
};
/*≠≠ node_modules/recur-fs/lib/mv.js ≠≠*/

/*== node_modules/recur-fs/lib/indir.js ==*/
$m['recur-fs/lib/indir.js#2.2.3'] = { exports: {} };
var _recurfslibindirjs223_path = require('path');

/**
 * Check that a 'filepath' is likely a child of a given directory
 * Applies to nested directories
 * Only makes String comparison. Does not check for existance
 * @param {String} directory
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['recur-fs/lib/indir.js#2.2.3'].exports = function indir(directory, filepath) {
	if (directory && filepath) {
		directory = _recurfslibindirjs223_path.resolve(directory);
		filepath = _recurfslibindirjs223_path.resolve(filepath);

		if (~filepath.indexOf(directory)) {
			return !~_recurfslibindirjs223_path.relative(directory, filepath).indexOf('..');
		}
	}

	return false;
};
/*≠≠ node_modules/recur-fs/lib/indir.js ≠≠*/

/*== node_modules/recur-fs/lib/cp.js ==*/
$m['recur-fs/lib/cp.js#2.2.3'] = { exports: {} };
var _recurfslibcpjs223_fs = require('fs'),
    _recurfslibcpjs223_mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports,
    _recurfslibcpjs223_path = require('path'),
    _recurfslibcpjs223_rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;

/**
 * Copy file or directory 'source' to 'destination'
 * Copies contents of 'source' if directory and ends in trailing '/'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @param {Function} fn(err, filepath)
 */
$m['recur-fs/lib/cp.js#2.2.3'].exports = function cp(source, destination, force, fn) {
	var filepath = '',
	    first = true,
	    outstanding = 0;

	if (force == null) force = false;

	function copy(source, destination) {
		outstanding++;
		_recurfslibcpjs223_fs.stat(source, function (err, stat) {
			var isDestFile;
			outstanding--;
			// Exit if proper error, otherwise skip
			if (err) {
				if (err.code === 'ENOENT') return;
				return fn(err);
			} else {
				isDestFile = _recurfslibcpjs223_path.extname(destination).length;
				// File
				if (stat.isFile()) {
					// Handle file or directory as destination
					var destDir = isDestFile ? _recurfslibcpjs223_path.dirname(destination) : destination,
					    destName = isDestFile ? _recurfslibcpjs223_path.basename(destination) : _recurfslibcpjs223_path.basename(source),
					    filepath = _recurfslibcpjs223_path.resolve(destDir, destName);
					// Write file if it doesn't already exist
					if (!force && _recurfslibcpjs223_fs.existsSync(filepath)) {
						if (!outstanding) return fn(null, filepath);
					} else {
						_recurfslibcpjs223_rm(filepath, function (err) {
							// Ignore rm errors
							var file;
							outstanding++;
							// Return the new path for the first source
							if (first) {
								filepath = filepath;
								first = false;
							}
							// Pipe stream
							_recurfslibcpjs223_fs.createReadStream(source).pipe(file = _recurfslibcpjs223_fs.createWriteStream(filepath));
							file.on('error', function (err) {
								return fn(err);
							});
							file.on('close', function () {
								outstanding--;
								// Return if no outstanding
								if (!outstanding) return fn(null, filepath);
							});
						});
					}
					// Directory
				} else {
					// Guard against invalid directory to file copy
					if (isDestFile) {
						fn(new Error('invalid destination for copy: ' + destination));
					} else {
						// Copy contents only if source ends in '/'
						var contentsOnly = first && /\\$|\/$/.test(source),
						    dest = contentsOnly ? destination : _recurfslibcpjs223_path.resolve(destination, _recurfslibcpjs223_path.basename(source));

						// Create in destination
						outstanding++;
						_recurfslibcpjs223_mkdir(dest, function (err) {
							outstanding--;
							if (err) {
								return fn(err);
							} else {
								// Loop through contents
								outstanding++;
								_recurfslibcpjs223_fs.readdir(source, function (err, files) {
									outstanding--;
									// Exit if proper error, otherwise skip
									if (err) {
										if (err.code === 'ENOENT') return;else return fn(err);
									} else {
										// Return the new path for the first source
										if (first) {
											filepath = dest;
											first = false;
										}
										// Loop through files and cp
										files.forEach(function (file) {
											copy(_recurfslibcpjs223_path.resolve(source, file), dest);
										});
										// Return if no outstanding
										if (!outstanding) return fn(null, filepath);
									}
								});
							}
						});
					}
				}
			}
		});
		// Return if no outstanding
		if (!outstanding) return fn(null, filepath);
	};

	return copy(source, destination);
};

/**
 * Synchronously copy file or directory 'source' to 'destination'
 * Copies contents of 'source' if directory and ends in trailing '/'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @returns {String}
 */
$m['recur-fs/lib/cp.js#2.2.3'].exports.sync = function cpSync(source, destination, force) {
	var filepath = '',
	    first = true;

	if (force == null) force = false;

	function copy(source, destination) {
		if (_recurfslibcpjs223_fs.existsSync(source)) {
			var stat = _recurfslibcpjs223_fs.statSync(source),
			    isDestFile = _recurfslibcpjs223_path.extname(destination).length;

			// File
			if (stat.isFile()) {
				// Handle file or directory as destination
				var destDir = isDestFile ? _recurfslibcpjs223_path.dirname(destination) : destination,
				    destName = isDestFile ? _recurfslibcpjs223_path.basename(destination) : _recurfslibcpjs223_path.basename(source),
				    filepath = _recurfslibcpjs223_path.resolve(destDir, destName);

				// Return the new path for the first source
				if (first) {
					filepath = filepath;
					first = false;
				}
				// Write file only if it doesn't already exist
				if (_recurfslibcpjs223_fs.existsSync(filepath)) {
					if (!force) return filepath;
					_recurfslibcpjs223_rm.sync(filepath);
				}
				_recurfslibcpjs223_fs.writeFileSync(filepath, _recurfslibcpjs223_fs.readFileSync(source));

				// Directory
			} else {
				// Guard against invalid directory to file copy
				if (isDestFile) throw new Error('invalid destination for copy: ' + destination);
				// Copy contents only if source ends in '/'
				var contentsOnly = first && /\\$|\/$/.test(source),
				    dest = contentsOnly ? destination : _recurfslibcpjs223_path.resolve(destination, _recurfslibcpjs223_path.basename(source));

				// Return the new path for the first source
				if (first) {
					filepath = dest;
					first = false;
				}
				// Create in destination
				_recurfslibcpjs223_mkdir.sync(dest);
				// Loop through files and copy
				var files = _recurfslibcpjs223_fs.readdirSync(source);
				files.forEach(function (file) {
					copy(_recurfslibcpjs223_path.resolve(source, file), dest);
				});
			}
		}
		return filepath;
	};

	return copy(source, destination);
};
/*≠≠ node_modules/recur-fs/lib/cp.js ≠≠*/

/*== node_modules/recur-fs/index.js ==*/
$m['recur-fs/index.js#2.2.3'] = { exports: {} };
$m['recur-fs/index.js#2.2.3'].exports.cp = $m['recur-fs/lib/cp.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.indir = $m['recur-fs/lib/indir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.mv = $m['recur-fs/lib/mv.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.readdir = $m['recur-fs/lib/readdir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.walk = $m['recur-fs/lib/walk.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.hunt = $m['recur-fs/lib/hunt.js#2.2.3'].exports;
/*≠≠ node_modules/recur-fs/index.js ≠≠*/

/*== node_modules/has-ansi/index.js ==*/
$m['has-ansi/index.js#2.0.0'] = { exports: {} };
'use strict';

var _hasansiindexjs200_ansiRegex = $m['ansi-regex/index.js#2.0.0'].exports;
var _hasansiindexjs200_re = new RegExp(_hasansiindexjs200_ansiRegex().source); // remove the `g` flag
$m['has-ansi/index.js#2.0.0'].exports = _hasansiindexjs200_re.test.bind(_hasansiindexjs200_re);
/*≠≠ node_modules/has-ansi/index.js ≠≠*/

/*== node_modules/strip-ansi/index.js ==*/
$m['strip-ansi/index.js#3.0.1'] = { exports: {} };
'use strict';

var _stripansiindexjs301_ansiRegex = $m['ansi-regex/index.js#2.0.0'].exports();

$m['strip-ansi/index.js#3.0.1'].exports = function (str) {
	return typeof str === 'string' ? str.replace(_stripansiindexjs301_ansiRegex, '') : str;
};
/*≠≠ node_modules/strip-ansi/index.js ≠≠*/

/*== node_modules/md5/md5.js ==*/
$m['md5/md5.js#2.2.1'] = { exports: {} };
(function () {
  var crypt = $m['crypt/crypt.js#0.0.1'].exports,
      utf8 = $m['charenc/charenc.js#0.0.1'].exports.utf8,
      isBuffer = $m['is-buffer/index.js#1.1.4'].exports,
      bin = $m['charenc/charenc.js#0.0.1'].exports.bin,


  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String) {
      if (options && options.encoding === 'binary') message = bin.stringToBytes(message);else message = utf8.stringToBytes(message);
    } else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);else if (!Array.isArray(message)) message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a = 1732584193,
        b = -271733879,
        c = -1732584194,
        d = 271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << l % 32;
    m[(l + 64 >>> 9 << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i + 0], 7, -680876936);
      d = FF(d, a, b, c, m[i + 1], 12, -389564586);
      c = FF(c, d, a, b, m[i + 2], 17, 606105819);
      b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i + 4], 7, -176418897);
      d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
      c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i + 7], 22, -45705983);
      a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
      d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i + 10], 17, -42063);
      b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
      a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
      d = FF(d, a, b, c, m[i + 13], 12, -40341101);
      c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
      b = FF(b, c, d, a, m[i + 15], 22, 1236535329);

      a = GG(a, b, c, d, m[i + 1], 5, -165796510);
      d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
      c = GG(c, d, a, b, m[i + 11], 14, 643717713);
      b = GG(b, c, d, a, m[i + 0], 20, -373897302);
      a = GG(a, b, c, d, m[i + 5], 5, -701558691);
      d = GG(d, a, b, c, m[i + 10], 9, 38016083);
      c = GG(c, d, a, b, m[i + 15], 14, -660478335);
      b = GG(b, c, d, a, m[i + 4], 20, -405537848);
      a = GG(a, b, c, d, m[i + 9], 5, 568446438);
      d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
      c = GG(c, d, a, b, m[i + 3], 14, -187363961);
      b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
      a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
      d = GG(d, a, b, c, m[i + 2], 9, -51403784);
      c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
      b = GG(b, c, d, a, m[i + 12], 20, -1926607734);

      a = HH(a, b, c, d, m[i + 5], 4, -378558);
      d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
      b = HH(b, c, d, a, m[i + 14], 23, -35309556);
      a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
      d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
      c = HH(c, d, a, b, m[i + 7], 16, -155497632);
      b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
      a = HH(a, b, c, d, m[i + 13], 4, 681279174);
      d = HH(d, a, b, c, m[i + 0], 11, -358537222);
      c = HH(c, d, a, b, m[i + 3], 16, -722521979);
      b = HH(b, c, d, a, m[i + 6], 23, 76029189);
      a = HH(a, b, c, d, m[i + 9], 4, -640364487);
      d = HH(d, a, b, c, m[i + 12], 11, -421815835);
      c = HH(c, d, a, b, m[i + 15], 16, 530742520);
      b = HH(b, c, d, a, m[i + 2], 23, -995338651);

      a = II(a, b, c, d, m[i + 0], 6, -198630844);
      d = II(d, a, b, c, m[i + 7], 10, 1126891415);
      c = II(c, d, a, b, m[i + 14], 15, -1416354905);
      b = II(b, c, d, a, m[i + 5], 21, -57434055);
      a = II(a, b, c, d, m[i + 12], 6, 1700485571);
      d = II(d, a, b, c, m[i + 3], 10, -1894986606);
      c = II(c, d, a, b, m[i + 10], 15, -1051523);
      b = II(b, c, d, a, m[i + 1], 21, -2054922799);
      a = II(a, b, c, d, m[i + 8], 6, 1873313359);
      d = II(d, a, b, c, m[i + 15], 10, -30611744);
      c = II(c, d, a, b, m[i + 6], 15, -1560198380);
      b = II(b, c, d, a, m[i + 13], 21, 1309151649);
      a = II(a, b, c, d, m[i + 4], 6, -145523070);
      d = II(d, a, b, c, m[i + 11], 10, -1120210379);
      c = II(c, d, a, b, m[i + 2], 15, 718787259);
      b = II(b, c, d, a, m[i + 9], 21, -343485551);

      a = a + aa >>> 0;
      b = b + bb >>> 0;
      c = c + cc >>> 0;
      d = d + dd >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._gg = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._hh = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._ii = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  $m['md5/md5.js#2.2.1'].exports = function (message, options) {
    if (message === undefined || message === null) throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
  };
})();
/*≠≠ node_modules/md5/md5.js ≠≠*/

/*== node_modules/async/eachOf.js ==*/
$m['async/eachOf.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOf.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/eachOf.js#2.0.1'].exports.default = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _asynceachOfjs201__isArrayLike2.default)(coll) ? _asynceachOfjs201_eachOfArrayLike : _asynceachOfjs201_eachOfGeneric;
    eachOfImplementation(coll, iteratee, callback);
};

var _asynceachOfjs201__isArrayLike = $m['lodash/isArrayLike.js#4.16.2'].exports;

var _asynceachOfjs201__isArrayLike2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__isArrayLike);

var _asynceachOfjs201__eachOfLimit = $m['async/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfjs201__eachOfLimit2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__eachOfLimit);

var _asynceachOfjs201__doLimit = $m['async/internal/doLimit.js#2.0.1'].exports;

var _asynceachOfjs201__doLimit2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__doLimit);

var _asynceachOfjs201__noop = $m['lodash/noop.js#4.16.2'].exports;

var _asynceachOfjs201__noop2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__noop);

var _asynceachOfjs201__once = $m['lodash/once.js#4.16.2'].exports;

var _asynceachOfjs201__once2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__once);

var _asynceachOfjs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asynceachOfjs201__onlyOnce2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__onlyOnce);

function _asynceachOfjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

// eachOf implementation optimized for array-likes
function _asynceachOfjs201_eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _asynceachOfjs201__once2.default)(callback || _asynceachOfjs201__noop2.default);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err) {
        if (err) {
            callback(err);
        } else if (++completed === length) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _asynceachOfjs201__onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var _asynceachOfjs201_eachOfGeneric = (0, _asynceachOfjs201__doLimit2.default)(_asynceachOfjs201__eachOfLimit2.default, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
$m['async/eachOf.js#2.0.1'].exports = $m['async/eachOf.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOf.js ≠≠*/

/*== node_modules/async/parallel.js ==*/
$m['async/parallel.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/parallel.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/parallel.js#2.0.1'].exports.default = _asyncparalleljs201_parallelLimit;

var _asyncparalleljs201__eachOf = $m['async/eachOf.js#2.0.1'].exports;

var _asyncparalleljs201__eachOf2 = _asyncparalleljs201__interopRequireDefault(_asyncparalleljs201__eachOf);

var _asyncparalleljs201__parallel = $m['async/internal/parallel.js#2.0.1'].exports;

var _asyncparalleljs201__parallel2 = _asyncparalleljs201__interopRequireDefault(_asyncparalleljs201__parallel);

function _asyncparalleljs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function _asyncparalleljs201_parallelLimit(tasks, callback) {
  (0, _asyncparalleljs201__parallel2.default)(_asyncparalleljs201__eachOf2.default, tasks, callback);
}
$m['async/parallel.js#2.0.1'].exports = $m['async/parallel.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/parallel.js ≠≠*/

/*== lib/utils/env.js ==*/
$m['lib/utils/env.js'] = { exports: {} };
'use strict';

const _libutilsenvjs_path = require('path');

const _libutilsenvjs_RE_ILLEGAL_ID = /[\- .*]/g;

/**
 * Set BUDDY env 'key'
 * @param {String} key
 * @param {String|Array} value
 * @param {String} [id]
 */
$m['lib/utils/env.js'].exports = function env(key, value, id) {
  id = id != null ? id.replace(_libutilsenvjs_RE_ILLEGAL_ID, '').toUpperCase() + '_' : '';

  if (Array.isArray(value)) {
    value = value.reduce((value, item) => {
      const isFile = 'object' == typeof item && 'extension' in item;

      switch (key) {
        case 'INPUT':
          value += isFile ? _libutilsenvjs_path.relative(process.cwd(), item.filepath) : item;
          break;
        case 'INPUT_HASH':
          value += isFile ? item.hash : item;
          break;
        case 'INPUT_DATE':
          value += isFile ? item.date : item;
          break;
        case 'OUTPUT':
          value += _libutilsenvjs_path.relative(process.cwd(), item);
          break;
        case 'OUTPUT_HASH':
        case 'OUTPUT_DATE':
          value += item;
          break;
      }

      return value;
    }, '');
  }

  process.env[`BUDDY_${ id }${ key }`] = value;
};
/*≠≠ lib/utils/env.js ≠≠*/

/*== lib/utils/index.js ==*/
$m['lib/utils/index.js'] = { exports: {} };
'use strict';

$m['lib/utils/index.js'].exports = {
  callable: $m['lib/utils/callable.js'].exports,
  cnsl: $m['lib/utils/cnsl.js'].exports,
  env: $m['lib/utils/env.js'].exports,
  string: $m['lib/utils/string.js'].exports
};
/*≠≠ lib/utils/index.js ≠≠*/

/*== node_modules/lodash/flatten.js ==*/
$m['lodash/flatten.js#4.16.2'] = { exports: {} };
var _lodashflattenjs4162_baseFlatten = $m['lodash/_baseFlatten.js#4.16.2'].exports;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function _lodashflattenjs4162_flatten(array) {
  var length = array ? array.length : 0;
  return length ? _lodashflattenjs4162_baseFlatten(array, 1) : [];
}

$m['lodash/flatten.js#4.16.2'].exports = _lodashflattenjs4162_flatten;
/*≠≠ node_modules/lodash/flatten.js ≠≠*/

/*== lib/config/fileCache.js ==*/
$m['lib/config/fileCache.js'] = { exports: {} };
'use strict';

const _libconfigfileCachejs_EventEmitter = require('events').EventEmitter;
const _libconfigfileCachejs_path = require('path');
const _libconfigfileCachejs_Watcher = $m['yaw/index.js#0.1.1'].exports;

// Export
$m['lib/config/fileCache.js'].exports = function fileCacheFactory(watch) {
  return new _libconfigfileCachejs_FileCache(watch);
};

class _libconfigfileCachejs_FileCache extends _libconfigfileCachejs_EventEmitter {
  /**
   * Constructor
   * @param {Boolean} watch
   */
  constructor(watch) {
    super();

    this._cache = new Map();
    this._dirs = new Set();
    this.watching = watch;

    if (watch) {
      this.watcher = new _libconfigfileCachejs_Watcher();
      this.watcher.on('change', this.onWatchChange.bind(this));
      this.watcher.on('delete', this.onWatchDelete.bind(this));
      this.watcher.on('error', this.onWatchError.bind(this));
    }
  }

  /**
   * Store a 'file' in the cache
   * @param {File} file
   * @returns {File}
   */
  addFile(file) {
    if (!this._cache.has(file.filepath)) {
      const dir = _libconfigfileCachejs_path.dirname(file.filepath);

      this._cache.set(file.filepath, file);
      if (!this._dirs.has(dir)) this._dirs.add(dir);
      if (this.watching) this.watcher.watch(file.filepath);
    }

    return file;
  }

  /**
   * Remove a file from the cache by it's 'filepath'
   * @param {Object} file
   * @returns {File}
   */
  removeFile(file) {
    this._cache.delete(file.filepath);
    if (this.watching) this.watcher.unwatch(file.filepath);
    return file;
  }

  /**
   * Retrieve a file from the cache by 'key' (filepath or type:id)
   * @param {String} key
   * @returns {Object}
   */
  getFile(key) {
    return this._cache.get(key);
  }

  /**
   * Determine if the cache contains a file by 'key' (filepath or type:id)
   * @param {String} key
   * @returns {Boolean}
   */
  hasFile(key) {
    return this._cache.has(key);
  }

  /**
   * Retrieve all file paths
   * @returns {Array}
   */
  getPaths() {
    return this._cache.keys();
  }

  /**
   * Retrieve all unique directories
   * @returns {Array}
   */
  getDirs() {
    return [...this._dirs];
  }

  /**
   * Flush the cache
   */
  flush() {
    if (this.watching) this.watcher.clean();
    this._cache.clear();
    this._dirs.clear();
  }

  /**
   * Handle changes to watched files
   * @param {String} filepath
   * @param {Stats} stats
   */
  onWatchChange(filepath, stats) {
    const file = this._cache.get(filepath);

    // Reset file
    if (file) {
      // Hard reset
      file.reset(true);
      this.emit('change', file);
    }
  }

  /**
   * Handle deleted watched files
   * @param {String} filepath
   */
  onWatchDelete(filepath) {
    const file = this._cache.get(filepath);

    // Destroy file
    if (file) {
      file.destroy();
      this.removeFile(file);
    }
  }

  /**
   * Handle error watching files
   * @param {Error} err
   */
  onWatchError(err) {
    this.emit('error', err);
  }
}
/*≠≠ lib/config/fileCache.js ≠≠*/

/*== lib/File.js ==*/
$m['lib/File.js'] = { exports: {} };
'use strict';

const { debug: _libFilejs_debug, print: _libFilejs_print, strong: _libFilejs_strong, warn: _libFilejs_warn } = $m['lib/utils/cnsl.js'].exports;
const { getSharedDecendants: _libFilejs_getSharedDecendants, walk: _libFilejs_walk } = $m['lib/utils/tree.js'].exports;
const { regexpEscape: _libFilejs_regexpEscape, truncate: _libFilejs_truncate } = $m['lib/utils/string.js'].exports;
const { resolve: _libFilejs_resolve, nativeModules: _libFilejs_nativeModules } = $m['lib/dependency-resolver/index.js'].exports;
const { readFileSync: _libFilejs_readFile, writeFileSync: _libFilejs_writeFile } = require('fs');
const { mkdir: { sync: _libFilejs_mkdir } } = $m['recur-fs/index.js#2.2.3'].exports;
const _libFilejs_callable = $m['lib/utils/callable.js'].exports;
const _libFilejs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libFilejs_md5 = $m['md5/md5.js#2.2.1'].exports;
const _libFilejs_parallel = $m['async/parallel.js#2.0.1'].exports;
const _libFilejs_path = require('path');
const _libFilejs_series = $m['async/series.js#2.0.1'].exports;
const _libFilejs_sortBy = $m['lodash/sortBy.js#4.16.2'].exports;
const _libFilejs_unique = $m['lodash/uniq.js#4.16.2'].exports;

const _libFilejs_MAX_DEPTH = 10000;
const _libFilejs_RE_ESCAPE_ID = /[#._-\s/\\]/g;
const _libFilejs_WORKFLOW_INLINEABLE = ['load'];
const _libFilejs_WORKFLOW_STANDARD = ['load', 'parse', 'runWorkflowForDependencies'];
const _libFilejs_WORKFLOWS = {
  standard: 1,
  inlineable: 2,
  writeable: 4
};

$m['lib/File.js'].exports = class File {
  /**
   * Constructor
   * @param {String} id
   * @param {String} filepath
   * @param {String} type
   * @param {Object} options
   *  - {Object} caches
   *  - {Object} fileExtensions
   *  - {Function} fileFactory
   *  - {Object} globalAliases
   *  - {Array} npmModulepaths
   *  - {Object} pluginOptions
   *  - {Object} runtimeOptions
   */
  constructor(id, filepath, type, options) {
    this.allDependencies = null;
    this.content = '';
    this.encoding = 'utf8';
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.depth = 0;
    this.fileContent = '';
    this.filepath = filepath;
    this.hash = '';
    this.helpers = [];
    this.id = id;
    // TODO: short name when compressed?
    this.idSafe = id.replace(_libFilejs_RE_ESCAPE_ID, '');
    this.isCircularDependency = false;
    this.isDependency = false;
    this.isInline = false;
    this.isLocked = false;
    this.options = options;
    this.parent = null;
    this.ran = 0;
    this.type = type;
    this.workflows = {
      standard: [_libFilejs_WORKFLOW_STANDARD],
      inlineable: [_libFilejs_WORKFLOW_INLINEABLE],
      writeable: [[]]
    };

    this.extension = _libFilejs_path.extname(this.filepath).slice(1);
    this.relpath = _libFilejs_truncate(_libFilejs_path.relative(process.cwd(), filepath));
    this.name = _libFilejs_path.basename(this.filepath);

    // Force generation of hash
    this.load();

    _libFilejs_debug(`created File instance ${ _libFilejs_strong(this.relpath) }`, 3);
  }

  /**
   * Retrieve writeable state
   * @param {Boolean} batch
   * @returns {Boolean}
   */
  isWriteable(batch) {
    return !this.isInline
    // Only writeable if not node_module in batch mode
    && batch ? !~this.filepath.indexOf('node_modules') : !this.isDependency;
  }

  /**
   * Retrieve inlineable state
   * @returns {Boolean}
   */
  isInlineable() {
    return this.isInline;
  }

  /**
   * Retrieve parsed workflows for 'buildOptions'
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @returns {Array}
   */
  parseWorkflow(type, index, buildOptions) {
    if (!this.workflows[type] || !this.workflows[type][index]) return [];

    return this.workflows[type][index].reduce((tasks, task) => {
      if (~task.indexOf(':')) {
        let conditions = task.split(':');

        task = conditions.pop();
        const passed = conditions.every(condition => {
          return condition.charAt(0) == '!' ? !buildOptions[condition.slice(1)] : buildOptions[condition];
        });

        if (!passed) return tasks;
      }
      tasks.push(task);
      return tasks;
    }, []);
  }

  /**
   * Retrieve flattened dependency tree
   * @returns {Array}
   */
  getAllDependencies() {
    if (this.allDependencies) return this.allDependencies;

    let sorted = [];
    let unsorted = [];

    _libFilejs_walk(this, 'dependencies', file => {
      if (!unsorted.includes(file)) {
        unsorted.push(file);
        return true;
      }
    });

    _libFilejs_sortBy(unsorted, 'depth').reverse().forEach(file => {
      if (!sorted.includes(file)) {
        if (!file.isCircularDependency) {
          _libFilejs_walk(file, 'dependencyReferences', reference => {
            // Keep walking
            return reference.file && !reference.file.isCircularDependency;
          }, reference => {
            // Add reference file after walking it's dependencies
            if (reference.file && !sorted.includes(reference.file)) sorted.push(reference.file);
          });
        }
        sorted.push(file);
      }
    });

    this.allDependencies = sorted;
    return this.allDependencies;
  }

  /**
   * Retrieve flattened helpers
   * @returns {Array}
   */
  getAllHelpers() {
    let helpers = [];

    function add(parent) {
      helpers.push(...parent.helpers);
      // Add children
      parent.dependencies.forEach(dependency => {
        if (parent.id == dependency.owner) {
          add(dependency);
        }
      });
    }

    add(this);

    return _libFilejs_unique(helpers);
  }

  /**
   * Add 'dependencies'
   * @param {Array} dependencies
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   */
  addDependencies(dependencies, buildOptions) {
    if (!Array.isArray(dependencies)) dependencies = [dependencies];

    const { browser = true, ignoredFiles = [], watchOnly = false } = buildOptions;
    const resolveOptions = {
      fileExtensions: this.options.fileExtensions,
      globalAliases: this.options.globalAliases
    };

    // Files with no dependencies can safely be promoted to max depth
    if (!dependencies.length) this.depth = _libFilejs_MAX_DEPTH;

    dependencies.forEach(dependency => {
      // Inlined/sidecar dependencies are pre-resolved
      const filepath = dependency.filepath || _libFilejs_resolve(this.filepath, dependency.id, resolveOptions);

      // Unable to resolve filepath or create instance
      if (filepath === '') {
        _libFilejs_warn(`dependency ${ _libFilejs_strong(dependency.id) } for ${ _libFilejs_strong(this.id) } not found`, 3);
        return;
      }

      this.dependencyReferences.push(dependency);

      // Handle disabled, including native modules (force ignore of node_modules when watch only build)
      if (filepath === false || watchOnly && ~filepath.indexOf('node_modules')) {
        // Don't disable native modules on server
        dependency.isDisabled = browser ? true : !_libFilejs_nativeModules.includes(dependency.id);
        return;
      }

      const file = this.options.fileFactory(filepath, this.options);

      // Identify as inline-source dependency
      file.isInline = 'stack' in dependency;
      dependency.file = file;

      // Ignore if parent file or ignored child file
      if (file.isLocked || ignoredFiles.includes(filepath)) {
        dependency.isIgnored = true;
        return;
      }

      // Handle shared dependency
      if (file.isDependency) {
        // Ignore if already flagged as circular dependency
        if (file.isCircularDependency) return;

        // Promote to higher depth
        if (file.depth < this.depth + 1) file.depth = this.depth + 1;

        // Check for circular dependency (including deeply nested)
        // If 'file' is an ancestor of 'this',
        // we have a circular dependency one or several times removed
        let decendants = _libFilejs_getSharedDecendants(this, file);

        // Files are related (dependency is an ancestor)
        if (decendants.length) {
          // Replace ancestor dependency with current
          decendants[decendants.length - 1] = this;
          // Flag all files from current to ancestor as circular
          decendants.forEach(file => {
            file.isCircularDependency = true;
            file.depth = _libFilejs_MAX_DEPTH;
          });
        }

        return;
      }

      // Handle own dependency
      file.isDependency = true;
      file.depth = this.depth + 1;
      file.parent = this;
      this.dependencies.push(file);
    });
  }

  /**
   * Inline dependencyReferences
   */
  inlineDependencyReferences() {
    function inline(content, references) {
      let inlineContent;

      references.forEach(reference => {
        // Inline nested dependencies
        // Duplicates are allowed (not @import_once)
        inlineContent = reference.file.dependencyReferences.length ? inline(reference.file.content, reference.file.dependencyReferences) : reference.file.content;
        // Replace @import * with inlined content
        if (reference.context) content = content.replace(new RegExp(_libFilejs_regexpEscape(reference.context), 'mg'), inlineContent);
      });
      return content;
    }

    // TODO: remove comments?
    this.content = inline(this.content, this.dependencyReferences);
  }

  /**
   * Run workflow set based on 'type' and 'buildOptions'
   * @param {String} type
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   * @returns {null}
   */
  run(type, buildOptions, fn) {
    if (!this.workflows[type]) return fn();

    const workflows = this.workflows[type].map((workflow, idx) => {
      return _libFilejs_callable(this, 'runWorkflow', type, idx, buildOptions);
    });

    _libFilejs_series(workflows, err => {
      if (err) return fn(err);
      fn();
    });
  }

  /**
   * Run workflow set for 'type' and 'buildOptions' on 'dependencies'
   * @param {String} type
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Array} [dependencies]
   * @param {Function} fn(err)
   */
  runForDependencies(type, buildOptions, dependencies, fn) {
    dependencies = dependencies || [...this.dependencies];
    _libFilejs_parallel(dependencies.map(dependency => {
      return _libFilejs_callable(dependency, 'run', type, buildOptions);
    }), fn);
  }

  /**
   * Run workflow tasks for 'type' and 'index'
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   * @returns {null}
   */
  runWorkflow(type, index, buildOptions, fn) {
    if (this.ran & _libFilejs_WORKFLOWS[type] * (index + 1)) return fn();

    const workflow = this.parseWorkflow(type, index, buildOptions);
    const tasks = workflow.map(task => {
      return task == 'runWorkflowForDependencies' ? _libFilejs_callable(this, task, type, index, buildOptions) : _libFilejs_callable(this, task, buildOptions);
    });

    _libFilejs_series(tasks, err => {
      if (err) return fn(err);
      this.ran |= _libFilejs_WORKFLOWS[type] * (index + 1);
      fn();
    });
  }

  /**
   * Run workflow tasks for 'type' and 'index' on dependencies
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  runWorkflowForDependencies(type, index, buildOptions, fn) {
    _libFilejs_parallel([...this.dependencies].map(dependency => {
      return _libFilejs_callable(dependency, 'runWorkflow', type, index, buildOptions);
    }), fn);
  }

  /**
   * Read and store file contents
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  load(buildOptions, fn) {
    if (!this.fileContent) {
      const content = _libFilejs_readFile(this.filepath, this.encoding);

      this.content = this.fileContent = content;
      this.hash = _libFilejs_md5(content);

      _libFilejs_debug(`load: ${ _libFilejs_strong(this.relpath) }`, 4);
    } else {
      this.content = this.fileContent;
    }

    if (fn) fn();
  }

  /**
   * Parse file contents for dependency references [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  parse(buildOptions, fn) {
    _libFilejs_debug(`parse: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Compile file contents [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  compile(buildOptions, fn) {
    _libFilejs_debug(`compile: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Compress file contents [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  compress(buildOptions, fn) {
    _libFilejs_debug(`compress: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Write file contents to disk
   * @param {String} filepath
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err, results)
   */
  write(filepath, buildOptions, fn) {
    this.run('writeable', buildOptions, err => {
      if (err) return fn(err);

      const relpath = _libFilejs_truncate(_libFilejs_path.relative(process.cwd(), filepath));

      _libFilejs_mkdir(filepath);
      _libFilejs_writeFile(filepath, this.content, 'utf8');

      _libFilejs_print(_libFilejs_chalk.green(`built${ this.options.runtimeOptions.compress ? ' and compressed' : '' } ${ _libFilejs_strong(relpath) }`), 2);

      fn(null, {
        filepath,
        hash: _libFilejs_md5(this.content),
        helpers: this.getAllHelpers(),
        date: Date.now()
      });
    });
  }

  /**
   * Reset content
   * @param {Boolean} hard
   */
  reset(hard) {
    this.allDependencies = null;
    this.isCircularDependency = false;
    this.isDependency = false;
    this.isInline = false;
    this.isLocked = false;
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.depth = 0;
    this.helpers = [];
    this.parent = null;
    this.ran = 0;
    if (!hard) {
      this.content = this.fileContent;
    } else {
      this.content = this.fileContent = '';
    }
    _libFilejs_debug(`reset${ hard ? '(hard):' : ':' } ${ _libFilejs_strong(this.relpath) }`, 4);
  }

  /**
   * Destroy instance
   */
  destroy() {
    this.reset(true);
    this.options = null;
  }
};
/*≠≠ lib/File.js ≠≠*/

/*== lib/config/buildParser.js ==*/
$m['lib/config/buildParser.js'] = { exports: {} };
'use strict';

const { strong: _libconfigbuildParserjs_strong, warn: _libconfigbuildParserjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { indir: _libconfigbuildParserjs_indir, readdir: { sync: _libconfigbuildParserjs_readdir } } = $m['recur-fs/index.js#2.2.3'].exports;
const _libconfigbuildParserjs_filetype = $m['lib/config/filetype.js'].exports;
const _libconfigbuildParserjs_fs = require('fs');
const _libconfigbuildParserjs_glob = $m['glob/glob.js#7.1.0'].exports.sync;
const _libconfigbuildParserjs_match = $m['minimatch/minimatch.js#3.0.3'].exports;
const _libconfigbuildParserjs_path = require('path');
const _libconfigbuildParserjs_pluginLoader = $m['lib/config/pluginLoader.js'].exports;

const _libconfigbuildParserjs_DEPRECATED_VERSION = 'this build format is no longer compatible with newer versions of Buddy. See https://github.com/popeindustries/buddy/blob/master/docs/config.md for help';
const _libconfigbuildParserjs_RE_GLOB = /[\*\[\{]/;

let _libconfigbuildParserjs_numBuildTargets;

$m['lib/config/buildParser.js'].exports = {
  /**
   * Parse and validate build targets of 'config'
   * @param {Object} config
   */
  parse(config) {
    if (!config.build) throw Error('missing build data');
    config.build = _libconfigbuildParserjs_parseBuild(config.build, config.caches, config.fileExtensions, config.fileFactory, config.npmModulepaths, config.runtimeOptions, config.server);
  }
};

/**
 * Parse and validate build targets
 * @param {Object} build
 * @param {Object} caches
 * @param {Object} fileExtensions
 * @param {Function} fileFactory
 * @param {Array} npmModulepaths
 * @param {Object} runtimeOptions
 * @param {Object} server
 * @param {Object} [parent]
 * @returns {Array}
 */
function _libconfigbuildParserjs_parseBuild(build, caches, fileExtensions, fileFactory, npmModulepaths, runtimeOptions, server, parent) {
  if (!parent) _libconfigbuildParserjs_numBuildTargets = 0;
  // Deprecate sources
  if ('sources' in build) {
    _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('sources') } attribute is no longer supported. Use environment variable ${ _libconfigbuildParserjs_strong('NODE_PATH') } instead`, 1);
  }
  // Deprecate targets
  if ('targets' in build) {
    _libconfigbuildParserjs_warn(_libconfigbuildParserjs_DEPRECATED_VERSION);
    build = build.targets;
  }
  // Support basic mode with single build target
  if (!Array.isArray(build)) build = [build];

  return build.reduce((build, buildTarget) => {
    // Deprecate old formats
    if ('js' in buildTarget || 'css' in buildTarget || 'html' in buildTarget || 'targets' in buildTarget) {
      _libconfigbuildParserjs_warn(_libconfigbuildParserjs_DEPRECATED_VERSION);
      return build;
    }
    // Deprecate aliases
    if (buildTarget.alias) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('alias') } attribute is no longer supported. Use package.json ${ _libconfigbuildParserjs_strong('browser') } field instead`, 1);
    // Deprecate modular
    if (buildTarget.modular) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('modular') } attribute has been renamed to ${ _libconfigbuildParserjs_strong('bundle') }`, 1);
    // Deprecate sources
    if (buildTarget.sources) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('sources') } attribute is no longer supported. Use environment variable ${ _libconfigbuildParserjs_strong('NODE_PATH') } instead`, 1);

    if (buildTarget.bootstrap == null) buildTarget.bootstrap = true;
    if (buildTarget.label == null) buildTarget.label = '';
    if (buildTarget.bundle == null || buildTarget.modular) buildTarget.bundle = true;
    buildTarget.hasChildren = false;
    buildTarget.hasParent = !!parent;
    buildTarget.index = ++_libconfigbuildParserjs_numBuildTargets;
    buildTarget.caches = caches;
    buildTarget.runtimeOptions = runtimeOptions;
    buildTarget.watchOnly = !buildTarget.output;
    if (!buildTarget.hasParent) {
      let globalAliases = {};

      if (buildTarget.resolve) {
        globalAliases = buildTarget.resolve;
        delete buildTarget.resolve;
      }

      let pluginOptions = buildTarget.options || {};

      // Generate Babel options based on 'options' and target 'version'
      // Any versions that indicate server as target will return 'false'
      buildTarget.browser = _libconfigbuildParserjs_pluginLoader.loadBuildPlugins(pluginOptions, buildTarget.version);

      let fileFactoryOptions = { caches, fileExtensions, globalAliases, npmModulepaths, pluginOptions, runtimeOptions };

      // Create fileFactory function with memoized options
      fileFactoryOptions.fileFactory = function createFile(filepath) {
        return fileFactory(filepath, fileFactoryOptions);
      };

      buildTarget.fileFactory = fileFactoryOptions.fileFactory;
    } else {
      // options/version only valid for root parent build targets
      if (buildTarget.options || buildTarget.version) _libconfigbuildParserjs_warn("child build targets inherit their root parent 'version' and 'options'");
      buildTarget.browser = parent.browser;
      buildTarget.fileFactory = parent.fileFactory;
    }
    delete buildTarget.options;
    delete buildTarget.version;

    _libconfigbuildParserjs_parseInputOutput(buildTarget, fileExtensions, runtimeOptions);
    // Ignore build targets with nulled input (no grep match)
    if ('input' in buildTarget && buildTarget.input != null) {
      // Flag as app server target
      buildTarget.isAppServer = _libconfigbuildParserjs_isAppServer(buildTarget.inputpaths, server);
      // Store hooks
      if (buildTarget.before) buildTarget.before = _libconfigbuildParserjs_defineHook(buildTarget.before);
      if (buildTarget.afterEach) buildTarget.afterEach = _libconfigbuildParserjs_defineHook(buildTarget.afterEach);
      if (buildTarget.after) buildTarget.after = _libconfigbuildParserjs_defineHook(buildTarget.after);

      // Traverse child build targets
      if (buildTarget.build) {
        buildTarget.hasChildren = true;
        buildTarget.build = _libconfigbuildParserjs_parseBuild(buildTarget.build, caches, fileExtensions, fileFactory, npmModulepaths, runtimeOptions, server, buildTarget);
        _libconfigbuildParserjs_parseChildInputpaths(buildTarget);
      }
      build.push(buildTarget);
    }

    return build;
  }, []);
}

/**
 * Parse input/output path(s) for 'buildTarget'
 * @param {Object} buildTarget
 * @param {Object} fileExtensions
 * @param {Object} runtimeOptions
 */
function _libconfigbuildParserjs_parseInputOutput(buildTarget, fileExtensions, runtimeOptions) {
  let outputs, outputIsDirectory;

  // Parse output
  if (buildTarget.output) {
    outputs = buildTarget.output;

    if (!Array.isArray(outputs)) outputs = [outputs];

    // Use compressed if specified
    if (runtimeOptions.compress && 'output_compressed' in buildTarget) {
      let outputsCompressed = buildTarget.output_compressed;

      if (!Array.isArray(outputsCompressed)) outputsCompressed = [outputsCompressed];
      if (outputsCompressed.length != outputs.length) {
        throw Error(`total number of outputs (${ _libconfigbuildParserjs_strong(buildTarget.output) }) do not match total number of compressed outputs (${ _libconfigbuildParserjs_strong(buildTarget.output_compressed) })`);
      }
      outputs = outputsCompressed;
      buildTarget.output = buildTarget.output_compressed;
    }

    outputIsDirectory = outputs.length == 1 && !_libconfigbuildParserjs_path.extname(outputs[0]).length;
  } else {
    buildTarget.outputpaths = [];
  }

  // Parse input
  if (buildTarget.input) {
    let allFileExtensions = [];
    let inputs = buildTarget.input;
    let inputsRelative = [];

    // Gather all extensions to allow for easier filtering
    for (const type in fileExtensions) {
      allFileExtensions.push(...fileExtensions[type]);
    }

    if (!Array.isArray(inputs)) inputs = [inputs];

    buildTarget.inputpaths = inputs.reduce((inputs, input) => {
      // Expand glob pattern
      if (_libconfigbuildParserjs_RE_GLOB.test(input)) {
        inputs = inputs.concat(_libconfigbuildParserjs_glob(input, { matchBase: true }));
      } else {
        inputs.push(input);
      }
      return inputs;
    }, []).reduce((inputs, input) => {
      input = _libconfigbuildParserjs_path.resolve(input);
      // Expand directory
      if (!_libconfigbuildParserjs_path.extname(input).length) {
        // Batch mode will change output behaviour if dir -> dir
        buildTarget.batch = true;
        inputs = inputs.concat(_libconfigbuildParserjs_readdir(input, (resource, stat) => {
          const isFile = stat.isFile();

          // Capture relative path for dir -> dir
          if (isFile) inputsRelative.push(_libconfigbuildParserjs_path.relative(input, resource));
          return isFile;
        }));
      } else {
        inputs.push(input);
        inputsRelative.push(_libconfigbuildParserjs_path.basename(input));
      }
      return inputs;
    }, []).filter((input, idx) => {
      const extension = _libconfigbuildParserjs_path.extname(input).slice(1);
      let include = true;

      // Include/exclude if grepping
      if (runtimeOptions.grep) {
        include = buildTarget.label == runtimeOptions.grep || _libconfigbuildParserjs_match(input, runtimeOptions.grep, { matchBase: true });
        if (runtimeOptions.invert) include = !include;
      }
      // Exclude unknown files
      if (!allFileExtensions.includes(extension)) {
        include = false;
      }

      if (!include) inputsRelative.splice(idx, 1);
      return include;
    }).map(input => {
      const inputpath = _libconfigbuildParserjs_path.resolve(input);
      if (!_libconfigbuildParserjs_fs.existsSync(inputpath)) _libconfigbuildParserjs_warn(_libconfigbuildParserjs_strong(input) + ' doesn\'t exist', 1);
      return inputpath;
    });

    if (!buildTarget.inputpaths.length) {
      buildTarget.input = null;
      buildTarget.inputpaths = null;
      return;
    }

    if (outputs) {
      if (buildTarget.inputpaths.length != outputs.length && !outputIsDirectory) {
        throw Error(`unable to resolve inputs (${ _libconfigbuildParserjs_strong(buildTarget.input) }) with outputs (${ _libconfigbuildParserjs_strong(buildTarget[runtimeOptions.compress ? 'output_compressed' : 'output']) })`);
      }

      buildTarget.outputpaths = buildTarget.inputpaths.map((inputpath, idx) => {
        let outputpath = '';

        if (outputIsDirectory) {
          // Preserve relative paths when batching
          outputpath = _libconfigbuildParserjs_path.join(_libconfigbuildParserjs_path.resolve(outputs[0]), inputsRelative[idx]);
        } else {
          outputpath = _libconfigbuildParserjs_path.resolve(outputs[idx]);
        }

        const extension = _libconfigbuildParserjs_path.extname(outputpath);
        const type = _libconfigbuildParserjs_filetype(inputpath, fileExtensions);

        // Resolve missing extension
        if (!extension) outputpath += `.${ type }`;
        if (type != 'image' && extension != `.${ type }`) outputpath = outputpath.replace(extension, `.${ type }`);

        return outputpath;
      });
    }
  }
}

/**
 * Parse nested child input paths
 * @param {Object} buildTarget
 */
function _libconfigbuildParserjs_parseChildInputpaths(buildTarget) {
  function parse(build) {
    let inputpaths = [];

    build.forEach(buildTarget => {
      inputpaths = inputpaths.concat(buildTarget.inputpaths, buildTarget.build ? parse(buildTarget.build) : []);
    });

    return inputpaths;
  }

  buildTarget.childInputpaths = parse(buildTarget.build);
}

/**
 * Determine if 'inputpaths' contain server file
 * @param {Array} inputpaths
 * @param {Object} server
 * @returns {Boolean}
 */
function _libconfigbuildParserjs_isAppServer(inputpaths, server) {
  // Test if 'p' is in 'dirs'
  function contains(dirs, p) {
    if (!Array.isArray(dirs)) dirs = [dirs];
    return dirs.some(dir => {
      return _libconfigbuildParserjs_indir(dir, p);
    });
  }

  return server != undefined && server.file != undefined && contains(inputpaths, _libconfigbuildParserjs_path.resolve(server.file));
}

/**
 * Convert hook path or expression to Function
 * @param {String} hook
 * @returns {Function}
 */
function _libconfigbuildParserjs_defineHook(hook) {
  // Load file content if filepath
  if (_libconfigbuildParserjs_path.extname(hook) && (~hook.indexOf('/') || ~hook.indexOf(_libconfigbuildParserjs_path.sep))) {
    let hookpath;

    if (_libconfigbuildParserjs_fs.existsSync(hookpath = _libconfigbuildParserjs_path.resolve(hook))) {
      hook = _libconfigbuildParserjs_fs.readFileSync(hookpath, 'utf8');
    } else {
      throw Error('hook (' + _libconfigbuildParserjs_strong(hook) + ') isn\'t a valid path');
    }
  }

  return new Function('global', 'process', 'console', 'require', 'context', 'options', 'done', hook);
}
/*≠≠ lib/config/buildParser.js ≠≠*/

/*== node_modules/async/waterfall.js ==*/
$m['async/waterfall.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/waterfall.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/waterfall.js#2.0.1'].exports.default = function (tasks, callback) {
    callback = (0, _asyncwaterfalljs201__once2.default)(callback || _asyncwaterfalljs201__noop2.default);
    if (!(0, _asyncwaterfalljs201__isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        if (taskIndex === tasks.length) {
            return callback.apply(null, [null].concat(args));
        }

        var taskCallback = (0, _asyncwaterfalljs201__onlyOnce2.default)((0, _asyncwaterfalljs201__rest2.default)(function (err, args) {
            if (err) {
                return callback.apply(null, [err].concat(args));
            }
            nextTask(args);
        }));

        args.push(taskCallback);

        var task = tasks[taskIndex++];
        task.apply(null, args);
    }

    nextTask([]);
};

var _asyncwaterfalljs201__isArray = $m['lodash/isArray.js#4.16.2'].exports;

var _asyncwaterfalljs201__isArray2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__isArray);

var _asyncwaterfalljs201__noop = $m['lodash/noop.js#4.16.2'].exports;

var _asyncwaterfalljs201__noop2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__noop);

var _asyncwaterfalljs201__once = $m['async/internal/once.js#2.0.1'].exports;

var _asyncwaterfalljs201__once2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__once);

var _asyncwaterfalljs201__rest = $m['lodash/rest.js#4.16.2'].exports;

var _asyncwaterfalljs201__rest2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__rest);

var _asyncwaterfalljs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asyncwaterfalljs201__onlyOnce2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__onlyOnce);

function _asyncwaterfalljs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

$m['async/waterfall.js#2.0.1'].exports = $m['async/waterfall.js#2.0.1'].exports['default'];

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of functions to run, each function is passed
 * a `callback(err, result1, result2, ...)` it must call on completion. The
 * first argument is an error (which can be `null`) and any further arguments
 * will be passed as arguments in order to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
/*≠≠ node_modules/async/waterfall.js ≠≠*/

/*== lib/utils/uniqueFilepath.js ==*/
$m['lib/utils/uniqueFilepath.js'] = { exports: {} };
'use strict';

const { regexpEscape: _libutilsuniqueFilepathjs_regexpEscape } = $m['lib/utils/string.js'].exports;
const _libutilsuniqueFilepathjs_fs = require('fs');
const _libutilsuniqueFilepathjs_md5 = $m['md5/md5.js#2.2.1'].exports;
const _libutilsuniqueFilepathjs_path = require('path');

const _libutilsuniqueFilepathjs_RE_HASH_TOKEN = /%hash%/;
const _libutilsuniqueFilepathjs_RE_TOKEN = /%(?:hash|date)%/;

$m['lib/utils/uniqueFilepath.js'].exports = {
  /**
   * Find file matching 'pattern'
   * @param {String} pattern
   * @returns {String}
   */
  findFile(pattern) {
    pattern = _libutilsuniqueFilepathjs_path.resolve(pattern);

    // Limit scope to containing directory
    const dir = _libutilsuniqueFilepathjs_path.dirname(pattern);
    let files, reToken;

    // Matches {hash} or {date}
    if (reToken = _libutilsuniqueFilepathjs_RE_TOKEN.exec(pattern)) {
      try {
        files = _libutilsuniqueFilepathjs_fs.readdirSync(dir);
      } catch (err) {
        // Directory doesn't exist
        return '';
      }

      // Generate regexp with pattern as wildcard
      const re = new RegExp(_libutilsuniqueFilepathjs_regexpEscape(pattern).replace(reToken[0], _libutilsuniqueFilepathjs_RE_HASH_TOKEN.test(pattern) ? '[a-f0-9]{32}' : '[0-9]{13,}'));

      for (let i = 0, n = files.length; i < n; i++) {
        const filepath = _libutilsuniqueFilepathjs_path.resolve(dir, files[i]);

        if (re.test(filepath)) return filepath;
      }
    }

    return '';
  },

  /**
   * Generate unique filepath from 'pattern'
   * @param {String} pattern
   * @param {String|Boolean} content
   * @returns {String}
   */
  generate(pattern, content) {
    pattern = _libutilsuniqueFilepathjs_path.resolve(pattern);

    let reToken, wildcard;

    if (reToken = _libutilsuniqueFilepathjs_RE_TOKEN.exec(pattern)) {
      wildcard = reToken[0];
      if (wildcard == '%hash%') {
        // Remove if content == false
        pattern = pattern.replace(wildcard, content ? _libutilsuniqueFilepathjs_md5(content) : '');
      } else if (wildcard == '%date%') {
        pattern = pattern.replace(wildcard, content ? Date.now() : '');
      }
    }

    return pattern;
  },

  /**
   * Determine whether 'pattern' is supported
   * @param {String} pattern
   * @returns {Boolean}
   */
  isUniquePattern(pattern) {
    return _libutilsuniqueFilepathjs_RE_TOKEN.test(pattern);
  }
};
/*≠≠ lib/utils/uniqueFilepath.js ≠≠*/

/*== lib/utils/pathname.js ==*/
$m['lib/utils/pathname.js'] = { exports: {} };
'use strict';

const _libutilspathnamejs_path = require('path');

/**
 * Retrieve path name (dirname/filename) of 'p'
 * @param {String} p
 * @returns {String}
 */
$m['lib/utils/pathname.js'].exports = function pathname(p) {
  p = _libutilspathnamejs_path.resolve(p);

  let dir = _libutilspathnamejs_path.resolve(p, '..');

  if (dir == process.cwd()) dir = '.';

  return `${ _libutilspathnamejs_path.basename(dir) }/${ _libutilspathnamejs_path.basename(p) }`;
};
/*≠≠ lib/utils/pathname.js ≠≠*/

/*== node_modules/lodash/merge.js ==*/
$m['lodash/merge.js#4.16.2'] = { exports: {} };
var _lodashmergejs4162_baseMerge = $m['lodash/_baseMerge.js#4.16.2'].exports,
    _lodashmergejs4162_createAssigner = $m['lodash/_createAssigner.js#4.16.2'].exports;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var _lodashmergejs4162_merge = _lodashmergejs4162_createAssigner(function (object, source, srcIndex) {
  _lodashmergejs4162_baseMerge(object, source, srcIndex);
});

$m['lodash/merge.js#4.16.2'].exports = _lodashmergejs4162_merge;
/*≠≠ node_modules/lodash/merge.js ≠≠*/

/*== lib/config/index.js ==*/
$m['lib/config/index.js'] = { exports: {} };
'use strict';

const { error: _libconfigindexjs_error, print: _libconfigindexjs_print, strong: _libconfigindexjs_strong, warn: _libconfigindexjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { hunt: { sync: _libconfigindexjs_hunt } } = $m['recur-fs/index.js#2.2.3'].exports;
const { identify: _libconfigindexjs_identify } = $m['lib/dependency-resolver/index.js'].exports;
const _libconfigindexjs_buildParser = $m['lib/config/buildParser.js'].exports;
const _libconfigindexjs_dependencyResolverCache = $m['lib/dependency-resolver/cache.js'].exports;
const _libconfigindexjs_File = $m['lib/File.js'].exports;
const _libconfigindexjs_fileCache = $m['lib/config/fileCache.js'].exports;
const _libconfigindexjs_fs = require('fs');
const _libconfigindexjs_merge = $m['lodash/merge.js#4.16.2'].exports;
const _libconfigindexjs_path = require('path');
const _libconfigindexjs_pluginLoader = $m['lib/config/pluginLoader.js'].exports;
const _libconfigindexjs_utils = $m['lib/utils/index.js'].exports;

const _libconfigindexjs_DEFAULT_MANIFEST = {
  js: 'buddy.js',
  json: 'buddy.json',
  pkgjson: 'package.json'
};

/**
 * Retrieve new instance of Config
 * @param {String|Object} [configpath]
 * @param {Object} [runtimeOptions]
 * @returns {Config}
 */
$m['lib/config/index.js'].exports = function configFactory(configpath, runtimeOptions) {
  return new _libconfigindexjs_Config(configpath, runtimeOptions);
};

class _libconfigindexjs_Config {
  /**
   * Constructor
   * @param {String|Object} [configpath]
   * @param {Object} [runtimeOptions]
   */
  constructor(configpath, runtimeOptions) {
    let data;

    if ('string' == typeof configpath || configpath == null) {
      this.url = _libconfigindexjs_locateConfig(configpath);
      data = require(this.url);

      // Set current directory to location of file
      process.chdir(_libconfigindexjs_path.dirname(this.url));
      _libconfigindexjs_print('loaded config ' + _libconfigindexjs_strong(this.url), 0);

      // Passed in JSON object
    } else {
      this.url = '';
      data = configpath;
    }
    // Package.json
    if (data.buddy) data = data.buddy;
    // Handle super simple mode
    if (data.input) data = { build: [data] };

    this.build = [];
    this.fileDefinitionByExtension = {};
    this.fileExtensions = {};
    this.npmModulepaths = _libconfigindexjs_parseNpmModulepaths();
    this.runtimeOptions = _libconfigindexjs_merge({
      compress: false,
      deploy: false,
      grep: false,
      invert: false,
      reload: false,
      script: false,
      serve: false,
      watch: false,
      verbose: false
    }, runtimeOptions);
    this.script = '';
    this.server = {
      directory: '.',
      port: 8080
    };
    this.caches = {
      fileInstances: _libconfigindexjs_fileCache(this.runtimeOptions.watch),
      dependencyResolver: _libconfigindexjs_dependencyResolverCache,
      clear: _libconfigindexjs_dependencyResolverCache.clear
    };
    this.fileFactory = this.fileFactory.bind(this);

    // Merge config file data
    _libconfigindexjs_merge(this, data);

    // Load default/installed plugins
    // Generates fileExtensions/types used to validate build
    _libconfigindexjs_pluginLoader.loadPluginModules(this, _libconfigindexjs_parsePlugins(this));
    // Parse build data
    _libconfigindexjs_buildParser.parse(this);
  }

  /**
   * Retrieve File instance for 'filepath'
   * @param {String} filepath
   * @param {Object} options
   *  - {Object} caches
   *  - {Object} fileExtensions
   *  - {Function} fileFactory
   *  - {Object} globalAliases
   *  - {Array} npmModulepaths
   *  - {Object} pluginOptions
   *  - {Object} runtimeOptions
   * @returns {File}
   */
  fileFactory(filepath, options) {
    const { caches, fileExtensions, globalAliases } = options;

    // Retrieve cached
    if (caches.fileInstances.hasFile(filepath)) return caches.fileInstances.getFile(filepath);

    const extension = _libconfigindexjs_path.extname(filepath).slice(1);
    const id = _libconfigindexjs_identify(filepath, { fileExtensions, globalAliases });
    const ctor = this.fileDefinitionByExtension[extension];

    if (!id) throw Error(`unable to create file for: ${ _libconfigindexjs_strong(filepath) }`);

    const file = new ctor(id, filepath, options);

    caches.fileInstances.addFile(file);
    // Warn of multiple versions
    if (caches.dependencyResolver.hasMultipleVersions(id)) {
      _libconfigindexjs_warn(`more than one version of ${ _libconfigindexjs_strong(id.split('#')[0]) } exists (${ _libconfigindexjs_strong(file.relpath) })`, 2);
    }

    return file;
  }

  /**
   * Register file 'extensions' for 'type'
   * @param {Array} extensions
   * @param {String} type
   */
  registerFileExtensionsForType(extensions, type) {
    if (!this.fileExtensions[type]) this.fileExtensions[type] = [];
    this.fileExtensions[type].push(...extensions);
  }

  /**
   * Register target 'version' for 'type'
   * @param {String} version
   * @param {Array} plugins
   * @param {String} type
   */
  registerTargetVersionForType(version, plugins, type) {
    if (type == 'js') {
      _libconfigindexjs_pluginLoader.addPreset('babel', version, plugins);
    }
  }

  /**
   * Register file definitiion and 'extensions' for 'type'
   * @param {Function} define
   * @param {Array} extensions
   * @param {String} type
   */
  registerFileDefinitionAndExtensionsForType(define, extensions, type) {
    const def = define(this.fileDefinitionByExtension[type] || _libconfigindexjs_File, _libconfigindexjs_utils);

    if (extensions) {
      this.registerFileExtensionsForType(extensions, type);
      extensions.forEach(extension => {
        this.fileDefinitionByExtension[extension] = def;
      });
    }
  }

  /**
   * Extend file definitiion for 'extensions' or 'type'
   * @param {Function} extend
   * @param {Array} extensions
   * @param {String} type
   * @returns {null}
   */
  extendFileDefinitionForExtensionsOrType(extend, extensions, type) {
    const key = extensions ? extensions[0] : this.fileExtensions[type][0];
    const def = this.fileDefinitionByExtension[key];

    if (!def) return _libconfigindexjs_error(`no File type available for extension for ${ _libconfigindexjs_strong(key) }`);

    extend(def.prototype, _libconfigindexjs_utils);
  }

  /**
   * Destroy instance
   */
  destroy() {
    this.caches.fileInstances.flush();
    this.caches.dependencyResolver.clear();
  }
}

/**
 * Locate the configuration file
 * Walks the directory tree if no file/directory specified
 * @param {String} [url]
 * @returns {String}
 */
function _libconfigindexjs_locateConfig(url) {
  let configpath = '';

  function check(dir) {
    // Support js, json, and package.json
    const urljs = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.js);
    const urljson = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.json);
    const urlpkgjson = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.pkgjson);
    let urlFinal;

    if (_libconfigindexjs_fs.existsSync(urlFinal = urljs) || _libconfigindexjs_fs.existsSync(urlFinal = urljson) || _libconfigindexjs_fs.existsSync(urlFinal = urlpkgjson)) {
      return urlFinal;
    }

    return '';
  }

  if (url) {
    configpath = _libconfigindexjs_path.resolve(url);
    try {
      // Try default file name if passed directory
      if (!_libconfigindexjs_path.extname(configpath).length || _libconfigindexjs_fs.statSync(configpath).isDirectory()) {
        configpath = check(configpath);
        if (!configpath) throw Error('no default found');
      }
    } catch (err) {
      throw Error(_libconfigindexjs_strong('buddy') + ' config not found in ' + _libconfigindexjs_strong(_libconfigindexjs_path.dirname(url)));
    }

    // No url specified
  } else {
    try {
      // Find the first instance of a DEFAULT file based on the current working directory
      configpath = _libconfigindexjs_hunt(process.cwd(), (resource, stat) => {
        if (stat.isFile()) {
          const basename = _libconfigindexjs_path.basename(resource);

          return basename == _libconfigindexjs_DEFAULT_MANIFEST.js || basename == _libconfigindexjs_DEFAULT_MANIFEST.json || basename == _libconfigindexjs_DEFAULT_MANIFEST.pkgjson;
        }
      }, true);
    } catch (err) {
      if (!configpath) throw Error(_libconfigindexjs_strong('buddy') + ' config not found');
    }
  }

  return configpath;
}

/**
 * Parse plugins defined in 'config'
 * @param {Config} config
 * @returns {Array}
 */
function _libconfigindexjs_parsePlugins(config) {
  let plugins = [];

  function parse(plugins) {
    return plugins.map(plugin => {
      if ('string' == typeof plugin) plugin = _libconfigindexjs_path.resolve(plugin);
      return plugin;
    });
  }

  // Handle plugin paths defined in config file
  if (config.plugins) {
    plugins.push(...parse(config.plugins));
    delete config.plugins;
  }
  // Handle plugin paths/functions defined in runtime options
  if (config.runtimeOptions.plugins) {
    plugins.push(...parse(config.runtimeOptions.plugins));
    delete config.runtimeOptions.plugins;
  }

  return plugins;
}

/**
 * Parse all npm package paths
 * @returns {Array}
 */
function _libconfigindexjs_parseNpmModulepaths() {
  const jsonpath = _libconfigindexjs_path.resolve('package.json');

  try {
    const json = require(jsonpath);

    return ['dependencies', 'devDependencies', 'optionalDependencies'].reduce((packages, type) => {
      if (type in json) {
        for (const dependency in json[type]) {
          packages.push(_libconfigindexjs_path.resolve('node_modules', dependency));
        }
      }
      return packages;
    }, []);
  } catch (err) {
    return [];
  }
}
/*≠≠ lib/config/index.js ≠≠*/

/*== lib/build.js ==*/
$m['lib/build.js'] = { exports: {} };
'use strict';

const { debug: _libbuildjs_debug, print: _libbuildjs_print, start: _libbuildjs_start, stop: _libbuildjs_stop, strong: _libbuildjs_strong, warn: _libbuildjs_warn } = $m['lib/utils/cnsl.js'].exports;
const _libbuildjs_callable = $m['lib/utils/callable.js'].exports;
const _libbuildjs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libbuildjs_env = $m['lib/utils/env.js'].exports;
const _libbuildjs_flatten = $m['lodash/flatten.js#4.16.2'].exports;
const _libbuildjs_fs = require('fs');
const _libbuildjs_merge = $m['lodash/merge.js#4.16.2'].exports;
const _libbuildjs_parallel = $m['async/parallel.js#2.0.1'].exports;
const _libbuildjs_pathname = $m['lib/utils/pathname.js'].exports;
const _libbuildjs_series = $m['async/series.js#2.0.1'].exports;
const _libbuildjs_uniqueFilepath = $m['lib/utils/uniqueFilepath.js'].exports;
const _libbuildjs_waterfall = $m['async/waterfall.js#2.0.1'].exports;

const _libbuildjs_MAX_INPUT_STRING_LENGTH = 3;

/**
 * Build instance factory
 * @param {Object} props
 *  - {Boolean} bootstrap
 *  - {Object} build
 *  - {Boolean} bundle
 *  - {Object} caches
 *  - {Array} childInputpaths
 *  - {Function} fileFactory
 *  - {Boolean} hasChildren
 *  - {Boolean} hasParent
 *  - {Number} index
 *  - {String} input
 *  - {Array} inputpaths
 *  - {Boolean} isAppServer
 *  - {String} label
 *  - {String} output
 *  - {Array} outputpaths
 *  - {Object} runtimeOptions
 *  - {Boolean} watchOnly
 *  - {Boolean} writeableFilterFlag
 * @returns {Build}
 */
$m['lib/build.js'].exports = function buildFactory(props) {
  return new _libbuildjs_Build(props);
};

class _libbuildjs_Build {
  /**
   * Constructor
   * @param {Object} props
   *  - {Boolean} bootstrap
   *  - {Boolean} browser
   *  - {Object} build
   *  - {Boolean} bundle
   *  - {Object} caches
   *  - {Array} childInputpaths
   *  - {Function} fileFactory
   *  - {Boolean} hasChildren
   *  - {Boolean} hasParent
   *  - {Number} index
   *  - {String} input
   *  - {Array} inputpaths
   *  - {Boolean} isAppServer
   *  - {String} label
   *  - {String} output
   *  - {Array} outputpaths
   *  - {Object} runtimeOptions
   *  - {Boolean} watchOnly
   *  - {Boolean} writeableFilterFlag
   */
  constructor(props) {
    _libbuildjs_merge(this, props);
    this.id = this.label || this.index != null && this.index.toString();
    this.referencedFiles = [];
    this.processFilesOptions = {
      batch: !this.bundle && this.batch,
      // TODO: should only parent include?
      boilerplate: true,
      bootstrap: this.bootstrap,
      browser: this.browser,
      bundle: this.bundle,
      compress: this.runtimeOptions.compress,
      // TODO: include in child if watching?
      helpers: !this.hasParent && this.bundle,
      ignoredFiles: this.childInputpaths,
      watchOnly: this.watchOnly
    };

    // Handle printing long input arrays
    if (this.inputpaths.length > 1) {
      this.inputString = this.inputpaths.map(input => {
        return _libbuildjs_pathname(input);
      });
      // Trim long lists
      if (this.inputString.length > _libbuildjs_MAX_INPUT_STRING_LENGTH) {
        const remainder = this.inputString.length - _libbuildjs_MAX_INPUT_STRING_LENGTH;

        this.inputString = `${ this.inputString.slice(0, _libbuildjs_MAX_INPUT_STRING_LENGTH).join(', ') } ...and ${ remainder } other${ remainder > 1 ? 's' : '' }`;
      } else {
        this.inputString = this.inputString.join(', ');
      }
    } else {
      this.inputString = _libbuildjs_pathname(this.inputpaths[0]);
    }

    _libbuildjs_debug(`created Build instance with input: ${ _libbuildjs_strong(this.inputString) } and output: ${ _libbuildjs_strong(this.output) }`, 2);
  }

  /**
   * Run build
   * @param {Function} fn(err, results)
   * @returns {null}
   */
  run(fn) {
    // Skip if watch only and not running a watch build
    if (this.watchOnly && !this.runtimeOptions.watch) return fn();

    const timerID = this.inputpaths[0];
    const type = this.watchOnly && this.runtimeOptions.watch ? 'watching' : 'building';

    this.referencedFiles = [];

    _libbuildjs_start(timerID);

    _libbuildjs_print(`${ type } ${ _libbuildjs_strong(this.inputString) } ${ this.output ? 'to ' + _libbuildjs_strong(this.output) : '' }`, 1);

    _libbuildjs_waterfall([
    // Execute 'before' hook
    _libbuildjs_callable(this, 'executeHook', 'before', [this], this.inputpaths),
    // Init file instances
    _libbuildjs_callable(this, 'initFiles' /* , filepaths */),
    // Process files
    _libbuildjs_callable(this, 'processFiles' /* , files */),
    // Print
    _libbuildjs_callable(this, 'printProgress', timerID /* , referencedFiles */),
    // Execute 'afterEach' hooks
    _libbuildjs_callable(this, 'executeHook', 'afterEach' /* , referencedFiles */),
    // Build child targets
    _libbuildjs_callable(this, 'runChildren' /* , referencedFiles */),
    // Write files
    _libbuildjs_callable(this, 'writeFiles' /* , referencedFiles, childResults */),
    // Execute 'after' hook
    _libbuildjs_callable(this, 'executeHook', 'after', [this] /* , results */),
    // Reset
    _libbuildjs_callable(this, 'reset' /* , results */)], fn);
  }

  /**
   * Parse source 'filepaths'
   * @param {Array} filepaths
   * @param {Function} fn(err, files)
   */
  initFiles(filepaths, fn) {
    fn(null, filepaths.reduce((files, filepath) => {
      const file = this.fileFactory(filepath, this.fileFactoryOptions);

      if (!file) {
        _libbuildjs_warn(`${ _libbuildjs_strong(filepath) } not found in project source`, 4);
      } else {
        files.push(file);
      }
      return files;
    }, []));
  }

  /**
   * Process 'files'
   * @param {Array} files
   * @param {Function} fn(err, files)
   */
  processFiles(files, fn) {
    _libbuildjs_env('INPUT', files, this.id);
    _libbuildjs_env('INPUT_HASH', files, this.id);
    _libbuildjs_env('INPUT_DATE', files, this.id);

    _libbuildjs_parallel(files.map(file => _libbuildjs_callable(file, 'run', 'standard', this.processFilesOptions)), err => {
      if (err) return fn(err);
      this.referencedFiles = files.reduce((referencedFiles, file) => {
        referencedFiles.push(file);
        file.getAllDependencies().forEach(dependency => {
          if (!referencedFiles.includes(dependency)) referencedFiles.push(dependency);
        });
        return referencedFiles;
      }, []);
      fn(null, this.referencedFiles);
    });
  }

  /**
   * Print progress
   * @param {String} timerID
   * @param {Array} files
   * @param {Function} fn(err, files)
   */
  printProgress(timerID, files, fn) {
    _libbuildjs_print('[processed ' + _libbuildjs_strong(files.length) + (files.length > 1 ? ' files' : ' file') + ' in ' + _libbuildjs_chalk.cyan(_libbuildjs_stop(timerID) + 'ms') + ']', 2);
    fn(null, files);
  }

  /**
   * Run child builds
   * @param {Array} files
   * @param {Function} fn(err, files, childResults)
   * @returns {null}
   */
  runChildren(files, fn) {
    if (!this.hasChildren) return fn(null, files, []);

    // Lock files to prevent inclusion in downstream targets
    this.lock(this.referencedFiles);
    _libbuildjs_series(this.build.map(build => _libbuildjs_callable(build, 'build')), (err, results) => {
      if (err) return fn(err);

      this.unlock(this.referencedFiles);
      fn(files, _libbuildjs_flatten(results || []));
    });
  }

  /**
   * Write content for 'files'
   * @param {Array} files
   * @param {Array} childResults
   * @param {Function} fn(err, results)
   */
  writeFiles(files, childResults, fn) {
    const writeable = files.filter(file => file.isWriteable(this.processFilesOptions.batch)).reduce((writeable, file) => {
      let filepath = '';

      for (let i = 0, n = this.inputpaths.length; i < n; i++) {
        if (this.inputpaths[i] == file.filepath) {
          filepath = this.outputpaths[i];
          break;
        }
      }

      // Don't write if no output path
      if (filepath) {
        // Handle generating unique paths
        if (_libbuildjs_uniqueFilepath.isUniquePattern(filepath)) {
          // Remove existing
          const existing = _libbuildjs_uniqueFilepath.findFile(filepath);

          if (existing && _libbuildjs_fs.existsSync(existing)) _libbuildjs_fs.unlinkSync(existing);

          // Generate unique path
          // Disable during watch otherwise css reloading won't work
          filepath = _libbuildjs_uniqueFilepath.generate(filepath, !this.runtimeOptions.watch ? file.content : false);
        }

        writeable.push(_libbuildjs_callable(file, 'write', filepath, this.processFilesOptions));
      }

      return writeable;
    }, []);

    // Results are [{ filepath, hash, date, helpers }]
    _libbuildjs_parallel(writeable, (err, results) => {
      if (err) return fn(err);

      _libbuildjs_env('OUTPUT', results.map(item => item.filepath), this.id);
      _libbuildjs_env('OUTPUT_HASH', results.map(item => item.hash), this.id);
      _libbuildjs_env('OUTPUT_DATE', results.map(item => item.date), this.id);

      fn(null, results.concat(childResults));
    });
  }

  /**
   * Reset referenced files
   * @param {Array} results
   * @param {Array} fn(err, results)
   */
  reset(results, fn) {
    this.referencedFiles.forEach(file => file.reset());
    this.caches.clear();
    fn(null, results);
  }

  /**
   * Set lock flag for 'files'
   * @param {Array} files
   */
  lock(files) {
    files.forEach(file => {
      file.isLocked = true;
    });
  }

  /**
   * Unset lock flag for 'files'
   * @param {Array} files
   */
  unlock(files) {
    files.forEach(file => {
      file.isLocked = false;
    });
  }

  /**
   * Determine if 'file' is a referenced file (child targets included)
   * @param {File} file
   * @returns {Boolean}
   */
  hasFile(file) {
    if (this.referencedFiles.includes(file)) return true;

    if (this.hasChildren) {
      for (let i = 0, n = this.build.length; i < n; i++) {
        if (this.build[i].hasFile(file)) return true;
      }
    }

    return false;
  }

  /**
   * Execute the 'hook' function for 'contexts'
   * @param {String} hook
   * @param {Array} contexts
   * @param {Object} [passthrough]
   * @param {Function} fn(err)
   * @returns {null}
   */
  executeHook(hook, contexts, passthrough, fn) {
    // Handle missing passthrough value
    if (!fn && 'function' == typeof passthrough) {
      fn = passthrough;
      passthrough = contexts;
    }
    if (!this[hook]) return fn(null, passthrough);

    _libbuildjs_print('executing ' + hook + ' hook...', 2);
    _libbuildjs_parallel(contexts.map(context => {
      // Make global objects available to the function
      return _libbuildjs_callable(this, hook, global, process, console, require, context, this.runtimeOptions);
    }), err => {
      fn(err, passthrough);
    });
  }
}
/*≠≠ lib/build.js ≠≠*/

/*== lib/buddy.js ==*/
$m['lib/buddy.js'] = { exports: {} };
'use strict';

const { spawn: _libbuddyjs_spawn } = require('child_process');
const _libbuddyjs_buildFactory = $m['lib/build.js'].exports;
const _libbuddyjs_callable = $m['lib/utils/callable.js'].exports;
const _libbuddyjs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libbuddyjs_cnsl = $m['lib/utils/cnsl.js'].exports;
const _libbuddyjs_compact = $m['lodash/compact.js#4.16.2'].exports;
const _libbuddyjs_configFactory = $m['lib/config/index.js'].exports;
const _libbuddyjs_flatten = $m['lodash/flatten.js#4.16.2'].exports;
const _libbuddyjs_path = require('path');
const _libbuddyjs_series = $m['async/series.js#2.0.1'].exports;

const { BELL: _libbuddyjs_BELL, debug: _libbuddyjs_debug, error: _libbuddyjs_error, print: _libbuddyjs_print, start: _libbuddyjs_start, stop: _libbuddyjs_stop, strong: _libbuddyjs_strong } = _libbuddyjs_cnsl;
let _libbuddyjs_serverfarm = null;

/**
 * Buddy instance factory
 * @param {String|Object} configpath [file name | JSON Object]
 * @param {Object} options
 * @returns {Buddy}
 */
module.exports = function buddyFactory(configpath, options) {
  return new _libbuddyjs_Buddy(configpath, options);
};

class _libbuddyjs_Buddy {
  /**
   * Constructor
   * Initialize based on configuration located at 'configpath'
   * The directory tree will be walked if no 'configpath' specified
   * @param {String|Object} configpath [file name | JSON Object]
   * @param {Object} runtimeOptions
   */
  constructor(configpath, runtimeOptions = {}) {
    // Set console behaviour
    _libbuddyjs_cnsl.verbose = runtimeOptions.verbose;

    this.building = false;
    this.config = _libbuddyjs_configFactory(configpath, runtimeOptions);
    this.onFileCacheChange = this.onFileCacheChange.bind(this);

    // Setup watch
    if (this.config.runtimeOptions.watch) {
      this.config.caches.fileInstances.on('change', this.onFileCacheChange);
      // TODO: add error listener
    }

    // Initialize builds
    this.builds = this.initBuilds(this.config);
  }

  /**
   * Build sources based on build targets specified in config
   * @param {Function} fn
   */
  build(fn) {
    _libbuddyjs_start('build');

    // Build targets
    this.run(this.builds, (err, results) => {
      if (err) return fn ? fn(err) : _libbuddyjs_error(err, 2);
      _libbuddyjs_print(`completed build in ${ _libbuddyjs_chalk.cyan(_libbuddyjs_stop('build') / 1000 + 's') }`, 1);
      // Run script
      this.executeScript();
      if (fn) fn(null, results.map(result => result.filepath));
    });
  }

  /**
   * Build sources and watch for changes
   * @param {Function} fn
   */
  watch(fn) {
    // Build first
    this.build((err, results) => {
      if (err) return fn ? fn(err) : _libbuddyjs_error(err, 2);

      if (this.config.runtimeOptions.reload || this.config.runtimeOptions.serve) {
        // Protect against uninstalled add-on
        try {
          // Hide from buddy parsing
          _libbuddyjs_serverfarm = $m['lib/utils/index.js'].exports;
        } catch (tryError) {
          return _libbuddyjs_error('buddy-server add-on missing. Install \'buddy-server\' with npm', 2, true);
        }
        // Start servers
        _libbuddyjs_serverfarm.start(this.config.runtimeOptions.serve, this.config.runtimeOptions.reload, this.config.server, serverError => {
          if (serverError) {/* Ignore and keep watching */}
        });
      } else {
        _libbuddyjs_print('watching files for changes:', 1);
      }
    });
  }

  /**
   * Cleanup after unhandled exception
   */
  exceptionalCleanup() {
    if (_libbuddyjs_serverfarm) _libbuddyjs_serverfarm.stop();
  }

  /**
   * Reset
   */
  destroy() {
    this.exceptionalCleanup();
    this.config.destroy();

    this.config = null;
    this.builds = [];
  }

  /**
   * Recursively initialize all valid build instances specified in configuration
   * @param {Options} config
   * @returns {Array}
   */
  initBuilds(config) {
    function init(builds) {
      return builds.map(build => {
        const instance = _libbuddyjs_buildFactory(build);

        // Traverse
        if (instance.hasChildren) instance.build = init(instance.build);
        return instance;
      });
    }

    return init(config.build);
  }

  /**
   * Run all build targets
   * @param {Array} builds
   * @param {Function} fn(err, results)
   */
  run(builds, fn) {
    this.building = true;

    // Execute builds in sequence
    _libbuddyjs_series(builds.map(build => _libbuddyjs_callable(build, 'run')), (err, results) => {
      if (err) return fn(err);

      this.building = false;
      fn(null, _libbuddyjs_compact(_libbuddyjs_flatten(results)));
    });
  }

  /**
   * Run the script defined in config 'script'
   */
  executeScript() {
    let hasErrored = false;
    let args, command, script;

    if (this.config.runtimeOptions.script && (script = this.config.script)) {
      script = script.split(' ');
      command = script.shift();
      args = script;

      _libbuddyjs_print('executing script...', 1);
      _libbuddyjs_debug(`execute: ${ _libbuddyjs_strong(this.config.script) }`, 3);

      script = _libbuddyjs_spawn(command, args, { cwd: process.cwd() });

      script.stdout.on('data', data => {
        process.stdout.write(data.toString());
      });

      script.stderr.on('data', data => {
        process.stderr.write(data.toString());
        hasErrored = true;
      });

      script.on('close', code => {
        if (hasErrored) process.stderr.write(_libbuddyjs_BELL);
      });
    }
  }

  /**
   * Handle cache changes
   * @param {File} file
   */
  onFileCacheChange(file) {
    const now = new Date();
    const builds = this.builds.filter(build => build.hasFile(file));
    // Determine if any changes to app server code that needs a restart
    const servers = builds.filter(build => build.isAppServer);

    if (!this.building) {
      _libbuddyjs_print(`[${ now.toLocaleTimeString() }] ${ _libbuddyjs_chalk.yellow('changed') } ${ _libbuddyjs_strong(_libbuddyjs_path.relative(process.cwd(), file.filepath)) }`, 1);

      _libbuddyjs_start('watch');

      this.run(builds, (err, filepaths) => {
        // Don't throw
        if (err) return _libbuddyjs_error(err, 2, false);
        if (_libbuddyjs_serverfarm) {
          // Trigger partial refresh if only 1 css file, full reload if not
          const filepath = filepaths.length == 1 && _libbuddyjs_path.extname(filepaths[0]) == '.css' ? filepaths[0] : 'foo.js';

          // Refresh browser
          if (!servers.length) return _libbuddyjs_serverfarm.refresh(_libbuddyjs_path.basename(filepath));

          // Restart app server
          _libbuddyjs_serverfarm.restart(err => {
            if (err) {} /* ignore */
            // Refresh browser
            _libbuddyjs_serverfarm.refresh(_libbuddyjs_path.basename(filepath));
          });
        }
        _libbuddyjs_print(`completed build in ${ _libbuddyjs_chalk.cyan(_libbuddyjs_stop('watch') / 1000 + 's') }`, 1);
        // Run test script
        this.executeScript();
      });
    }
  }
}
/*≠≠ lib/buddy.js ≠≠*/