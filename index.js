/** BUDDY BUILT **/
var $m = {};
var originalRequire = require;
require = function buddyRequire (id) {
  if (!$m[id]) return originalRequire(id);
  if ('function' == typeof $m[id]) $m[id]();
  return $m[id].exports;
};
/*== node_modules/lodash/_setToArray.js ==*/
$m['lodash/_setToArray.js#4.15.0'] = { exports: {} };
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function _lodashsetToArrayjs4150_setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

$m['lodash/_setToArray.js#4.15.0'].exports = _lodashsetToArrayjs4150_setToArray;
/*≠≠ node_modules/lodash/_setToArray.js ≠≠*/

/*== node_modules/lodash/noop.js ==*/
$m['lodash/noop.js#4.15.0'] = { exports: {} };
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function _lodashnoopjs4150_noop() {
  // No operation performed.
}

$m['lodash/noop.js#4.15.0'].exports = _lodashnoopjs4150_noop;
/*≠≠ node_modules/lodash/noop.js ≠≠*/

/*== node_modules/lodash/_freeGlobal.js ==*/
$m['lodash/_freeGlobal.js#4.15.0'] = { exports: {} };
/** Detect free variable `global` from Node.js. */
var _lodashfreeGlobaljs4150_freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

$m['lodash/_freeGlobal.js#4.15.0'].exports = _lodashfreeGlobaljs4150_freeGlobal;
/*≠≠ node_modules/lodash/_freeGlobal.js ≠≠*/

/*== node_modules/lodash/_root.js ==*/
$m['lodash/_root.js#4.15.0'] = { exports: {} };
var _lodashrootjs4150_freeGlobal = $m['lodash/_freeGlobal.js#4.15.0'].exports;

/** Detect free variable `self`. */
var _lodashrootjs4150_freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var _lodashrootjs4150_root = _lodashrootjs4150_freeGlobal || _lodashrootjs4150_freeSelf || Function('return this')();

$m['lodash/_root.js#4.15.0'].exports = _lodashrootjs4150_root;
/*≠≠ node_modules/lodash/_root.js ≠≠*/

/*== node_modules/lodash/_getValue.js ==*/
$m['lodash/_getValue.js#4.15.0'] = { exports: {} };
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function _lodashgetValuejs4150_getValue(object, key) {
  return object == null ? undefined : object[key];
}

$m['lodash/_getValue.js#4.15.0'].exports = _lodashgetValuejs4150_getValue;
/*≠≠ node_modules/lodash/_getValue.js ≠≠*/

/*== node_modules/lodash/_toSource.js ==*/
$m['lodash/_toSource.js#4.15.0'] = { exports: {} };
/** Used for built-in method references. */
var _lodashtoSourcejs4150_funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashtoSourcejs4150_funcToString = _lodashtoSourcejs4150_funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function _lodashtoSourcejs4150_toSource(func) {
  if (func != null) {
    try {
      return _lodashtoSourcejs4150_funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

$m['lodash/_toSource.js#4.15.0'].exports = _lodashtoSourcejs4150_toSource;
/*≠≠ node_modules/lodash/_toSource.js ≠≠*/

/*== node_modules/lodash/isObject.js ==*/
$m['lodash/isObject.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function _lodashisObjectjs4150_isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

$m['lodash/isObject.js#4.15.0'].exports = _lodashisObjectjs4150_isObject;
/*≠≠ node_modules/lodash/isObject.js ≠≠*/

/*== node_modules/lodash/_coreJsData.js ==*/
$m['lodash/_coreJsData.js#4.15.0'] = { exports: {} };
var _lodashcoreJsDatajs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/** Used to detect overreaching core-js shims. */
var _lodashcoreJsDatajs4150_coreJsData = _lodashcoreJsDatajs4150_root['__core-js_shared__'];

$m['lodash/_coreJsData.js#4.15.0'].exports = _lodashcoreJsDatajs4150_coreJsData;
/*≠≠ node_modules/lodash/_coreJsData.js ≠≠*/

/*== node_modules/lodash/_isMasked.js ==*/
$m['lodash/_isMasked.js#4.15.0'] = { exports: {} };
var _lodashisMaskedjs4150_coreJsData = $m['lodash/_coreJsData.js#4.15.0'].exports;

/** Used to detect methods masquerading as native. */
var _lodashisMaskedjs4150_maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_lodashisMaskedjs4150_coreJsData && _lodashisMaskedjs4150_coreJsData.keys && _lodashisMaskedjs4150_coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function _lodashisMaskedjs4150_isMasked(func) {
  return !!_lodashisMaskedjs4150_maskSrcKey && _lodashisMaskedjs4150_maskSrcKey in func;
}

$m['lodash/_isMasked.js#4.15.0'].exports = _lodashisMaskedjs4150_isMasked;
/*≠≠ node_modules/lodash/_isMasked.js ≠≠*/

/*== node_modules/lodash/_isHostObject.js ==*/
$m['lodash/_isHostObject.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function _lodashisHostObjectjs4150_isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

$m['lodash/_isHostObject.js#4.15.0'].exports = _lodashisHostObjectjs4150_isHostObject;
/*≠≠ node_modules/lodash/_isHostObject.js ≠≠*/

/*== node_modules/lodash/isFunction.js ==*/
$m['lodash/isFunction.js#4.15.0'] = { exports: {} };
var _lodashisFunctionjs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashisFunctionjs4150_funcTag = '[object Function]',
    _lodashisFunctionjs4150_genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var _lodashisFunctionjs4150_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisFunctionjs4150_objectToString = _lodashisFunctionjs4150_objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function _lodashisFunctionjs4150_isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = _lodashisFunctionjs4150_isObject(value) ? _lodashisFunctionjs4150_objectToString.call(value) : '';
  return tag == _lodashisFunctionjs4150_funcTag || tag == _lodashisFunctionjs4150_genTag;
}

$m['lodash/isFunction.js#4.15.0'].exports = _lodashisFunctionjs4150_isFunction;
/*≠≠ node_modules/lodash/isFunction.js ≠≠*/

/*== node_modules/lodash/_baseIsNative.js ==*/
$m['lodash/_baseIsNative.js#4.15.0'] = { exports: {} };
var _lodashbaseIsNativejs4150_isFunction = $m['lodash/isFunction.js#4.15.0'].exports,
    _lodashbaseIsNativejs4150_isHostObject = $m['lodash/_isHostObject.js#4.15.0'].exports,
    _lodashbaseIsNativejs4150_isMasked = $m['lodash/_isMasked.js#4.15.0'].exports,
    _lodashbaseIsNativejs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseIsNativejs4150_toSource = $m['lodash/_toSource.js#4.15.0'].exports;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var _lodashbaseIsNativejs4150_reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var _lodashbaseIsNativejs4150_reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _lodashbaseIsNativejs4150_funcProto = Function.prototype,
    _lodashbaseIsNativejs4150_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashbaseIsNativejs4150_funcToString = _lodashbaseIsNativejs4150_funcProto.toString;

/** Used to check objects for own properties. */
var _lodashbaseIsNativejs4150_hasOwnProperty = _lodashbaseIsNativejs4150_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var _lodashbaseIsNativejs4150_reIsNative = RegExp('^' + _lodashbaseIsNativejs4150_funcToString.call(_lodashbaseIsNativejs4150_hasOwnProperty).replace(_lodashbaseIsNativejs4150_reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function _lodashbaseIsNativejs4150_baseIsNative(value) {
  if (!_lodashbaseIsNativejs4150_isObject(value) || _lodashbaseIsNativejs4150_isMasked(value)) {
    return false;
  }
  var pattern = _lodashbaseIsNativejs4150_isFunction(value) || _lodashbaseIsNativejs4150_isHostObject(value) ? _lodashbaseIsNativejs4150_reIsNative : _lodashbaseIsNativejs4150_reIsHostCtor;
  return pattern.test(_lodashbaseIsNativejs4150_toSource(value));
}

$m['lodash/_baseIsNative.js#4.15.0'].exports = _lodashbaseIsNativejs4150_baseIsNative;
/*≠≠ node_modules/lodash/_baseIsNative.js ≠≠*/

/*== node_modules/lodash/_getNative.js ==*/
$m['lodash/_getNative.js#4.15.0'] = { exports: {} };
var _lodashgetNativejs4150_baseIsNative = $m['lodash/_baseIsNative.js#4.15.0'].exports,
    _lodashgetNativejs4150_getValue = $m['lodash/_getValue.js#4.15.0'].exports;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function _lodashgetNativejs4150_getNative(object, key) {
  var value = _lodashgetNativejs4150_getValue(object, key);
  return _lodashgetNativejs4150_baseIsNative(value) ? value : undefined;
}

$m['lodash/_getNative.js#4.15.0'].exports = _lodashgetNativejs4150_getNative;
/*≠≠ node_modules/lodash/_getNative.js ≠≠*/

/*== node_modules/lodash/_Set.js ==*/
$m['lodash/_Set.js#4.15.0'] = { exports: {} };
var _lodashSetjs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports,
    _lodashSetjs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashSetjs4150_Set = _lodashSetjs4150_getNative(_lodashSetjs4150_root, 'Set');

$m['lodash/_Set.js#4.15.0'].exports = _lodashSetjs4150_Set;
/*≠≠ node_modules/lodash/_Set.js ≠≠*/

/*== node_modules/lodash/_createSet.js ==*/
$m['lodash/_createSet.js#4.15.0'] = { exports: {} };
var _lodashcreateSetjs4150_Set = $m['lodash/_Set.js#4.15.0'].exports,
    _lodashcreateSetjs4150_noop = $m['lodash/noop.js#4.15.0'].exports,
    _lodashcreateSetjs4150_setToArray = $m['lodash/_setToArray.js#4.15.0'].exports;

/** Used as references for various `Number` constants. */
var _lodashcreateSetjs4150_INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var _lodashcreateSetjs4150_createSet = !(_lodashcreateSetjs4150_Set && 1 / _lodashcreateSetjs4150_setToArray(new _lodashcreateSetjs4150_Set([, -0]))[1] == _lodashcreateSetjs4150_INFINITY) ? _lodashcreateSetjs4150_noop : function (values) {
  return new _lodashcreateSetjs4150_Set(values);
};

$m['lodash/_createSet.js#4.15.0'].exports = _lodashcreateSetjs4150_createSet;
/*≠≠ node_modules/lodash/_createSet.js ≠≠*/

/*== node_modules/lodash/_cacheHas.js ==*/
$m['lodash/_cacheHas.js#4.15.0'] = { exports: {} };
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashcacheHasjs4150_cacheHas(cache, key) {
  return cache.has(key);
}

$m['lodash/_cacheHas.js#4.15.0'].exports = _lodashcacheHasjs4150_cacheHas;
/*≠≠ node_modules/lodash/_cacheHas.js ≠≠*/

/*== node_modules/lodash/_arrayIncludesWith.js ==*/
$m['lodash/_arrayIncludesWith.js#4.15.0'] = { exports: {} };
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function _lodasharrayIncludesWithjs4150_arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

$m['lodash/_arrayIncludesWith.js#4.15.0'].exports = _lodasharrayIncludesWithjs4150_arrayIncludesWith;
/*≠≠ node_modules/lodash/_arrayIncludesWith.js ≠≠*/

/*== node_modules/lodash/_baseIsNaN.js ==*/
$m['lodash/_baseIsNaN.js#4.15.0'] = { exports: {} };
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function _lodashbaseIsNaNjs4150_baseIsNaN(value) {
  return value !== value;
}

$m['lodash/_baseIsNaN.js#4.15.0'].exports = _lodashbaseIsNaNjs4150_baseIsNaN;
/*≠≠ node_modules/lodash/_baseIsNaN.js ≠≠*/

/*== node_modules/lodash/_baseFindIndex.js ==*/
$m['lodash/_baseFindIndex.js#4.15.0'] = { exports: {} };
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashbaseFindIndexjs4150_baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

$m['lodash/_baseFindIndex.js#4.15.0'].exports = _lodashbaseFindIndexjs4150_baseFindIndex;
/*≠≠ node_modules/lodash/_baseFindIndex.js ≠≠*/

/*== node_modules/lodash/_baseIndexOf.js ==*/
$m['lodash/_baseIndexOf.js#4.15.0'] = { exports: {} };
var _lodashbaseIndexOfjs4150_baseFindIndex = $m['lodash/_baseFindIndex.js#4.15.0'].exports,
    _lodashbaseIndexOfjs4150_baseIsNaN = $m['lodash/_baseIsNaN.js#4.15.0'].exports;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashbaseIndexOfjs4150_baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return _lodashbaseIndexOfjs4150_baseFindIndex(array, _lodashbaseIndexOfjs4150_baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

$m['lodash/_baseIndexOf.js#4.15.0'].exports = _lodashbaseIndexOfjs4150_baseIndexOf;
/*≠≠ node_modules/lodash/_baseIndexOf.js ≠≠*/

/*== node_modules/lodash/_arrayIncludes.js ==*/
$m['lodash/_arrayIncludes.js#4.15.0'] = { exports: {} };
var _lodasharrayIncludesjs4150_baseIndexOf = $m['lodash/_baseIndexOf.js#4.15.0'].exports;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function _lodasharrayIncludesjs4150_arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && _lodasharrayIncludesjs4150_baseIndexOf(array, value, 0) > -1;
}

$m['lodash/_arrayIncludes.js#4.15.0'].exports = _lodasharrayIncludesjs4150_arrayIncludes;
/*≠≠ node_modules/lodash/_arrayIncludes.js ≠≠*/

/*== node_modules/lodash/_setCacheHas.js ==*/
$m['lodash/_setCacheHas.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function _lodashsetCacheHasjs4150_setCacheHas(value) {
  return this.__data__.has(value);
}

$m['lodash/_setCacheHas.js#4.15.0'].exports = _lodashsetCacheHasjs4150_setCacheHas;
/*≠≠ node_modules/lodash/_setCacheHas.js ≠≠*/

/*== node_modules/lodash/_setCacheAdd.js ==*/
$m['lodash/_setCacheAdd.js#4.15.0'] = { exports: {} };
/** Used to stand-in for `undefined` hash values. */
var _lodashsetCacheAddjs4150_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function _lodashsetCacheAddjs4150_setCacheAdd(value) {
  this.__data__.set(value, _lodashsetCacheAddjs4150_HASH_UNDEFINED);
  return this;
}

$m['lodash/_setCacheAdd.js#4.15.0'].exports = _lodashsetCacheAddjs4150_setCacheAdd;
/*≠≠ node_modules/lodash/_setCacheAdd.js ≠≠*/

/*== node_modules/lodash/_isKeyable.js ==*/
$m['lodash/_isKeyable.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function _lodashisKeyablejs4150_isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

$m['lodash/_isKeyable.js#4.15.0'].exports = _lodashisKeyablejs4150_isKeyable;
/*≠≠ node_modules/lodash/_isKeyable.js ≠≠*/

/*== node_modules/lodash/_getMapData.js ==*/
$m['lodash/_getMapData.js#4.15.0'] = { exports: {} };
var _lodashgetMapDatajs4150_isKeyable = $m['lodash/_isKeyable.js#4.15.0'].exports;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function _lodashgetMapDatajs4150_getMapData(map, key) {
  var data = map.__data__;
  return _lodashgetMapDatajs4150_isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

$m['lodash/_getMapData.js#4.15.0'].exports = _lodashgetMapDatajs4150_getMapData;
/*≠≠ node_modules/lodash/_getMapData.js ≠≠*/

/*== node_modules/lodash/_mapCacheSet.js ==*/
$m['lodash/_mapCacheSet.js#4.15.0'] = { exports: {} };
var _lodashmapCacheSetjs4150_getMapData = $m['lodash/_getMapData.js#4.15.0'].exports;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function _lodashmapCacheSetjs4150_mapCacheSet(key, value) {
  _lodashmapCacheSetjs4150_getMapData(this, key).set(key, value);
  return this;
}

$m['lodash/_mapCacheSet.js#4.15.0'].exports = _lodashmapCacheSetjs4150_mapCacheSet;
/*≠≠ node_modules/lodash/_mapCacheSet.js ≠≠*/

/*== node_modules/lodash/_mapCacheHas.js ==*/
$m['lodash/_mapCacheHas.js#4.15.0'] = { exports: {} };
var _lodashmapCacheHasjs4150_getMapData = $m['lodash/_getMapData.js#4.15.0'].exports;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashmapCacheHasjs4150_mapCacheHas(key) {
  return _lodashmapCacheHasjs4150_getMapData(this, key).has(key);
}

$m['lodash/_mapCacheHas.js#4.15.0'].exports = _lodashmapCacheHasjs4150_mapCacheHas;
/*≠≠ node_modules/lodash/_mapCacheHas.js ≠≠*/

/*== node_modules/lodash/_mapCacheGet.js ==*/
$m['lodash/_mapCacheGet.js#4.15.0'] = { exports: {} };
var _lodashmapCacheGetjs4150_getMapData = $m['lodash/_getMapData.js#4.15.0'].exports;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashmapCacheGetjs4150_mapCacheGet(key) {
  return _lodashmapCacheGetjs4150_getMapData(this, key).get(key);
}

$m['lodash/_mapCacheGet.js#4.15.0'].exports = _lodashmapCacheGetjs4150_mapCacheGet;
/*≠≠ node_modules/lodash/_mapCacheGet.js ≠≠*/

/*== node_modules/lodash/_mapCacheDelete.js ==*/
$m['lodash/_mapCacheDelete.js#4.15.0'] = { exports: {} };
var _lodashmapCacheDeletejs4150_getMapData = $m['lodash/_getMapData.js#4.15.0'].exports;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashmapCacheDeletejs4150_mapCacheDelete(key) {
  return _lodashmapCacheDeletejs4150_getMapData(this, key)['delete'](key);
}

$m['lodash/_mapCacheDelete.js#4.15.0'].exports = _lodashmapCacheDeletejs4150_mapCacheDelete;
/*≠≠ node_modules/lodash/_mapCacheDelete.js ≠≠*/

/*== node_modules/lodash/_Map.js ==*/
$m['lodash/_Map.js#4.15.0'] = { exports: {} };
var _lodashMapjs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports,
    _lodashMapjs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashMapjs4150_Map = _lodashMapjs4150_getNative(_lodashMapjs4150_root, 'Map');

$m['lodash/_Map.js#4.15.0'].exports = _lodashMapjs4150_Map;
/*≠≠ node_modules/lodash/_Map.js ≠≠*/

/*== node_modules/lodash/eq.js ==*/
$m['lodash/eq.js#4.15.0'] = { exports: {} };
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function _lodasheqjs4150_eq(value, other) {
  return value === other || value !== value && other !== other;
}

$m['lodash/eq.js#4.15.0'].exports = _lodasheqjs4150_eq;
/*≠≠ node_modules/lodash/eq.js ≠≠*/

/*== node_modules/lodash/_assocIndexOf.js ==*/
$m['lodash/_assocIndexOf.js#4.15.0'] = { exports: {} };
var _lodashassocIndexOfjs4150_eq = $m['lodash/eq.js#4.15.0'].exports;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function _lodashassocIndexOfjs4150_assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (_lodashassocIndexOfjs4150_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

$m['lodash/_assocIndexOf.js#4.15.0'].exports = _lodashassocIndexOfjs4150_assocIndexOf;
/*≠≠ node_modules/lodash/_assocIndexOf.js ≠≠*/

/*== node_modules/lodash/_listCacheSet.js ==*/
$m['lodash/_listCacheSet.js#4.15.0'] = { exports: {} };
var _lodashlistCacheSetjs4150_assocIndexOf = $m['lodash/_assocIndexOf.js#4.15.0'].exports;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function _lodashlistCacheSetjs4150_listCacheSet(key, value) {
  var data = this.__data__,
      index = _lodashlistCacheSetjs4150_assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

$m['lodash/_listCacheSet.js#4.15.0'].exports = _lodashlistCacheSetjs4150_listCacheSet;
/*≠≠ node_modules/lodash/_listCacheSet.js ≠≠*/

/*== node_modules/lodash/_listCacheHas.js ==*/
$m['lodash/_listCacheHas.js#4.15.0'] = { exports: {} };
var _lodashlistCacheHasjs4150_assocIndexOf = $m['lodash/_assocIndexOf.js#4.15.0'].exports;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashlistCacheHasjs4150_listCacheHas(key) {
  return _lodashlistCacheHasjs4150_assocIndexOf(this.__data__, key) > -1;
}

$m['lodash/_listCacheHas.js#4.15.0'].exports = _lodashlistCacheHasjs4150_listCacheHas;
/*≠≠ node_modules/lodash/_listCacheHas.js ≠≠*/

/*== node_modules/lodash/_listCacheGet.js ==*/
$m['lodash/_listCacheGet.js#4.15.0'] = { exports: {} };
var _lodashlistCacheGetjs4150_assocIndexOf = $m['lodash/_assocIndexOf.js#4.15.0'].exports;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashlistCacheGetjs4150_listCacheGet(key) {
  var data = this.__data__,
      index = _lodashlistCacheGetjs4150_assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

$m['lodash/_listCacheGet.js#4.15.0'].exports = _lodashlistCacheGetjs4150_listCacheGet;
/*≠≠ node_modules/lodash/_listCacheGet.js ≠≠*/

/*== node_modules/lodash/_listCacheDelete.js ==*/
$m['lodash/_listCacheDelete.js#4.15.0'] = { exports: {} };
var _lodashlistCacheDeletejs4150_assocIndexOf = $m['lodash/_assocIndexOf.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashlistCacheDeletejs4150_arrayProto = Array.prototype;

/** Built-in value references. */
var _lodashlistCacheDeletejs4150_splice = _lodashlistCacheDeletejs4150_arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashlistCacheDeletejs4150_listCacheDelete(key) {
  var data = this.__data__,
      index = _lodashlistCacheDeletejs4150_assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    _lodashlistCacheDeletejs4150_splice.call(data, index, 1);
  }
  return true;
}

$m['lodash/_listCacheDelete.js#4.15.0'].exports = _lodashlistCacheDeletejs4150_listCacheDelete;
/*≠≠ node_modules/lodash/_listCacheDelete.js ≠≠*/

/*== node_modules/lodash/_listCacheClear.js ==*/
$m['lodash/_listCacheClear.js#4.15.0'] = { exports: {} };
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function _lodashlistCacheClearjs4150_listCacheClear() {
  this.__data__ = [];
}

$m['lodash/_listCacheClear.js#4.15.0'].exports = _lodashlistCacheClearjs4150_listCacheClear;
/*≠≠ node_modules/lodash/_listCacheClear.js ≠≠*/

/*== node_modules/lodash/_ListCache.js ==*/
$m['lodash/_ListCache.js#4.15.0'] = { exports: {} };
var _lodashListCachejs4150_listCacheClear = $m['lodash/_listCacheClear.js#4.15.0'].exports,
    _lodashListCachejs4150_listCacheDelete = $m['lodash/_listCacheDelete.js#4.15.0'].exports,
    _lodashListCachejs4150_listCacheGet = $m['lodash/_listCacheGet.js#4.15.0'].exports,
    _lodashListCachejs4150_listCacheHas = $m['lodash/_listCacheHas.js#4.15.0'].exports,
    _lodashListCachejs4150_listCacheSet = $m['lodash/_listCacheSet.js#4.15.0'].exports;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashListCachejs4150_ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `ListCache`.
_lodashListCachejs4150_ListCache.prototype.clear = _lodashListCachejs4150_listCacheClear;
_lodashListCachejs4150_ListCache.prototype['delete'] = _lodashListCachejs4150_listCacheDelete;
_lodashListCachejs4150_ListCache.prototype.get = _lodashListCachejs4150_listCacheGet;
_lodashListCachejs4150_ListCache.prototype.has = _lodashListCachejs4150_listCacheHas;
_lodashListCachejs4150_ListCache.prototype.set = _lodashListCachejs4150_listCacheSet;

$m['lodash/_ListCache.js#4.15.0'].exports = _lodashListCachejs4150_ListCache;
/*≠≠ node_modules/lodash/_ListCache.js ≠≠*/

/*== node_modules/lodash/_nativeCreate.js ==*/
$m['lodash/_nativeCreate.js#4.15.0'] = { exports: {} };
var _lodashnativeCreatejs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashnativeCreatejs4150_nativeCreate = _lodashnativeCreatejs4150_getNative(Object, 'create');

$m['lodash/_nativeCreate.js#4.15.0'].exports = _lodashnativeCreatejs4150_nativeCreate;
/*≠≠ node_modules/lodash/_nativeCreate.js ≠≠*/

/*== node_modules/lodash/_hashSet.js ==*/
$m['lodash/_hashSet.js#4.15.0'] = { exports: {} };
var _lodashhashSetjs4150_nativeCreate = $m['lodash/_nativeCreate.js#4.15.0'].exports;

/** Used to stand-in for `undefined` hash values. */
var _lodashhashSetjs4150_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function _lodashhashSetjs4150_hashSet(key, value) {
  var data = this.__data__;
  data[key] = _lodashhashSetjs4150_nativeCreate && value === undefined ? _lodashhashSetjs4150_HASH_UNDEFINED : value;
  return this;
}

$m['lodash/_hashSet.js#4.15.0'].exports = _lodashhashSetjs4150_hashSet;
/*≠≠ node_modules/lodash/_hashSet.js ≠≠*/

/*== node_modules/lodash/_hashHas.js ==*/
$m['lodash/_hashHas.js#4.15.0'] = { exports: {} };
var _lodashhashHasjs4150_nativeCreate = $m['lodash/_nativeCreate.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashhashHasjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashhashHasjs4150_hasOwnProperty = _lodashhashHasjs4150_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashhashHasjs4150_hashHas(key) {
  var data = this.__data__;
  return _lodashhashHasjs4150_nativeCreate ? data[key] !== undefined : _lodashhashHasjs4150_hasOwnProperty.call(data, key);
}

$m['lodash/_hashHas.js#4.15.0'].exports = _lodashhashHasjs4150_hashHas;
/*≠≠ node_modules/lodash/_hashHas.js ≠≠*/

/*== node_modules/lodash/_hashGet.js ==*/
$m['lodash/_hashGet.js#4.15.0'] = { exports: {} };
var _lodashhashGetjs4150_nativeCreate = $m['lodash/_nativeCreate.js#4.15.0'].exports;

/** Used to stand-in for `undefined` hash values. */
var _lodashhashGetjs4150_HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _lodashhashGetjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashhashGetjs4150_hasOwnProperty = _lodashhashGetjs4150_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashhashGetjs4150_hashGet(key) {
  var data = this.__data__;
  if (_lodashhashGetjs4150_nativeCreate) {
    var result = data[key];
    return result === _lodashhashGetjs4150_HASH_UNDEFINED ? undefined : result;
  }
  return _lodashhashGetjs4150_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

$m['lodash/_hashGet.js#4.15.0'].exports = _lodashhashGetjs4150_hashGet;
/*≠≠ node_modules/lodash/_hashGet.js ≠≠*/

/*== node_modules/lodash/_hashDelete.js ==*/
$m['lodash/_hashDelete.js#4.15.0'] = { exports: {} };
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashhashDeletejs4150_hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

$m['lodash/_hashDelete.js#4.15.0'].exports = _lodashhashDeletejs4150_hashDelete;
/*≠≠ node_modules/lodash/_hashDelete.js ≠≠*/

/*== node_modules/lodash/_hashClear.js ==*/
$m['lodash/_hashClear.js#4.15.0'] = { exports: {} };
var _lodashhashClearjs4150_nativeCreate = $m['lodash/_nativeCreate.js#4.15.0'].exports;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function _lodashhashClearjs4150_hashClear() {
  this.__data__ = _lodashhashClearjs4150_nativeCreate ? _lodashhashClearjs4150_nativeCreate(null) : {};
}

$m['lodash/_hashClear.js#4.15.0'].exports = _lodashhashClearjs4150_hashClear;
/*≠≠ node_modules/lodash/_hashClear.js ≠≠*/

/*== node_modules/lodash/_Hash.js ==*/
$m['lodash/_Hash.js#4.15.0'] = { exports: {} };
var _lodashHashjs4150_hashClear = $m['lodash/_hashClear.js#4.15.0'].exports,
    _lodashHashjs4150_hashDelete = $m['lodash/_hashDelete.js#4.15.0'].exports,
    _lodashHashjs4150_hashGet = $m['lodash/_hashGet.js#4.15.0'].exports,
    _lodashHashjs4150_hashHas = $m['lodash/_hashHas.js#4.15.0'].exports,
    _lodashHashjs4150_hashSet = $m['lodash/_hashSet.js#4.15.0'].exports;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashHashjs4150_Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `Hash`.
_lodashHashjs4150_Hash.prototype.clear = _lodashHashjs4150_hashClear;
_lodashHashjs4150_Hash.prototype['delete'] = _lodashHashjs4150_hashDelete;
_lodashHashjs4150_Hash.prototype.get = _lodashHashjs4150_hashGet;
_lodashHashjs4150_Hash.prototype.has = _lodashHashjs4150_hashHas;
_lodashHashjs4150_Hash.prototype.set = _lodashHashjs4150_hashSet;

$m['lodash/_Hash.js#4.15.0'].exports = _lodashHashjs4150_Hash;
/*≠≠ node_modules/lodash/_Hash.js ≠≠*/

/*== node_modules/lodash/_mapCacheClear.js ==*/
$m['lodash/_mapCacheClear.js#4.15.0'] = { exports: {} };
var _lodashmapCacheClearjs4150_Hash = $m['lodash/_Hash.js#4.15.0'].exports,
    _lodashmapCacheClearjs4150_ListCache = $m['lodash/_ListCache.js#4.15.0'].exports,
    _lodashmapCacheClearjs4150_Map = $m['lodash/_Map.js#4.15.0'].exports;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function _lodashmapCacheClearjs4150_mapCacheClear() {
  this.__data__ = {
    'hash': new _lodashmapCacheClearjs4150_Hash(),
    'map': new (_lodashmapCacheClearjs4150_Map || _lodashmapCacheClearjs4150_ListCache)(),
    'string': new _lodashmapCacheClearjs4150_Hash()
  };
}

$m['lodash/_mapCacheClear.js#4.15.0'].exports = _lodashmapCacheClearjs4150_mapCacheClear;
/*≠≠ node_modules/lodash/_mapCacheClear.js ≠≠*/

/*== node_modules/lodash/_MapCache.js ==*/
$m['lodash/_MapCache.js#4.15.0'] = { exports: {} };
var _lodashMapCachejs4150_mapCacheClear = $m['lodash/_mapCacheClear.js#4.15.0'].exports,
    _lodashMapCachejs4150_mapCacheDelete = $m['lodash/_mapCacheDelete.js#4.15.0'].exports,
    _lodashMapCachejs4150_mapCacheGet = $m['lodash/_mapCacheGet.js#4.15.0'].exports,
    _lodashMapCachejs4150_mapCacheHas = $m['lodash/_mapCacheHas.js#4.15.0'].exports,
    _lodashMapCachejs4150_mapCacheSet = $m['lodash/_mapCacheSet.js#4.15.0'].exports;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashMapCachejs4150_MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `MapCache`.
_lodashMapCachejs4150_MapCache.prototype.clear = _lodashMapCachejs4150_mapCacheClear;
_lodashMapCachejs4150_MapCache.prototype['delete'] = _lodashMapCachejs4150_mapCacheDelete;
_lodashMapCachejs4150_MapCache.prototype.get = _lodashMapCachejs4150_mapCacheGet;
_lodashMapCachejs4150_MapCache.prototype.has = _lodashMapCachejs4150_mapCacheHas;
_lodashMapCachejs4150_MapCache.prototype.set = _lodashMapCachejs4150_mapCacheSet;

$m['lodash/_MapCache.js#4.15.0'].exports = _lodashMapCachejs4150_MapCache;
/*≠≠ node_modules/lodash/_MapCache.js ≠≠*/

/*== node_modules/lodash/_SetCache.js ==*/
$m['lodash/_SetCache.js#4.15.0'] = { exports: {} };
var _lodashSetCachejs4150_MapCache = $m['lodash/_MapCache.js#4.15.0'].exports,
    _lodashSetCachejs4150_setCacheAdd = $m['lodash/_setCacheAdd.js#4.15.0'].exports,
    _lodashSetCachejs4150_setCacheHas = $m['lodash/_setCacheHas.js#4.15.0'].exports;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function _lodashSetCachejs4150_SetCache(values) {
    var index = -1,
        length = values ? values.length : 0;

    this.__data__ = new _lodashSetCachejs4150_MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}

// Add methods to `SetCache`.
_lodashSetCachejs4150_SetCache.prototype.add = _lodashSetCachejs4150_SetCache.prototype.push = _lodashSetCachejs4150_setCacheAdd;
_lodashSetCachejs4150_SetCache.prototype.has = _lodashSetCachejs4150_setCacheHas;

$m['lodash/_SetCache.js#4.15.0'].exports = _lodashSetCachejs4150_SetCache;
/*≠≠ node_modules/lodash/_SetCache.js ≠≠*/

/*== node_modules/lodash/_baseUniq.js ==*/
$m['lodash/_baseUniq.js#4.15.0'] = { exports: {} };
var _lodashbaseUniqjs4150_SetCache = $m['lodash/_SetCache.js#4.15.0'].exports,
    _lodashbaseUniqjs4150_arrayIncludes = $m['lodash/_arrayIncludes.js#4.15.0'].exports,
    _lodashbaseUniqjs4150_arrayIncludesWith = $m['lodash/_arrayIncludesWith.js#4.15.0'].exports,
    _lodashbaseUniqjs4150_cacheHas = $m['lodash/_cacheHas.js#4.15.0'].exports,
    _lodashbaseUniqjs4150_createSet = $m['lodash/_createSet.js#4.15.0'].exports,
    _lodashbaseUniqjs4150_setToArray = $m['lodash/_setToArray.js#4.15.0'].exports;

/** Used as the size to enable large array optimizations. */
var _lodashbaseUniqjs4150_LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function _lodashbaseUniqjs4150_baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _lodashbaseUniqjs4150_arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _lodashbaseUniqjs4150_arrayIncludesWith;
  } else if (length >= _lodashbaseUniqjs4150_LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : _lodashbaseUniqjs4150_createSet(array);
    if (set) {
      return _lodashbaseUniqjs4150_setToArray(set);
    }
    isCommon = false;
    includes = _lodashbaseUniqjs4150_cacheHas;
    seen = new _lodashbaseUniqjs4150_SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

$m['lodash/_baseUniq.js#4.15.0'].exports = _lodashbaseUniqjs4150_baseUniq;
/*≠≠ node_modules/lodash/_baseUniq.js ≠≠*/

/*== node_modules/lodash/uniqWith.js ==*/
$m['lodash/uniqWith.js#4.15.0'] = { exports: {} };
var _lodashuniqWithjs4150_baseUniq = $m['lodash/_baseUniq.js#4.15.0'].exports;

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function _lodashuniqWithjs4150_uniqWith(array, comparator) {
  return array && array.length ? _lodashuniqWithjs4150_baseUniq(array, undefined, comparator) : [];
}

$m['lodash/uniqWith.js#4.15.0'].exports = _lodashuniqWithjs4150_uniqWith;
/*≠≠ node_modules/lodash/uniqWith.js ≠≠*/

/*== node_modules/lodash/isObjectLike.js ==*/
$m['lodash/isObjectLike.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function _lodashisObjectLikejs4150_isObjectLike(value) {
  return !!value && typeof value == 'object';
}

$m['lodash/isObjectLike.js#4.15.0'].exports = _lodashisObjectLikejs4150_isObjectLike;
/*≠≠ node_modules/lodash/isObjectLike.js ≠≠*/

/*== node_modules/lodash/_nodeUtil.js ==*/
$m['lodash/_nodeUtil.js#4.15.0'] = { exports: {} };
var _lodashnodeUtiljs4150_freeGlobal = $m['lodash/_freeGlobal.js#4.15.0'].exports;

/** Detect free variable `exports`. */
var _lodashnodeUtiljs4150_freeExports = typeof $m['lodash/_nodeUtil.js#4.15.0'].exports == 'object' && $m['lodash/_nodeUtil.js#4.15.0'].exports && !$m['lodash/_nodeUtil.js#4.15.0'].exports.nodeType && $m['lodash/_nodeUtil.js#4.15.0'].exports;

/** Detect free variable `module`. */
var _lodashnodeUtiljs4150_freeModule = _lodashnodeUtiljs4150_freeExports && typeof $m['lodash/_nodeUtil.js#4.15.0'] == 'object' && $m['lodash/_nodeUtil.js#4.15.0'] && !$m['lodash/_nodeUtil.js#4.15.0'].nodeType && $m['lodash/_nodeUtil.js#4.15.0'];

/** Detect the popular CommonJS extension `module.exports`. */
var _lodashnodeUtiljs4150_moduleExports = _lodashnodeUtiljs4150_freeModule && _lodashnodeUtiljs4150_freeModule.exports === _lodashnodeUtiljs4150_freeExports;

/** Detect free variable `process` from Node.js. */
var _lodashnodeUtiljs4150_freeProcess = _lodashnodeUtiljs4150_moduleExports && _lodashnodeUtiljs4150_freeGlobal.process;

/** Used to access faster Node.js helpers. */
var _lodashnodeUtiljs4150_nodeUtil = function () {
  try {
    return _lodashnodeUtiljs4150_freeProcess && _lodashnodeUtiljs4150_freeProcess.binding('util');
  } catch (e) {}
}();

$m['lodash/_nodeUtil.js#4.15.0'].exports = _lodashnodeUtiljs4150_nodeUtil;
/*≠≠ node_modules/lodash/_nodeUtil.js ≠≠*/

/*== node_modules/lodash/_baseUnary.js ==*/
$m['lodash/_baseUnary.js#4.15.0'] = { exports: {} };
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function _lodashbaseUnaryjs4150_baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

$m['lodash/_baseUnary.js#4.15.0'].exports = _lodashbaseUnaryjs4150_baseUnary;
/*≠≠ node_modules/lodash/_baseUnary.js ≠≠*/

/*== node_modules/lodash/isLength.js ==*/
$m['lodash/isLength.js#4.15.0'] = { exports: {} };
/** Used as references for various `Number` constants. */
var _lodashisLengthjs4150_MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function _lodashisLengthjs4150_isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= _lodashisLengthjs4150_MAX_SAFE_INTEGER;
}

$m['lodash/isLength.js#4.15.0'].exports = _lodashisLengthjs4150_isLength;
/*≠≠ node_modules/lodash/isLength.js ≠≠*/

/*== node_modules/lodash/_baseIsTypedArray.js ==*/
$m['lodash/_baseIsTypedArray.js#4.15.0'] = { exports: {} };
var _lodashbaseIsTypedArrayjs4150_isLength = $m['lodash/isLength.js#4.15.0'].exports,
    _lodashbaseIsTypedArrayjs4150_isObjectLike = $m['lodash/isObjectLike.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashbaseIsTypedArrayjs4150_argsTag = '[object Arguments]',
    _lodashbaseIsTypedArrayjs4150_arrayTag = '[object Array]',
    _lodashbaseIsTypedArrayjs4150_boolTag = '[object Boolean]',
    _lodashbaseIsTypedArrayjs4150_dateTag = '[object Date]',
    _lodashbaseIsTypedArrayjs4150_errorTag = '[object Error]',
    _lodashbaseIsTypedArrayjs4150_funcTag = '[object Function]',
    _lodashbaseIsTypedArrayjs4150_mapTag = '[object Map]',
    _lodashbaseIsTypedArrayjs4150_numberTag = '[object Number]',
    _lodashbaseIsTypedArrayjs4150_objectTag = '[object Object]',
    _lodashbaseIsTypedArrayjs4150_regexpTag = '[object RegExp]',
    _lodashbaseIsTypedArrayjs4150_setTag = '[object Set]',
    _lodashbaseIsTypedArrayjs4150_stringTag = '[object String]',
    _lodashbaseIsTypedArrayjs4150_weakMapTag = '[object WeakMap]';

var _lodashbaseIsTypedArrayjs4150_arrayBufferTag = '[object ArrayBuffer]',
    _lodashbaseIsTypedArrayjs4150_dataViewTag = '[object DataView]',
    _lodashbaseIsTypedArrayjs4150_float32Tag = '[object Float32Array]',
    _lodashbaseIsTypedArrayjs4150_float64Tag = '[object Float64Array]',
    _lodashbaseIsTypedArrayjs4150_int8Tag = '[object Int8Array]',
    _lodashbaseIsTypedArrayjs4150_int16Tag = '[object Int16Array]',
    _lodashbaseIsTypedArrayjs4150_int32Tag = '[object Int32Array]',
    _lodashbaseIsTypedArrayjs4150_uint8Tag = '[object Uint8Array]',
    _lodashbaseIsTypedArrayjs4150_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashbaseIsTypedArrayjs4150_uint16Tag = '[object Uint16Array]',
    _lodashbaseIsTypedArrayjs4150_uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var _lodashbaseIsTypedArrayjs4150_typedArrayTags = {};
_lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_float32Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_float64Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_int8Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_int16Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_int32Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_uint8Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_uint8ClampedTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_uint16Tag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_uint32Tag] = true;
_lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_argsTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_arrayTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_arrayBufferTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_boolTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_dataViewTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_dateTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_errorTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_funcTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_mapTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_numberTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_objectTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_regexpTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_setTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_stringTag] = _lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_weakMapTag] = false;

/** Used for built-in method references. */
var _lodashbaseIsTypedArrayjs4150_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashbaseIsTypedArrayjs4150_objectToString = _lodashbaseIsTypedArrayjs4150_objectProto.toString;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function _lodashbaseIsTypedArrayjs4150_baseIsTypedArray(value) {
    return _lodashbaseIsTypedArrayjs4150_isObjectLike(value) && _lodashbaseIsTypedArrayjs4150_isLength(value.length) && !!_lodashbaseIsTypedArrayjs4150_typedArrayTags[_lodashbaseIsTypedArrayjs4150_objectToString.call(value)];
}

$m['lodash/_baseIsTypedArray.js#4.15.0'].exports = _lodashbaseIsTypedArrayjs4150_baseIsTypedArray;
/*≠≠ node_modules/lodash/_baseIsTypedArray.js ≠≠*/

/*== node_modules/lodash/isTypedArray.js ==*/
$m['lodash/isTypedArray.js#4.15.0'] = { exports: {} };
var _lodashisTypedArrayjs4150_baseIsTypedArray = $m['lodash/_baseIsTypedArray.js#4.15.0'].exports,
    _lodashisTypedArrayjs4150_baseUnary = $m['lodash/_baseUnary.js#4.15.0'].exports,
    _lodashisTypedArrayjs4150_nodeUtil = $m['lodash/_nodeUtil.js#4.15.0'].exports;

/* Node.js helper references. */
var _lodashisTypedArrayjs4150_nodeIsTypedArray = _lodashisTypedArrayjs4150_nodeUtil && _lodashisTypedArrayjs4150_nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var _lodashisTypedArrayjs4150_isTypedArray = _lodashisTypedArrayjs4150_nodeIsTypedArray ? _lodashisTypedArrayjs4150_baseUnary(_lodashisTypedArrayjs4150_nodeIsTypedArray) : _lodashisTypedArrayjs4150_baseIsTypedArray;

$m['lodash/isTypedArray.js#4.15.0'].exports = _lodashisTypedArrayjs4150_isTypedArray;
/*≠≠ node_modules/lodash/isTypedArray.js ≠≠*/

/*== node_modules/lodash/isArray.js ==*/
$m['lodash/isArray.js#4.15.0'] = { exports: {} };
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var _lodashisArrayjs4150_isArray = Array.isArray;

$m['lodash/isArray.js#4.15.0'].exports = _lodashisArrayjs4150_isArray;
/*≠≠ node_modules/lodash/isArray.js ≠≠*/

/*== node_modules/lodash/_baseGetTag.js ==*/
$m['lodash/_baseGetTag.js#4.15.0'] = { exports: {} };
/** Used for built-in method references. */
var _lodashbaseGetTagjs4150_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashbaseGetTagjs4150_objectToString = _lodashbaseGetTagjs4150_objectProto.toString;

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function _lodashbaseGetTagjs4150_baseGetTag(value) {
  return _lodashbaseGetTagjs4150_objectToString.call(value);
}

$m['lodash/_baseGetTag.js#4.15.0'].exports = _lodashbaseGetTagjs4150_baseGetTag;
/*≠≠ node_modules/lodash/_baseGetTag.js ≠≠*/

/*== node_modules/lodash/_WeakMap.js ==*/
$m['lodash/_WeakMap.js#4.15.0'] = { exports: {} };
var _lodashWeakMapjs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports,
    _lodashWeakMapjs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashWeakMapjs4150_WeakMap = _lodashWeakMapjs4150_getNative(_lodashWeakMapjs4150_root, 'WeakMap');

$m['lodash/_WeakMap.js#4.15.0'].exports = _lodashWeakMapjs4150_WeakMap;
/*≠≠ node_modules/lodash/_WeakMap.js ≠≠*/

/*== node_modules/lodash/_Promise.js ==*/
$m['lodash/_Promise.js#4.15.0'] = { exports: {} };
var _lodashPromisejs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports,
    _lodashPromisejs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashPromisejs4150_Promise = _lodashPromisejs4150_getNative(_lodashPromisejs4150_root, 'Promise');

$m['lodash/_Promise.js#4.15.0'].exports = _lodashPromisejs4150_Promise;
/*≠≠ node_modules/lodash/_Promise.js ≠≠*/

/*== node_modules/lodash/_DataView.js ==*/
$m['lodash/_DataView.js#4.15.0'] = { exports: {} };
var _lodashDataViewjs4150_getNative = $m['lodash/_getNative.js#4.15.0'].exports,
    _lodashDataViewjs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/* Built-in method references that are verified to be native. */
var _lodashDataViewjs4150_DataView = _lodashDataViewjs4150_getNative(_lodashDataViewjs4150_root, 'DataView');

$m['lodash/_DataView.js#4.15.0'].exports = _lodashDataViewjs4150_DataView;
/*≠≠ node_modules/lodash/_DataView.js ≠≠*/

/*== node_modules/lodash/_getTag.js ==*/
$m['lodash/_getTag.js#4.15.0'] = { exports: {} };
var _lodashgetTagjs4150_DataView = $m['lodash/_DataView.js#4.15.0'].exports,
    _lodashgetTagjs4150_Map = $m['lodash/_Map.js#4.15.0'].exports,
    _lodashgetTagjs4150_Promise = $m['lodash/_Promise.js#4.15.0'].exports,
    _lodashgetTagjs4150_Set = $m['lodash/_Set.js#4.15.0'].exports,
    _lodashgetTagjs4150_WeakMap = $m['lodash/_WeakMap.js#4.15.0'].exports,
    _lodashgetTagjs4150_baseGetTag = $m['lodash/_baseGetTag.js#4.15.0'].exports,
    _lodashgetTagjs4150_toSource = $m['lodash/_toSource.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashgetTagjs4150_mapTag = '[object Map]',
    _lodashgetTagjs4150_objectTag = '[object Object]',
    _lodashgetTagjs4150_promiseTag = '[object Promise]',
    _lodashgetTagjs4150_setTag = '[object Set]',
    _lodashgetTagjs4150_weakMapTag = '[object WeakMap]';

var _lodashgetTagjs4150_dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var _lodashgetTagjs4150_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashgetTagjs4150_objectToString = _lodashgetTagjs4150_objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var _lodashgetTagjs4150_dataViewCtorString = _lodashgetTagjs4150_toSource(_lodashgetTagjs4150_DataView),
    _lodashgetTagjs4150_mapCtorString = _lodashgetTagjs4150_toSource(_lodashgetTagjs4150_Map),
    _lodashgetTagjs4150_promiseCtorString = _lodashgetTagjs4150_toSource(_lodashgetTagjs4150_Promise),
    _lodashgetTagjs4150_setCtorString = _lodashgetTagjs4150_toSource(_lodashgetTagjs4150_Set),
    _lodashgetTagjs4150_weakMapCtorString = _lodashgetTagjs4150_toSource(_lodashgetTagjs4150_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var _lodashgetTagjs4150_getTag = _lodashgetTagjs4150_baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (_lodashgetTagjs4150_DataView && _lodashgetTagjs4150_getTag(new _lodashgetTagjs4150_DataView(new ArrayBuffer(1))) != _lodashgetTagjs4150_dataViewTag || _lodashgetTagjs4150_Map && _lodashgetTagjs4150_getTag(new _lodashgetTagjs4150_Map()) != _lodashgetTagjs4150_mapTag || _lodashgetTagjs4150_Promise && _lodashgetTagjs4150_getTag(_lodashgetTagjs4150_Promise.resolve()) != _lodashgetTagjs4150_promiseTag || _lodashgetTagjs4150_Set && _lodashgetTagjs4150_getTag(new _lodashgetTagjs4150_Set()) != _lodashgetTagjs4150_setTag || _lodashgetTagjs4150_WeakMap && _lodashgetTagjs4150_getTag(new _lodashgetTagjs4150_WeakMap()) != _lodashgetTagjs4150_weakMapTag) {
    _lodashgetTagjs4150_getTag = function (value) {
        var result = _lodashgetTagjs4150_objectToString.call(value),
            Ctor = result == _lodashgetTagjs4150_objectTag ? value.constructor : undefined,
            ctorString = Ctor ? _lodashgetTagjs4150_toSource(Ctor) : undefined;

        if (ctorString) {
            switch (ctorString) {
                case _lodashgetTagjs4150_dataViewCtorString:
                    return _lodashgetTagjs4150_dataViewTag;
                case _lodashgetTagjs4150_mapCtorString:
                    return _lodashgetTagjs4150_mapTag;
                case _lodashgetTagjs4150_promiseCtorString:
                    return _lodashgetTagjs4150_promiseTag;
                case _lodashgetTagjs4150_setCtorString:
                    return _lodashgetTagjs4150_setTag;
                case _lodashgetTagjs4150_weakMapCtorString:
                    return _lodashgetTagjs4150_weakMapTag;
            }
        }
        return result;
    };
}

$m['lodash/_getTag.js#4.15.0'].exports = _lodashgetTagjs4150_getTag;
/*≠≠ node_modules/lodash/_getTag.js ≠≠*/

/*== node_modules/lodash/isArrayLike.js ==*/
$m['lodash/isArrayLike.js#4.15.0'] = { exports: {} };
var _lodashisArrayLikejs4150_isFunction = $m['lodash/isFunction.js#4.15.0'].exports,
    _lodashisArrayLikejs4150_isLength = $m['lodash/isLength.js#4.15.0'].exports;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function _lodashisArrayLikejs4150_isArrayLike(value) {
  return value != null && _lodashisArrayLikejs4150_isLength(value.length) && !_lodashisArrayLikejs4150_isFunction(value);
}

$m['lodash/isArrayLike.js#4.15.0'].exports = _lodashisArrayLikejs4150_isArrayLike;
/*≠≠ node_modules/lodash/isArrayLike.js ≠≠*/

/*== node_modules/lodash/_overArg.js ==*/
$m['lodash/_overArg.js#4.15.0'] = { exports: {} };
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function _lodashoverArgjs4150_overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

$m['lodash/_overArg.js#4.15.0'].exports = _lodashoverArgjs4150_overArg;
/*≠≠ node_modules/lodash/_overArg.js ≠≠*/

/*== node_modules/lodash/_nativeKeys.js ==*/
$m['lodash/_nativeKeys.js#4.15.0'] = { exports: {} };
var _lodashnativeKeysjs4150_overArg = $m['lodash/_overArg.js#4.15.0'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashnativeKeysjs4150_nativeKeys = _lodashnativeKeysjs4150_overArg(Object.keys, Object);

$m['lodash/_nativeKeys.js#4.15.0'].exports = _lodashnativeKeysjs4150_nativeKeys;
/*≠≠ node_modules/lodash/_nativeKeys.js ≠≠*/

/*== node_modules/lodash/_isPrototype.js ==*/
$m['lodash/_isPrototype.js#4.15.0'] = { exports: {} };
/** Used for built-in method references. */
var _lodashisPrototypejs4150_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function _lodashisPrototypejs4150_isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || _lodashisPrototypejs4150_objectProto;

  return value === proto;
}

$m['lodash/_isPrototype.js#4.15.0'].exports = _lodashisPrototypejs4150_isPrototype;
/*≠≠ node_modules/lodash/_isPrototype.js ≠≠*/

/*== node_modules/lodash/_baseKeys.js ==*/
$m['lodash/_baseKeys.js#4.15.0'] = { exports: {} };
var _lodashbaseKeysjs4150_isPrototype = $m['lodash/_isPrototype.js#4.15.0'].exports,
    _lodashbaseKeysjs4150_nativeKeys = $m['lodash/_nativeKeys.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashbaseKeysjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseKeysjs4150_hasOwnProperty = _lodashbaseKeysjs4150_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashbaseKeysjs4150_baseKeys(object) {
  if (!_lodashbaseKeysjs4150_isPrototype(object)) {
    return _lodashbaseKeysjs4150_nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (_lodashbaseKeysjs4150_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_baseKeys.js#4.15.0'].exports = _lodashbaseKeysjs4150_baseKeys;
/*≠≠ node_modules/lodash/_baseKeys.js ≠≠*/

/*== node_modules/lodash/_isIndex.js ==*/
$m['lodash/_isIndex.js#4.15.0'] = { exports: {} };
/** Used as references for various `Number` constants. */
var _lodashisIndexjs4150_MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var _lodashisIndexjs4150_reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function _lodashisIndexjs4150_isIndex(value, length) {
  length = length == null ? _lodashisIndexjs4150_MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || _lodashisIndexjs4150_reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

$m['lodash/_isIndex.js#4.15.0'].exports = _lodashisIndexjs4150_isIndex;
/*≠≠ node_modules/lodash/_isIndex.js ≠≠*/

/*== node_modules/lodash/isArrayLikeObject.js ==*/
$m['lodash/isArrayLikeObject.js#4.15.0'] = { exports: {} };
var _lodashisArrayLikeObjectjs4150_isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports,
    _lodashisArrayLikeObjectjs4150_isObjectLike = $m['lodash/isObjectLike.js#4.15.0'].exports;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function _lodashisArrayLikeObjectjs4150_isArrayLikeObject(value) {
  return _lodashisArrayLikeObjectjs4150_isObjectLike(value) && _lodashisArrayLikeObjectjs4150_isArrayLike(value);
}

$m['lodash/isArrayLikeObject.js#4.15.0'].exports = _lodashisArrayLikeObjectjs4150_isArrayLikeObject;
/*≠≠ node_modules/lodash/isArrayLikeObject.js ≠≠*/

/*== node_modules/lodash/isArguments.js ==*/
$m['lodash/isArguments.js#4.15.0'] = { exports: {} };
var _lodashisArgumentsjs4150_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashisArgumentsjs4150_argsTag = '[object Arguments]';

/** Used for built-in method references. */
var _lodashisArgumentsjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashisArgumentsjs4150_hasOwnProperty = _lodashisArgumentsjs4150_objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisArgumentsjs4150_objectToString = _lodashisArgumentsjs4150_objectProto.toString;

/** Built-in value references. */
var _lodashisArgumentsjs4150_propertyIsEnumerable = _lodashisArgumentsjs4150_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function _lodashisArgumentsjs4150_isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return _lodashisArgumentsjs4150_isArrayLikeObject(value) && _lodashisArgumentsjs4150_hasOwnProperty.call(value, 'callee') && (!_lodashisArgumentsjs4150_propertyIsEnumerable.call(value, 'callee') || _lodashisArgumentsjs4150_objectToString.call(value) == _lodashisArgumentsjs4150_argsTag);
}

$m['lodash/isArguments.js#4.15.0'].exports = _lodashisArgumentsjs4150_isArguments;
/*≠≠ node_modules/lodash/isArguments.js ≠≠*/

/*== node_modules/lodash/_baseTimes.js ==*/
$m['lodash/_baseTimes.js#4.15.0'] = { exports: {} };
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function _lodashbaseTimesjs4150_baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

$m['lodash/_baseTimes.js#4.15.0'].exports = _lodashbaseTimesjs4150_baseTimes;
/*≠≠ node_modules/lodash/_baseTimes.js ≠≠*/

/*== node_modules/lodash/_arrayLikeKeys.js ==*/
$m['lodash/_arrayLikeKeys.js#4.15.0'] = { exports: {} };
var _lodasharrayLikeKeysjs4150_baseTimes = $m['lodash/_baseTimes.js#4.15.0'].exports,
    _lodasharrayLikeKeysjs4150_isArguments = $m['lodash/isArguments.js#4.15.0'].exports,
    _lodasharrayLikeKeysjs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports,
    _lodasharrayLikeKeysjs4150_isIndex = $m['lodash/_isIndex.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodasharrayLikeKeysjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodasharrayLikeKeysjs4150_hasOwnProperty = _lodasharrayLikeKeysjs4150_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function _lodasharrayLikeKeysjs4150_arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = _lodasharrayLikeKeysjs4150_isArray(value) || _lodasharrayLikeKeysjs4150_isArguments(value) ? _lodasharrayLikeKeysjs4150_baseTimes(value.length, String) : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || _lodasharrayLikeKeysjs4150_hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || _lodasharrayLikeKeysjs4150_isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_arrayLikeKeys.js#4.15.0'].exports = _lodasharrayLikeKeysjs4150_arrayLikeKeys;
/*≠≠ node_modules/lodash/_arrayLikeKeys.js ≠≠*/

/*== node_modules/lodash/keys.js ==*/
$m['lodash/keys.js#4.15.0'] = { exports: {} };
var _lodashkeysjs4150_arrayLikeKeys = $m['lodash/_arrayLikeKeys.js#4.15.0'].exports,
    _lodashkeysjs4150_baseKeys = $m['lodash/_baseKeys.js#4.15.0'].exports,
    _lodashkeysjs4150_isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function _lodashkeysjs4150_keys(object) {
  return _lodashkeysjs4150_isArrayLike(object) ? _lodashkeysjs4150_arrayLikeKeys(object) : _lodashkeysjs4150_baseKeys(object);
}

$m['lodash/keys.js#4.15.0'].exports = _lodashkeysjs4150_keys;
/*≠≠ node_modules/lodash/keys.js ≠≠*/

/*== node_modules/lodash/_equalObjects.js ==*/
$m['lodash/_equalObjects.js#4.15.0'] = { exports: {} };
var _lodashequalObjectsjs4150_keys = $m['lodash/keys.js#4.15.0'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalObjectsjs4150_PARTIAL_COMPARE_FLAG = 2;

/** Used for built-in method references. */
var _lodashequalObjectsjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashequalObjectsjs4150_hasOwnProperty = _lodashequalObjectsjs4150_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashequalObjectsjs4150_equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & _lodashequalObjectsjs4150_PARTIAL_COMPARE_FLAG,
      objProps = _lodashequalObjectsjs4150_keys(object),
      objLength = objProps.length,
      othProps = _lodashequalObjectsjs4150_keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : _lodashequalObjectsjs4150_hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

$m['lodash/_equalObjects.js#4.15.0'].exports = _lodashequalObjectsjs4150_equalObjects;
/*≠≠ node_modules/lodash/_equalObjects.js ≠≠*/

/*== node_modules/lodash/_mapToArray.js ==*/
$m['lodash/_mapToArray.js#4.15.0'] = { exports: {} };
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function _lodashmapToArrayjs4150_mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

$m['lodash/_mapToArray.js#4.15.0'].exports = _lodashmapToArrayjs4150_mapToArray;
/*≠≠ node_modules/lodash/_mapToArray.js ≠≠*/

/*== node_modules/lodash/_arraySome.js ==*/
$m['lodash/_arraySome.js#4.15.0'] = { exports: {} };
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function _lodasharraySomejs4150_arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

$m['lodash/_arraySome.js#4.15.0'].exports = _lodasharraySomejs4150_arraySome;
/*≠≠ node_modules/lodash/_arraySome.js ≠≠*/

/*== node_modules/lodash/_equalArrays.js ==*/
$m['lodash/_equalArrays.js#4.15.0'] = { exports: {} };
var _lodashequalArraysjs4150_SetCache = $m['lodash/_SetCache.js#4.15.0'].exports,
    _lodashequalArraysjs4150_arraySome = $m['lodash/_arraySome.js#4.15.0'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalArraysjs4150_UNORDERED_COMPARE_FLAG = 1,
    _lodashequalArraysjs4150_PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function _lodashequalArraysjs4150_equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & _lodashequalArraysjs4150_PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & _lodashequalArraysjs4150_UNORDERED_COMPARE_FLAG ? new _lodashequalArraysjs4150_SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_lodashequalArraysjs4150_arraySome(other, function (othValue, othIndex) {
        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          return seen.add(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

$m['lodash/_equalArrays.js#4.15.0'].exports = _lodashequalArraysjs4150_equalArrays;
/*≠≠ node_modules/lodash/_equalArrays.js ≠≠*/

/*== node_modules/lodash/_Uint8Array.js ==*/
$m['lodash/_Uint8Array.js#4.15.0'] = { exports: {} };
var _lodashUint8Arrayjs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/** Built-in value references. */
var _lodashUint8Arrayjs4150_Uint8Array = _lodashUint8Arrayjs4150_root.Uint8Array;

$m['lodash/_Uint8Array.js#4.15.0'].exports = _lodashUint8Arrayjs4150_Uint8Array;
/*≠≠ node_modules/lodash/_Uint8Array.js ≠≠*/

/*== node_modules/lodash/_Symbol.js ==*/
$m['lodash/_Symbol.js#4.15.0'] = { exports: {} };
var _lodashSymboljs4150_root = $m['lodash/_root.js#4.15.0'].exports;

/** Built-in value references. */
var _lodashSymboljs4150_Symbol = _lodashSymboljs4150_root.Symbol;

$m['lodash/_Symbol.js#4.15.0'].exports = _lodashSymboljs4150_Symbol;
/*≠≠ node_modules/lodash/_Symbol.js ≠≠*/

/*== node_modules/lodash/_equalByTag.js ==*/
$m['lodash/_equalByTag.js#4.15.0'] = { exports: {} };
var _lodashequalByTagjs4150_Symbol = $m['lodash/_Symbol.js#4.15.0'].exports,
    _lodashequalByTagjs4150_Uint8Array = $m['lodash/_Uint8Array.js#4.15.0'].exports,
    _lodashequalByTagjs4150_eq = $m['lodash/eq.js#4.15.0'].exports,
    _lodashequalByTagjs4150_equalArrays = $m['lodash/_equalArrays.js#4.15.0'].exports,
    _lodashequalByTagjs4150_mapToArray = $m['lodash/_mapToArray.js#4.15.0'].exports,
    _lodashequalByTagjs4150_setToArray = $m['lodash/_setToArray.js#4.15.0'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashequalByTagjs4150_UNORDERED_COMPARE_FLAG = 1,
    _lodashequalByTagjs4150_PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var _lodashequalByTagjs4150_boolTag = '[object Boolean]',
    _lodashequalByTagjs4150_dateTag = '[object Date]',
    _lodashequalByTagjs4150_errorTag = '[object Error]',
    _lodashequalByTagjs4150_mapTag = '[object Map]',
    _lodashequalByTagjs4150_numberTag = '[object Number]',
    _lodashequalByTagjs4150_regexpTag = '[object RegExp]',
    _lodashequalByTagjs4150_setTag = '[object Set]',
    _lodashequalByTagjs4150_stringTag = '[object String]',
    _lodashequalByTagjs4150_symbolTag = '[object Symbol]';

var _lodashequalByTagjs4150_arrayBufferTag = '[object ArrayBuffer]',
    _lodashequalByTagjs4150_dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var _lodashequalByTagjs4150_symbolProto = _lodashequalByTagjs4150_Symbol ? _lodashequalByTagjs4150_Symbol.prototype : undefined,
    _lodashequalByTagjs4150_symbolValueOf = _lodashequalByTagjs4150_symbolProto ? _lodashequalByTagjs4150_symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashequalByTagjs4150_equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case _lodashequalByTagjs4150_dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case _lodashequalByTagjs4150_arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new _lodashequalByTagjs4150_Uint8Array(object), new _lodashequalByTagjs4150_Uint8Array(other))) {
        return false;
      }
      return true;

    case _lodashequalByTagjs4150_boolTag:
    case _lodashequalByTagjs4150_dateTag:
    case _lodashequalByTagjs4150_numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return _lodashequalByTagjs4150_eq(+object, +other);

    case _lodashequalByTagjs4150_errorTag:
      return object.name == other.name && object.message == other.message;

    case _lodashequalByTagjs4150_regexpTag:
    case _lodashequalByTagjs4150_stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case _lodashequalByTagjs4150_mapTag:
      var convert = _lodashequalByTagjs4150_mapToArray;

    case _lodashequalByTagjs4150_setTag:
      var isPartial = bitmask & _lodashequalByTagjs4150_PARTIAL_COMPARE_FLAG;
      convert || (convert = _lodashequalByTagjs4150_setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= _lodashequalByTagjs4150_UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _lodashequalByTagjs4150_equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case _lodashequalByTagjs4150_symbolTag:
      if (_lodashequalByTagjs4150_symbolValueOf) {
        return _lodashequalByTagjs4150_symbolValueOf.call(object) == _lodashequalByTagjs4150_symbolValueOf.call(other);
      }
  }
  return false;
}

$m['lodash/_equalByTag.js#4.15.0'].exports = _lodashequalByTagjs4150_equalByTag;
/*≠≠ node_modules/lodash/_equalByTag.js ≠≠*/

/*== node_modules/lodash/_stackSet.js ==*/
$m['lodash/_stackSet.js#4.15.0'] = { exports: {} };
var _lodashstackSetjs4150_ListCache = $m['lodash/_ListCache.js#4.15.0'].exports,
    _lodashstackSetjs4150_Map = $m['lodash/_Map.js#4.15.0'].exports,
    _lodashstackSetjs4150_MapCache = $m['lodash/_MapCache.js#4.15.0'].exports;

/** Used as the size to enable large array optimizations. */
var _lodashstackSetjs4150_LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function _lodashstackSetjs4150_stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof _lodashstackSetjs4150_ListCache) {
    var pairs = cache.__data__;
    if (!_lodashstackSetjs4150_Map || pairs.length < _lodashstackSetjs4150_LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new _lodashstackSetjs4150_MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

$m['lodash/_stackSet.js#4.15.0'].exports = _lodashstackSetjs4150_stackSet;
/*≠≠ node_modules/lodash/_stackSet.js ≠≠*/

/*== node_modules/lodash/_stackHas.js ==*/
$m['lodash/_stackHas.js#4.15.0'] = { exports: {} };
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function _lodashstackHasjs4150_stackHas(key) {
  return this.__data__.has(key);
}

$m['lodash/_stackHas.js#4.15.0'].exports = _lodashstackHasjs4150_stackHas;
/*≠≠ node_modules/lodash/_stackHas.js ≠≠*/

/*== node_modules/lodash/_stackGet.js ==*/
$m['lodash/_stackGet.js#4.15.0'] = { exports: {} };
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function _lodashstackGetjs4150_stackGet(key) {
  return this.__data__.get(key);
}

$m['lodash/_stackGet.js#4.15.0'].exports = _lodashstackGetjs4150_stackGet;
/*≠≠ node_modules/lodash/_stackGet.js ≠≠*/

/*== node_modules/lodash/_stackDelete.js ==*/
$m['lodash/_stackDelete.js#4.15.0'] = { exports: {} };
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function _lodashstackDeletejs4150_stackDelete(key) {
  return this.__data__['delete'](key);
}

$m['lodash/_stackDelete.js#4.15.0'].exports = _lodashstackDeletejs4150_stackDelete;
/*≠≠ node_modules/lodash/_stackDelete.js ≠≠*/

/*== node_modules/lodash/_stackClear.js ==*/
$m['lodash/_stackClear.js#4.15.0'] = { exports: {} };
var _lodashstackClearjs4150_ListCache = $m['lodash/_ListCache.js#4.15.0'].exports;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function _lodashstackClearjs4150_stackClear() {
  this.__data__ = new _lodashstackClearjs4150_ListCache();
}

$m['lodash/_stackClear.js#4.15.0'].exports = _lodashstackClearjs4150_stackClear;
/*≠≠ node_modules/lodash/_stackClear.js ≠≠*/

/*== node_modules/lodash/_Stack.js ==*/
$m['lodash/_Stack.js#4.15.0'] = { exports: {} };
var _lodashStackjs4150_ListCache = $m['lodash/_ListCache.js#4.15.0'].exports,
    _lodashStackjs4150_stackClear = $m['lodash/_stackClear.js#4.15.0'].exports,
    _lodashStackjs4150_stackDelete = $m['lodash/_stackDelete.js#4.15.0'].exports,
    _lodashStackjs4150_stackGet = $m['lodash/_stackGet.js#4.15.0'].exports,
    _lodashStackjs4150_stackHas = $m['lodash/_stackHas.js#4.15.0'].exports,
    _lodashStackjs4150_stackSet = $m['lodash/_stackSet.js#4.15.0'].exports;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function _lodashStackjs4150_Stack(entries) {
  this.__data__ = new _lodashStackjs4150_ListCache(entries);
}

// Add methods to `Stack`.
_lodashStackjs4150_Stack.prototype.clear = _lodashStackjs4150_stackClear;
_lodashStackjs4150_Stack.prototype['delete'] = _lodashStackjs4150_stackDelete;
_lodashStackjs4150_Stack.prototype.get = _lodashStackjs4150_stackGet;
_lodashStackjs4150_Stack.prototype.has = _lodashStackjs4150_stackHas;
_lodashStackjs4150_Stack.prototype.set = _lodashStackjs4150_stackSet;

$m['lodash/_Stack.js#4.15.0'].exports = _lodashStackjs4150_Stack;
/*≠≠ node_modules/lodash/_Stack.js ≠≠*/

/*== node_modules/lodash/_baseIsEqualDeep.js ==*/
$m['lodash/_baseIsEqualDeep.js#4.15.0'] = { exports: {} };
var _lodashbaseIsEqualDeepjs4150_Stack = $m['lodash/_Stack.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_equalArrays = $m['lodash/_equalArrays.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_equalByTag = $m['lodash/_equalByTag.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_equalObjects = $m['lodash/_equalObjects.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_getTag = $m['lodash/_getTag.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_isHostObject = $m['lodash/_isHostObject.js#4.15.0'].exports,
    _lodashbaseIsEqualDeepjs4150_isTypedArray = $m['lodash/isTypedArray.js#4.15.0'].exports;

/** Used to compose bitmasks for comparison styles. */
var _lodashbaseIsEqualDeepjs4150_PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var _lodashbaseIsEqualDeepjs4150_argsTag = '[object Arguments]',
    _lodashbaseIsEqualDeepjs4150_arrayTag = '[object Array]',
    _lodashbaseIsEqualDeepjs4150_objectTag = '[object Object]';

/** Used for built-in method references. */
var _lodashbaseIsEqualDeepjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseIsEqualDeepjs4150_hasOwnProperty = _lodashbaseIsEqualDeepjs4150_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function _lodashbaseIsEqualDeepjs4150_baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = _lodashbaseIsEqualDeepjs4150_isArray(object),
      othIsArr = _lodashbaseIsEqualDeepjs4150_isArray(other),
      objTag = _lodashbaseIsEqualDeepjs4150_arrayTag,
      othTag = _lodashbaseIsEqualDeepjs4150_arrayTag;

  if (!objIsArr) {
    objTag = _lodashbaseIsEqualDeepjs4150_getTag(object);
    objTag = objTag == _lodashbaseIsEqualDeepjs4150_argsTag ? _lodashbaseIsEqualDeepjs4150_objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = _lodashbaseIsEqualDeepjs4150_getTag(other);
    othTag = othTag == _lodashbaseIsEqualDeepjs4150_argsTag ? _lodashbaseIsEqualDeepjs4150_objectTag : othTag;
  }
  var objIsObj = objTag == _lodashbaseIsEqualDeepjs4150_objectTag && !_lodashbaseIsEqualDeepjs4150_isHostObject(object),
      othIsObj = othTag == _lodashbaseIsEqualDeepjs4150_objectTag && !_lodashbaseIsEqualDeepjs4150_isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new _lodashbaseIsEqualDeepjs4150_Stack());
    return objIsArr || _lodashbaseIsEqualDeepjs4150_isTypedArray(object) ? _lodashbaseIsEqualDeepjs4150_equalArrays(object, other, equalFunc, customizer, bitmask, stack) : _lodashbaseIsEqualDeepjs4150_equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & _lodashbaseIsEqualDeepjs4150_PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && _lodashbaseIsEqualDeepjs4150_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _lodashbaseIsEqualDeepjs4150_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _lodashbaseIsEqualDeepjs4150_Stack());
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _lodashbaseIsEqualDeepjs4150_Stack());
  return _lodashbaseIsEqualDeepjs4150_equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

$m['lodash/_baseIsEqualDeep.js#4.15.0'].exports = _lodashbaseIsEqualDeepjs4150_baseIsEqualDeep;
/*≠≠ node_modules/lodash/_baseIsEqualDeep.js ≠≠*/

/*== node_modules/lodash/_baseIsEqual.js ==*/
$m['lodash/_baseIsEqual.js#4.15.0'] = { exports: {} };
var _lodashbaseIsEqualjs4150_baseIsEqualDeep = $m['lodash/_baseIsEqualDeep.js#4.15.0'].exports,
    _lodashbaseIsEqualjs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseIsEqualjs4150_isObjectLike = $m['lodash/isObjectLike.js#4.15.0'].exports;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function _lodashbaseIsEqualjs4150_baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !_lodashbaseIsEqualjs4150_isObject(value) && !_lodashbaseIsEqualjs4150_isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return _lodashbaseIsEqualjs4150_baseIsEqualDeep(value, other, _lodashbaseIsEqualjs4150_baseIsEqual, customizer, bitmask, stack);
}

$m['lodash/_baseIsEqual.js#4.15.0'].exports = _lodashbaseIsEqualjs4150_baseIsEqual;
/*≠≠ node_modules/lodash/_baseIsEqual.js ≠≠*/

/*== node_modules/lodash/isEqual.js ==*/
$m['lodash/isEqual.js#4.15.0'] = { exports: {} };
var _lodashisEqualjs4150_baseIsEqual = $m['lodash/_baseIsEqual.js#4.15.0'].exports;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function _lodashisEqualjs4150_isEqual(value, other) {
  return _lodashisEqualjs4150_baseIsEqual(value, other);
}

$m['lodash/isEqual.js#4.15.0'].exports = _lodashisEqualjs4150_isEqual;
/*≠≠ node_modules/lodash/isEqual.js ≠≠*/

/*== lib/utils/string.js ==*/
$m['lib/utils/string.js'] = { exports: {} };
'use strict';

const _libutilsstringjs_isEqual = $m['lodash/isEqual.js#4.15.0'].exports;
const _libutilsstringjs_unique = $m['lodash/uniqWith.js#4.15.0'].exports;

// Line starting with '//'
const _libutilsstringjs_RE_COMMENT_SINGLE_LINE = /^\s*(?:\/\/|#).+$/gm;
// Multi line block '/** ... */'
const _libutilsstringjs_RE_COMMENT_MULTI_LINES = /((?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/))$/gm;
const _libutilsstringjs_SEG_LENGTH = 30;

$m['lib/utils/string.js'].exports = {
  /**
   * Strip comments from 'str'
   * @param {String} str
   * @returns {String}
   */
  commentStrip(str) {
    // Remove commented lines
    str = str.replace(_libutilsstringjs_RE_COMMENT_SINGLE_LINE, '');
    str = str.replace(_libutilsstringjs_RE_COMMENT_MULTI_LINES, '');
    return str;
  },

  /**
   * Wrap 'str' in comment based on 'type'
   * @param {String} str
   * @param {String} type
   * @returns {String}
   */
  commentWrap(str, type) {
    let open, close;

    if (type == 'html') {
      open = '<!-- ';
      close = ' -->';
    } else {
      open = '/* ';
      close = ' */';
    }

    return open + str + close;
  },

  /**
   * Match unique occurrences in 'str'
   * @param {String} str
   * @param {RegExp} regexp
   * @returns {Array}
   */
  uniqueMatch(str, regexp) {
    let results = [];
    let match;

    while (match = regexp.exec(str)) {
      results.push({
        context: match[0],
        match: match[1] || ''
      });
    }

    // Filter duplicates
    return _libutilsstringjs_unique(results, _libutilsstringjs_isEqual);
  },

  /**
   * Escape 'str' for use in RegExp constructor
   * @param {String} str
   * @returns {String}
   */
  regexpEscape(str) {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  },

  /**
   * Truncate 'str'
   * @param {String} str
   * @returns {String}
   */
  truncate(str) {
    if (str.length > _libutilsstringjs_SEG_LENGTH * 2 + 3) {
      return str.slice(0, _libutilsstringjs_SEG_LENGTH) + '...' + str.slice(-_libutilsstringjs_SEG_LENGTH);
    }

    return str;
  }
};
/*≠≠ lib/utils/string.js ≠≠*/

/*== lib/utils/env.js ==*/
$m['lib/utils/env.js'] = { exports: {} };
'use strict';

const _libutilsenvjs_path = require('path');

const _libutilsenvjs_RE_ILLEGAL_ID = /[\- .*]/g;

/**
 * Set BUDDY env 'key'
 * @param {String} key
 * @param {String|Array} value
 * @param {String} [id]
 */
$m['lib/utils/env.js'].exports = function env(key, value, id) {
  id = id != null ? id.replace(_libutilsenvjs_RE_ILLEGAL_ID, '').toUpperCase() + '_' : '';

  if (Array.isArray(value)) {
    value = value.reduce((value, item) => {
      const isFile = 'object' == typeof item && 'extension' in item;

      switch (key) {
        case 'INPUT':
          value += isFile ? _libutilsenvjs_path.relative(process.cwd(), item.filepath) : item;
          break;
        case 'INPUT_HASH':
          value += isFile ? item.hash : item;
          break;
        case 'INPUT_DATE':
          value += isFile ? item.date : item;
          break;
        case 'OUTPUT':
          value += _libutilsenvjs_path.relative(process.cwd(), item);
          break;
        case 'OUTPUT_HASH':
        case 'OUTPUT_DATE':
          value += item;
          break;
      }

      return value;
    }, '');
  }

  process.env[`BUDDY_${ id }${ key }`] = value;
};
/*≠≠ lib/utils/env.js ≠≠*/

/*== node_modules/supports-color/index.js ==*/
$m['supports-color/index.js#2.0.0'] = { exports: {} };
'use strict';

var _supportscolorindexjs200_argv = process.argv;

var _supportscolorindexjs200_terminator = _supportscolorindexjs200_argv.indexOf('--');
var _supportscolorindexjs200_hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = _supportscolorindexjs200_argv.indexOf(flag);
	return pos !== -1 && (_supportscolorindexjs200_terminator !== -1 ? pos < _supportscolorindexjs200_terminator : true);
};

$m['supports-color/index.js#2.0.0'].exports = function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (_supportscolorindexjs200_hasFlag('no-color') || _supportscolorindexjs200_hasFlag('no-colors') || _supportscolorindexjs200_hasFlag('color=false')) {
		return false;
	}

	if (_supportscolorindexjs200_hasFlag('color') || _supportscolorindexjs200_hasFlag('colors') || _supportscolorindexjs200_hasFlag('color=true') || _supportscolorindexjs200_hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
}();
/*≠≠ node_modules/supports-color/index.js ≠≠*/

/*== node_modules/ansi-regex/index.js ==*/
$m['ansi-regex/index.js#2.0.0'] = { exports: {} };
'use strict';

$m['ansi-regex/index.js#2.0.0'].exports = function () {
	return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g
	);
};
/*≠≠ node_modules/ansi-regex/index.js ≠≠*/

/*== node_modules/has-ansi/index.js ==*/
$m['has-ansi/index.js#2.0.0'] = { exports: {} };
'use strict';

var _hasansiindexjs200_ansiRegex = $m['ansi-regex/index.js#2.0.0'].exports;
var _hasansiindexjs200_re = new RegExp(_hasansiindexjs200_ansiRegex().source); // remove the `g` flag
$m['has-ansi/index.js#2.0.0'].exports = _hasansiindexjs200_re.test.bind(_hasansiindexjs200_re);
/*≠≠ node_modules/has-ansi/index.js ≠≠*/

/*== node_modules/strip-ansi/index.js ==*/
$m['strip-ansi/index.js#3.0.1'] = { exports: {} };
'use strict';

var _stripansiindexjs301_ansiRegex = $m['ansi-regex/index.js#2.0.0'].exports();

$m['strip-ansi/index.js#3.0.1'].exports = function (str) {
	return typeof str === 'string' ? str.replace(_stripansiindexjs301_ansiRegex, '') : str;
};
/*≠≠ node_modules/strip-ansi/index.js ≠≠*/

/*== node_modules/ansi-styles/index.js ==*/
$m['ansi-styles/index.js#2.2.1'] = { exports: {} };
'use strict';

function _ansistylesindexjs221_assembleStyles() {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty($m['ansi-styles/index.js#2.2.1'], 'exports', {
	enumerable: true,
	get: _ansistylesindexjs221_assembleStyles
});
/*≠≠ node_modules/ansi-styles/index.js ≠≠*/

/*== node_modules/escape-string-regexp/index.js ==*/
$m['escape-string-regexp/index.js#1.0.5'] = { exports: {} };
'use strict';

var _escapestringregexpindexjs105_matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

$m['escape-string-regexp/index.js#1.0.5'].exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(_escapestringregexpindexjs105_matchOperatorsRe, '\\$&');
};
/*≠≠ node_modules/escape-string-regexp/index.js ≠≠*/

/*== node_modules/chalk/index.js ==*/
$m['chalk/index.js#1.1.3'] = { exports: {} };
'use strict';

var _chalkindexjs113_escapeStringRegexp = $m['escape-string-regexp/index.js#1.0.5'].exports;
var _chalkindexjs113_ansiStyles = $m['ansi-styles/index.js#2.2.1'].exports;
var _chalkindexjs113_stripAnsi = $m['strip-ansi/index.js#3.0.1'].exports;
var _chalkindexjs113_hasAnsi = $m['has-ansi/index.js#2.0.0'].exports;
var _chalkindexjs113_supportsColor = $m['supports-color/index.js#2.0.0'].exports;
var _chalkindexjs113_defineProps = Object.defineProperties;
var _chalkindexjs113_isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function _chalkindexjs113_Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? _chalkindexjs113_supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (_chalkindexjs113_isSimpleWindowsTerm) {
	_chalkindexjs113_ansiStyles.blue.open = '\u001b[94m';
}

var _chalkindexjs113_styles = function () {
	var ret = {};

	Object.keys(_chalkindexjs113_ansiStyles).forEach(function (key) {
		_chalkindexjs113_ansiStyles[key].closeRe = new RegExp(_chalkindexjs113_escapeStringRegexp(_chalkindexjs113_ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return _chalkindexjs113_build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
}();

var _chalkindexjs113_proto = _chalkindexjs113_defineProps(function chalk() {}, _chalkindexjs113_styles);

function _chalkindexjs113_build(_styles) {
	var builder = function () {
		return _chalkindexjs113_applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = _chalkindexjs113_proto;

	return builder;
}

function _chalkindexjs113_applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = _chalkindexjs113_ansiStyles.dim.open;
	if (_chalkindexjs113_isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		_chalkindexjs113_ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = _chalkindexjs113_ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	_chalkindexjs113_ansiStyles.dim.open = originalDim;

	return str;
}

function _chalkindexjs113_init() {
	var ret = {};

	Object.keys(_chalkindexjs113_styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return _chalkindexjs113_build.call(this, [name]);
			}
		};
	});

	return ret;
}

_chalkindexjs113_defineProps(_chalkindexjs113_Chalk.prototype, _chalkindexjs113_init());

$m['chalk/index.js#1.1.3'].exports = new _chalkindexjs113_Chalk();
$m['chalk/index.js#1.1.3'].exports.styles = _chalkindexjs113_ansiStyles;
$m['chalk/index.js#1.1.3'].exports.hasColor = _chalkindexjs113_hasAnsi;
$m['chalk/index.js#1.1.3'].exports.stripColor = _chalkindexjs113_stripAnsi;
$m['chalk/index.js#1.1.3'].exports.supportsColor = _chalkindexjs113_supportsColor;
/*≠≠ node_modules/chalk/index.js ≠≠*/

/*== lib/utils/cnsl.js ==*/
$m['lib/utils/cnsl.js'] = { exports: {} };
'use strict';

const _libutilscnsljs_chalk = $m['chalk/index.js#1.1.3'].exports;

const _libutilscnsljs_TOO_LONG = 10;

const _libutilscnsljs_start = process.hrtime();
let _libutilscnsljs_last = null;
let _libutilscnsljs_timers = {};

$m['lib/utils/cnsl.js'].exports.BELL = '\x07';
// Silent during testing by default
$m['lib/utils/cnsl.js'].exports.silent = process.env.NODE_ENV == 'test';
$m['lib/utils/cnsl.js'].exports.verbose = false;

/**
 * Start tracking duration of event 'id'
 * @param {String} id
 */
$m['lib/utils/cnsl.js'].exports.start = function (id) {
  _libutilscnsljs_timers[id] = process.hrtime();
};

/**
 * Stop tracking duration of event 'id'
 * @param {String} id
 * @returns {Number}
 */
$m['lib/utils/cnsl.js'].exports.stop = function (id) {
  const ms = _libutilscnsljs_msDiff(process.hrtime(), _libutilscnsljs_timers[id]);

  delete _libutilscnsljs_timers[id];

  return ms;
};

/**
 * Print 'msg' to console, with indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.print = function (msg, column) {
  if (column == null) column = 0;
  if (!$m['lib/utils/cnsl.js'].exports.silent) console.log($m['lib/utils/cnsl.js'].exports.indent(msg, column));
};

/**
 * Print 'err' to console, with error colour and indentation level
 * @param {Object|String} err
 * @param {Int} column
 * @param {Boolean} throws
 */
$m['lib/utils/cnsl.js'].exports.error = function (err, column, throws) {
  if (column == null) column = 0;
  if (throws == null) throws = true;
  if ('string' == typeof err) err = new Error(err);
  // Add beep when not throwing
  if (!throws) err.message += $m['lib/utils/cnsl.js'].exports.BELL;
  $m['lib/utils/cnsl.js'].exports.print(_libutilscnsljs_chalk.bold.red('error ') + err.message + (err.filepath ? ' in ' + _libutilscnsljs_chalk.bold.grey(err.filepath) : ''), column);
  if (throws && !$m['lib/utils/cnsl.js'].exports.silent) throw err;
};

/**
 * Print 'msg' to console, with warning colour and indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.warn = function (msg, column) {
  if (column == null) column = 0;
  if ('string' instanceof Error) msg = msg.message;
  $m['lib/utils/cnsl.js'].exports.print(_libutilscnsljs_chalk.bold.yellow('warning ') + msg, column);
};

/**
 * Print 'msg' to console, with debug colour and indentation level
 * @param {String} msg
 * @param {Int} column
 */
$m['lib/utils/cnsl.js'].exports.debug = function (msg, column) {
  const now = process.hrtime();

  if (!_libutilscnsljs_last) _libutilscnsljs_last = now;

  const ellapsed = _libutilscnsljs_msDiff(now, _libutilscnsljs_last);

  if (column == null) column = 0;
  if ($m['lib/utils/cnsl.js'].exports.verbose) {
    msg = _libutilscnsljs_chalk.cyan('+') + _libutilscnsljs_chalk.bold.grey((ellapsed > _libutilscnsljs_TOO_LONG ? _libutilscnsljs_chalk.red(ellapsed) : ellapsed) + 'ms') + _libutilscnsljs_chalk.cyan('::') + _libutilscnsljs_chalk.bold.grey(_libutilscnsljs_msDiff(now, _libutilscnsljs_start) + 'ms') + _libutilscnsljs_chalk.cyan('=') + msg;
    $m['lib/utils/cnsl.js'].exports.print(msg, column);
  }
  _libutilscnsljs_last = now;
};

/**
 * Colourize 'string' for emphasis
 * @param {String} string
 * @returns {String}
 */
$m['lib/utils/cnsl.js'].exports.strong = function (string) {
  return _libutilscnsljs_chalk.bold.grey(string);
};

/**
 * Indent the given 'string' a specific number of spaces
 * @param {String} string
 * @param {Int} column
 * @returns {String}
 */
$m['lib/utils/cnsl.js'].exports.indent = function (string, column) {
  const spaces = new Array(++column).join('  ');

  return string.replace(/^/gm, spaces);
};

/**
 * Retrieve difference in ms
 * @param {Array} t1
 * @param {Array} t2
 * @returns {Number}
 */
function _libutilscnsljs_msDiff(t1, t2) {
  t1 = (t1[0] * 1e9 + t1[1]) / 1e6;
  t2 = (t2[0] * 1e9 + t2[1]) / 1e6;
  return Math.ceil((t1 - t2) * 100) / 100;
}
/*≠≠ lib/utils/cnsl.js ≠≠*/

/*== lib/utils/callable.js ==*/
$m['lib/utils/callable.js'] = { exports: {} };
'use strict';

/**
 * Retrieve callable function 'fn' with 'context' and optional 'args'
 * @param {Object} context
 * @param {Function} fn
 * @param {Array} args
 * @returns {Function}
 */

$m['lib/utils/callable.js'].exports = function callable(context, fn, ...args) {
  return function callableFunction(...moreArgs) {
    context[fn].call(context, ...args, ...moreArgs);
  };
};
/*≠≠ lib/utils/callable.js ≠≠*/

/*== lib/utils/index.js ==*/
$m['lib/utils/index.js'] = { exports: {} };
'use strict';

$m['lib/utils/index.js'].exports = {
  callable: $m['lib/utils/callable.js'].exports,
  cnsl: $m['lib/utils/cnsl.js'].exports,
  env: $m['lib/utils/env.js'].exports,
  string: $m['lib/utils/string.js'].exports
};
/*≠≠ lib/utils/index.js ≠≠*/

/*== node_modules/async/internal/doLimit.js ==*/
$m['async/internal/doLimit.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/doLimit.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/doLimit.js#2.0.1'].exports.default = _asyncinternaldoLimitjs201_doLimit;
function _asyncinternaldoLimitjs201_doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}
$m['async/internal/doLimit.js#2.0.1'].exports = $m['async/internal/doLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/doLimit.js ≠≠*/

/*== node_modules/async/internal/onlyOnce.js ==*/
$m['async/internal/onlyOnce.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/onlyOnce.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/onlyOnce.js#2.0.1'].exports.default = _asyncinternalonlyOncejs201_onlyOnce;
function _asyncinternalonlyOncejs201_onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
$m['async/internal/onlyOnce.js#2.0.1'].exports = $m['async/internal/onlyOnce.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/onlyOnce.js ≠≠*/

/*== node_modules/async/internal/getIterator.js ==*/
$m['async/internal/getIterator.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/getIterator.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/internal/getIterator.js#2.0.1'].exports.default = function (coll) {
    return _asyncinternalgetIteratorjs201_iteratorSymbol && coll[_asyncinternalgetIteratorjs201_iteratorSymbol] && coll[_asyncinternalgetIteratorjs201_iteratorSymbol]();
};

var _asyncinternalgetIteratorjs201_iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

$m['async/internal/getIterator.js#2.0.1'].exports = $m['async/internal/getIterator.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/getIterator.js ≠≠*/

/*== node_modules/async/internal/iterator.js ==*/
$m['async/internal/iterator.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/iterator.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/iterator.js#2.0.1'].exports.default = _asyncinternaliteratorjs201_iterator;

var _asyncinternaliteratorjs201__isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports;

var _asyncinternaliteratorjs201__isArrayLike2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__isArrayLike);

var _asyncinternaliteratorjs201__getIterator = $m['async/internal/getIterator.js#2.0.1'].exports;

var _asyncinternaliteratorjs201__getIterator2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__getIterator);

var _asyncinternaliteratorjs201__keys = $m['lodash/keys.js#4.15.0'].exports;

var _asyncinternaliteratorjs201__keys2 = _asyncinternaliteratorjs201__interopRequireDefault(_asyncinternaliteratorjs201__keys);

function _asyncinternaliteratorjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternaliteratorjs201_createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function _asyncinternaliteratorjs201_createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function _asyncinternaliteratorjs201_createObjectIterator(obj) {
    var okeys = (0, _asyncinternaliteratorjs201__keys2.default)(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key: key } : null;
    };
}

function _asyncinternaliteratorjs201_iterator(coll) {
    if ((0, _asyncinternaliteratorjs201__isArrayLike2.default)(coll)) {
        return _asyncinternaliteratorjs201_createArrayIterator(coll);
    }

    var iterator = (0, _asyncinternaliteratorjs201__getIterator2.default)(coll);
    return iterator ? _asyncinternaliteratorjs201_createES2015Iterator(iterator) : _asyncinternaliteratorjs201_createObjectIterator(coll);
}
$m['async/internal/iterator.js#2.0.1'].exports = $m['async/internal/iterator.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/iterator.js ≠≠*/

/*== node_modules/async/internal/once.js ==*/
$m['async/internal/once.js#2.0.1'] = { exports: {} };
"use strict";

Object.defineProperty($m['async/internal/once.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/once.js#2.0.1'].exports.default = _asyncinternaloncejs201_once;
function _asyncinternaloncejs201_once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
$m['async/internal/once.js#2.0.1'].exports = $m['async/internal/once.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/once.js ≠≠*/

/*== node_modules/async/internal/eachOfLimit.js ==*/
$m['async/internal/eachOfLimit.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/eachOfLimit.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/eachOfLimit.js#2.0.1'].exports.default = _asyncinternaleachOfLimitjs201__eachOfLimit;

var _asyncinternaleachOfLimitjs201__noop = $m['lodash/noop.js#4.15.0'].exports;

var _asyncinternaleachOfLimitjs201__noop2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__noop);

var _asyncinternaleachOfLimitjs201__once = $m['async/internal/once.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__once2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__once);

var _asyncinternaleachOfLimitjs201__iterator = $m['async/internal/iterator.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__iterator2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__iterator);

var _asyncinternaleachOfLimitjs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asyncinternaleachOfLimitjs201__onlyOnce2 = _asyncinternaleachOfLimitjs201__interopRequireDefault(_asyncinternaleachOfLimitjs201__onlyOnce);

function _asyncinternaleachOfLimitjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternaleachOfLimitjs201__eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = (0, _asyncinternaleachOfLimitjs201__once2.default)(callback || _asyncinternaleachOfLimitjs201__noop2.default);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = (0, _asyncinternaleachOfLimitjs201__iterator2.default)(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (done && running <= 0) {
                return callback(null);
            } else {
                replenish();
            }
        }

        function replenish() {
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _asyncinternaleachOfLimitjs201__onlyOnce2.default)(iterateeCallback));
            }
        }

        replenish();
    };
}
$m['async/internal/eachOfLimit.js#2.0.1'].exports = $m['async/internal/eachOfLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/eachOfLimit.js ≠≠*/

/*== node_modules/async/eachOfLimit.js ==*/
$m['async/eachOfLimit.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOfLimit.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/eachOfLimit.js#2.0.1'].exports.default = _asynceachOfLimitjs201_eachOfLimit;

var _asynceachOfLimitjs201__eachOfLimit2 = $m['async/internal/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfLimitjs201__eachOfLimit3 = _asynceachOfLimitjs201__interopRequireDefault(_asynceachOfLimitjs201__eachOfLimit2);

function _asynceachOfLimitjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function _asynceachOfLimitjs201_eachOfLimit(coll, limit, iteratee, callback) {
  (0, _asynceachOfLimitjs201__eachOfLimit3.default)(limit)(coll, iteratee, callback);
}
$m['async/eachOfLimit.js#2.0.1'].exports = $m['async/eachOfLimit.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOfLimit.js ≠≠*/

/*== node_modules/async/eachOfSeries.js ==*/
$m['async/eachOfSeries.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOfSeries.js#2.0.1'].exports, "__esModule", {
  value: true
});

var _asynceachOfSeriesjs201__eachOfLimit = $m['async/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfSeriesjs201__eachOfLimit2 = _asynceachOfSeriesjs201__interopRequireDefault(_asynceachOfSeriesjs201__eachOfLimit);

var _asynceachOfSeriesjs201__doLimit = $m['async/internal/doLimit.js#2.0.1'].exports;

var _asynceachOfSeriesjs201__doLimit2 = _asynceachOfSeriesjs201__interopRequireDefault(_asynceachOfSeriesjs201__doLimit);

function _asynceachOfSeriesjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each item in `coll`. The
 * `key` is the item's key, or index in the case of an array. The iteratee is
 * passed a `callback(err)` which must be called once it has completed. If no
 * error has occurred, the callback should be run without arguments or with an
 * explicit `null` argument. Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
$m['async/eachOfSeries.js#2.0.1'].exports.default = (0, _asynceachOfSeriesjs201__doLimit2.default)(_asynceachOfSeriesjs201__eachOfLimit2.default, 1);
$m['async/eachOfSeries.js#2.0.1'].exports = $m['async/eachOfSeries.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOfSeries.js ≠≠*/

/*== node_modules/lodash/isSymbol.js ==*/
$m['lodash/isSymbol.js#4.15.0'] = { exports: {} };
var _lodashisSymboljs4150_isObjectLike = $m['lodash/isObjectLike.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashisSymboljs4150_symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var _lodashisSymboljs4150_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisSymboljs4150_objectToString = _lodashisSymboljs4150_objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function _lodashisSymboljs4150_isSymbol(value) {
  return typeof value == 'symbol' || _lodashisSymboljs4150_isObjectLike(value) && _lodashisSymboljs4150_objectToString.call(value) == _lodashisSymboljs4150_symbolTag;
}

$m['lodash/isSymbol.js#4.15.0'].exports = _lodashisSymboljs4150_isSymbol;
/*≠≠ node_modules/lodash/isSymbol.js ≠≠*/

/*== node_modules/lodash/toNumber.js ==*/
$m['lodash/toNumber.js#4.15.0'] = { exports: {} };
var _lodashtoNumberjs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashtoNumberjs4150_isSymbol = $m['lodash/isSymbol.js#4.15.0'].exports;

/** Used as references for various `Number` constants. */
var _lodashtoNumberjs4150_NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var _lodashtoNumberjs4150_reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var _lodashtoNumberjs4150_reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var _lodashtoNumberjs4150_reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var _lodashtoNumberjs4150_reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var _lodashtoNumberjs4150_freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function _lodashtoNumberjs4150_toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (_lodashtoNumberjs4150_isSymbol(value)) {
    return _lodashtoNumberjs4150_NAN;
  }
  if (_lodashtoNumberjs4150_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = _lodashtoNumberjs4150_isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(_lodashtoNumberjs4150_reTrim, '');
  var isBinary = _lodashtoNumberjs4150_reIsBinary.test(value);
  return isBinary || _lodashtoNumberjs4150_reIsOctal.test(value) ? _lodashtoNumberjs4150_freeParseInt(value.slice(2), isBinary ? 2 : 8) : _lodashtoNumberjs4150_reIsBadHex.test(value) ? _lodashtoNumberjs4150_NAN : +value;
}

$m['lodash/toNumber.js#4.15.0'].exports = _lodashtoNumberjs4150_toNumber;
/*≠≠ node_modules/lodash/toNumber.js ≠≠*/

/*== node_modules/lodash/toFinite.js ==*/
$m['lodash/toFinite.js#4.15.0'] = { exports: {} };
var _lodashtoFinitejs4150_toNumber = $m['lodash/toNumber.js#4.15.0'].exports;

/** Used as references for various `Number` constants. */
var _lodashtoFinitejs4150_INFINITY = 1 / 0,
    _lodashtoFinitejs4150_MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function _lodashtoFinitejs4150_toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = _lodashtoFinitejs4150_toNumber(value);
  if (value === _lodashtoFinitejs4150_INFINITY || value === -_lodashtoFinitejs4150_INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * _lodashtoFinitejs4150_MAX_INTEGER;
  }
  return value === value ? value : 0;
}

$m['lodash/toFinite.js#4.15.0'].exports = _lodashtoFinitejs4150_toFinite;
/*≠≠ node_modules/lodash/toFinite.js ≠≠*/

/*== node_modules/lodash/toInteger.js ==*/
$m['lodash/toInteger.js#4.15.0'] = { exports: {} };
var _lodashtoIntegerjs4150_toFinite = $m['lodash/toFinite.js#4.15.0'].exports;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function _lodashtoIntegerjs4150_toInteger(value) {
  var result = _lodashtoIntegerjs4150_toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

$m['lodash/toInteger.js#4.15.0'].exports = _lodashtoIntegerjs4150_toInteger;
/*≠≠ node_modules/lodash/toInteger.js ≠≠*/

/*== node_modules/lodash/_apply.js ==*/
$m['lodash/_apply.js#4.15.0'] = { exports: {} };
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function _lodashapplyjs4150_apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

$m['lodash/_apply.js#4.15.0'].exports = _lodashapplyjs4150_apply;
/*≠≠ node_modules/lodash/_apply.js ≠≠*/

/*== node_modules/lodash/_baseRest.js ==*/
$m['lodash/_baseRest.js#4.15.0'] = { exports: {} };
var _lodashbaseRestjs4150_apply = $m['lodash/_apply.js#4.15.0'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashbaseRestjs4150_nativeMax = Math.max;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function _lodashbaseRestjs4150_baseRest(func, start) {
  start = _lodashbaseRestjs4150_nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = _lodashbaseRestjs4150_nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return _lodashbaseRestjs4150_apply(func, this, otherArgs);
  };
}

$m['lodash/_baseRest.js#4.15.0'].exports = _lodashbaseRestjs4150_baseRest;
/*≠≠ node_modules/lodash/_baseRest.js ≠≠*/

/*== node_modules/lodash/rest.js ==*/
$m['lodash/rest.js#4.15.0'] = { exports: {} };
var _lodashrestjs4150_baseRest = $m['lodash/_baseRest.js#4.15.0'].exports,
    _lodashrestjs4150_toInteger = $m['lodash/toInteger.js#4.15.0'].exports;

/** Used as the `TypeError` message for "Functions" methods. */
var _lodashrestjs4150_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function _lodashrestjs4150_rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(_lodashrestjs4150_FUNC_ERROR_TEXT);
  }
  start = start === undefined ? start : _lodashrestjs4150_toInteger(start);
  return _lodashrestjs4150_baseRest(func, start);
}

$m['lodash/rest.js#4.15.0'].exports = _lodashrestjs4150_rest;
/*≠≠ node_modules/lodash/rest.js ≠≠*/

/*== node_modules/async/internal/parallel.js ==*/
$m['async/internal/parallel.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/internal/parallel.js#2.0.1'].exports, "__esModule", {
    value: true
});
$m['async/internal/parallel.js#2.0.1'].exports.default = _asyncinternalparalleljs201__parallel;

var _asyncinternalparalleljs201__noop = $m['lodash/noop.js#4.15.0'].exports;

var _asyncinternalparalleljs201__noop2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__noop);

var _asyncinternalparalleljs201__isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports;

var _asyncinternalparalleljs201__isArrayLike2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__isArrayLike);

var _asyncinternalparalleljs201__rest = $m['lodash/rest.js#4.15.0'].exports;

var _asyncinternalparalleljs201__rest2 = _asyncinternalparalleljs201__interopRequireDefault(_asyncinternalparalleljs201__rest);

function _asyncinternalparalleljs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncinternalparalleljs201__parallel(eachfn, tasks, callback) {
    callback = callback || _asyncinternalparalleljs201__noop2.default;
    var results = (0, _asyncinternalparalleljs201__isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        task((0, _asyncinternalparalleljs201__rest2.default)(function (err, args) {
            if (args.length <= 1) {
                args = args[0];
            }
            results[key] = args;
            callback(err);
        }));
    }, function (err) {
        callback(err, results);
    });
}
$m['async/internal/parallel.js#2.0.1'].exports = $m['async/internal/parallel.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/internal/parallel.js ≠≠*/

/*== node_modules/async/series.js ==*/
$m['async/series.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/series.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/series.js#2.0.1'].exports.default = _asyncseriesjs201_series;

var _asyncseriesjs201__parallel = $m['async/internal/parallel.js#2.0.1'].exports;

var _asyncseriesjs201__parallel2 = _asyncseriesjs201__interopRequireDefault(_asyncseriesjs201__parallel);

var _asyncseriesjs201__eachOfSeries = $m['async/eachOfSeries.js#2.0.1'].exports;

var _asyncseriesjs201__eachOfSeries2 = _asyncseriesjs201__interopRequireDefault(_asyncseriesjs201__eachOfSeries);

function _asyncseriesjs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run, each
 * function is passed a `callback(err, result)` it must call on completion with
 * an error `err` (which can be `null`) and an optional `result` value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function _asyncseriesjs201_series(tasks, callback) {
  (0, _asyncseriesjs201__parallel2.default)(_asyncseriesjs201__eachOfSeries2.default, tasks, callback);
}
$m['async/series.js#2.0.1'].exports = $m['async/series.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/series.js ≠≠*/

/*== node_modules/lodash/_isFlattenable.js ==*/
$m['lodash/_isFlattenable.js#4.15.0'] = { exports: {} };
var _lodashisFlattenablejs4150_Symbol = $m['lodash/_Symbol.js#4.15.0'].exports,
    _lodashisFlattenablejs4150_isArguments = $m['lodash/isArguments.js#4.15.0'].exports,
    _lodashisFlattenablejs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports;

/** Built-in value references. */
var _lodashisFlattenablejs4150_spreadableSymbol = _lodashisFlattenablejs4150_Symbol ? _lodashisFlattenablejs4150_Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function _lodashisFlattenablejs4150_isFlattenable(value) {
    return _lodashisFlattenablejs4150_isArray(value) || _lodashisFlattenablejs4150_isArguments(value) || !!(_lodashisFlattenablejs4150_spreadableSymbol && value && value[_lodashisFlattenablejs4150_spreadableSymbol]);
}

$m['lodash/_isFlattenable.js#4.15.0'].exports = _lodashisFlattenablejs4150_isFlattenable;
/*≠≠ node_modules/lodash/_isFlattenable.js ≠≠*/

/*== node_modules/lodash/_arrayPush.js ==*/
$m['lodash/_arrayPush.js#4.15.0'] = { exports: {} };
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function _lodasharrayPushjs4150_arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

$m['lodash/_arrayPush.js#4.15.0'].exports = _lodasharrayPushjs4150_arrayPush;
/*≠≠ node_modules/lodash/_arrayPush.js ≠≠*/

/*== node_modules/lodash/_baseFlatten.js ==*/
$m['lodash/_baseFlatten.js#4.15.0'] = { exports: {} };
var _lodashbaseFlattenjs4150_arrayPush = $m['lodash/_arrayPush.js#4.15.0'].exports,
    _lodashbaseFlattenjs4150_isFlattenable = $m['lodash/_isFlattenable.js#4.15.0'].exports;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function _lodashbaseFlattenjs4150_baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _lodashbaseFlattenjs4150_isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        _lodashbaseFlattenjs4150_baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _lodashbaseFlattenjs4150_arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

$m['lodash/_baseFlatten.js#4.15.0'].exports = _lodashbaseFlattenjs4150_baseFlatten;
/*≠≠ node_modules/lodash/_baseFlatten.js ≠≠*/

/*== node_modules/lodash/flatten.js ==*/
$m['lodash/flatten.js#4.15.0'] = { exports: {} };
var _lodashflattenjs4150_baseFlatten = $m['lodash/_baseFlatten.js#4.15.0'].exports;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function _lodashflattenjs4150_flatten(array) {
  var length = array ? array.length : 0;
  return length ? _lodashflattenjs4150_baseFlatten(array, 1) : [];
}

$m['lodash/flatten.js#4.15.0'].exports = _lodashflattenjs4150_flatten;
/*≠≠ node_modules/lodash/flatten.js ≠≠*/

/*== lib/plugins/react/index.js ==*/
$m['lib/plugins/react/index.js'] = { exports: {} };
'use strict';

const _libpluginsreactindexjs_FILE_EXTENSIONS = ['jsx'];
const _libpluginsreactindexjs_PLUGINS = ['babel-plugin-syntax-jsx', 'babel-plugin-transform-react-display-name', 'babel-plugin-transform-react-jsx'];

$m['lib/plugins/react/index.js'].exports = {
  name: 'react',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileExtensionsForType(_libpluginsreactindexjs_FILE_EXTENSIONS, this.type);
    config.registerTargetVersionForType(this.name, _libpluginsreactindexjs_PLUGINS, this.type);
  }
};
/*≠≠ lib/plugins/react/index.js ≠≠*/

/*== lib/plugins/json/index.js ==*/
$m['lib/plugins/json/index.js'] = { exports: {} };
'use strict';

const _libpluginsjsonindexjs_FILE_EXTENSIONS = ['json'];
const _libpluginsjsonindexjs_WORKFLOW_STANDARD = ['load'];

$m['lib/plugins/json/index.js'].exports = {
  name: 'json',
  type: 'json',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    // Allow json files to be parsed as js also
    config.registerFileExtensionsForType(_libpluginsjsonindexjs_FILE_EXTENSIONS, 'js');
    config.registerFileDefinitionAndExtensionsForType(_libpluginsjsonindexjs_define, _libpluginsjsonindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsjsonindexjs_define(File, utils) {
  return class JSONFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'json', options);

      this.workflows.standard = [_libpluginsjsonindexjs_WORKFLOW_STANDARD];
      // No processing required
      this.workflows.inlineable = [[]];
    }
  };
}
/*≠≠ lib/plugins/json/index.js ≠≠*/

/*== lib/plugins/js/index.js ==*/
$m['lib/plugins/js/index.js'] = { exports: {} };
'use strict';

const { commentStrip: _libpluginsjsindexjs_commentStrip, uniqueMatch: _libpluginsjsindexjs_uniqueMatch } = require('../../utils/string');
const { debug: _libpluginsjsindexjs_debug, strong: _libpluginsjsindexjs_strong } = require('../../utils/cnsl');
const _libpluginsjsindexjs_concat = require('./concat');
const _libpluginsjsindexjs_flatten = require('./flatten');
const _libpluginsjsindexjs_inline = require('./inline');
const _libpluginsjsindexjs_replaceEnvironment = require('./replaceEnvironment');
const _libpluginsjsindexjs_replaceReferences = require('./replaceReferences');
const _libpluginsjsindexjs_transpile = require('./transpile');

const _libpluginsjsindexjs_FILE_EXTENSIONS = ['js'];
const _libpluginsjsindexjs_HEADER = '/** BUDDY BUILT **/';
const _libpluginsjsindexjs_RE_BUDDY_BUILT = /^\/\*\* BUDDY BUILT \*\*\//;
const _libpluginsjsindexjs_RE_BROWSERIFY_BUILT = /function\(require,\s?module,\s?exports\)|__webpack_require__/;
const _libpluginsjsindexjs_RE_HELPER = /babelHelpers\.([a-zA-Z]+)\(/gm;
const _libpluginsjsindexjs_RE_REQUIRE = /require\(['"]([^'"]+)[^)]+\)/g;
const _libpluginsjsindexjs_RE_WEBPACK_BUILT = /__we[a-z]ack_require__/;
const _libpluginsjsindexjs_WORKFLOW_STANDARD = ['runWorkflowForDependencies', '!watchOnly:replaceEnvironment', '!watchOnly:bundle:replaceReferences', '!watchOnly:inline', '!watchOnly:transpile', '!watchOnly:bundle:flatten'];
const _libpluginsjsindexjs_WORKFLOW_INLINEABLE = ['load', 'replaceEnvironment', 'compress:compress'];
const _libpluginsjsindexjs_WORKFLOW_WRITEABLE = ['bundle:concat', 'compress:compress'];

$m['lib/plugins/js/index.js'].exports = {
  name: 'js',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginsjsindexjs_define, _libpluginsjsindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsjsindexjs_define(File, utils) {
  return class JSFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'js', options);

      this.workflows.standard[1] = _libpluginsjsindexjs_WORKFLOW_STANDARD;
      this.workflows.inlineable = [_libpluginsjsindexjs_WORKFLOW_INLINEABLE];
      this.workflows.writeable = [_libpluginsjsindexjs_WORKFLOW_WRITEABLE];

      this.ast = null;
      this.isBuddyBuilt = false;
      this.isBuilt = false;
      this.isNpmModule = this.options.npmModulepaths ? this.options.npmModulepaths.some(modulepath => ~this.filepath.indexOf(modulepath)) : false;
      this.transpiled = false;
      this.flattened = false;

      if (this.isBuddyBuilt) this.content = _libpluginsjsindexjs_concat.unconcat(this);
    }

    /**
     * Read and store file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    load(buildOptions, fn) {
      super.load(buildOptions, err => {
        if (err && fn) return fn(err);

        this.isBuddyBuilt = _libpluginsjsindexjs_RE_BUDDY_BUILT.test(this.content);
        this.isBuilt = _libpluginsjsindexjs_RE_BROWSERIFY_BUILT.test(this.content) || _libpluginsjsindexjs_RE_WEBPACK_BUILT.test(this.content);
        if (this.isBuddyBuilt) this.content = _libpluginsjsindexjs_concat.unwrap(this, buildOptions);
        if (this.isBuilt) console.log(this.id);

        if (fn) fn();
      });
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    parse(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      const content = _libpluginsjsindexjs_commentStrip(this.content);

      super.addDependencies(_libpluginsjsindexjs_uniqueMatch(content, _libpluginsjsindexjs_RE_REQUIRE).map(match => {
        match.id = match.match;
        return match;
      }), buildOptions);
      fn();
    }

    /**
     * Replace process.env references with values
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    replaceEnvironment(buildOptions, fn) {
      this.content = _libpluginsjsindexjs_replaceEnvironment(this.content, buildOptions.browser);
      _libpluginsjsindexjs_debug(`replace environment vars: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Replace relative dependency references with fully resolved
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    replaceReferences(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      this.content = _libpluginsjsindexjs_replaceReferences(this.content, this.dependencyReferences, buildOptions.browser);
      _libpluginsjsindexjs_debug(`replace dependency references: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Inline json/disabled dependency content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    inline(buildOptions, fn) {
      if (this.isBuddyBuilt || this.isBuilt) return fn();

      this.content = _libpluginsjsindexjs_inline(this.content, this.dependencyReferences, buildOptions.browser);
      _libpluginsjsindexjs_debug(`inline: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Transpile file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    transpile(buildOptions, fn) {
      // Skip pre-built & node_modules files
      if (!this.transpiled && !this.isBuddyBuilt && !this.isBuilt && !this.isNpmModule) {
        try {
          _libpluginsjsindexjs_transpile(this, this.options.pluginOptions.babel);

          _libpluginsjsindexjs_debug(`transpile: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
          this.transpiled = true;
        } catch (err) {
          return fn(err);
        }
      }

      // Always parse helpers
      this.helpers = _libpluginsjsindexjs_uniqueMatch(this.content, _libpluginsjsindexjs_RE_HELPER).map(item => item.match);

      fn();
    }

    /**
     * Flatten file scope
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     * @returns {null}
     */
    flatten(buildOptions, fn) {
      // Built files should be flattened
      if (this.flattened || this.isBuddyBuilt) return fn();

      try {
        // Do not replace 'module.exports' for writeable Node files
        _libpluginsjsindexjs_flatten(this, buildOptions.browser ? true : !this.isWriteable(buildOptions.batch));

        _libpluginsjsindexjs_debug(`flatten: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
        this.flattened = true;
      } catch (err) {
        return fn(err);
      }

      fn();
    }

    /**
     * Concatenate file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    concat(buildOptions, fn) {
      this.content = _libpluginsjsindexjs_concat(this, _libpluginsjsindexjs_HEADER, buildOptions);
      _libpluginsjsindexjs_debug(`concat: ${ _libpluginsjsindexjs_strong(this.relpath) }`, 4);
      fn();
    }

    /**
     * Reset content
     * @param {Boolean} hard
     */
    reset(hard) {
      this.ast = null;
      this.flattened = false;
      this.transpiled = false;
      super.reset(hard);
    }
  };
}
/*≠≠ lib/plugins/js/index.js ≠≠*/

/*== lib/plugins/img/index.js ==*/
$m['lib/plugins/img/index.js'] = { exports: {} };
'use strict';

const _libpluginsimgindexjs_FILE_EXTENSIONS = ['gif', 'jpg', 'jpeg', 'png', 'svg'];
const _libpluginsimgindexjs_WORKFLOW_WRITEABLE = ['compress:compress'];

$m['lib/plugins/img/index.js'].exports = {
  name: 'img',
  type: 'img',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginsimgindexjs_define, _libpluginsimgindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginsimgindexjs_define(File, utils) {
  return class IMGFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'img', options);

      this.workflows.writeable = [_libpluginsimgindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Read and store file contents
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    load(buildOptions, fn) {
      // Make sure to load as Buffer
      if (this.extension != 'svg') this.encoding = null;
      super.load(buildOptions, fn);
    }
  };
}
/*≠≠ lib/plugins/img/index.js ≠≠*/

/*== node_modules/inline-source/lib/run.js ==*/
$m['inline-source/lib/run.js#5.1.0'] = { exports: {} };
'use strict';

/**
 * Process stack for 'sources'
 * @param {Object} context
 * @param {Array} sources
 * @param {Boolean} swallowErrors
 * @param {Function} [fn]
 * @returns {null}
 */

$m['inline-source/lib/run.js#5.1.0'].exports = function run(context, sources, swallowErrors, fn) {
  let errored = false;
  let outstanding = sources.length;

  if (outstanding) {
    sources.forEach(source => {
      // Async
      if (fn) {
        let idx = 0;
        function next(err) {
          if (err) {
            if (!swallowErrors) {
              errored = true;
              return fn(err);
            }
            // Clear content
            source.content = '';
            source.errored = true;
          }

          if (!errored) {
            const handler = source.stack[idx++];

            if (handler) return handler(source, context, next);

            // Done
            if (! --outstanding) return fn(null, context.html);
          }
        };

        next();

        // Sync
      } else {
        source.stack.forEach(handler => {
          if (!errored) {
            try {
              handler(source, context);
            } catch (err) {
              if (!swallowErrors) {
                errored = true;
                throw err;
              } else {
                // Clear content
                source.content = '';
                source.errored = true;
              }
            }
          }
        });
      }
    });

    // Done sync
    if (!fn) return context.html;

    // No sources
  } else {
    return fn ? fn(null, context.html) : context.html;
  }
};
/*≠≠ node_modules/inline-source/lib/run.js ≠≠*/

/*== node_modules/lodash/_getPrototype.js ==*/
$m['lodash/_getPrototype.js#4.15.0'] = { exports: {} };
var _lodashgetPrototypejs4150_overArg = $m['lodash/_overArg.js#4.15.0'].exports;

/** Built-in value references. */
var _lodashgetPrototypejs4150_getPrototype = _lodashgetPrototypejs4150_overArg(Object.getPrototypeOf, Object);

$m['lodash/_getPrototype.js#4.15.0'].exports = _lodashgetPrototypejs4150_getPrototype;
/*≠≠ node_modules/lodash/_getPrototype.js ≠≠*/

/*== node_modules/lodash/isPlainObject.js ==*/
$m['lodash/isPlainObject.js#4.15.0'] = { exports: {} };
var _lodashisPlainObjectjs4150_getPrototype = $m['lodash/_getPrototype.js#4.15.0'].exports,
    _lodashisPlainObjectjs4150_isHostObject = $m['lodash/_isHostObject.js#4.15.0'].exports,
    _lodashisPlainObjectjs4150_isObjectLike = $m['lodash/isObjectLike.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashisPlainObjectjs4150_objectTag = '[object Object]';

/** Used for built-in method references. */
var _lodashisPlainObjectjs4150_funcProto = Function.prototype,
    _lodashisPlainObjectjs4150_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _lodashisPlainObjectjs4150_funcToString = _lodashisPlainObjectjs4150_funcProto.toString;

/** Used to check objects for own properties. */
var _lodashisPlainObjectjs4150_hasOwnProperty = _lodashisPlainObjectjs4150_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var _lodashisPlainObjectjs4150_objectCtorString = _lodashisPlainObjectjs4150_funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _lodashisPlainObjectjs4150_objectToString = _lodashisPlainObjectjs4150_objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function _lodashisPlainObjectjs4150_isPlainObject(value) {
    if (!_lodashisPlainObjectjs4150_isObjectLike(value) || _lodashisPlainObjectjs4150_objectToString.call(value) != _lodashisPlainObjectjs4150_objectTag || _lodashisPlainObjectjs4150_isHostObject(value)) {
        return false;
    }
    var proto = _lodashisPlainObjectjs4150_getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = _lodashisPlainObjectjs4150_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && _lodashisPlainObjectjs4150_funcToString.call(Ctor) == _lodashisPlainObjectjs4150_objectCtorString;
}

$m['lodash/isPlainObject.js#4.15.0'].exports = _lodashisPlainObjectjs4150_isPlainObject;
/*≠≠ node_modules/lodash/isPlainObject.js ≠≠*/

/*== node_modules/inline-source/lib/utils.js ==*/
$m['inline-source/lib/utils.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibutilsjs510_isPlainObject = $m['lodash/isPlainObject.js#4.15.0'].exports;
const _inlinesourcelibutilsjs510_path = require('path');

const _inlinesourcelibutilsjs510_ATTRIBUTE_BLACKLIST = ['href', 'rel', 'src', 'data', 'xmlns', 'xmlns:xlink', 'version', 'baseprofile'];
const _inlinesourcelibutilsjs510_RE_ESCAPE = /[-\/\\^$*+?.()|[\]{}]/g;
// Multiline, tags
const _inlinesourcelibutilsjs510_RE_NOT_FILEPATH = /[\r\n<>]/gm;

$m['inline-source/lib/utils.js#5.1.0'].exports = {
  /**
   * Determine if 'str' is likely a filepath
   * @param {String} str
   * @returns {Boolean}
   */
  isFilepath(str) {
    _inlinesourcelibutilsjs510_RE_NOT_FILEPATH.lastIndex = 0;
    if (str) return !_inlinesourcelibutilsjs510_RE_NOT_FILEPATH.test(str);
    return false;
  },

  /**
   * Retrieve tag regexp for 'attribute'
   * @param {String} attribute
   * @returns {RegExp}
   */
  getTagRegExp(attribute) {
    // <([a-zA-Z]+)\b[^>]*?\s(?:inline [^>]*?|inline|inline=([\'\"]).*?\2[^>]*?)>(?:<\/\1\s?>)?
    return new RegExp('<([a-zA-Z]+)\\b[^>]*?\\s(?:' + attribute + ' [^>]*?|' + attribute + '|' + attribute + '=([\\\'\\\"])(?:true|' + attribute + ')\\2[^>]*?)>(?:<\\/\\1\\s?>)?', 'gm');
  },

  /**
   * Parse 'attributes'
   * @param {Object} attributes
   * @returns {Object}
   */
  parseAttributes(attributes) {
    for (const prop in attributes) {
      // Parse boolean values
      if (attributes[prop] === '') attributes[prop] = true;
    }

    return attributes;
  },

  /**
   * Parse props with 'prefix' from 'attributes'
   * @param {Object} attributes
   * @param {String} prefix
   * @returns {Object}
   */
  parseProps(attributes, prefix) {
    prefix += '-';

    let props = {};

    for (const prop in attributes) {
      // Strip 'inline-' and store
      if (prop.indexOf(prefix) == 0) {
        props[prop.slice(prefix.length)] = attributes[prop];
      }
    }

    return props;
  },

  /**
   * Retrieve resolved 'filepath' and optional anchor
   * @param {String} filepath
   * @param {String} htmlpath
   * @param {String} rootpath
   * @returns {Array}
   */
  getSourcepath(filepath, htmlpath, rootpath) {
    if (filepath) {
      // Relative path
      if (htmlpath && filepath.indexOf('./') == 0 || filepath.indexOf('../') == 0) {
        filepath = _inlinesourcelibutilsjs510_path.resolve(_inlinesourcelibutilsjs510_path.dirname(htmlpath), filepath);
      } else {
        // Strip leading '/'
        if (filepath.indexOf('/') == 0) filepath = filepath.slice(1);
      }
      if (~filepath.indexOf('#')) filepath = filepath.split('#');

      return Array.isArray(filepath) ? [_inlinesourcelibutilsjs510_path.resolve(rootpath, filepath[0]), filepath[1]] : [_inlinesourcelibutilsjs510_path.resolve(rootpath, filepath), ''];
    }

    return ['', ''];
  },

  /**
   * Retrieve type based on 'type'
   * @param {String} type
   * @returns {String}
   */
  getTypeFromType(type) {
    if (type) {
      switch (type) {
        case 'application/javascript':
        case 'application/x-javascript':
        case 'application/ecmascript':
        case 'text/javascript':
        case 'text/ecmascript':
        case 'javascript':
        case 'js':
        case 'ecmascript':
          return 'js';
        case 'text/css':
        case 'css':
          return 'css';
        case 'image/png':
        case 'image/gif':
        case 'image/jpeg':
        case 'image/jpg':
        case 'image/svg+xml':
        case 'image/svg':
        case 'png':
        case 'gif':
        case 'jpeg':
        case 'jpg':
        case 'svg':
        case 'image':
          return 'image';
        case 'application/json':
        case 'text/json':
        case 'json':
          return 'json';
        default:
          return type;
      }
    }
  },

  /**
   * Retrieve type based on 'tag'
   * @param {String} tag
   * @returns {String}
   */
  getTypeFromTag(tag) {
    if (tag) {
      switch (tag) {
        case 'script':
          return 'js';
        case 'link':
          return 'css';
        case 'img':
        case 'object':
          return 'image';
        default:
          return '';
      }
    }
  },

  /**
   * Retrieve format based on 'extension'
   * @param {String} extension
   * @returns {String}
   */
  getFormatFromExtension(extension) {
    if (extension) {
      switch (extension) {
        case 'js':
          return 'js';
        case 'json':
          return 'json';
        case 'css':
          return 'css';
        case 'gif':
          return 'gif';
        case 'png':
          return 'png';
        case 'jpeg':
        case 'jpg':
          return 'jpeg';
        case 'svg':
          return 'svg+xml';
        default:
          return extension;
      }
    }
  },

  /**
   * Retrieve leading whitespace for 'source' in 'html'
   * @param {String} source
   * @param {String} html
   * @returns {String}
   */
  getPadding(source, html) {
    const re = new RegExp('^([\\t ]+)' + this.escape(source), 'gm');
    const match = re.exec(html);

    return match ? match[1] : '';
  },

  /**
   * Retrieve stringified attributes
   * @param {Object} attributes
   * @param {String} prefix
   * @param {Boolean} strict
   * @returns {String}
   */
  getAttributeString(attributes, prefix, strict) {
    let str = '';

    for (const prop in attributes) {
      // Ignore blacklisted and prefixed attributes
      const include = strict ? prop.indexOf(prefix) != 0 && !~_inlinesourcelibutilsjs510_ATTRIBUTE_BLACKLIST.indexOf(prop) : prop.indexOf(prefix) != 0;

      if (include) {
        str += attributes[prop] === true ? ' ' + prop : ' ' + prop + '="' + attributes[prop] + '"';
      }
    }

    return str;
  },

  /**
   * Retrieve ignored state for 'tag' or 'type' or 'format'
   * @param {String | Array} ignore
   * @param {String} tag
   * @param {String} type
   * @param {String} format
   * @returns {Boolean}
   */
  isIgnored(ignore, tag, type, format) {
    // Clean svg+xml ==> svg
    const formatAlt = format && format.indexOf('+') ? format.split('+')[0] : null;

    // Backwards compat for 3.x style format
    if (_inlinesourcelibutilsjs510_isPlainObject(ignore)) {
      let ig = [];

      for (const prop in ignore) {
        if (Array.isArray(ignore[prop])) {
          ig = ig.concat(ignore[prop]);
        } else {
          ig.push(ignore[prop]);
        }
      }
      ignore = ig;
    }

    if (!Array.isArray(ignore)) ignore = [ignore];

    return !!(~ignore.indexOf(tag) || ~ignore.indexOf(type) || ~ignore.indexOf(format) || ~ignore.indexOf(formatAlt));
  },

  /**
   * Escape 'str' for use in RegExp constructor
   * @param {String} str
   * @returns {String}
   */
  escape(str) {
    return str.replace(_inlinesourcelibutilsjs510_RE_ESCAPE, '\\$&');
  },

  /**
   * No op
   * @param {Error} [err]
   */
  noop(err) {
    if (err) throw err;
  }
};
/*≠≠ node_modules/inline-source/lib/utils.js ≠≠*/

/*== node_modules/htmlparser2/lib/CollectingHandler.js ==*/
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/CollectingHandler.js#3.9.1'].exports = _htmlparser2libCollectingHandlerjs391_CollectingHandler;

function _htmlparser2libCollectingHandlerjs391_CollectingHandler(cbs) {
	this._cbs = cbs || {};
	this.events = [];
}

var _htmlparser2libCollectingHandlerjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;
Object.keys(_htmlparser2libCollectingHandlerjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 0) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function () {
			this.events.push([name]);
			if (this._cbs[name]) this._cbs[name]();
		};
	} else if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 1) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function (a) {
			this.events.push([name, a]);
			if (this._cbs[name]) this._cbs[name](a);
		};
	} else if (_htmlparser2libCollectingHandlerjs391_EVENTS[name] === 2) {
		name = "on" + name;
		_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype[name] = function (a, b) {
			this.events.push([name, a, b]);
			if (this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype.onreset = function () {
	this.events = [];
	if (this._cbs.onreset) this._cbs.onreset();
};

_htmlparser2libCollectingHandlerjs391_CollectingHandler.prototype.restart = function () {
	if (this._cbs.onreset) this._cbs.onreset();

	for (var i = 0, len = this.events.length; i < len; i++) {
		if (this._cbs[this.events[i][0]]) {

			var num = this.events[i].length;

			if (num === 1) {
				this._cbs[this.events[i][0]]();
			} else if (num === 2) {
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};
};
/*≠≠ node_modules/htmlparser2/lib/CollectingHandler.js ≠≠*/

/*== node_modules/domutils/lib/helpers.js ==*/
$m['domutils/lib/helpers.js#1.5.1'] = { exports: {} };
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
$m['domutils/lib/helpers.js#1.5.1'].exports.removeSubsets = function (nodes) {
	var idx = nodes.length,
	    node,
	    ancestor,
	    replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var _domutilslibhelpersjs151_POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var _domutilslibhelpersjs151_comparePos = $m['domutils/lib/helpers.js#1.5.1'].exports.compareDocumentPosition = function (nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return _domutilslibhelpersjs151_POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return _domutilslibhelpersjs151_POSITION.FOLLOWING | _domutilslibhelpersjs151_POSITION.CONTAINED_BY;
		}
		return _domutilslibhelpersjs151_POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return _domutilslibhelpersjs151_POSITION.PRECEDING | _domutilslibhelpersjs151_POSITION.CONTAINS;
		}
		return _domutilslibhelpersjs151_POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
$m['domutils/lib/helpers.js#1.5.1'].exports.uniqueSort = function (nodes) {
	var idx = nodes.length,
	    node,
	    position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function (a, b) {
		var relative = _domutilslibhelpersjs151_comparePos(a, b);
		if (relative & _domutilslibhelpersjs151_POSITION.PRECEDING) {
			return -1;
		} else if (relative & _domutilslibhelpersjs151_POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};
/*≠≠ node_modules/domutils/lib/helpers.js ≠≠*/

/*== node_modules/domelementtype/index.js ==*/
$m['domelementtype/index.js#1.3.0'] = { exports: {} };
//Types of elements found in the DOM
$m['domelementtype/index.js#1.3.0'].exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function (elem) {
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
/*≠≠ node_modules/domelementtype/index.js ≠≠*/

/*== node_modules/domutils/lib/legacy.js ==*/
$m['domutils/lib/legacy.js#1.5.1'] = { exports: {} };
var _domutilsliblegacyjs151_ElementType = $m['domelementtype/index.js#1.3.0'].exports;
var _domutilsliblegacyjs151_isTag = $m['domutils/lib/legacy.js#1.5.1'].exports.isTag = _domutilsliblegacyjs151_ElementType.isTag;

$m['domutils/lib/legacy.js#1.5.1'].exports.testElement = function (options, element) {
	for (var key in options) {
		if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {
			if (!_domutilsliblegacyjs151_isTag(element) || !options.tag_name(element.name)) {
				return false;
			}
		} else if (key === "tag_type") {
			if (!options.tag_type(element.type)) return false;
		} else if (key === "tag_contains") {
			if (_domutilsliblegacyjs151_isTag(element) || !options.tag_contains(element.data)) {
				return false;
			}
		} else if (!element.attribs || !options[key](element.attribs[key])) {
			return false;
		}
	}
	return true;
};

var _domutilsliblegacyjs151_Checks = {
	tag_name: function (name) {
		if (typeof name === "function") {
			return function (elem) {
				return _domutilsliblegacyjs151_isTag(elem) && name(elem.name);
			};
		} else if (name === "*") {
			return _domutilsliblegacyjs151_isTag;
		} else {
			return function (elem) {
				return _domutilsliblegacyjs151_isTag(elem) && elem.name === name;
			};
		}
	},
	tag_type: function (type) {
		if (typeof type === "function") {
			return function (elem) {
				return type(elem.type);
			};
		} else {
			return function (elem) {
				return elem.type === type;
			};
		}
	},
	tag_contains: function (data) {
		if (typeof data === "function") {
			return function (elem) {
				return !_domutilsliblegacyjs151_isTag(elem) && data(elem.data);
			};
		} else {
			return function (elem) {
				return !_domutilsliblegacyjs151_isTag(elem) && elem.data === data;
			};
		}
	}
};

function _domutilsliblegacyjs151_getAttribCheck(attrib, value) {
	if (typeof value === "function") {
		return function (elem) {
			return elem.attribs && value(elem.attribs[attrib]);
		};
	} else {
		return function (elem) {
			return elem.attribs && elem.attribs[attrib] === value;
		};
	}
}

function _domutilsliblegacyjs151_combineFuncs(a, b) {
	return function (elem) {
		return a(elem) || b(elem);
	};
}

$m['domutils/lib/legacy.js#1.5.1'].exports.getElements = function (options, element, recurse, limit) {
	var funcs = Object.keys(options).map(function (key) {
		var value = options[key];
		return key in _domutilsliblegacyjs151_Checks ? _domutilsliblegacyjs151_Checks[key](value) : _domutilsliblegacyjs151_getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(funcs.reduce(_domutilsliblegacyjs151_combineFuncs), element, recurse, limit);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementById = function (id, element, recurse) {
	if (!Array.isArray(element)) element = [element];
	return this.findOne(_domutilsliblegacyjs151_getAttribCheck("id", id), element, recurse !== false);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementsByTagName = function (name, element, recurse, limit) {
	return this.filter(_domutilsliblegacyjs151_Checks.tag_name(name), element, recurse, limit);
};

$m['domutils/lib/legacy.js#1.5.1'].exports.getElementsByTagType = function (type, element, recurse, limit) {
	return this.filter(_domutilsliblegacyjs151_Checks.tag_type(type), element, recurse, limit);
};
/*≠≠ node_modules/domutils/lib/legacy.js ≠≠*/

/*== node_modules/domutils/lib/querying.js ==*/
$m['domutils/lib/querying.js#1.5.1'] = { exports: {} };
var _domutilslibqueryingjs151_isTag = $m['domelementtype/index.js#1.3.0'].exports.isTag;

$m['domutils/lib/querying.js#1.5.1'].exports = {
	filter: _domutilslibqueryingjs151_filter,
	find: _domutilslibqueryingjs151_find,
	findOneChild: _domutilslibqueryingjs151_findOneChild,
	findOne: _domutilslibqueryingjs151_findOne,
	existsOne: _domutilslibqueryingjs151_existsOne,
	findAll: _domutilslibqueryingjs151_findAll
};

function _domutilslibqueryingjs151_filter(test, element, recurse, limit) {
	if (!Array.isArray(element)) element = [element];

	if (typeof limit !== "number" || !isFinite(limit)) {
		limit = Infinity;
	}
	return _domutilslibqueryingjs151_find(test, element, recurse !== false, limit);
}

function _domutilslibqueryingjs151_find(test, elems, recurse, limit) {
	var result = [],
	    childs;

	for (var i = 0, j = elems.length; i < j; i++) {
		if (test(elems[i])) {
			result.push(elems[i]);
			if (--limit <= 0) break;
		}

		childs = elems[i].children;
		if (recurse && childs && childs.length > 0) {
			childs = _domutilslibqueryingjs151_find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if (limit <= 0) break;
		}
	}

	return result;
}

function _domutilslibqueryingjs151_findOneChild(test, elems) {
	for (var i = 0, l = elems.length; i < l; i++) {
		if (test(elems[i])) return elems[i];
	}

	return null;
}

function _domutilslibqueryingjs151_findOne(test, elems) {
	var elem = null;

	for (var i = 0, l = elems.length; i < l && !elem; i++) {
		if (!_domutilslibqueryingjs151_isTag(elems[i])) {
			continue;
		} else if (test(elems[i])) {
			elem = elems[i];
		} else if (elems[i].children.length > 0) {
			elem = _domutilslibqueryingjs151_findOne(test, elems[i].children);
		}
	}

	return elem;
}

function _domutilslibqueryingjs151_existsOne(test, elems) {
	for (var i = 0, l = elems.length; i < l; i++) {
		if (_domutilslibqueryingjs151_isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && _domutilslibqueryingjs151_existsOne(test, elems[i].children))) {
			return true;
		}
	}

	return false;
}

function _domutilslibqueryingjs151_findAll(test, elems) {
	var result = [];
	for (var i = 0, j = elems.length; i < j; i++) {
		if (!_domutilslibqueryingjs151_isTag(elems[i])) continue;
		if (test(elems[i])) result.push(elems[i]);

		if (elems[i].children.length > 0) {
			result = result.concat(_domutilslibqueryingjs151_findAll(test, elems[i].children));
		}
	}
	return result;
}
/*≠≠ node_modules/domutils/lib/querying.js ≠≠*/

/*== node_modules/domutils/lib/manipulation.js ==*/
$m['domutils/lib/manipulation.js#1.5.1'] = { exports: {} };
$m['domutils/lib/manipulation.js#1.5.1'].exports.removeElement = function (elem) {
	if (elem.prev) elem.prev.next = elem.next;
	if (elem.next) elem.next.prev = elem.prev;

	if (elem.parent) {
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.replaceElement = function (elem, replacement) {
	var prev = replacement.prev = elem.prev;
	if (prev) {
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if (next) {
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if (parent) {
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.appendChild = function (elem, child) {
	child.parent = elem;

	if (elem.children.push(child) !== 1) {
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.append = function (elem, next) {
	var parent = elem.parent,
	    currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if (currNext) {
		currNext.prev = next;
		if (parent) {
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if (parent) {
		parent.children.push(next);
	}
};

$m['domutils/lib/manipulation.js#1.5.1'].exports.prepend = function (elem, prev) {
	var parent = elem.parent;
	if (parent) {
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if (elem.prev) {
		elem.prev.next = prev;
	}

	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};
/*≠≠ node_modules/domutils/lib/manipulation.js ≠≠*/

/*== node_modules/domutils/lib/traversal.js ==*/
$m['domutils/lib/traversal.js#1.5.1'] = { exports: {} };
var _domutilslibtraversaljs151_getChildren = $m['domutils/lib/traversal.js#1.5.1'].exports.getChildren = function (elem) {
	return elem.children;
};

var _domutilslibtraversaljs151_getParent = $m['domutils/lib/traversal.js#1.5.1'].exports.getParent = function (elem) {
	return elem.parent;
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getSiblings = function (elem) {
	var parent = _domutilslibtraversaljs151_getParent(elem);
	return parent ? _domutilslibtraversaljs151_getChildren(parent) : [elem];
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getAttributeValue = function (elem, name) {
	return elem.attribs && elem.attribs[name];
};

$m['domutils/lib/traversal.js#1.5.1'].exports.hasAttrib = function (elem, name) {
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

$m['domutils/lib/traversal.js#1.5.1'].exports.getName = function (elem) {
	return elem.name;
};
/*≠≠ node_modules/domutils/lib/traversal.js ≠≠*/

/*== node_modules/entities/lib/decode_codepoint.js ==*/
$m['entities/lib/decode_codepoint.js#1.1.1'] = { exports: {} };
var _entitieslibdecodecodepointjs111_decodeMap = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };

$m['entities/lib/decode_codepoint.js#1.1.1'].exports = _entitieslibdecodecodepointjs111_decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function _entitieslibdecodecodepointjs111_decodeCodePoint(codePoint) {

	if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
		return "\uFFFD";
	}

	if (codePoint in _entitieslibdecodecodepointjs111_decodeMap) {
		codePoint = _entitieslibdecodecodepointjs111_decodeMap[codePoint];
	}

	var output = "";

	if (codePoint > 0xFFFF) {
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}
/*≠≠ node_modules/entities/lib/decode_codepoint.js ≠≠*/

/*== node_modules/entities/lib/decode.js ==*/
$m['entities/lib/decode.js#1.1.1'] = { exports: {} };
var _entitieslibdecodejs111_entityMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" },
    _entitieslibdecodejs111_legacyMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "AElig": "\u00C6", "aelig": "\u00E6", "Agrave": "\u00C0", "agrave": "\u00E0", "amp": "&", "AMP": "&", "Aring": "\u00C5", "aring": "\u00E5", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "brvbar": "\u00A6", "Ccedil": "\u00C7", "ccedil": "\u00E7", "cedil": "\u00B8", "cent": "\u00A2", "copy": "\u00A9", "COPY": "\u00A9", "curren": "\u00A4", "deg": "\u00B0", "divide": "\u00F7", "Eacute": "\u00C9", "eacute": "\u00E9", "Ecirc": "\u00CA", "ecirc": "\u00EA", "Egrave": "\u00C8", "egrave": "\u00E8", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "frac12": "\u00BD", "frac14": "\u00BC", "frac34": "\u00BE", "gt": ">", "GT": ">", "Iacute": "\u00CD", "iacute": "\u00ED", "Icirc": "\u00CE", "icirc": "\u00EE", "iexcl": "\u00A1", "Igrave": "\u00CC", "igrave": "\u00EC", "iquest": "\u00BF", "Iuml": "\u00CF", "iuml": "\u00EF", "laquo": "\u00AB", "lt": "<", "LT": "<", "macr": "\u00AF", "micro": "\u00B5", "middot": "\u00B7", "nbsp": "\u00A0", "not": "\u00AC", "Ntilde": "\u00D1", "ntilde": "\u00F1", "Oacute": "\u00D3", "oacute": "\u00F3", "Ocirc": "\u00D4", "ocirc": "\u00F4", "Ograve": "\u00D2", "ograve": "\u00F2", "ordf": "\u00AA", "ordm": "\u00BA", "Oslash": "\u00D8", "oslash": "\u00F8", "Otilde": "\u00D5", "otilde": "\u00F5", "Ouml": "\u00D6", "ouml": "\u00F6", "para": "\u00B6", "plusmn": "\u00B1", "pound": "\u00A3", "quot": "\"", "QUOT": "\"", "raquo": "\u00BB", "reg": "\u00AE", "REG": "\u00AE", "sect": "\u00A7", "shy": "\u00AD", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "szlig": "\u00DF", "THORN": "\u00DE", "thorn": "\u00FE", "times": "\u00D7", "Uacute": "\u00DA", "uacute": "\u00FA", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uml": "\u00A8", "Uuml": "\u00DC", "uuml": "\u00FC", "Yacute": "\u00DD", "yacute": "\u00FD", "yen": "\u00A5", "yuml": "\u00FF" },
    _entitieslibdecodejs111_xmlMap = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" },
    _entitieslibdecodejs111_decodeCodePoint = $m['entities/lib/decode_codepoint.js#1.1.1'].exports;

var _entitieslibdecodejs111_decodeXMLStrict = _entitieslibdecodejs111_getStrictDecoder(_entitieslibdecodejs111_xmlMap),
    _entitieslibdecodejs111_decodeHTMLStrict = _entitieslibdecodejs111_getStrictDecoder(_entitieslibdecodejs111_entityMap);

function _entitieslibdecodejs111_getStrictDecoder(map) {
	var keys = Object.keys(map).join("|"),
	    replace = _entitieslibdecodejs111_getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function (str) {
		return String(str).replace(re, replace);
	};
}

var _entitieslibdecodejs111_decodeHTML = function () {
	var legacy = Object.keys(_entitieslibdecodejs111_legacyMap).sort(_entitieslibdecodejs111_sorter);

	var keys = Object.keys(_entitieslibdecodejs111_entityMap).sort(_entitieslibdecodejs111_sorter);

	for (var i = 0, j = 0; i < keys.length; i++) {
		if (legacy[j] === keys[i]) {
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = _entitieslibdecodejs111_getReplacer(_entitieslibdecodejs111_entityMap);

	function replacer(str) {
		if (str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function (str) {
		return String(str).replace(re, replacer);
	};
}();

function _entitieslibdecodejs111_sorter(a, b) {
	return a < b ? 1 : -1;
}

function _entitieslibdecodejs111_getReplacer(map) {
	return function replace(str) {
		if (str.charAt(1) === "#") {
			if (str.charAt(2) === "X" || str.charAt(2) === "x") {
				return _entitieslibdecodejs111_decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return _entitieslibdecodejs111_decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

$m['entities/lib/decode.js#1.1.1'].exports = {
	XML: _entitieslibdecodejs111_decodeXMLStrict,
	HTML: _entitieslibdecodejs111_decodeHTML,
	HTMLStrict: _entitieslibdecodejs111_decodeHTMLStrict
};
/*≠≠ node_modules/entities/lib/decode.js ≠≠*/

/*== node_modules/entities/lib/encode.js ==*/
$m['entities/lib/encode.js#1.1.1'] = { exports: {} };
var _entitieslibencodejs111_inverseXML = _entitieslibencodejs111_getInverseObj({ "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" }),
    _entitieslibencodejs111_xmlReplacer = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseXML);

$m['entities/lib/encode.js#1.1.1'].exports.XML = _entitieslibencodejs111_getInverse(_entitieslibencodejs111_inverseXML, _entitieslibencodejs111_xmlReplacer);

var _entitieslibencodejs111_inverseHTML = _entitieslibencodejs111_getInverseObj({ "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" }),
    _entitieslibencodejs111_htmlReplacer = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseHTML);

$m['entities/lib/encode.js#1.1.1'].exports.HTML = _entitieslibencodejs111_getInverse(_entitieslibencodejs111_inverseHTML, _entitieslibencodejs111_htmlReplacer);

function _entitieslibencodejs111_getInverseObj(obj) {
	return Object.keys(obj).sort().reduce(function (inverse, name) {
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function _entitieslibencodejs111_getInverseReplacer(inverse) {
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function (k) {
		if (k.length === 1) {
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var _entitieslibencodejs111_re_nonASCII = /[^\0-\x7F]/g,
    _entitieslibencodejs111_re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function _entitieslibencodejs111_singleCharReplacer(c) {
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function _entitieslibencodejs111_astralReplacer(c) {
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function _entitieslibencodejs111_getInverse(inverse, re) {
	function func(name) {
		return inverse[name];
	}

	return function (data) {
		return data.replace(re, func).replace(_entitieslibencodejs111_re_astralSymbols, _entitieslibencodejs111_astralReplacer).replace(_entitieslibencodejs111_re_nonASCII, _entitieslibencodejs111_singleCharReplacer);
	};
}

var _entitieslibencodejs111_re_xmlChars = _entitieslibencodejs111_getInverseReplacer(_entitieslibencodejs111_inverseXML);

function _entitieslibencodejs111_escapeXML(data) {
	return data.replace(_entitieslibencodejs111_re_xmlChars, _entitieslibencodejs111_singleCharReplacer).replace(_entitieslibencodejs111_re_astralSymbols, _entitieslibencodejs111_astralReplacer).replace(_entitieslibencodejs111_re_nonASCII, _entitieslibencodejs111_singleCharReplacer);
}

$m['entities/lib/encode.js#1.1.1'].exports.escape = _entitieslibencodejs111_escapeXML;
/*≠≠ node_modules/entities/lib/encode.js ≠≠*/

/*== node_modules/entities/index.js ==*/
$m['entities/index.js#1.1.1'] = { exports: {} };
var _entitiesindexjs111_encode = $m['entities/lib/encode.js#1.1.1'].exports,
    _entitiesindexjs111_decode = $m['entities/lib/decode.js#1.1.1'].exports;

$m['entities/index.js#1.1.1'].exports.decode = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_decode.XML : _entitiesindexjs111_decode.HTML)(data);
};

$m['entities/index.js#1.1.1'].exports.decodeStrict = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_decode.XML : _entitiesindexjs111_decode.HTMLStrict)(data);
};

$m['entities/index.js#1.1.1'].exports.encode = function (data, level) {
	return (!level || level <= 0 ? _entitiesindexjs111_encode.XML : _entitiesindexjs111_encode.HTML)(data);
};

$m['entities/index.js#1.1.1'].exports.encodeXML = _entitiesindexjs111_encode.XML;

$m['entities/index.js#1.1.1'].exports.encodeHTML4 = $m['entities/index.js#1.1.1'].exports.encodeHTML5 = $m['entities/index.js#1.1.1'].exports.encodeHTML = _entitiesindexjs111_encode.HTML;

$m['entities/index.js#1.1.1'].exports.decodeXML = $m['entities/index.js#1.1.1'].exports.decodeXMLStrict = _entitiesindexjs111_decode.XML;

$m['entities/index.js#1.1.1'].exports.decodeHTML4 = $m['entities/index.js#1.1.1'].exports.decodeHTML5 = $m['entities/index.js#1.1.1'].exports.decodeHTML = _entitiesindexjs111_decode.HTML;

$m['entities/index.js#1.1.1'].exports.decodeHTML4Strict = $m['entities/index.js#1.1.1'].exports.decodeHTML5Strict = $m['entities/index.js#1.1.1'].exports.decodeHTMLStrict = _entitiesindexjs111_decode.HTMLStrict;

$m['entities/index.js#1.1.1'].exports.escape = _entitiesindexjs111_encode.escape;
/*≠≠ node_modules/entities/index.js ≠≠*/

/*== node_modules/dom-serializer/no...odules/domelementtype/index.js ==*/
$m['domelementtype/index.js#1.1.3'] = { exports: {} };
//Types of elements found in the DOM
$m['domelementtype/index.js#1.1.3'].exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>

	isTag: function (elem) {
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
/*≠≠ node_modules/dom-serializer/no...odules/domelementtype/index.js ≠≠*/

/*== node_modules/dom-serializer/index.js ==*/
$m['dom-serializer/index.js#0.1.0'] = { exports: {} };
/*
  Module dependencies
*/
var _domserializerindexjs010_ElementType = $m['domelementtype/index.js#1.1.3'].exports;
var _domserializerindexjs010_entities = $m['entities/index.js#1.1.1'].exports;

/*
  Boolean Attributes
*/
var _domserializerindexjs010_booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var _domserializerindexjs010_unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function _domserializerindexjs010_formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (!value && _domserializerindexjs010_booleanAttributes[key]) {
      output += key;
    } else {
      output += key + '="' + (opts.decodeEntities ? _domserializerindexjs010_entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var _domserializerindexjs010_singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var _domserializerindexjs010_render = $m['dom-serializer/index.js#0.1.0'].exports = function (dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += _domserializerindexjs010_render(elem.children, opts);else if (_domserializerindexjs010_ElementType.isTag(elem)) output += _domserializerindexjs010_renderTag(elem, opts);else if (elem.type === _domserializerindexjs010_ElementType.Directive) output += _domserializerindexjs010_renderDirective(elem);else if (elem.type === _domserializerindexjs010_ElementType.Comment) output += _domserializerindexjs010_renderComment(elem);else if (elem.type === _domserializerindexjs010_ElementType.CDATA) output += _domserializerindexjs010_renderCdata(elem);else output += _domserializerindexjs010_renderText(elem, opts);
  }

  return output;
};

function _domserializerindexjs010_renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = { decodeEntities: opts.decodeEntities, xmlMode: true };

  var tag = '<' + elem.name,
      attribs = _domserializerindexjs010_formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += _domserializerindexjs010_render(elem.children, opts);
    }

    if (!_domserializerindexjs010_singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function _domserializerindexjs010_renderDirective(elem) {
  return '<' + elem.data + '>';
}

function _domserializerindexjs010_renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in _domserializerindexjs010_unencodedElements)) {
    data = _domserializerindexjs010_entities.encodeXML(data);
  }

  return data;
}

function _domserializerindexjs010_renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function _domserializerindexjs010_renderComment(elem) {
  return '<!--' + elem.data + '-->';
}
/*≠≠ node_modules/dom-serializer/index.js ≠≠*/

/*== node_modules/domutils/lib/stringify.js ==*/
$m['domutils/lib/stringify.js#1.5.1'] = { exports: {} };
var _domutilslibstringifyjs151_ElementType = $m['domelementtype/index.js#1.3.0'].exports,
    _domutilslibstringifyjs151_getOuterHTML = $m['dom-serializer/index.js#0.1.0'].exports,
    _domutilslibstringifyjs151_isTag = _domutilslibstringifyjs151_ElementType.isTag;

$m['domutils/lib/stringify.js#1.5.1'].exports = {
	getInnerHTML: _domutilslibstringifyjs151_getInnerHTML,
	getOuterHTML: _domutilslibstringifyjs151_getOuterHTML,
	getText: _domutilslibstringifyjs151_getText
};

function _domutilslibstringifyjs151_getInnerHTML(elem, opts) {
	return elem.children ? elem.children.map(function (elem) {
		return _domutilslibstringifyjs151_getOuterHTML(elem, opts);
	}).join("") : "";
}

function _domutilslibstringifyjs151_getText(elem) {
	if (Array.isArray(elem)) return elem.map(_domutilslibstringifyjs151_getText).join("");
	if (_domutilslibstringifyjs151_isTag(elem) || elem.type === _domutilslibstringifyjs151_ElementType.CDATA) return _domutilslibstringifyjs151_getText(elem.children);
	if (elem.type === _domutilslibstringifyjs151_ElementType.Text) return elem.data;
	return "";
}
/*≠≠ node_modules/domutils/lib/stringify.js ≠≠*/

/*== node_modules/domutils/index.js ==*/
$m['domutils/index.js#1.5.1'] = { exports: {} };
var _domutilsindexjs151_DomUtils = $m['domutils/index.js#1.5.1'].exports;

[$m['domutils/lib/stringify.js#1.5.1'].exports, $m['domutils/lib/traversal.js#1.5.1'].exports, $m['domutils/lib/manipulation.js#1.5.1'].exports, $m['domutils/lib/querying.js#1.5.1'].exports, $m['domutils/lib/legacy.js#1.5.1'].exports, $m['domutils/lib/helpers.js#1.5.1'].exports].forEach(function (ext) {
	Object.keys(ext).forEach(function (key) {
		_domutilsindexjs151_DomUtils[key] = ext[key].bind(_domutilsindexjs151_DomUtils);
	});
});
/*≠≠ node_modules/domutils/index.js ≠≠*/

/*== node_modules/htmlparser2/lib/ProxyHandler.js ==*/
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/ProxyHandler.js#3.9.1'].exports = _htmlparser2libProxyHandlerjs391_ProxyHandler;

function _htmlparser2libProxyHandlerjs391_ProxyHandler(cbs) {
	this._cbs = cbs || {};
}

var _htmlparser2libProxyHandlerjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;
Object.keys(_htmlparser2libProxyHandlerjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 0) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function () {
			if (this._cbs[name]) this._cbs[name]();
		};
	} else if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 1) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function (a) {
			if (this._cbs[name]) this._cbs[name](a);
		};
	} else if (_htmlparser2libProxyHandlerjs391_EVENTS[name] === 2) {
		name = "on" + name;
		_htmlparser2libProxyHandlerjs391_ProxyHandler.prototype[name] = function (a, b) {
			if (this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});
};
/*≠≠ node_modules/htmlparser2/lib/ProxyHandler.js ≠≠*/

/*== node_modules/inherits/inherits_browser.js ==*/
$m['inherits/inherits_browser.js#2.0.3'] = { exports: {} };
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  $m['inherits/inherits_browser.js#2.0.3'].exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  $m['inherits/inherits_browser.js#2.0.3'].exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
/*≠≠ node_modules/inherits/inherits_browser.js ≠≠*/

/*== node_modules/htmlparser2/lib/Tokenizer.js ==*/
$m['htmlparser2/lib/Tokenizer.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports = _htmlparser2libTokenizerjs391_Tokenizer;

var _htmlparser2libTokenizerjs391_decodeCodePoint = $m['entities/lib/decode_codepoint.js#1.1.1'].exports,
    _htmlparser2libTokenizerjs391_entityMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" },
    _htmlparser2libTokenizerjs391_legacyMap = { "Aacute": "\u00C1", "aacute": "\u00E1", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "AElig": "\u00C6", "aelig": "\u00E6", "Agrave": "\u00C0", "agrave": "\u00E0", "amp": "&", "AMP": "&", "Aring": "\u00C5", "aring": "\u00E5", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "brvbar": "\u00A6", "Ccedil": "\u00C7", "ccedil": "\u00E7", "cedil": "\u00B8", "cent": "\u00A2", "copy": "\u00A9", "COPY": "\u00A9", "curren": "\u00A4", "deg": "\u00B0", "divide": "\u00F7", "Eacute": "\u00C9", "eacute": "\u00E9", "Ecirc": "\u00CA", "ecirc": "\u00EA", "Egrave": "\u00C8", "egrave": "\u00E8", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "frac12": "\u00BD", "frac14": "\u00BC", "frac34": "\u00BE", "gt": ">", "GT": ">", "Iacute": "\u00CD", "iacute": "\u00ED", "Icirc": "\u00CE", "icirc": "\u00EE", "iexcl": "\u00A1", "Igrave": "\u00CC", "igrave": "\u00EC", "iquest": "\u00BF", "Iuml": "\u00CF", "iuml": "\u00EF", "laquo": "\u00AB", "lt": "<", "LT": "<", "macr": "\u00AF", "micro": "\u00B5", "middot": "\u00B7", "nbsp": "\u00A0", "not": "\u00AC", "Ntilde": "\u00D1", "ntilde": "\u00F1", "Oacute": "\u00D3", "oacute": "\u00F3", "Ocirc": "\u00D4", "ocirc": "\u00F4", "Ograve": "\u00D2", "ograve": "\u00F2", "ordf": "\u00AA", "ordm": "\u00BA", "Oslash": "\u00D8", "oslash": "\u00F8", "Otilde": "\u00D5", "otilde": "\u00F5", "Ouml": "\u00D6", "ouml": "\u00F6", "para": "\u00B6", "plusmn": "\u00B1", "pound": "\u00A3", "quot": "\"", "QUOT": "\"", "raquo": "\u00BB", "reg": "\u00AE", "REG": "\u00AE", "sect": "\u00A7", "shy": "\u00AD", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "szlig": "\u00DF", "THORN": "\u00DE", "thorn": "\u00FE", "times": "\u00D7", "Uacute": "\u00DA", "uacute": "\u00FA", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uml": "\u00A8", "Uuml": "\u00DC", "uuml": "\u00FC", "Yacute": "\u00DD", "yacute": "\u00FD", "yen": "\u00A5", "yuml": "\u00FF" },
    _htmlparser2libTokenizerjs391_xmlMap = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" },
    _htmlparser2libTokenizerjs391_i = 0,
    _htmlparser2libTokenizerjs391_TEXT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    //after <
_htmlparser2libTokenizerjs391_IN_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME = _htmlparser2libTokenizerjs391_i++,


//attributes
_htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ = _htmlparser2libTokenizerjs391_i++,
    // "
_htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ = _htmlparser2libTokenizerjs391_i++,
    // '
_htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ = _htmlparser2libTokenizerjs391_i++,


//declarations
_htmlparser2libTokenizerjs391_BEFORE_DECLARATION = _htmlparser2libTokenizerjs391_i++,
    // !
_htmlparser2libTokenizerjs391_IN_DECLARATION = _htmlparser2libTokenizerjs391_i++,


//processing instructions
_htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION = _htmlparser2libTokenizerjs391_i++,
    // ?

//comments
_htmlparser2libTokenizerjs391_BEFORE_COMMENT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_COMMENT = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_COMMENT_1 = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_AFTER_COMMENT_2 = _htmlparser2libTokenizerjs391_i++,


//cdata
_htmlparser2libTokenizerjs391_BEFORE_CDATA_1 = _htmlparser2libTokenizerjs391_i++,
    // [
_htmlparser2libTokenizerjs391_BEFORE_CDATA_2 = _htmlparser2libTokenizerjs391_i++,
    // C
_htmlparser2libTokenizerjs391_BEFORE_CDATA_3 = _htmlparser2libTokenizerjs391_i++,
    // D
_htmlparser2libTokenizerjs391_BEFORE_CDATA_4 = _htmlparser2libTokenizerjs391_i++,
    // A
_htmlparser2libTokenizerjs391_BEFORE_CDATA_5 = _htmlparser2libTokenizerjs391_i++,
    // T
_htmlparser2libTokenizerjs391_BEFORE_CDATA_6 = _htmlparser2libTokenizerjs391_i++,
    // A
_htmlparser2libTokenizerjs391_IN_CDATA = _htmlparser2libTokenizerjs391_i++,
    // [
_htmlparser2libTokenizerjs391_AFTER_CDATA_1 = _htmlparser2libTokenizerjs391_i++,
    // ]
_htmlparser2libTokenizerjs391_AFTER_CDATA_2 = _htmlparser2libTokenizerjs391_i++,
    // ]

//special tags
_htmlparser2libTokenizerjs391_BEFORE_SPECIAL = _htmlparser2libTokenizerjs391_i++,
    //S
_htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END = _htmlparser2libTokenizerjs391_i++,
    //S

_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1 = _htmlparser2libTokenizerjs391_i++,
    //C
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2 = _htmlparser2libTokenizerjs391_i++,
    //R
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3 = _htmlparser2libTokenizerjs391_i++,
    //I
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4 = _htmlparser2libTokenizerjs391_i++,
    //P
_htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_1 = _htmlparser2libTokenizerjs391_i++,
    //C
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_2 = _htmlparser2libTokenizerjs391_i++,
    //R
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_3 = _htmlparser2libTokenizerjs391_i++,
    //I
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_4 = _htmlparser2libTokenizerjs391_i++,
    //P
_htmlparser2libTokenizerjs391_AFTER_SCRIPT_5 = _htmlparser2libTokenizerjs391_i++,
    //T

_htmlparser2libTokenizerjs391_BEFORE_STYLE_1 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_BEFORE_STYLE_2 = _htmlparser2libTokenizerjs391_i++,
    //Y
_htmlparser2libTokenizerjs391_BEFORE_STYLE_3 = _htmlparser2libTokenizerjs391_i++,
    //L
_htmlparser2libTokenizerjs391_BEFORE_STYLE_4 = _htmlparser2libTokenizerjs391_i++,
    //E
_htmlparser2libTokenizerjs391_AFTER_STYLE_1 = _htmlparser2libTokenizerjs391_i++,
    //T
_htmlparser2libTokenizerjs391_AFTER_STYLE_2 = _htmlparser2libTokenizerjs391_i++,
    //Y
_htmlparser2libTokenizerjs391_AFTER_STYLE_3 = _htmlparser2libTokenizerjs391_i++,
    //L
_htmlparser2libTokenizerjs391_AFTER_STYLE_4 = _htmlparser2libTokenizerjs391_i++,
    //E

_htmlparser2libTokenizerjs391_BEFORE_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //&
_htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //#
_htmlparser2libTokenizerjs391_IN_NAMED_ENTITY = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY = _htmlparser2libTokenizerjs391_i++,
    _htmlparser2libTokenizerjs391_IN_HEX_ENTITY = _htmlparser2libTokenizerjs391_i++,
    //X

_htmlparser2libTokenizerjs391_j = 0,
    _htmlparser2libTokenizerjs391_SPECIAL_NONE = _htmlparser2libTokenizerjs391_j++,
    _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT = _htmlparser2libTokenizerjs391_j++,
    _htmlparser2libTokenizerjs391_SPECIAL_STYLE = _htmlparser2libTokenizerjs391_j++;

function _htmlparser2libTokenizerjs391_whitespace(c) {
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function _htmlparser2libTokenizerjs391_characterState(char, SUCCESS) {
	return function (c) {
		if (c === char) this._state = SUCCESS;
	};
}

function _htmlparser2libTokenizerjs391_ifElseState(upper, SUCCESS, FAILURE) {
	var lower = upper.toLowerCase();

	if (upper === lower) {
		return function (c) {
			if (c === lower) {
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function (c) {
			if (c === lower || c === upper) {
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function _htmlparser2libTokenizerjs391_consumeSpecialNameChar(upper, NEXT_STATE) {
	var lower = upper.toLowerCase();

	return function (c) {
		if (c === lower || c === upper) {
			this._state = NEXT_STATE;
		} else {
			this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function _htmlparser2libTokenizerjs391_Tokenizer(options, cbs) {
	this._state = _htmlparser2libTokenizerjs391_TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = _htmlparser2libTokenizerjs391_TEXT;
	this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateText = function (c) {
	if (c === "<") {
		if (this._index > this._sectionStart) {
			this._cbs.ontext(this._getSection());
		}
		this._state = _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if (this._decodeEntities && this._special === _htmlparser2libTokenizerjs391_SPECIAL_NONE && c === "&") {
		if (this._index > this._sectionStart) {
			this._cbs.ontext(this._getSection());
		}
		this._baseState = _htmlparser2libTokenizerjs391_TEXT;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeTagName = function (c) {
	if (c === "/") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME;
	} else if (c === "<") {
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if (c === ">" || this._special !== _htmlparser2libTokenizerjs391_SPECIAL_NONE || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
	} else if (c === "!") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if (c === "?") {
		this._state = _htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = !this._xmlMode && (c === "s" || c === "S") ? _htmlparser2libTokenizerjs391_BEFORE_SPECIAL : _htmlparser2libTokenizerjs391_IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInTagName = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._emitToken("onopentagname");
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCloseingTagName = function (c) {
	if (_htmlparser2libTokenizerjs391_whitespace(c)) ;else if (c === ">") {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
	} else if (this._special !== _htmlparser2libTokenizerjs391_SPECIAL_NONE) {
		if (c === "s" || c === "S") {
			this._state = _htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END;
		} else {
			this._state = _htmlparser2libTokenizerjs391_TEXT;
			this._index--;
		}
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInCloseingTagName = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._emitToken("onclosetag");
		this._state = _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCloseingTagName = function (c) {
	//skip everything until ">"
	if (c === ">") {
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeAttributeName = function (c) {
	if (c === ">") {
		this._cbs.onopentagend();
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c === "/") {
		this._state = _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInSelfClosingTag = function (c) {
	if (c === ">") {
		this._cbs.onselfclosingtag();
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeName = function (c) {
	if (c === "=" || c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterAttributeName = function (c) {
	if (c === "=") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE;
	} else if (c === "/" || c === ">") {
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeAttributeValue = function (c) {
	if (c === "\"") {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if (c === "'") {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if (!_htmlparser2libTokenizerjs391_whitespace(c)) {
		this._state = _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {
	if (c === "\"") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {
	if (c === "'") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {
	if (_htmlparser2libTokenizerjs391_whitespace(c) || c === ">") {
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if (this._decodeEntities && c === "&") {
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = _htmlparser2libTokenizerjs391_BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeDeclaration = function (c) {
	this._state = c === "[" ? _htmlparser2libTokenizerjs391_BEFORE_CDATA_1 : c === "-" ? _htmlparser2libTokenizerjs391_BEFORE_COMMENT : _htmlparser2libTokenizerjs391_IN_DECLARATION;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInDeclaration = function (c) {
	if (c === ">") {
		this._cbs.ondeclaration(this._getSection());
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInProcessingInstruction = function (c) {
	if (c === ">") {
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeComment = function (c) {
	if (c === "-") {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_DECLARATION;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInComment = function (c) {
	if (c === "-") this._state = _htmlparser2libTokenizerjs391_AFTER_COMMENT_1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterComment1 = function (c) {
	if (c === "-") {
		this._state = _htmlparser2libTokenizerjs391_AFTER_COMMENT_2;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterComment2 = function (c) {
	if (c === ">") {
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c !== "-") {
		this._state = _htmlparser2libTokenizerjs391_IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata1 = _htmlparser2libTokenizerjs391_ifElseState("C", _htmlparser2libTokenizerjs391_BEFORE_CDATA_2, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata2 = _htmlparser2libTokenizerjs391_ifElseState("D", _htmlparser2libTokenizerjs391_BEFORE_CDATA_3, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata3 = _htmlparser2libTokenizerjs391_ifElseState("A", _htmlparser2libTokenizerjs391_BEFORE_CDATA_4, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata4 = _htmlparser2libTokenizerjs391_ifElseState("T", _htmlparser2libTokenizerjs391_BEFORE_CDATA_5, _htmlparser2libTokenizerjs391_IN_DECLARATION);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata5 = _htmlparser2libTokenizerjs391_ifElseState("A", _htmlparser2libTokenizerjs391_BEFORE_CDATA_6, _htmlparser2libTokenizerjs391_IN_DECLARATION);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeCdata6 = function (c) {
	if (c === "[") {
		this._state = _htmlparser2libTokenizerjs391_IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_DECLARATION;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInCdata = function (c) {
	if (c === "]") this._state = _htmlparser2libTokenizerjs391_AFTER_CDATA_1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCdata1 = _htmlparser2libTokenizerjs391_characterState("]", _htmlparser2libTokenizerjs391_AFTER_CDATA_2);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterCdata2 = function (c) {
	if (c === ">") {
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = _htmlparser2libTokenizerjs391_TEXT;
		this._sectionStart = this._index + 1;
	} else if (c !== "]") {
		this._state = _htmlparser2libTokenizerjs391_IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeSpecial = function (c) {
	if (c === "c" || c === "C") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1;
	} else if (c === "t" || c === "T") {
		this._state = _htmlparser2libTokenizerjs391_BEFORE_STYLE_1;
	} else {
		this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
	if (this._special === _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT && (c === "c" || c === "C")) {
		this._state = _htmlparser2libTokenizerjs391_AFTER_SCRIPT_1;
	} else if (this._special === _htmlparser2libTokenizerjs391_SPECIAL_STYLE && (c === "t" || c === "T")) {
		this._state = _htmlparser2libTokenizerjs391_AFTER_STYLE_1;
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript1 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("R", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript2 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("I", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript3 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("P", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript4 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("T", _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeScript5 = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_SCRIPT;
	}
	this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
	this._index--; //consume the token again
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript1 = _htmlparser2libTokenizerjs391_ifElseState("R", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_2, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript2 = _htmlparser2libTokenizerjs391_ifElseState("I", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_3, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript3 = _htmlparser2libTokenizerjs391_ifElseState("P", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_4, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript4 = _htmlparser2libTokenizerjs391_ifElseState("T", _htmlparser2libTokenizerjs391_AFTER_SCRIPT_5, _htmlparser2libTokenizerjs391_TEXT);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterScript5 = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle1 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("Y", _htmlparser2libTokenizerjs391_BEFORE_STYLE_2);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle2 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("L", _htmlparser2libTokenizerjs391_BEFORE_STYLE_3);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle3 = _htmlparser2libTokenizerjs391_consumeSpecialNameChar("E", _htmlparser2libTokenizerjs391_BEFORE_STYLE_4);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeStyle4 = function (c) {
	if (c === "/" || c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_STYLE;
	}
	this._state = _htmlparser2libTokenizerjs391_IN_TAG_NAME;
	this._index--; //consume the token again
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle1 = _htmlparser2libTokenizerjs391_ifElseState("Y", _htmlparser2libTokenizerjs391_AFTER_STYLE_2, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle2 = _htmlparser2libTokenizerjs391_ifElseState("L", _htmlparser2libTokenizerjs391_AFTER_STYLE_3, _htmlparser2libTokenizerjs391_TEXT);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle3 = _htmlparser2libTokenizerjs391_ifElseState("E", _htmlparser2libTokenizerjs391_AFTER_STYLE_4, _htmlparser2libTokenizerjs391_TEXT);

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateAfterStyle4 = function (c) {
	if (c === ">" || _htmlparser2libTokenizerjs391_whitespace(c)) {
		this._special = _htmlparser2libTokenizerjs391_SPECIAL_NONE;
		this._state = _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	} else this._state = _htmlparser2libTokenizerjs391_TEXT;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeEntity = _htmlparser2libTokenizerjs391_ifElseState("#", _htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY, _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY);
_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateBeforeNumericEntity = _htmlparser2libTokenizerjs391_ifElseState("X", _htmlparser2libTokenizerjs391_IN_HEX_ENTITY, _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
_htmlparser2libTokenizerjs391_Tokenizer.prototype._parseNamedEntityStrict = function () {
	//offset = 1
	if (this._sectionStart + 1 < this._index) {
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? _htmlparser2libTokenizerjs391_xmlMap : _htmlparser2libTokenizerjs391_entityMap;

		if (map.hasOwnProperty(entity)) {
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};

//parses legacy entities (without trailing semicolon)
_htmlparser2libTokenizerjs391_Tokenizer.prototype._parseLegacyEntity = function () {
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if (limit > 6) limit = 6; //the max length of legacy entities is 6

	while (limit >= 2) {
		//the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if (_htmlparser2libTokenizerjs391_legacyMap.hasOwnProperty(entity)) {
			this._emitPartial(_htmlparser2libTokenizerjs391_legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInNamedEntity = function (c) {
	if (c === ";") {
		this._parseNamedEntityStrict();
		if (this._sectionStart + 1 < this._index && !this._xmlMode) {
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
		if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== _htmlparser2libTokenizerjs391_TEXT) {
			if (c !== "=") {
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
	var sectionStart = this._sectionStart + offset;

	if (sectionStart !== this._index) {
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(_htmlparser2libTokenizerjs391_decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInNumericEntity = function (c) {
	if (c === ";") {
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if (c < "0" || c > "9") {
		if (!this._xmlMode) {
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._stateInHexEntity = function (c) {
	if (c === ";") {
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
		if (!this._xmlMode) {
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._cleanup = function () {
	if (this._sectionStart < 0) {
		this._buffer = "";
		this._index = 0;
		this._bufferOffset += this._index;
	} else if (this._running) {
		if (this._state === _htmlparser2libTokenizerjs391_TEXT) {
			if (this._sectionStart !== this._index) {
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if (this._sectionStart === this._index) {
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
_htmlparser2libTokenizerjs391_Tokenizer.prototype.write = function (chunk) {
	if (this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._parse = function () {
	while (this._index < this._buffer.length && this._running) {
		var c = this._buffer.charAt(this._index);
		if (this._state === _htmlparser2libTokenizerjs391_TEXT) {
			this._stateText(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_TAG_NAME) {
			this._stateBeforeTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CLOSING_TAG_NAME) {
			this._stateBeforeCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME) {
			this._stateInCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CLOSING_TAG_NAME) {
			this._stateAfterCloseingTagName(c);
		} else if (this._state === _htmlparser2libTokenizerjs391_IN_SELF_CLOSING_TAG) {
			this._stateInSelfClosingTag(c);
		}

		/*
  *	attributes
  */
		else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME) {
				this._stateBeforeAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME) {
				this._stateInAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME) {
				this._stateAfterAttributeName(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE) {
				this._stateBeforeAttributeValue(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ) {
				this._stateInAttributeValueDoubleQuotes(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ) {
				this._stateInAttributeValueSingleQuotes(c);
			} else if (this._state === _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ) {
				this._stateInAttributeValueNoQuotes(c);
			}

			/*
   *	declarations
   */
			else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_DECLARATION) {
					this._stateBeforeDeclaration(c);
				} else if (this._state === _htmlparser2libTokenizerjs391_IN_DECLARATION) {
					this._stateInDeclaration(c);
				}

				/*
    *	processing instructions
    */
				else if (this._state === _htmlparser2libTokenizerjs391_IN_PROCESSING_INSTRUCTION) {
						this._stateInProcessingInstruction(c);
					}

					/*
     *	comments
     */
					else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_COMMENT) {
							this._stateBeforeComment(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_IN_COMMENT) {
							this._stateInComment(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_1) {
							this._stateAfterComment1(c);
						} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_2) {
							this._stateAfterComment2(c);
						}

						/*
      *	cdata
      */
						else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_1) {
								this._stateBeforeCdata1(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_2) {
								this._stateBeforeCdata2(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_3) {
								this._stateBeforeCdata3(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_4) {
								this._stateBeforeCdata4(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_5) {
								this._stateBeforeCdata5(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_CDATA_6) {
								this._stateBeforeCdata6(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_IN_CDATA) {
								this._stateInCdata(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_1) {
								this._stateAfterCdata1(c);
							} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_2) {
								this._stateAfterCdata2(c);
							}

							/*
       * special tags
       */
							else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SPECIAL) {
									this._stateBeforeSpecial(c);
								} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SPECIAL_END) {
									this._stateBeforeSpecialEnd(c);
								}

								/*
        * script
        */
								else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_1) {
										this._stateBeforeScript1(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_2) {
										this._stateBeforeScript2(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_3) {
										this._stateBeforeScript3(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_4) {
										this._stateBeforeScript4(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_SCRIPT_5) {
										this._stateBeforeScript5(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_1) {
										this._stateAfterScript1(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_2) {
										this._stateAfterScript2(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_3) {
										this._stateAfterScript3(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_4) {
										this._stateAfterScript4(c);
									} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_SCRIPT_5) {
										this._stateAfterScript5(c);
									}

									/*
         * style
         */
									else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_1) {
											this._stateBeforeStyle1(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_2) {
											this._stateBeforeStyle2(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_3) {
											this._stateBeforeStyle3(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_STYLE_4) {
											this._stateBeforeStyle4(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_1) {
											this._stateAfterStyle1(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_2) {
											this._stateAfterStyle2(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_3) {
											this._stateAfterStyle3(c);
										} else if (this._state === _htmlparser2libTokenizerjs391_AFTER_STYLE_4) {
											this._stateAfterStyle4(c);
										}

										/*
          * entities
          */
										else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_ENTITY) {
												this._stateBeforeEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_BEFORE_NUMERIC_ENTITY) {
												this._stateBeforeNumericEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY) {
												this._stateInNamedEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY) {
												this._stateInNumericEntity(c);
											} else if (this._state === _htmlparser2libTokenizerjs391_IN_HEX_ENTITY) {
												this._stateInHexEntity(c);
											} else {
												this._cbs.onerror(Error("unknown _state"), this._state);
											}

		this._index++;
	}

	this._cleanup();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.pause = function () {
	this._running = false;
};
_htmlparser2libTokenizerjs391_Tokenizer.prototype.resume = function () {
	this._running = true;

	if (this._index < this._buffer.length) {
		this._parse();
	}
	if (this._ended) {
		this._finish();
	}
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.end = function (chunk) {
	if (this._ended) this._cbs.onerror(Error(".end() after done!"));
	if (chunk) this.write(chunk);

	this._ended = true;

	if (this._running) this._finish();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._finish = function () {
	//if there is remaining data, emit it in a reasonable way
	if (this._sectionStart < this._index) {
		this._handleTrailingData();
	}

	this._cbs.onend();
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._handleTrailingData = function () {
	var data = this._buffer.substr(this._sectionStart);

	if (this._state === _htmlparser2libTokenizerjs391_IN_CDATA || this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_1 || this._state === _htmlparser2libTokenizerjs391_AFTER_CDATA_2) {
		this._cbs.oncdata(data);
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_COMMENT || this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_1 || this._state === _htmlparser2libTokenizerjs391_AFTER_COMMENT_2) {
		this._cbs.oncomment(data);
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_NAMED_ENTITY && !this._xmlMode) {
		this._parseLegacyEntity();
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_NUMERIC_ENTITY && !this._xmlMode) {
		this._decodeNumericEntity(2, 10);
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state === _htmlparser2libTokenizerjs391_IN_HEX_ENTITY && !this._xmlMode) {
		this._decodeNumericEntity(3, 16);
		if (this._sectionStart < this._index) {
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if (this._state !== _htmlparser2libTokenizerjs391_IN_TAG_NAME && this._state !== _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_BEFORE_ATTRIBUTE_VALUE && this._state !== _htmlparser2libTokenizerjs391_AFTER_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_NAME && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_SQ && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_DQ && this._state !== _htmlparser2libTokenizerjs391_IN_ATTRIBUTE_VALUE_NQ && this._state !== _htmlparser2libTokenizerjs391_IN_CLOSING_TAG_NAME) {
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.reset = function () {
	_htmlparser2libTokenizerjs391_Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype.getAbsoluteIndex = function () {
	return this._bufferOffset + this._index;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._getSection = function () {
	return this._buffer.substring(this._sectionStart, this._index);
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._emitToken = function (name) {
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

_htmlparser2libTokenizerjs391_Tokenizer.prototype._emitPartial = function (value) {
	if (this._baseState !== _htmlparser2libTokenizerjs391_TEXT) {
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};
/*≠≠ node_modules/htmlparser2/lib/Tokenizer.js ≠≠*/

/*== node_modules/htmlparser2/lib/Parser.js ==*/
$m['htmlparser2/lib/Parser.js#3.9.1'] = { exports: {} };
var _htmlparser2libParserjs391_Tokenizer = $m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports;

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var _htmlparser2libParserjs391_formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var _htmlparser2libParserjs391_openImpliesClose = {
	tr: { tr: true, th: true, td: true },
	th: { th: true },
	td: { thead: true, th: true, td: true },
	body: { head: true, link: true, script: true },
	li: { li: true },
	p: { p: true },
	h1: { p: true },
	h2: { p: true },
	h3: { p: true },
	h4: { p: true },
	h5: { p: true },
	h6: { p: true },
	select: _htmlparser2libParserjs391_formTags,
	input: _htmlparser2libParserjs391_formTags,
	output: _htmlparser2libParserjs391_formTags,
	button: _htmlparser2libParserjs391_formTags,
	datalist: _htmlparser2libParserjs391_formTags,
	textarea: _htmlparser2libParserjs391_formTags,
	option: { option: true },
	optgroup: { optgroup: true }
};

var _htmlparser2libParserjs391_voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var _htmlparser2libParserjs391_re_nameEnd = /\s|\//;

function _htmlparser2libParserjs391_Parser(cbs, options) {
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;

	if (this._options.Tokenizer) {
		_htmlparser2libParserjs391_Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new _htmlparser2libParserjs391_Tokenizer(this._options, this);

	if (this._cbs.onparserinit) this._cbs.onparserinit(this);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libParserjs391_Parser, require("events").EventEmitter);

_htmlparser2libParserjs391_Parser.prototype._updatePosition = function (initialOffset) {
	if (this.endIndex === null) {
		if (this._tokenizer._sectionStart <= initialOffset) {
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	} else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
_htmlparser2libParserjs391_Parser.prototype.ontext = function (data) {
	this._updatePosition(1);
	this.endIndex--;

	if (this._cbs.ontext) this._cbs.ontext(data);
};

_htmlparser2libParserjs391_Parser.prototype.onopentagname = function (name) {
	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	this._tagname = name;

	if (!this._options.xmlMode && name in _htmlparser2libParserjs391_openImpliesClose) {
		for (var el; (el = this._stack[this._stack.length - 1]) in _htmlparser2libParserjs391_openImpliesClose[name]; this.onclosetag(el));
	}

	if (this._options.xmlMode || !(name in _htmlparser2libParserjs391_voidElements)) {
		this._stack.push(name);
	}

	if (this._cbs.onopentagname) this._cbs.onopentagname(name);
	if (this._cbs.onopentag) this._attribs = {};
};

_htmlparser2libParserjs391_Parser.prototype.onopentagend = function () {
	this._updatePosition(1);

	if (this._attribs) {
		if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in _htmlparser2libParserjs391_voidElements) {
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

_htmlparser2libParserjs391_Parser.prototype.onclosetag = function (name) {
	this._updatePosition(1);

	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	if (this._stack.length && (!(name in _htmlparser2libParserjs391_voidElements) || this._options.xmlMode)) {
		var pos = this._stack.lastIndexOf(name);
		if (pos !== -1) {
			if (this._cbs.onclosetag) {
				pos = this._stack.length - pos;
				while (pos--) this._cbs.onclosetag(this._stack.pop());
			} else this._stack.length = pos;
		} else if (name === "p" && !this._options.xmlMode) {
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if (!this._options.xmlMode && (name === "br" || name === "p")) {
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

_htmlparser2libParserjs391_Parser.prototype.onselfclosingtag = function () {
	if (this._options.xmlMode || this._options.recognizeSelfClosing) {
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

_htmlparser2libParserjs391_Parser.prototype._closeCurrentTag = function () {
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if (this._stack[this._stack.length - 1] === name) {
		if (this._cbs.onclosetag) {
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

_htmlparser2libParserjs391_Parser.prototype.onattribname = function (name) {
	if (this._lowerCaseAttributeNames) {
		name = name.toLowerCase();
	}
	this._attribname = name;
};

_htmlparser2libParserjs391_Parser.prototype.onattribdata = function (value) {
	this._attribvalue += value;
};

_htmlparser2libParserjs391_Parser.prototype.onattribend = function () {
	if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

_htmlparser2libParserjs391_Parser.prototype._getInstructionName = function (value) {
	var idx = value.search(_htmlparser2libParserjs391_re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if (this._lowerCaseTagNames) {
		name = name.toLowerCase();
	}

	return name;
};

_htmlparser2libParserjs391_Parser.prototype.ondeclaration = function (value) {
	if (this._cbs.onprocessinginstruction) {
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

_htmlparser2libParserjs391_Parser.prototype.onprocessinginstruction = function (value) {
	if (this._cbs.onprocessinginstruction) {
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

_htmlparser2libParserjs391_Parser.prototype.oncomment = function (value) {
	this._updatePosition(4);

	if (this._cbs.oncomment) this._cbs.oncomment(value);
	if (this._cbs.oncommentend) this._cbs.oncommentend();
};

_htmlparser2libParserjs391_Parser.prototype.oncdata = function (value) {
	this._updatePosition(1);

	if (this._options.xmlMode || this._options.recognizeCDATA) {
		if (this._cbs.oncdatastart) this._cbs.oncdatastart();
		if (this._cbs.ontext) this._cbs.ontext(value);
		if (this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

_htmlparser2libParserjs391_Parser.prototype.onerror = function (err) {
	if (this._cbs.onerror) this._cbs.onerror(err);
};

_htmlparser2libParserjs391_Parser.prototype.onend = function () {
	if (this._cbs.onclosetag) {
		for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));
	}
	if (this._cbs.onend) this._cbs.onend();
};

//Resets the parser to a blank state, ready to parse a new HTML document
_htmlparser2libParserjs391_Parser.prototype.reset = function () {
	if (this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if (this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
_htmlparser2libParserjs391_Parser.prototype.parseComplete = function (data) {
	this.reset();
	this.end(data);
};

_htmlparser2libParserjs391_Parser.prototype.write = function (chunk) {
	this._tokenizer.write(chunk);
};

_htmlparser2libParserjs391_Parser.prototype.end = function (chunk) {
	this._tokenizer.end(chunk);
};

_htmlparser2libParserjs391_Parser.prototype.pause = function () {
	this._tokenizer.pause();
};

_htmlparser2libParserjs391_Parser.prototype.resume = function () {
	this._tokenizer.resume();
};

//alias for backwards compat
_htmlparser2libParserjs391_Parser.prototype.parseChunk = _htmlparser2libParserjs391_Parser.prototype.write;
_htmlparser2libParserjs391_Parser.prototype.done = _htmlparser2libParserjs391_Parser.prototype.end;

$m['htmlparser2/lib/Parser.js#3.9.1'].exports = _htmlparser2libParserjs391_Parser;
/*≠≠ node_modules/htmlparser2/lib/Parser.js ≠≠*/

/*== node_modules/htmlparser2/lib/WritableStream.js ==*/
$m['htmlparser2/lib/WritableStream.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/WritableStream.js#3.9.1'].exports = _htmlparser2libWritableStreamjs391_Stream;

var _htmlparser2libWritableStreamjs391_Parser = $m['htmlparser2/lib/Parser.js#3.9.1'].exports,
    _htmlparser2libWritableStreamjs391_WritableStream = require("stream").Writable || {}.Writable,
    _htmlparser2libWritableStreamjs391_StringDecoder = require("string_decoder").StringDecoder,
    _htmlparser2libWritableStreamjs391_Buffer = require("buffer").Buffer;

function _htmlparser2libWritableStreamjs391_Stream(cbs, options) {
	var parser = this._parser = new _htmlparser2libWritableStreamjs391_Parser(cbs, options);
	var decoder = this._decoder = new _htmlparser2libWritableStreamjs391_StringDecoder();

	_htmlparser2libWritableStreamjs391_WritableStream.call(this, { decodeStrings: false });

	this.once("finish", function () {
		parser.end(decoder.end());
	});
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libWritableStreamjs391_Stream, _htmlparser2libWritableStreamjs391_WritableStream);

_htmlparser2libWritableStreamjs391_WritableStream.prototype._write = function (chunk, encoding, cb) {
	if (chunk instanceof _htmlparser2libWritableStreamjs391_Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};
/*≠≠ node_modules/htmlparser2/lib/WritableStream.js ≠≠*/

/*== node_modules/htmlparser2/lib/Stream.js ==*/
$m['htmlparser2/lib/Stream.js#3.9.1'] = function () {
$m['htmlparser2/lib/Stream.js#3.9.1'] = { exports: {} };
$m['htmlparser2/lib/Stream.js#3.9.1'].exports = _htmlparser2libStreamjs391_Stream;

var _htmlparser2libStreamjs391_Parser = $m['htmlparser2/lib/WritableStream.js#3.9.1'].exports;

function _htmlparser2libStreamjs391_Stream(options) {
	_htmlparser2libStreamjs391_Parser.call(this, new _htmlparser2libStreamjs391_Cbs(this), options);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libStreamjs391_Stream, _htmlparser2libStreamjs391_Parser);

_htmlparser2libStreamjs391_Stream.prototype.readable = true;

function _htmlparser2libStreamjs391_Cbs(scope) {
	this.scope = scope;
}

var _htmlparser2libStreamjs391_EVENTS = $m['htmlparser2/lib/index.js#3.9.1'].exports.EVENTS;

Object.keys(_htmlparser2libStreamjs391_EVENTS).forEach(function (name) {
	if (_htmlparser2libStreamjs391_EVENTS[name] === 0) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function () {
			this.scope.emit(name);
		};
	} else if (_htmlparser2libStreamjs391_EVENTS[name] === 1) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function (a) {
			this.scope.emit(name, a);
		};
	} else if (_htmlparser2libStreamjs391_EVENTS[name] === 2) {
		_htmlparser2libStreamjs391_Cbs.prototype["on" + name] = function (a, b) {
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});
};
/*≠≠ node_modules/htmlparser2/lib/Stream.js ≠≠*/

/*== node_modules/htmlparser2/lib/FeedHandler.js ==*/
$m['htmlparser2/lib/FeedHandler.js#3.9.1'] = function () {
$m['htmlparser2/lib/FeedHandler.js#3.9.1'] = { exports: {} };
var _htmlparser2libFeedHandlerjs391_index = $m['htmlparser2/lib/index.js#3.9.1'].exports,
    _htmlparser2libFeedHandlerjs391_DomHandler = _htmlparser2libFeedHandlerjs391_index.DomHandler,
    _htmlparser2libFeedHandlerjs391_DomUtils = _htmlparser2libFeedHandlerjs391_index.DomUtils;

//TODO: make this a streamable handler
function _htmlparser2libFeedHandlerjs391_FeedHandler(callback, options) {
	this.init(callback, options);
}

$m['inherits/inherits_browser.js#2.0.3'].exports(_htmlparser2libFeedHandlerjs391_FeedHandler, _htmlparser2libFeedHandlerjs391_DomHandler);

_htmlparser2libFeedHandlerjs391_FeedHandler.prototype.init = _htmlparser2libFeedHandlerjs391_DomHandler;

function _htmlparser2libFeedHandlerjs391_getElements(what, where) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, true);
}
function _htmlparser2libFeedHandlerjs391_getOneElement(what, where) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function _htmlparser2libFeedHandlerjs391_fetch(what, where, recurse) {
	return _htmlparser2libFeedHandlerjs391_DomUtils.getText(_htmlparser2libFeedHandlerjs391_DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
}

function _htmlparser2libFeedHandlerjs391_addConditionally(obj, prop, what, where, recurse) {
	var tmp = _htmlparser2libFeedHandlerjs391_fetch(what, where, recurse);
	if (tmp) obj[prop] = tmp;
}

var _htmlparser2libFeedHandlerjs391_isValidFeed = function (value) {
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

_htmlparser2libFeedHandlerjs391_FeedHandler.prototype.onend = function () {
	var feed = {},
	    feedRoot = _htmlparser2libFeedHandlerjs391_getOneElement(_htmlparser2libFeedHandlerjs391_isValidFeed, this.dom),
	    tmp,
	    childs;

	if (feedRoot) {
		if (feedRoot.name === "feed") {
			childs = feedRoot.children;

			feed.type = "atom";
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "id", "id", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "title", "title", childs);
			if ((tmp = _htmlparser2libFeedHandlerjs391_getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "description", "subtitle", childs);
			if (tmp = _htmlparser2libFeedHandlerjs391_fetch("updated", childs)) feed.updated = new Date(tmp);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "author", "email", childs, true);

			feed.items = _htmlparser2libFeedHandlerjs391_getElements("entry", childs).map(function (item) {
				var entry = {},
				    tmp;

				item = item.children;

				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "id", "id", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "title", "title", item);
				if ((tmp = _htmlparser2libFeedHandlerjs391_getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("summary", item) || _htmlparser2libFeedHandlerjs391_fetch("content", item)) entry.description = tmp;
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("updated", item)) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = _htmlparser2libFeedHandlerjs391_getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "title", "title", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "link", "link", childs);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "description", "description", childs);
			if (tmp = _htmlparser2libFeedHandlerjs391_fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);
			_htmlparser2libFeedHandlerjs391_addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = _htmlparser2libFeedHandlerjs391_getElements("item", feedRoot.children).map(function (item) {
				var entry = {},
				    tmp;

				item = item.children;

				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "id", "guid", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "title", "title", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "link", "link", item);
				_htmlparser2libFeedHandlerjs391_addConditionally(entry, "description", "description", item);
				if (tmp = _htmlparser2libFeedHandlerjs391_fetch("pubDate", item)) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	_htmlparser2libFeedHandlerjs391_DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
};

$m['htmlparser2/lib/FeedHandler.js#3.9.1'].exports = _htmlparser2libFeedHandlerjs391_FeedHandler;
};
/*≠≠ node_modules/htmlparser2/lib/FeedHandler.js ≠≠*/

/*== node_modules/domhandler/lib/node.js ==*/
$m['domhandler/lib/node.js#2.3.0'] = { exports: {} };
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var _domhandlerlibnodejs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return _domhandlerlibnodejs230_nodeTypes[this.type] || _domhandlerlibnodejs230_nodeTypes.element;
	}
};

var _domhandlerlibnodejs230_domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var _domhandlerlibnodejs230_nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(_domhandlerlibnodejs230_domLvl1).forEach(function (key) {
	var shorthand = _domhandlerlibnodejs230_domLvl1[key];
	Object.defineProperty(_domhandlerlibnodejs230_NodePrototype, key, {
		get: function () {
			return this[shorthand] || null;
		},
		set: function (val) {
			this[shorthand] = val;
			return val;
		}
	});
});
/*≠≠ node_modules/domhandler/lib/node.js ≠≠*/

/*== node_modules/domhandler/lib/element.js ==*/
$m['domhandler/lib/element.js#2.3.0'] = { exports: {} };
// DOM-Level-1-compliant structure
var _domhandlerlibelementjs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports;
var _domhandlerlibelementjs230_ElementPrototype = $m['domhandler/lib/element.js#2.3.0'].exports = Object.create(_domhandlerlibelementjs230_NodePrototype);

var _domhandlerlibelementjs230_domLvl1 = {
	tagName: "name"
};

Object.keys(_domhandlerlibelementjs230_domLvl1).forEach(function (key) {
	var shorthand = _domhandlerlibelementjs230_domLvl1[key];
	Object.defineProperty(_domhandlerlibelementjs230_ElementPrototype, key, {
		get: function () {
			return this[shorthand] || null;
		},
		set: function (val) {
			this[shorthand] = val;
			return val;
		}
	});
});
/*≠≠ node_modules/domhandler/lib/element.js ≠≠*/

/*== node_modules/domhandler/index.js ==*/
$m['domhandler/index.js#2.3.0'] = { exports: {} };
var _domhandlerindexjs230_ElementType = $m['domelementtype/index.js#1.3.0'].exports;

var _domhandlerindexjs230_re_whitespace = /\s+/g;
var _domhandlerindexjs230_NodePrototype = $m['domhandler/lib/node.js#2.3.0'].exports;
var _domhandlerindexjs230_ElementPrototype = $m['domhandler/lib/element.js#2.3.0'].exports;

function _domhandlerindexjs230_DomHandler(callback, options, elementCB) {
	if (typeof callback === "object") {
		elementCB = options;
		options = callback;
		callback = null;
	} else if (typeof options === "function") {
		elementCB = options;
		options = _domhandlerindexjs230_defaultOpts;
	}
	this._callback = callback;
	this._options = options || _domhandlerindexjs230_defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var _domhandlerindexjs230_defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false };

_domhandlerindexjs230_DomHandler.prototype.onparserinit = function (parser) {
	this._parser = parser;
};

//Resets the handler back to starting state
_domhandlerindexjs230_DomHandler.prototype.onreset = function () {
	_domhandlerindexjs230_DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
_domhandlerindexjs230_DomHandler.prototype.onend = function () {
	if (this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

_domhandlerindexjs230_DomHandler.prototype._handleCallback = _domhandlerindexjs230_DomHandler.prototype.onerror = function (error) {
	if (typeof this._callback === "function") {
		this._callback(error, this.dom);
	} else {
		if (error) throw error;
	}
};

_domhandlerindexjs230_DomHandler.prototype.onclosetag = function () {
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	var elem = this._tagStack.pop();
	if (this._elementCB) this._elementCB(elem);
};

_domhandlerindexjs230_DomHandler.prototype._addDomElement = function (element) {
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if (this._options.withStartIndices) {
		element.startIndex = this._parser.startIndex;
	}

	if (this._options.withDomLvl1) {
		element.__proto__ = element.type === "tag" ? _domhandlerindexjs230_ElementPrototype : _domhandlerindexjs230_NodePrototype;
	}

	if (previousSibling) {
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

_domhandlerindexjs230_DomHandler.prototype.onopentag = function (name, attribs) {
	var element = {
		type: name === "script" ? _domhandlerindexjs230_ElementType.Script : name === "style" ? _domhandlerindexjs230_ElementType.Style : _domhandlerindexjs230_ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	this._addDomElement(element);

	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.ontext = function (data) {
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === _domhandlerindexjs230_ElementType.Text) {
		if (normalize) {
			lastTag.data = (lastTag.data + data).replace(_domhandlerindexjs230_re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === _domhandlerindexjs230_ElementType.Text) {
			if (normalize) {
				lastTag.data = (lastTag.data + data).replace(_domhandlerindexjs230_re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if (normalize) {
				data = data.replace(_domhandlerindexjs230_re_whitespace, " ");
			}

			this._addDomElement({
				data: data,
				type: _domhandlerindexjs230_ElementType.Text
			});
		}
	}
};

_domhandlerindexjs230_DomHandler.prototype.oncomment = function (data) {
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if (lastTag && lastTag.type === _domhandlerindexjs230_ElementType.Comment) {
		lastTag.data += data;
		return;
	}

	var element = {
		data: data,
		type: _domhandlerindexjs230_ElementType.Comment
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.oncdatastart = function () {
	var element = {
		children: [{
			data: "",
			type: _domhandlerindexjs230_ElementType.Text
		}],
		type: _domhandlerindexjs230_ElementType.CDATA
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

_domhandlerindexjs230_DomHandler.prototype.oncommentend = _domhandlerindexjs230_DomHandler.prototype.oncdataend = function () {
	this._tagStack.pop();
};

_domhandlerindexjs230_DomHandler.prototype.onprocessinginstruction = function (name, data) {
	this._addDomElement({
		name: name,
		data: data,
		type: _domhandlerindexjs230_ElementType.Directive
	});
};

$m['domhandler/index.js#2.3.0'].exports = _domhandlerindexjs230_DomHandler;
/*≠≠ node_modules/domhandler/index.js ≠≠*/

/*== node_modules/htmlparser2/lib/index.js ==*/
$m['htmlparser2/lib/index.js#3.9.1'] = { exports: {} };
var _htmlparser2libindexjs391_Parser = $m['htmlparser2/lib/Parser.js#3.9.1'].exports,
    _htmlparser2libindexjs391_DomHandler = $m['domhandler/index.js#2.3.0'].exports;

function _htmlparser2libindexjs391_defineProp(name, value) {
	delete $m['htmlparser2/lib/index.js#3.9.1'].exports[name];
	$m['htmlparser2/lib/index.js#3.9.1'].exports[name] = value;
	return value;
}

$m['htmlparser2/lib/index.js#3.9.1'].exports = {
	Parser: _htmlparser2libindexjs391_Parser,
	Tokenizer: $m['htmlparser2/lib/Tokenizer.js#3.9.1'].exports,
	ElementType: $m['domelementtype/index.js#1.3.0'].exports,
	DomHandler: _htmlparser2libindexjs391_DomHandler,
	get FeedHandler() {
		return _htmlparser2libindexjs391_defineProp("FeedHandler", require("htmlparser2/lib/FeedHandler.js#3.9.1"));
	},
	get Stream() {
		return _htmlparser2libindexjs391_defineProp("Stream", require("htmlparser2/lib/Stream.js#3.9.1"));
	},
	get WritableStream() {
		return _htmlparser2libindexjs391_defineProp("WritableStream", $m['htmlparser2/lib/WritableStream.js#3.9.1'].exports);
	},
	get ProxyHandler() {
		return _htmlparser2libindexjs391_defineProp("ProxyHandler", require("htmlparser2/lib/ProxyHandler.js#3.9.1"));
	},
	get DomUtils() {
		return _htmlparser2libindexjs391_defineProp("DomUtils", $m['domutils/index.js#1.5.1'].exports);
	},
	get CollectingHandler() {
		return _htmlparser2libindexjs391_defineProp("CollectingHandler", require("htmlparser2/lib/CollectingHandler.js#3.9.1"));
	},
	// For legacy support
	DefaultHandler: _htmlparser2libindexjs391_DomHandler,
	get RssHandler() {
		return _htmlparser2libindexjs391_defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function (data, options) {
		var handler = new _htmlparser2libindexjs391_DomHandler(options);
		new _htmlparser2libindexjs391_Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function (feed, options) {
		var handler = new $m['htmlparser2/lib/index.js#3.9.1'].exports.FeedHandler(options);
		new _htmlparser2libindexjs391_Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function (cb, options, elementCb) {
		var handler = new _htmlparser2libindexjs391_DomHandler(cb, options, elementCb);
		return new _htmlparser2libindexjs391_Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};
/*≠≠ node_modules/htmlparser2/lib/index.js ≠≠*/

/*== node_modules/inline-source/lib/parse.js ==*/
$m['inline-source/lib/parse.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibparsejs510_htmlparser = $m['htmlparser2/lib/index.js#3.9.1'].exports;
const _inlinesourcelibparsejs510_path = require('path');
const _inlinesourcelibparsejs510_utils = $m['inline-source/lib/utils.js#5.1.0'].exports;

const _inlinesourcelibparsejs510_RE_COMMENT = /(<!--[^[i][\S\s]+?--\s?>)/gm;

/**
 * Parse inlineable sources, modifying passed 'context'
 * @param {Object} context
 * @param {Function} [fn]
 */
$m['inline-source/lib/parse.js#5.1.0'].exports = function parse(context, fn) {
  fn = fn || _inlinesourcelibparsejs510_utils.noop;

  const html = context.html.replace(_inlinesourcelibparsejs510_RE_COMMENT, '');
  // This api uses a synchronous callback handler, so order and definition of 'match' is preserved
  const parser = new _inlinesourcelibparsejs510_htmlparser.Parser(new _inlinesourcelibparsejs510_htmlparser.DomHandler(function (err, dom) {
    if (err) return fn(err);

    const parsed = dom[0];
    const attributes = _inlinesourcelibparsejs510_utils.parseAttributes(parsed.attribs);
    const props = _inlinesourcelibparsejs510_utils.parseProps(attributes, context.attribute);
    const tag = match[1];
    const type = _inlinesourcelibparsejs510_utils.getTypeFromType(attributes.type) || _inlinesourcelibparsejs510_utils.getTypeFromTag(match[1]);
    const filepath = _inlinesourcelibparsejs510_utils.getSourcepath(attributes.src || attributes.href || attributes.data, context.htmlpath, context.rootpath);
    const extension = _inlinesourcelibparsejs510_path.extname(filepath[0]).slice(1);
    const format = _inlinesourcelibparsejs510_utils.getFormatFromExtension(extension);

    // Ignore based on tag or type
    if (!_inlinesourcelibparsejs510_utils.isIgnored(context.ignore, tag, type, format)) {
      context.sources.push({
        attributes,
        compress: 'compress' in props ? props.compress : context.compress,
        content: null,
        errored: false,
        extension,
        fileContent: '',
        filepath: filepath[0],
        filepathAnchor: filepath[1],
        format,
        match: match[0],
        padding: context.pretty ? _inlinesourcelibparsejs510_utils.getPadding(match[0], context.html) : '',
        parentContext: context,
        props,
        replace: '',
        stack: context.stack,
        svgAsImage: 'svgasimage' in props ? props.svgasimage : context.svgAsImage,
        tag: match[1],
        type
      });
    }
  }));
  let match;

  while (match = context.re.exec(html)) {
    parser.parseComplete(match);
  }

  fn();
};
/*≠≠ node_modules/inline-source/lib/parse.js ≠≠*/

/*== node_modules/inline-source/lib/wrap.js ==*/
$m['inline-source/lib/wrap.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibwrapjs510_utils = $m['inline-source/lib/utils.js#5.1.0'].exports;

const _inlinesourcelibwrapjs510_RE_BEGIN_LINE = /^./gm;

/**
 * Wrap source content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 */
$m['inline-source/lib/wrap.js#5.1.0'].exports = function wrap(source, context, next) {
  if (source.content != null && !source.replace) {
    const attrs = _inlinesourcelibwrapjs510_utils.getAttributeString(source.attributes, context.attribute, !source.errored);
    // link tags are not closed
    const closing = source.tag != 'link' ? '</' + source.tag + '>' : '';
    const content = context.pretty ? '\n' + source.content.replace(_inlinesourcelibwrapjs510_RE_BEGIN_LINE, source.padding + '$&') + '\n' + source.padding : source.content;

    source.replace = '<' + source.tag + attrs + '>' + content + closing;
  }

  if (next) next();
};
/*≠≠ node_modules/inline-source/lib/wrap.js ≠≠*/

/*== node_modules/inline-source/lib/load.js ==*/
$m['inline-source/lib/load.js#5.1.0'] = { exports: {} };
'use strict';

/**
 * Load content for 'source'
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 */

$m['inline-source/lib/load.js#5.1.0'].exports = function load(source, context, next) {
  if (!source.fileContent && source.filepath) {
    // Raw buffer if image and not svg
    var encoding = source.type == 'image' && source.format != 'svg+xml' ? null : 'utf8';

    if (next) {
      context.fs.readFile(source.filepath, encoding, (err, content) => {
        if (err) return next(err);
        source.fileContent = content;
        return next();
      });
    } else {
      source.fileContent = context.fs.readFileSync(source.filepath, encoding);
    }
  } else {
    if (next) next();
  }
};
/*≠≠ node_modules/inline-source/lib/load.js ≠≠*/

/*== node_modules/lodash/_isIterateeCall.js ==*/
$m['lodash/_isIterateeCall.js#4.15.0'] = { exports: {} };
var _lodashisIterateeCalljs4150_eq = $m['lodash/eq.js#4.15.0'].exports,
    _lodashisIterateeCalljs4150_isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports,
    _lodashisIterateeCalljs4150_isIndex = $m['lodash/_isIndex.js#4.15.0'].exports,
    _lodashisIterateeCalljs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function _lodashisIterateeCalljs4150_isIterateeCall(value, index, object) {
  if (!_lodashisIterateeCalljs4150_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number' ? _lodashisIterateeCalljs4150_isArrayLike(object) && _lodashisIterateeCalljs4150_isIndex(index, object.length) : type == 'string' && index in object) {
    return _lodashisIterateeCalljs4150_eq(object[index], value);
  }
  return false;
}

$m['lodash/_isIterateeCall.js#4.15.0'].exports = _lodashisIterateeCalljs4150_isIterateeCall;
/*≠≠ node_modules/lodash/_isIterateeCall.js ≠≠*/

/*== node_modules/lodash/_createAssigner.js ==*/
$m['lodash/_createAssigner.js#4.15.0'] = { exports: {} };
var _lodashcreateAssignerjs4150_baseRest = $m['lodash/_baseRest.js#4.15.0'].exports,
    _lodashcreateAssignerjs4150_isIterateeCall = $m['lodash/_isIterateeCall.js#4.15.0'].exports;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function _lodashcreateAssignerjs4150_createAssigner(assigner) {
  return _lodashcreateAssignerjs4150_baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && _lodashcreateAssignerjs4150_isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

$m['lodash/_createAssigner.js#4.15.0'].exports = _lodashcreateAssignerjs4150_createAssigner;
/*≠≠ node_modules/lodash/_createAssigner.js ≠≠*/

/*== node_modules/lodash/_nativeKeysIn.js ==*/
$m['lodash/_nativeKeysIn.js#4.15.0'] = { exports: {} };
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashnativeKeysInjs4150_nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_nativeKeysIn.js#4.15.0'].exports = _lodashnativeKeysInjs4150_nativeKeysIn;
/*≠≠ node_modules/lodash/_nativeKeysIn.js ≠≠*/

/*== node_modules/lodash/_baseKeysIn.js ==*/
$m['lodash/_baseKeysIn.js#4.15.0'] = { exports: {} };
var _lodashbaseKeysInjs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseKeysInjs4150_isPrototype = $m['lodash/_isPrototype.js#4.15.0'].exports,
    _lodashbaseKeysInjs4150_nativeKeysIn = $m['lodash/_nativeKeysIn.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashbaseKeysInjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashbaseKeysInjs4150_hasOwnProperty = _lodashbaseKeysInjs4150_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function _lodashbaseKeysInjs4150_baseKeysIn(object) {
  if (!_lodashbaseKeysInjs4150_isObject(object)) {
    return _lodashbaseKeysInjs4150_nativeKeysIn(object);
  }
  var isProto = _lodashbaseKeysInjs4150_isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_lodashbaseKeysInjs4150_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

$m['lodash/_baseKeysIn.js#4.15.0'].exports = _lodashbaseKeysInjs4150_baseKeysIn;
/*≠≠ node_modules/lodash/_baseKeysIn.js ≠≠*/

/*== node_modules/lodash/keysIn.js ==*/
$m['lodash/keysIn.js#4.15.0'] = { exports: {} };
var _lodashkeysInjs4150_arrayLikeKeys = $m['lodash/_arrayLikeKeys.js#4.15.0'].exports,
    _lodashkeysInjs4150_baseKeysIn = $m['lodash/_baseKeysIn.js#4.15.0'].exports,
    _lodashkeysInjs4150_isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function _lodashkeysInjs4150_keysIn(object) {
  return _lodashkeysInjs4150_isArrayLike(object) ? _lodashkeysInjs4150_arrayLikeKeys(object, true) : _lodashkeysInjs4150_baseKeysIn(object);
}

$m['lodash/keysIn.js#4.15.0'].exports = _lodashkeysInjs4150_keysIn;
/*≠≠ node_modules/lodash/keysIn.js ≠≠*/

/*== node_modules/lodash/_assignValue.js ==*/
$m['lodash/_assignValue.js#4.15.0'] = { exports: {} };
var _lodashassignValuejs4150_eq = $m['lodash/eq.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashassignValuejs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashassignValuejs4150_hasOwnProperty = _lodashassignValuejs4150_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function _lodashassignValuejs4150_assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_lodashassignValuejs4150_hasOwnProperty.call(object, key) && _lodashassignValuejs4150_eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}

$m['lodash/_assignValue.js#4.15.0'].exports = _lodashassignValuejs4150_assignValue;
/*≠≠ node_modules/lodash/_assignValue.js ≠≠*/

/*== node_modules/lodash/_copyObject.js ==*/
$m['lodash/_copyObject.js#4.15.0'] = { exports: {} };
var _lodashcopyObjectjs4150_assignValue = $m['lodash/_assignValue.js#4.15.0'].exports;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function _lodashcopyObjectjs4150_copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    _lodashcopyObjectjs4150_assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

$m['lodash/_copyObject.js#4.15.0'].exports = _lodashcopyObjectjs4150_copyObject;
/*≠≠ node_modules/lodash/_copyObject.js ≠≠*/

/*== node_modules/lodash/toPlainObject.js ==*/
$m['lodash/toPlainObject.js#4.15.0'] = { exports: {} };
var _lodashtoPlainObjectjs4150_copyObject = $m['lodash/_copyObject.js#4.15.0'].exports,
    _lodashtoPlainObjectjs4150_keysIn = $m['lodash/keysIn.js#4.15.0'].exports;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function _lodashtoPlainObjectjs4150_toPlainObject(value) {
  return _lodashtoPlainObjectjs4150_copyObject(value, _lodashtoPlainObjectjs4150_keysIn(value));
}

$m['lodash/toPlainObject.js#4.15.0'].exports = _lodashtoPlainObjectjs4150_toPlainObject;
/*≠≠ node_modules/lodash/toPlainObject.js ≠≠*/

/*== node_modules/lodash/_copyArray.js ==*/
$m['lodash/_copyArray.js#4.15.0'] = { exports: {} };
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function _lodashcopyArrayjs4150_copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

$m['lodash/_copyArray.js#4.15.0'].exports = _lodashcopyArrayjs4150_copyArray;
/*≠≠ node_modules/lodash/_copyArray.js ≠≠*/

/*== node_modules/lodash/stubFalse.js ==*/
$m['lodash/stubFalse.js#4.15.0'] = { exports: {} };
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function _lodashstubFalsejs4150_stubFalse() {
  return false;
}

$m['lodash/stubFalse.js#4.15.0'].exports = _lodashstubFalsejs4150_stubFalse;
/*≠≠ node_modules/lodash/stubFalse.js ≠≠*/

/*== node_modules/lodash/isBuffer.js ==*/
$m['lodash/isBuffer.js#4.15.0'] = { exports: {} };
var _lodashisBufferjs4150_root = $m['lodash/_root.js#4.15.0'].exports,
    _lodashisBufferjs4150_stubFalse = $m['lodash/stubFalse.js#4.15.0'].exports;

/** Detect free variable `exports`. */
var _lodashisBufferjs4150_freeExports = typeof $m['lodash/isBuffer.js#4.15.0'].exports == 'object' && $m['lodash/isBuffer.js#4.15.0'].exports && !$m['lodash/isBuffer.js#4.15.0'].exports.nodeType && $m['lodash/isBuffer.js#4.15.0'].exports;

/** Detect free variable `module`. */
var _lodashisBufferjs4150_freeModule = _lodashisBufferjs4150_freeExports && typeof $m['lodash/isBuffer.js#4.15.0'] == 'object' && $m['lodash/isBuffer.js#4.15.0'] && !$m['lodash/isBuffer.js#4.15.0'].nodeType && $m['lodash/isBuffer.js#4.15.0'];

/** Detect the popular CommonJS extension `module.exports`. */
var _lodashisBufferjs4150_moduleExports = _lodashisBufferjs4150_freeModule && _lodashisBufferjs4150_freeModule.exports === _lodashisBufferjs4150_freeExports;

/** Built-in value references. */
var _lodashisBufferjs4150_Buffer = _lodashisBufferjs4150_moduleExports ? _lodashisBufferjs4150_root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashisBufferjs4150_nativeIsBuffer = _lodashisBufferjs4150_Buffer ? _lodashisBufferjs4150_Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var _lodashisBufferjs4150_isBuffer = _lodashisBufferjs4150_nativeIsBuffer || _lodashisBufferjs4150_stubFalse;

$m['lodash/isBuffer.js#4.15.0'].exports = _lodashisBufferjs4150_isBuffer;
/*≠≠ node_modules/lodash/isBuffer.js ≠≠*/

/*== node_modules/lodash/_baseCreate.js ==*/
$m['lodash/_baseCreate.js#4.15.0'] = { exports: {} };
var _lodashbaseCreatejs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports;

/** Built-in value references. */
var _lodashbaseCreatejs4150_objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function _lodashbaseCreatejs4150_baseCreate(proto) {
  return _lodashbaseCreatejs4150_isObject(proto) ? _lodashbaseCreatejs4150_objectCreate(proto) : {};
}

$m['lodash/_baseCreate.js#4.15.0'].exports = _lodashbaseCreatejs4150_baseCreate;
/*≠≠ node_modules/lodash/_baseCreate.js ≠≠*/

/*== node_modules/lodash/_initCloneObject.js ==*/
$m['lodash/_initCloneObject.js#4.15.0'] = { exports: {} };
var _lodashinitCloneObjectjs4150_baseCreate = $m['lodash/_baseCreate.js#4.15.0'].exports,
    _lodashinitCloneObjectjs4150_getPrototype = $m['lodash/_getPrototype.js#4.15.0'].exports,
    _lodashinitCloneObjectjs4150_isPrototype = $m['lodash/_isPrototype.js#4.15.0'].exports;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function _lodashinitCloneObjectjs4150_initCloneObject(object) {
    return typeof object.constructor == 'function' && !_lodashinitCloneObjectjs4150_isPrototype(object) ? _lodashinitCloneObjectjs4150_baseCreate(_lodashinitCloneObjectjs4150_getPrototype(object)) : {};
}

$m['lodash/_initCloneObject.js#4.15.0'].exports = _lodashinitCloneObjectjs4150_initCloneObject;
/*≠≠ node_modules/lodash/_initCloneObject.js ≠≠*/

/*== node_modules/lodash/_cloneArrayBuffer.js ==*/
$m['lodash/_cloneArrayBuffer.js#4.15.0'] = { exports: {} };
var _lodashcloneArrayBufferjs4150_Uint8Array = $m['lodash/_Uint8Array.js#4.15.0'].exports;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function _lodashcloneArrayBufferjs4150_cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _lodashcloneArrayBufferjs4150_Uint8Array(result).set(new _lodashcloneArrayBufferjs4150_Uint8Array(arrayBuffer));
  return result;
}

$m['lodash/_cloneArrayBuffer.js#4.15.0'].exports = _lodashcloneArrayBufferjs4150_cloneArrayBuffer;
/*≠≠ node_modules/lodash/_cloneArrayBuffer.js ≠≠*/

/*== node_modules/lodash/_cloneTypedArray.js ==*/
$m['lodash/_cloneTypedArray.js#4.15.0'] = { exports: {} };
var _lodashcloneTypedArrayjs4150_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.15.0'].exports;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function _lodashcloneTypedArrayjs4150_cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _lodashcloneTypedArrayjs4150_cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

$m['lodash/_cloneTypedArray.js#4.15.0'].exports = _lodashcloneTypedArrayjs4150_cloneTypedArray;
/*≠≠ node_modules/lodash/_cloneTypedArray.js ≠≠*/

/*== node_modules/lodash/_cloneSymbol.js ==*/
$m['lodash/_cloneSymbol.js#4.15.0'] = { exports: {} };
var _lodashcloneSymboljs4150_Symbol = $m['lodash/_Symbol.js#4.15.0'].exports;

/** Used to convert symbols to primitives and strings. */
var _lodashcloneSymboljs4150_symbolProto = _lodashcloneSymboljs4150_Symbol ? _lodashcloneSymboljs4150_Symbol.prototype : undefined,
    _lodashcloneSymboljs4150_symbolValueOf = _lodashcloneSymboljs4150_symbolProto ? _lodashcloneSymboljs4150_symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function _lodashcloneSymboljs4150_cloneSymbol(symbol) {
  return _lodashcloneSymboljs4150_symbolValueOf ? Object(_lodashcloneSymboljs4150_symbolValueOf.call(symbol)) : {};
}

$m['lodash/_cloneSymbol.js#4.15.0'].exports = _lodashcloneSymboljs4150_cloneSymbol;
/*≠≠ node_modules/lodash/_cloneSymbol.js ≠≠*/

/*== node_modules/lodash/_arrayReduce.js ==*/
$m['lodash/_arrayReduce.js#4.15.0'] = { exports: {} };
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function _lodasharrayReducejs4150_arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

$m['lodash/_arrayReduce.js#4.15.0'].exports = _lodasharrayReducejs4150_arrayReduce;
/*≠≠ node_modules/lodash/_arrayReduce.js ≠≠*/

/*== node_modules/lodash/_addSetEntry.js ==*/
$m['lodash/_addSetEntry.js#4.15.0'] = { exports: {} };
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function _lodashaddSetEntryjs4150_addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

$m['lodash/_addSetEntry.js#4.15.0'].exports = _lodashaddSetEntryjs4150_addSetEntry;
/*≠≠ node_modules/lodash/_addSetEntry.js ≠≠*/

/*== node_modules/lodash/_cloneSet.js ==*/
$m['lodash/_cloneSet.js#4.15.0'] = { exports: {} };
var _lodashcloneSetjs4150_addSetEntry = $m['lodash/_addSetEntry.js#4.15.0'].exports,
    _lodashcloneSetjs4150_arrayReduce = $m['lodash/_arrayReduce.js#4.15.0'].exports,
    _lodashcloneSetjs4150_setToArray = $m['lodash/_setToArray.js#4.15.0'].exports;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function _lodashcloneSetjs4150_cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(_lodashcloneSetjs4150_setToArray(set), true) : _lodashcloneSetjs4150_setToArray(set);
  return _lodashcloneSetjs4150_arrayReduce(array, _lodashcloneSetjs4150_addSetEntry, new set.constructor());
}

$m['lodash/_cloneSet.js#4.15.0'].exports = _lodashcloneSetjs4150_cloneSet;
/*≠≠ node_modules/lodash/_cloneSet.js ≠≠*/

/*== node_modules/lodash/_cloneRegExp.js ==*/
$m['lodash/_cloneRegExp.js#4.15.0'] = { exports: {} };
/** Used to match `RegExp` flags from their coerced string values. */
var _lodashcloneRegExpjs4150_reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function _lodashcloneRegExpjs4150_cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, _lodashcloneRegExpjs4150_reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

$m['lodash/_cloneRegExp.js#4.15.0'].exports = _lodashcloneRegExpjs4150_cloneRegExp;
/*≠≠ node_modules/lodash/_cloneRegExp.js ≠≠*/

/*== node_modules/lodash/_addMapEntry.js ==*/
$m['lodash/_addMapEntry.js#4.15.0'] = { exports: {} };
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function _lodashaddMapEntryjs4150_addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

$m['lodash/_addMapEntry.js#4.15.0'].exports = _lodashaddMapEntryjs4150_addMapEntry;
/*≠≠ node_modules/lodash/_addMapEntry.js ≠≠*/

/*== node_modules/lodash/_cloneMap.js ==*/
$m['lodash/_cloneMap.js#4.15.0'] = { exports: {} };
var _lodashcloneMapjs4150_addMapEntry = $m['lodash/_addMapEntry.js#4.15.0'].exports,
    _lodashcloneMapjs4150_arrayReduce = $m['lodash/_arrayReduce.js#4.15.0'].exports,
    _lodashcloneMapjs4150_mapToArray = $m['lodash/_mapToArray.js#4.15.0'].exports;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function _lodashcloneMapjs4150_cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(_lodashcloneMapjs4150_mapToArray(map), true) : _lodashcloneMapjs4150_mapToArray(map);
  return _lodashcloneMapjs4150_arrayReduce(array, _lodashcloneMapjs4150_addMapEntry, new map.constructor());
}

$m['lodash/_cloneMap.js#4.15.0'].exports = _lodashcloneMapjs4150_cloneMap;
/*≠≠ node_modules/lodash/_cloneMap.js ≠≠*/

/*== node_modules/lodash/_cloneDataView.js ==*/
$m['lodash/_cloneDataView.js#4.15.0'] = { exports: {} };
var _lodashcloneDataViewjs4150_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.15.0'].exports;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function _lodashcloneDataViewjs4150_cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _lodashcloneDataViewjs4150_cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

$m['lodash/_cloneDataView.js#4.15.0'].exports = _lodashcloneDataViewjs4150_cloneDataView;
/*≠≠ node_modules/lodash/_cloneDataView.js ≠≠*/

/*== node_modules/lodash/_initCloneByTag.js ==*/
$m['lodash/_initCloneByTag.js#4.15.0'] = { exports: {} };
var _lodashinitCloneByTagjs4150_cloneArrayBuffer = $m['lodash/_cloneArrayBuffer.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneDataView = $m['lodash/_cloneDataView.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneMap = $m['lodash/_cloneMap.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneRegExp = $m['lodash/_cloneRegExp.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneSet = $m['lodash/_cloneSet.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneSymbol = $m['lodash/_cloneSymbol.js#4.15.0'].exports,
    _lodashinitCloneByTagjs4150_cloneTypedArray = $m['lodash/_cloneTypedArray.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashinitCloneByTagjs4150_boolTag = '[object Boolean]',
    _lodashinitCloneByTagjs4150_dateTag = '[object Date]',
    _lodashinitCloneByTagjs4150_mapTag = '[object Map]',
    _lodashinitCloneByTagjs4150_numberTag = '[object Number]',
    _lodashinitCloneByTagjs4150_regexpTag = '[object RegExp]',
    _lodashinitCloneByTagjs4150_setTag = '[object Set]',
    _lodashinitCloneByTagjs4150_stringTag = '[object String]',
    _lodashinitCloneByTagjs4150_symbolTag = '[object Symbol]';

var _lodashinitCloneByTagjs4150_arrayBufferTag = '[object ArrayBuffer]',
    _lodashinitCloneByTagjs4150_dataViewTag = '[object DataView]',
    _lodashinitCloneByTagjs4150_float32Tag = '[object Float32Array]',
    _lodashinitCloneByTagjs4150_float64Tag = '[object Float64Array]',
    _lodashinitCloneByTagjs4150_int8Tag = '[object Int8Array]',
    _lodashinitCloneByTagjs4150_int16Tag = '[object Int16Array]',
    _lodashinitCloneByTagjs4150_int32Tag = '[object Int32Array]',
    _lodashinitCloneByTagjs4150_uint8Tag = '[object Uint8Array]',
    _lodashinitCloneByTagjs4150_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashinitCloneByTagjs4150_uint16Tag = '[object Uint16Array]',
    _lodashinitCloneByTagjs4150_uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function _lodashinitCloneByTagjs4150_initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case _lodashinitCloneByTagjs4150_arrayBufferTag:
      return _lodashinitCloneByTagjs4150_cloneArrayBuffer(object);

    case _lodashinitCloneByTagjs4150_boolTag:
    case _lodashinitCloneByTagjs4150_dateTag:
      return new Ctor(+object);

    case _lodashinitCloneByTagjs4150_dataViewTag:
      return _lodashinitCloneByTagjs4150_cloneDataView(object, isDeep);

    case _lodashinitCloneByTagjs4150_float32Tag:case _lodashinitCloneByTagjs4150_float64Tag:
    case _lodashinitCloneByTagjs4150_int8Tag:case _lodashinitCloneByTagjs4150_int16Tag:case _lodashinitCloneByTagjs4150_int32Tag:
    case _lodashinitCloneByTagjs4150_uint8Tag:case _lodashinitCloneByTagjs4150_uint8ClampedTag:case _lodashinitCloneByTagjs4150_uint16Tag:case _lodashinitCloneByTagjs4150_uint32Tag:
      return _lodashinitCloneByTagjs4150_cloneTypedArray(object, isDeep);

    case _lodashinitCloneByTagjs4150_mapTag:
      return _lodashinitCloneByTagjs4150_cloneMap(object, isDeep, cloneFunc);

    case _lodashinitCloneByTagjs4150_numberTag:
    case _lodashinitCloneByTagjs4150_stringTag:
      return new Ctor(object);

    case _lodashinitCloneByTagjs4150_regexpTag:
      return _lodashinitCloneByTagjs4150_cloneRegExp(object);

    case _lodashinitCloneByTagjs4150_setTag:
      return _lodashinitCloneByTagjs4150_cloneSet(object, isDeep, cloneFunc);

    case _lodashinitCloneByTagjs4150_symbolTag:
      return _lodashinitCloneByTagjs4150_cloneSymbol(object);
  }
}

$m['lodash/_initCloneByTag.js#4.15.0'].exports = _lodashinitCloneByTagjs4150_initCloneByTag;
/*≠≠ node_modules/lodash/_initCloneByTag.js ≠≠*/

/*== node_modules/lodash/_initCloneArray.js ==*/
$m['lodash/_initCloneArray.js#4.15.0'] = { exports: {} };
/** Used for built-in method references. */
var _lodashinitCloneArrayjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashinitCloneArrayjs4150_hasOwnProperty = _lodashinitCloneArrayjs4150_objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function _lodashinitCloneArrayjs4150_initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && _lodashinitCloneArrayjs4150_hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

$m['lodash/_initCloneArray.js#4.15.0'].exports = _lodashinitCloneArrayjs4150_initCloneArray;
/*≠≠ node_modules/lodash/_initCloneArray.js ≠≠*/

/*== node_modules/lodash/stubArray.js ==*/
$m['lodash/stubArray.js#4.15.0'] = { exports: {} };
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function _lodashstubArrayjs4150_stubArray() {
  return [];
}

$m['lodash/stubArray.js#4.15.0'].exports = _lodashstubArrayjs4150_stubArray;
/*≠≠ node_modules/lodash/stubArray.js ≠≠*/

/*== node_modules/lodash/_getSymbols.js ==*/
$m['lodash/_getSymbols.js#4.15.0'] = { exports: {} };
var _lodashgetSymbolsjs4150_overArg = $m['lodash/_overArg.js#4.15.0'].exports,
    _lodashgetSymbolsjs4150_stubArray = $m['lodash/stubArray.js#4.15.0'].exports;

/* Built-in method references for those with the same name as other `lodash` methods. */
var _lodashgetSymbolsjs4150_nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var _lodashgetSymbolsjs4150_getSymbols = _lodashgetSymbolsjs4150_nativeGetSymbols ? _lodashgetSymbolsjs4150_overArg(_lodashgetSymbolsjs4150_nativeGetSymbols, Object) : _lodashgetSymbolsjs4150_stubArray;

$m['lodash/_getSymbols.js#4.15.0'].exports = _lodashgetSymbolsjs4150_getSymbols;
/*≠≠ node_modules/lodash/_getSymbols.js ≠≠*/

/*== node_modules/lodash/_baseGetAllKeys.js ==*/
$m['lodash/_baseGetAllKeys.js#4.15.0'] = { exports: {} };
var _lodashbaseGetAllKeysjs4150_arrayPush = $m['lodash/_arrayPush.js#4.15.0'].exports,
    _lodashbaseGetAllKeysjs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function _lodashbaseGetAllKeysjs4150_baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return _lodashbaseGetAllKeysjs4150_isArray(object) ? result : _lodashbaseGetAllKeysjs4150_arrayPush(result, symbolsFunc(object));
}

$m['lodash/_baseGetAllKeys.js#4.15.0'].exports = _lodashbaseGetAllKeysjs4150_baseGetAllKeys;
/*≠≠ node_modules/lodash/_baseGetAllKeys.js ≠≠*/

/*== node_modules/lodash/_getAllKeys.js ==*/
$m['lodash/_getAllKeys.js#4.15.0'] = { exports: {} };
var _lodashgetAllKeysjs4150_baseGetAllKeys = $m['lodash/_baseGetAllKeys.js#4.15.0'].exports,
    _lodashgetAllKeysjs4150_getSymbols = $m['lodash/_getSymbols.js#4.15.0'].exports,
    _lodashgetAllKeysjs4150_keys = $m['lodash/keys.js#4.15.0'].exports;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function _lodashgetAllKeysjs4150_getAllKeys(object) {
  return _lodashgetAllKeysjs4150_baseGetAllKeys(object, _lodashgetAllKeysjs4150_keys, _lodashgetAllKeysjs4150_getSymbols);
}

$m['lodash/_getAllKeys.js#4.15.0'].exports = _lodashgetAllKeysjs4150_getAllKeys;
/*≠≠ node_modules/lodash/_getAllKeys.js ≠≠*/

/*== node_modules/lodash/_copySymbols.js ==*/
$m['lodash/_copySymbols.js#4.15.0'] = { exports: {} };
var _lodashcopySymbolsjs4150_copyObject = $m['lodash/_copyObject.js#4.15.0'].exports,
    _lodashcopySymbolsjs4150_getSymbols = $m['lodash/_getSymbols.js#4.15.0'].exports;

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function _lodashcopySymbolsjs4150_copySymbols(source, object) {
  return _lodashcopySymbolsjs4150_copyObject(source, _lodashcopySymbolsjs4150_getSymbols(source), object);
}

$m['lodash/_copySymbols.js#4.15.0'].exports = _lodashcopySymbolsjs4150_copySymbols;
/*≠≠ node_modules/lodash/_copySymbols.js ≠≠*/

/*== node_modules/lodash/_cloneBuffer.js ==*/
$m['lodash/_cloneBuffer.js#4.15.0'] = { exports: {} };
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function _lodashcloneBufferjs4150_cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

$m['lodash/_cloneBuffer.js#4.15.0'].exports = _lodashcloneBufferjs4150_cloneBuffer;
/*≠≠ node_modules/lodash/_cloneBuffer.js ≠≠*/

/*== node_modules/lodash/_baseAssign.js ==*/
$m['lodash/_baseAssign.js#4.15.0'] = { exports: {} };
var _lodashbaseAssignjs4150_copyObject = $m['lodash/_copyObject.js#4.15.0'].exports,
    _lodashbaseAssignjs4150_keys = $m['lodash/keys.js#4.15.0'].exports;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function _lodashbaseAssignjs4150_baseAssign(object, source) {
  return object && _lodashbaseAssignjs4150_copyObject(source, _lodashbaseAssignjs4150_keys(source), object);
}

$m['lodash/_baseAssign.js#4.15.0'].exports = _lodashbaseAssignjs4150_baseAssign;
/*≠≠ node_modules/lodash/_baseAssign.js ≠≠*/

/*== node_modules/lodash/_arrayEach.js ==*/
$m['lodash/_arrayEach.js#4.15.0'] = { exports: {} };
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function _lodasharrayEachjs4150_arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

$m['lodash/_arrayEach.js#4.15.0'].exports = _lodasharrayEachjs4150_arrayEach;
/*≠≠ node_modules/lodash/_arrayEach.js ≠≠*/

/*== node_modules/lodash/_baseClone.js ==*/
$m['lodash/_baseClone.js#4.15.0'] = { exports: {} };
var _lodashbaseClonejs4150_Stack = $m['lodash/_Stack.js#4.15.0'].exports,
    _lodashbaseClonejs4150_arrayEach = $m['lodash/_arrayEach.js#4.15.0'].exports,
    _lodashbaseClonejs4150_assignValue = $m['lodash/_assignValue.js#4.15.0'].exports,
    _lodashbaseClonejs4150_baseAssign = $m['lodash/_baseAssign.js#4.15.0'].exports,
    _lodashbaseClonejs4150_cloneBuffer = $m['lodash/_cloneBuffer.js#4.15.0'].exports,
    _lodashbaseClonejs4150_copyArray = $m['lodash/_copyArray.js#4.15.0'].exports,
    _lodashbaseClonejs4150_copySymbols = $m['lodash/_copySymbols.js#4.15.0'].exports,
    _lodashbaseClonejs4150_getAllKeys = $m['lodash/_getAllKeys.js#4.15.0'].exports,
    _lodashbaseClonejs4150_getTag = $m['lodash/_getTag.js#4.15.0'].exports,
    _lodashbaseClonejs4150_initCloneArray = $m['lodash/_initCloneArray.js#4.15.0'].exports,
    _lodashbaseClonejs4150_initCloneByTag = $m['lodash/_initCloneByTag.js#4.15.0'].exports,
    _lodashbaseClonejs4150_initCloneObject = $m['lodash/_initCloneObject.js#4.15.0'].exports,
    _lodashbaseClonejs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports,
    _lodashbaseClonejs4150_isBuffer = $m['lodash/isBuffer.js#4.15.0'].exports,
    _lodashbaseClonejs4150_isHostObject = $m['lodash/_isHostObject.js#4.15.0'].exports,
    _lodashbaseClonejs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseClonejs4150_keys = $m['lodash/keys.js#4.15.0'].exports;

/** `Object#toString` result references. */
var _lodashbaseClonejs4150_argsTag = '[object Arguments]',
    _lodashbaseClonejs4150_arrayTag = '[object Array]',
    _lodashbaseClonejs4150_boolTag = '[object Boolean]',
    _lodashbaseClonejs4150_dateTag = '[object Date]',
    _lodashbaseClonejs4150_errorTag = '[object Error]',
    _lodashbaseClonejs4150_funcTag = '[object Function]',
    _lodashbaseClonejs4150_genTag = '[object GeneratorFunction]',
    _lodashbaseClonejs4150_mapTag = '[object Map]',
    _lodashbaseClonejs4150_numberTag = '[object Number]',
    _lodashbaseClonejs4150_objectTag = '[object Object]',
    _lodashbaseClonejs4150_regexpTag = '[object RegExp]',
    _lodashbaseClonejs4150_setTag = '[object Set]',
    _lodashbaseClonejs4150_stringTag = '[object String]',
    _lodashbaseClonejs4150_symbolTag = '[object Symbol]',
    _lodashbaseClonejs4150_weakMapTag = '[object WeakMap]';

var _lodashbaseClonejs4150_arrayBufferTag = '[object ArrayBuffer]',
    _lodashbaseClonejs4150_dataViewTag = '[object DataView]',
    _lodashbaseClonejs4150_float32Tag = '[object Float32Array]',
    _lodashbaseClonejs4150_float64Tag = '[object Float64Array]',
    _lodashbaseClonejs4150_int8Tag = '[object Int8Array]',
    _lodashbaseClonejs4150_int16Tag = '[object Int16Array]',
    _lodashbaseClonejs4150_int32Tag = '[object Int32Array]',
    _lodashbaseClonejs4150_uint8Tag = '[object Uint8Array]',
    _lodashbaseClonejs4150_uint8ClampedTag = '[object Uint8ClampedArray]',
    _lodashbaseClonejs4150_uint16Tag = '[object Uint16Array]',
    _lodashbaseClonejs4150_uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var _lodashbaseClonejs4150_cloneableTags = {};
_lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_argsTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_arrayTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_arrayBufferTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_dataViewTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_boolTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_dateTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_float32Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_float64Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_int8Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_int16Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_int32Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_mapTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_numberTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_objectTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_regexpTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_setTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_stringTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_symbolTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_uint8Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_uint8ClampedTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_uint16Tag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_uint32Tag] = true;
_lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_errorTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_funcTag] = _lodashbaseClonejs4150_cloneableTags[_lodashbaseClonejs4150_weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function _lodashbaseClonejs4150_baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!_lodashbaseClonejs4150_isObject(value)) {
    return value;
  }
  var isArr = _lodashbaseClonejs4150_isArray(value);
  if (isArr) {
    result = _lodashbaseClonejs4150_initCloneArray(value);
    if (!isDeep) {
      return _lodashbaseClonejs4150_copyArray(value, result);
    }
  } else {
    var tag = _lodashbaseClonejs4150_getTag(value),
        isFunc = tag == _lodashbaseClonejs4150_funcTag || tag == _lodashbaseClonejs4150_genTag;

    if (_lodashbaseClonejs4150_isBuffer(value)) {
      return _lodashbaseClonejs4150_cloneBuffer(value, isDeep);
    }
    if (tag == _lodashbaseClonejs4150_objectTag || tag == _lodashbaseClonejs4150_argsTag || isFunc && !object) {
      if (_lodashbaseClonejs4150_isHostObject(value)) {
        return object ? value : {};
      }
      result = _lodashbaseClonejs4150_initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return _lodashbaseClonejs4150_copySymbols(value, _lodashbaseClonejs4150_baseAssign(result, value));
      }
    } else {
      if (!_lodashbaseClonejs4150_cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _lodashbaseClonejs4150_initCloneByTag(value, tag, _lodashbaseClonejs4150_baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _lodashbaseClonejs4150_Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? _lodashbaseClonejs4150_getAllKeys(value) : _lodashbaseClonejs4150_keys(value);
  }
  _lodashbaseClonejs4150_arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _lodashbaseClonejs4150_assignValue(result, key, _lodashbaseClonejs4150_baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

$m['lodash/_baseClone.js#4.15.0'].exports = _lodashbaseClonejs4150_baseClone;
/*≠≠ node_modules/lodash/_baseClone.js ≠≠*/

/*== node_modules/lodash/_assignMergeValue.js ==*/
$m['lodash/_assignMergeValue.js#4.15.0'] = { exports: {} };
var _lodashassignMergeValuejs4150_eq = $m['lodash/eq.js#4.15.0'].exports;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function _lodashassignMergeValuejs4150_assignMergeValue(object, key, value) {
  if (value !== undefined && !_lodashassignMergeValuejs4150_eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
    object[key] = value;
  }
}

$m['lodash/_assignMergeValue.js#4.15.0'].exports = _lodashassignMergeValuejs4150_assignMergeValue;
/*≠≠ node_modules/lodash/_assignMergeValue.js ≠≠*/

/*== node_modules/lodash/_baseMergeDeep.js ==*/
$m['lodash/_baseMergeDeep.js#4.15.0'] = { exports: {} };
var _lodashbaseMergeDeepjs4150_assignMergeValue = $m['lodash/_assignMergeValue.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_baseClone = $m['lodash/_baseClone.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_copyArray = $m['lodash/_copyArray.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isArguments = $m['lodash/isArguments.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isFunction = $m['lodash/isFunction.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isPlainObject = $m['lodash/isPlainObject.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_isTypedArray = $m['lodash/isTypedArray.js#4.15.0'].exports,
    _lodashbaseMergeDeepjs4150_toPlainObject = $m['lodash/toPlainObject.js#4.15.0'].exports;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function _lodashbaseMergeDeepjs4150_baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    _lodashbaseMergeDeepjs4150_assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (_lodashbaseMergeDeepjs4150_isArray(srcValue) || _lodashbaseMergeDeepjs4150_isTypedArray(srcValue)) {
      if (_lodashbaseMergeDeepjs4150_isArray(objValue)) {
        newValue = objValue;
      } else if (_lodashbaseMergeDeepjs4150_isArrayLikeObject(objValue)) {
        newValue = _lodashbaseMergeDeepjs4150_copyArray(objValue);
      } else {
        isCommon = false;
        newValue = _lodashbaseMergeDeepjs4150_baseClone(srcValue, true);
      }
    } else if (_lodashbaseMergeDeepjs4150_isPlainObject(srcValue) || _lodashbaseMergeDeepjs4150_isArguments(srcValue)) {
      if (_lodashbaseMergeDeepjs4150_isArguments(objValue)) {
        newValue = _lodashbaseMergeDeepjs4150_toPlainObject(objValue);
      } else if (!_lodashbaseMergeDeepjs4150_isObject(objValue) || srcIndex && _lodashbaseMergeDeepjs4150_isFunction(objValue)) {
        isCommon = false;
        newValue = _lodashbaseMergeDeepjs4150_baseClone(srcValue, true);
      } else {
        newValue = objValue;
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _lodashbaseMergeDeepjs4150_assignMergeValue(object, key, newValue);
}

$m['lodash/_baseMergeDeep.js#4.15.0'].exports = _lodashbaseMergeDeepjs4150_baseMergeDeep;
/*≠≠ node_modules/lodash/_baseMergeDeep.js ≠≠*/

/*== node_modules/lodash/_baseMerge.js ==*/
$m['lodash/_baseMerge.js#4.15.0'] = { exports: {} };
var _lodashbaseMergejs4150_Stack = $m['lodash/_Stack.js#4.15.0'].exports,
    _lodashbaseMergejs4150_arrayEach = $m['lodash/_arrayEach.js#4.15.0'].exports,
    _lodashbaseMergejs4150_assignMergeValue = $m['lodash/_assignMergeValue.js#4.15.0'].exports,
    _lodashbaseMergejs4150_baseKeysIn = $m['lodash/_baseKeysIn.js#4.15.0'].exports,
    _lodashbaseMergejs4150_baseMergeDeep = $m['lodash/_baseMergeDeep.js#4.15.0'].exports,
    _lodashbaseMergejs4150_isArray = $m['lodash/isArray.js#4.15.0'].exports,
    _lodashbaseMergejs4150_isObject = $m['lodash/isObject.js#4.15.0'].exports,
    _lodashbaseMergejs4150_isTypedArray = $m['lodash/isTypedArray.js#4.15.0'].exports;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function _lodashbaseMergejs4150_baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(_lodashbaseMergejs4150_isArray(source) || _lodashbaseMergejs4150_isTypedArray(source))) {
    var props = _lodashbaseMergejs4150_baseKeysIn(source);
  }
  _lodashbaseMergejs4150_arrayEach(props || source, function (srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (_lodashbaseMergejs4150_isObject(srcValue)) {
      stack || (stack = new _lodashbaseMergejs4150_Stack());
      _lodashbaseMergejs4150_baseMergeDeep(object, source, key, srcIndex, _lodashbaseMergejs4150_baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _lodashbaseMergejs4150_assignMergeValue(object, key, newValue);
    }
  });
}

$m['lodash/_baseMerge.js#4.15.0'].exports = _lodashbaseMergejs4150_baseMerge;
/*≠≠ node_modules/lodash/_baseMerge.js ≠≠*/

/*== node_modules/lodash/merge.js ==*/
$m['lodash/merge.js#4.15.0'] = { exports: {} };
var _lodashmergejs4150_baseMerge = $m['lodash/_baseMerge.js#4.15.0'].exports,
    _lodashmergejs4150_createAssigner = $m['lodash/_createAssigner.js#4.15.0'].exports;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var _lodashmergejs4150_merge = _lodashmergejs4150_createAssigner(function (object, source, srcIndex) {
  _lodashmergejs4150_baseMerge(object, source, srcIndex);
});

$m['lodash/merge.js#4.15.0'].exports = _lodashmergejs4150_merge;
/*≠≠ node_modules/lodash/merge.js ≠≠*/

/*== node_modules/inline-source/lib/imgSVG.js ==*/
$m['inline-source/lib/imgSVG.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibimgSVGjs510_htmlparser = $m['htmlparser2/lib/index.js#3.9.1'].exports;
const _inlinesourcelibimgSVGjs510_merge = $m['lodash/merge.js#4.15.0'].exports;
const _inlinesourcelibimgSVGjs510_utils = $m['inline-source/lib/utils.js#5.1.0'].exports;

const _inlinesourcelibimgSVGjs510_DEFAULT_SVG_ATTR = {
  x: '0',
  y: '0',
  viewBox: '0 0 100 100'
};
const _inlinesourcelibimgSVGjs510_RE_SVG_CONTENT = /<svg[^>]+>([\S\s]*?)<\/\s?svg>/gm;
const _inlinesourcelibimgSVGjs510_RE_SYMBOL = /<symbol\sid=['"](.+)['"]>[\S\s]*?<\/\s?symbol>/gm;

/**
 * Handle IMG content
 * @param {Object} source
 * @param {Object} context
 * @param {Object} svgo
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/imgSVG.js#5.1.0'].exports = function imgSVG(source, context, svgo, next) {
  _inlinesourcelibimgSVGjs510_RE_SVG_CONTENT.lastIndex = 0;
  _inlinesourcelibimgSVGjs510_RE_SYMBOL.lastIndex = 0;

  const svgContent = _inlinesourcelibimgSVGjs510_RE_SVG_CONTENT.exec(source.fileContent) || source.fileContent;
  // Use default attributes if no outer <svg> tag
  const defaultAttributes = Array.isArray(svgContent) ? {} : _inlinesourcelibimgSVGjs510_DEFAULT_SVG_ATTR;
  let attributes = {};
  const parser = new _inlinesourcelibimgSVGjs510_htmlparser.Parser(new _inlinesourcelibimgSVGjs510_htmlparser.DomHandler((err, dom) => {
    if (err) return next(err);

    dom = dom.filter(item => {
      return item.type == 'tag' && item.name == 'svg';
    });

    if (dom.length) {
      attributes = _inlinesourcelibimgSVGjs510_utils.parseAttributes(dom[0].attribs);
      // Fix lowercasing
      if ('viewbox' in attributes) {
        attributes.viewBox = attributes.viewbox;
        delete attributes.viewbox;
      }
    }
  }));

  // Strip xml tag
  parser.parseComplete(source.fileContent);
  source.content = Array.isArray(svgContent) ? svgContent[1] : svgContent;
  source.attributes = _inlinesourcelibimgSVGjs510_merge({}, defaultAttributes, attributes, source.attributes);
  source.tag = 'svg';
  // Handle subset of symbols as specified with filepath anchor (foo.svg#foo,bar)
  if (source.filepathAnchor) {
    const includedIds = source.filepathAnchor.split(',');
    let content = source.content;
    let match;

    while (match = _inlinesourcelibimgSVGjs510_RE_SYMBOL.exec(source.content)) {
      if (!~includedIds.indexOf(match[1])) {
        content = content.replace(match[0], '');
      }
    }

    source.content = content;
  }
  if (source.compress) {
    // svgo sometiemes throws errors if content not wrapped in <svg>, so wrap here
    const attrs = _inlinesourcelibimgSVGjs510_utils.getAttributeString(source.attributes, context.attribute, false);
    const content = '<svg' + attrs + '>' + source.content + '</svg>';

    // Sync api call
    svgo.optimize(content, content => {
      _inlinesourcelibimgSVGjs510_RE_SVG_CONTENT.lastIndex = 0;
      var rematch = _inlinesourcelibimgSVGjs510_RE_SVG_CONTENT.exec(content.data);

      if (rematch) {
        source.content = rematch[1];
      } else {
        // Error re-parsing, leave as is;
        source.replace = content.data;
      }
    });
  }
  return next();
};
/*≠≠ node_modules/inline-source/lib/imgSVG.js ≠≠*/

/*== node_modules/inline-source/lib/img.js ==*/
$m['inline-source/lib/img.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibimgjs510_imgSVG = $m['inline-source/lib/imgSVG.js#5.1.0'].exports;
const _inlinesourcelibimgjs510_Svgo = {};
const _inlinesourcelibimgjs510_utils = $m['inline-source/lib/utils.js#5.1.0'].exports;

const _inlinesourcelibimgjs510_RE_XML_TAG = /<\?xml.+?\?>\s+/g;

const _inlinesourcelibimgjs510_svgo = new _inlinesourcelibimgjs510_Svgo({
  plugins: [
  // Prevent removal of unused <symbol> elements
  { cleanupIDs: false },
  // Prevent removal of xlink:href on <image> elements
  { removeEmptyAttrs: false }, { removeUselessDefs: false },
  // Prevent removal of <image> src attribute
  { removeUnknownsAndDefaults: false }]
});

/**
 * Handle IMG content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/img.js#5.1.0'].exports = function img(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibimgjs510_utils.noop;

  if (source.fileContent && !source.content && source.type == 'image') {
    const attributeType = source.attributes.type;
    let strict = !source.errored;
    let sourceProp = 'src';
    let data, encoding;

    delete source.attributes.type;

    // svg
    if (source.format == 'svg+xml') {
      if (!source.svgAsImage) return _inlinesourcelibimgjs510_imgSVG(source, context, _inlinesourcelibimgjs510_svgo, next);

      source.tag = 'img';
      // Strip xml tag
      source.content = source.fileContent.replace(_inlinesourcelibimgjs510_RE_XML_TAG, '');
      if (source.compress) {
        // Sync api call
        _inlinesourcelibimgjs510_svgo.optimize(source.content, content => {
          source.content = content.data;
        });
      }
      data = encodeURIComponent(source.content);
      encoding = 'utf8';

      // gif/png/jpeg
    } else {
      data = new Buffer(source.fileContent).toString('base64');
      encoding = 'base64';

      // Favicon
      if (source.tag == 'link') {
        source.attributes.type = attributeType;
        sourceProp = 'href';
        strict = false;
        delete source.attributes.href;
      }
    }

    const src = 'data:image/' + source.format + ';' + encoding + ',' + data;
    let attrs = _inlinesourcelibimgjs510_utils.getAttributeString(source.attributes, context.attribute, strict);

    attrs += ' ' + sourceProp + '="' + src + '"';
    source.content = src;
    source.replace = '<' + source.tag + attrs + ' />';

    next();
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/img.js ≠≠*/

/*== node_modules/inline-source/lib/js.js ==*/
$m['inline-source/lib/js.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibjsjs510_noop = $m['inline-source/lib/utils.js#5.1.0'].exports.noop;
const _inlinesourcelibjsjs510_uglify = {};

const _inlinesourcelibjsjs510_RE_SCRIPT = /(<)(\/script>)/g;

/**
 * Handle JavaScript content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/js.js#5.1.0'].exports = function js(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibjsjs510_noop;

  if (source.fileContent && !source.content && source.type == 'js') {
    try {
      source.content = source.compress ? _inlinesourcelibjsjs510_uglify.minify(source.fileContent, { fromString: true }).code : source.fileContent;

      // Escape closing </script>
      if (_inlinesourcelibjsjs510_RE_SCRIPT.test(source.content)) {
        source.content = source.content.replace(_inlinesourcelibjsjs510_RE_SCRIPT, '\\x3C$2');
      }

      next();
    } catch (err) {
      return next(err);
    }
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/js.js ≠≠*/

/*== node_modules/inline-source/lib/inline.js ==*/
$m['inline-source/lib/inline.js#5.1.0'] = { exports: {} };
'use strict';

/**
 * Inline source content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} next(err)
 */

$m['inline-source/lib/inline.js#5.1.0'].exports = function inline(source, context, next) {
  if (source.replace) {
    // Fix for PR#5
    context.html = context.html.replace(source.match, () => {
      return source.replace;
    });
  }

  if (next) next();
};
/*≠≠ node_modules/inline-source/lib/inline.js ≠≠*/

/*== node_modules/csso/lib/utils/list.js ==*/
$m['csso/lib/utils/list.js#2.2.1'] = { exports: {} };
//
//            item        item        item        item
//          /------\    /------\    /------\    /------\
//          | data |    | data |    | data |    | data |
//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
//          | next-+--->| next-+--->| next-+--->| next-+--> null
//          \------/    \------/    \------/    \------/
//             ^                                    ^
//             |                list                |
//             |              /------\              |
//             \--------------+-head |              |
//                            | tail-+--------------/
//                            \------/
//

function _cssolibutilslistjs221_createItem(data) {
    return {
        data: data,
        next: null,
        prev: null
    };
}

var _cssolibutilslistjs221_List = function (values) {
    this.cursor = null;
    this.head = null;
    this.tail = null;

    if (Array.isArray(values)) {
        var cursor = null;

        for (var i = 0; i < values.length; i++) {
            var item = _cssolibutilslistjs221_createItem(values[i]);

            if (cursor !== null) {
                cursor.next = item;
            } else {
                this.head = item;
            }

            item.prev = cursor;
            cursor = item;
        }

        this.tail = cursor;
    }
};

Object.defineProperty(_cssolibutilslistjs221_List.prototype, 'size', {
    get: function () {
        var size = 0;
        var cursor = this.head;

        while (cursor) {
            size++;
            cursor = cursor.next;
        }

        return size;
    }
});

_cssolibutilslistjs221_List.createItem = _cssolibutilslistjs221_createItem;
_cssolibutilslistjs221_List.prototype.createItem = _cssolibutilslistjs221_createItem;

_cssolibutilslistjs221_List.prototype.toArray = function () {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};
_cssolibutilslistjs221_List.prototype.toJSON = function () {
    return this.toArray();
};

_cssolibutilslistjs221_List.prototype.isEmpty = function () {
    return this.head === null;
};

_cssolibutilslistjs221_List.prototype.first = function () {
    return this.head && this.head.data;
};

_cssolibutilslistjs221_List.prototype.last = function () {
    return this.tail && this.tail.data;
};

_cssolibutilslistjs221_List.prototype.each = function (fn, context) {
    var item;
    var cursor = {
        prev: null,
        next: this.head,
        cursor: this.cursor
    };

    if (context === undefined) {
        context = this;
    }

    // push cursor
    this.cursor = cursor;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    this.cursor = this.cursor.cursor;
};

_cssolibutilslistjs221_List.prototype.eachRight = function (fn, context) {
    var item;
    var cursor = {
        prev: this.tail,
        next: null,
        cursor: this.cursor
    };

    if (context === undefined) {
        context = this;
    }

    // push cursor
    this.cursor = cursor;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    this.cursor = this.cursor.cursor;
};

_cssolibutilslistjs221_List.prototype.nextUntil = function (start, fn, context) {
    if (start === null) {
        return;
    }

    var item;
    var cursor = {
        prev: null,
        next: start,
        cursor: this.cursor
    };

    if (context === undefined) {
        context = this;
    }

    // push cursor
    this.cursor = cursor;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    this.cursor = this.cursor.cursor;
};

_cssolibutilslistjs221_List.prototype.prevUntil = function (start, fn, context) {
    if (start === null) {
        return;
    }

    var item;
    var cursor = {
        prev: start,
        next: null,
        cursor: this.cursor
    };

    if (context === undefined) {
        context = this;
    }

    // push cursor
    this.cursor = cursor;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    this.cursor = this.cursor.cursor;
};

_cssolibutilslistjs221_List.prototype.some = function (fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

_cssolibutilslistjs221_List.prototype.map = function (fn, context) {
    var result = [];
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.push(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

_cssolibutilslistjs221_List.prototype.copy = function () {
    var result = new _cssolibutilslistjs221_List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(_cssolibutilslistjs221_createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

_cssolibutilslistjs221_List.prototype.updateCursors = function (prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (prevNew === true || cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (nextNew === true || cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

_cssolibutilslistjs221_List.prototype.insert = function (item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t below to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //     item
        this.updateCursors(this.tail, item, null, item);

        // insert to end of the list
        if (this.tail !== null) {
            // if list has a tail, then it also has a head, but head doesn't change

            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = item;
        }

        // tail always start point to new item
        this.tail = item;
    }
};

_cssolibutilslistjs221_List.prototype.remove = function (item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t below to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t below to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

_cssolibutilslistjs221_List.prototype.appendList = function (list) {
    // ignore empty lists
    if (list.head === null) {
        return;
    }

    this.updateCursors(this.tail, list.tail, null, list.head);

    // insert to end of the list
    if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change

        // dest tail -> source head
        this.tail.next = list.head;

        // dest tail <- source head
        list.head.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
    }

    // tail always start point to new item
    this.tail = list.tail;

    list.head = null;
    list.tail = null;
};

$m['csso/lib/utils/list.js#2.2.1'].exports = _cssolibutilslistjs221_List;
/*≠≠ node_modules/csso/lib/utils/list.js ≠≠*/

/*== node_modules/csso/lib/utils/clone.js ==*/
$m['csso/lib/utils/clone.js#2.2.1'] = { exports: {} };
var _cssolibutilsclonejs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;

$m['csso/lib/utils/clone.js#2.2.1'].exports = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value)) {
                value = value.slice(0);
            } else if (value instanceof _cssolibutilsclonejs221_List) {
                value = new _cssolibutilsclonejs221_List(value.map(clone));
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};
/*≠≠ node_modules/csso/lib/utils/clone.js ≠≠*/

/*== node_modules/csso/lib/utils/walk.js ==*/
$m['csso/lib/utils/walk.js#2.2.1'] = { exports: {} };
function _cssolibutilswalkjs221_walkRules(node, item, list) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.rules.each(_cssolibutilswalkjs221_walkRules, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.block !== null) {
                _cssolibutilswalkjs221_walkRules.call(this, node.block);
            }

            this.fn(node, item, list);
            break;

        case 'Ruleset':
            this.fn(node, item, list);
            break;
    }
}

function _cssolibutilswalkjs221_walkRulesRight(node, item, list) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.rules.eachRight(_cssolibutilswalkjs221_walkRulesRight, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.block !== null) {
                _cssolibutilswalkjs221_walkRulesRight.call(this, node.block);
            }

            this.fn(node, item, list);
            break;

        case 'Ruleset':
            this.fn(node, item, list);
            break;
    }
}

function _cssolibutilswalkjs221_walkAll(node, item, list) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.rules.each(_cssolibutilswalkjs221_walkAll, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.expression !== null) {
                _cssolibutilswalkjs221_walkAll.call(this, node.expression);
            }
            if (node.block !== null) {
                _cssolibutilswalkjs221_walkAll.call(this, node.block);
            }
            break;

        case 'Ruleset':
            this.ruleset = node;

            if (node.selector !== null) {
                _cssolibutilswalkjs221_walkAll.call(this, node.selector);
            }
            _cssolibutilswalkjs221_walkAll.call(this, node.block);

            this.ruleset = null;
            break;

        case 'Selector':
            var oldSelector = this.selector;
            this.selector = node;

            node.selectors.each(_cssolibutilswalkjs221_walkAll, this);

            this.selector = oldSelector;
            break;

        case 'Block':
            node.declarations.each(_cssolibutilswalkjs221_walkAll, this);
            break;

        case 'Declaration':
            this.declaration = node;

            _cssolibutilswalkjs221_walkAll.call(this, node.property);
            _cssolibutilswalkjs221_walkAll.call(this, node.value);

            this.declaration = null;
            break;

        case 'Attribute':
            _cssolibutilswalkjs221_walkAll.call(this, node.name);
            if (node.value !== null) {
                _cssolibutilswalkjs221_walkAll.call(this, node.value);
            }
            break;

        case 'FunctionalPseudo':
        case 'Function':
            this['function'] = node;

            node.arguments.each(_cssolibutilswalkjs221_walkAll, this);

            this['function'] = null;
            break;

        case 'AtruleExpression':
            this.atruleExpression = node;

            node.sequence.each(_cssolibutilswalkjs221_walkAll, this);

            this.atruleExpression = null;
            break;

        case 'Value':
        case 'Argument':
        case 'SimpleSelector':
        case 'Braces':
        case 'Negation':
            node.sequence.each(_cssolibutilswalkjs221_walkAll, this);
            break;

        case 'Url':
        case 'Progid':
            _cssolibutilswalkjs221_walkAll.call(this, node.value);
            break;

        // nothig to do with
        // case 'Property':
        // case 'Combinator':
        // case 'Dimension':
        // case 'Hash':
        // case 'Identifier':
        // case 'Nth':
        // case 'Class':
        // case 'Id':
        // case 'Percentage':
        // case 'PseudoClass':
        // case 'PseudoElement':
        // case 'Space':
        // case 'Number':
        // case 'String':
        // case 'Operator':
        // case 'Raw':
    }

    this.fn(node, item, list);
}

function _cssolibutilswalkjs221_createContext(root, fn) {
    var context = {
        fn: fn,
        root: root,
        stylesheet: null,
        atruleExpression: null,
        ruleset: null,
        selector: null,
        declaration: null,
        function: null
    };

    return context;
}

$m['csso/lib/utils/walk.js#2.2.1'].exports = {
    all: function (root, fn) {
        _cssolibutilswalkjs221_walkAll.call(_cssolibutilswalkjs221_createContext(root, fn), root);
    },
    rules: function (root, fn) {
        _cssolibutilswalkjs221_walkRules.call(_cssolibutilswalkjs221_createContext(root, fn), root);
    },
    rulesRight: function (root, fn) {
        _cssolibutilswalkjs221_walkRulesRight.call(_cssolibutilswalkjs221_createContext(root, fn), root);
    }
};
/*≠≠ node_modules/csso/lib/utils/walk.js ≠≠*/

/*== node_modules/source-map/lib/util.js ==*/
$m['source-map/lib/util.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function _sourcemaplibutiljs056_getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
$m['source-map/lib/util.js#0.5.6'].exports.getArg = _sourcemaplibutiljs056_getArg;

var _sourcemaplibutiljs056_urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var _sourcemaplibutiljs056_dataUrlRegexp = /^data:.+\,.+$/;

function _sourcemaplibutiljs056_urlParse(aUrl) {
  var match = aUrl.match(_sourcemaplibutiljs056_urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
$m['source-map/lib/util.js#0.5.6'].exports.urlParse = _sourcemaplibutiljs056_urlParse;

function _sourcemaplibutiljs056_urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
$m['source-map/lib/util.js#0.5.6'].exports.urlGenerate = _sourcemaplibutiljs056_urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function _sourcemaplibutiljs056_normalize(aPath) {
  var path = aPath;
  var url = _sourcemaplibutiljs056_urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = $m['source-map/lib/util.js#0.5.6'].exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return _sourcemaplibutiljs056_urlGenerate(url);
  }
  return path;
}
$m['source-map/lib/util.js#0.5.6'].exports.normalize = _sourcemaplibutiljs056_normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function _sourcemaplibutiljs056_join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = _sourcemaplibutiljs056_urlParse(aPath);
  var aRootUrl = _sourcemaplibutiljs056_urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return _sourcemaplibutiljs056_urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(_sourcemaplibutiljs056_dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return _sourcemaplibutiljs056_urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : _sourcemaplibutiljs056_normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return _sourcemaplibutiljs056_urlGenerate(aRootUrl);
  }
  return joined;
}
$m['source-map/lib/util.js#0.5.6'].exports.join = _sourcemaplibutiljs056_join;

$m['source-map/lib/util.js#0.5.6'].exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(_sourcemaplibutiljs056_urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function _sourcemaplibutiljs056_relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
$m['source-map/lib/util.js#0.5.6'].exports.relative = _sourcemaplibutiljs056_relative;

var _sourcemaplibutiljs056_supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function _sourcemaplibutiljs056_identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function _sourcemaplibutiljs056_toSetString(aStr) {
  if (_sourcemaplibutiljs056_isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
$m['source-map/lib/util.js#0.5.6'].exports.toSetString = _sourcemaplibutiljs056_supportsNullProto ? _sourcemaplibutiljs056_identity : _sourcemaplibutiljs056_toSetString;

function _sourcemaplibutiljs056_fromSetString(aStr) {
  if (_sourcemaplibutiljs056_isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
$m['source-map/lib/util.js#0.5.6'].exports.fromSetString = _sourcemaplibutiljs056_supportsNullProto ? _sourcemaplibutiljs056_identity : _sourcemaplibutiljs056_fromSetString;

function _sourcemaplibutiljs056_isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function _sourcemaplibutiljs056_compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByOriginalPositions = _sourcemaplibutiljs056_compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function _sourcemaplibutiljs056_compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByGeneratedPositionsDeflated = _sourcemaplibutiljs056_compareByGeneratedPositionsDeflated;

function _sourcemaplibutiljs056_strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function _sourcemaplibutiljs056_compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = _sourcemaplibutiljs056_strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return _sourcemaplibutiljs056_strcmp(mappingA.name, mappingB.name);
}
$m['source-map/lib/util.js#0.5.6'].exports.compareByGeneratedPositionsInflated = _sourcemaplibutiljs056_compareByGeneratedPositionsInflated;
/*≠≠ node_modules/source-map/lib/util.js ≠≠*/

/*== node_modules/source-map/lib/mapping-list.js ==*/
$m['source-map/lib/mapping-list.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibmappinglistjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function _sourcemaplibmappinglistjs056_generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || _sourcemaplibmappinglistjs056_util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function _sourcemaplibmappinglistjs056_MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.add = function MappingList_add(aMapping) {
  if (_sourcemaplibmappinglistjs056_generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
_sourcemaplibmappinglistjs056_MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(_sourcemaplibmappinglistjs056_util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

$m['source-map/lib/mapping-list.js#0.5.6'].exports.MappingList = _sourcemaplibmappinglistjs056_MappingList;
/*≠≠ node_modules/source-map/lib/mapping-list.js ≠≠*/

/*== node_modules/source-map/lib/array-set.js ==*/
$m['source-map/lib/array-set.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibarraysetjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibarraysetjs056_has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function _sourcemaplibarraysetjs056_ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
_sourcemaplibarraysetjs056_ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new _sourcemaplibarraysetjs056_ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  var isDuplicate = _sourcemaplibarraysetjs056_has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  return _sourcemaplibarraysetjs056_has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = _sourcemaplibarraysetjs056_util.toSetString(aStr);
  if (_sourcemaplibarraysetjs056_has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
_sourcemaplibarraysetjs056_ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

$m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet = _sourcemaplibarraysetjs056_ArraySet;
/*≠≠ node_modules/source-map/lib/array-set.js ≠≠*/

/*== node_modules/source-map/lib/base64.js ==*/
$m['source-map/lib/base64.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibbase64js056_intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
$m['source-map/lib/base64.js#0.5.6'].exports.encode = function (number) {
  if (0 <= number && number < _sourcemaplibbase64js056_intToCharMap.length) {
    return _sourcemaplibbase64js056_intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
$m['source-map/lib/base64.js#0.5.6'].exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};
/*≠≠ node_modules/source-map/lib/base64.js ≠≠*/

/*== node_modules/source-map/lib/base64-vlq.js ==*/
$m['source-map/lib/base64-vlq.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var _sourcemaplibbase64vlqjs056_base64 = $m['source-map/lib/base64.js#0.5.6'].exports;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT = 5;

// binary: 100000
var _sourcemaplibbase64vlqjs056_VLQ_BASE = 1 << _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;

// binary: 011111
var _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK = _sourcemaplibbase64vlqjs056_VLQ_BASE - 1;

// binary: 100000
var _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT = _sourcemaplibbase64vlqjs056_VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function _sourcemaplibbase64vlqjs056_toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function _sourcemaplibbase64vlqjs056_fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
$m['source-map/lib/base64-vlq.js#0.5.6'].exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = _sourcemaplibbase64vlqjs056_toVLQSigned(aValue);

  do {
    digit = vlq & _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK;
    vlq >>>= _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT;
    }
    encoded += _sourcemaplibbase64vlqjs056_base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
$m['source-map/lib/base64-vlq.js#0.5.6'].exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = _sourcemaplibbase64vlqjs056_base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & _sourcemaplibbase64vlqjs056_VLQ_CONTINUATION_BIT);
    digit &= _sourcemaplibbase64vlqjs056_VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += _sourcemaplibbase64vlqjs056_VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = _sourcemaplibbase64vlqjs056_fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
/*≠≠ node_modules/source-map/lib/base64-vlq.js ≠≠*/

/*== node_modules/source-map/lib/source-map-generator.js ==*/
$m['source-map/lib/source-map-generator.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcemapgeneratorjs056_base64VLQ = $m['source-map/lib/base64-vlq.js#0.5.6'].exports;
var _sourcemaplibsourcemapgeneratorjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibsourcemapgeneratorjs056_ArraySet = $m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet;
var _sourcemaplibsourcemapgeneratorjs056_MappingList = $m['source-map/lib/mapping-list.js#0.5.6'].exports.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'file', null);
  this._sourceRoot = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'skipValidation', false);
  this._sources = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  this._names = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  this._mappings = new _sourcemaplibsourcemapgeneratorjs056_MappingList();
  this._sourcesContents = null;
}

_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'generated');
  var original = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'original', null);
  var source = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'source', null);
  var name = _sourcemaplibsourcemapgeneratorjs056_util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = _sourcemaplibsourcemapgeneratorjs056_util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[_sourcemaplibsourcemapgeneratorjs056_util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[_sourcemaplibsourcemapgeneratorjs056_util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();
  var newNames = new _sourcemaplibsourcemapgeneratorjs056_ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = _sourcemaplibsourcemapgeneratorjs056_util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = _sourcemaplibsourcemapgeneratorjs056_util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!_sourcemaplibsourcemapgeneratorjs056_util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }

    next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;

      next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += _sourcemaplibsourcemapgeneratorjs056_base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = _sourcemaplibsourcemapgeneratorjs056_util.relative(aSourceRoot, source);
    }
    var key = _sourcemaplibsourcemapgeneratorjs056_util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
_sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

$m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator = _sourcemaplibsourcemapgeneratorjs056_SourceMapGenerator;
/*≠≠ node_modules/source-map/lib/source-map-generator.js ≠≠*/

/*== node_modules/source-map/lib/source-node.js ==*/
$m['source-map/lib/source-node.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcenodejs056_SourceMapGenerator = $m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator;
var _sourcemaplibsourcenodejs056_util = $m['source-map/lib/util.js#0.5.6'].exports;

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var _sourcemaplibsourcenodejs056_REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var _sourcemaplibsourcenodejs056_NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var _sourcemaplibsourcenodejs056_isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function _sourcemaplibsourcenodejs056_SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[_sourcemaplibsourcenodejs056_isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
_sourcemaplibsourcenodejs056_SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new _sourcemaplibsourcenodejs056_SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are removed from this array, by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(_sourcemaplibsourcenodejs056_REGEX_NEWLINE);
  var shiftNextLine = function () {
    var lineContents = remainingLines.shift();
    // The last line of a file might not have a newline.
    var newLine = remainingLines.shift() || "";
    return lineContents + newLine;
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[0];
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[0];
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[0] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLines.length > 0) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = _sourcemaplibsourcenodejs056_util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? _sourcemaplibsourcenodejs056_util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new _sourcemaplibsourcenodejs056_SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[_sourcemaplibsourcenodejs056_isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[_sourcemaplibsourcenodejs056_isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[_sourcemaplibsourcenodejs056_isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
          line: this.line,
          column: this.column,
          name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[_sourcemaplibsourcenodejs056_isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[_sourcemaplibsourcenodejs056_util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][_sourcemaplibsourcenodejs056_isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(_sourcemaplibsourcenodejs056_util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
_sourcemaplibsourcenodejs056_SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new _sourcemaplibsourcenodejs056_SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === _sourcemaplibsourcenodejs056_NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

$m['source-map/lib/source-node.js#0.5.6'].exports.SourceNode = _sourcemaplibsourcenodejs056_SourceNode;
/*≠≠ node_modules/source-map/lib/source-node.js ≠≠*/

/*== node_modules/source-map/lib/quick-sort.js ==*/
$m['source-map/lib/quick-sort.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function _sourcemaplibquicksortjs056_swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function _sourcemaplibquicksortjs056_randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = _sourcemaplibquicksortjs056_randomIntInRange(p, r);
    var i = p - 1;

    _sourcemaplibquicksortjs056_swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        _sourcemaplibquicksortjs056_swap(ary, i, j);
      }
    }

    _sourcemaplibquicksortjs056_swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, p, q - 1);
    _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
$m['source-map/lib/quick-sort.js#0.5.6'].exports.quickSort = function (ary, comparator) {
  _sourcemaplibquicksortjs056_doQuickSort(ary, comparator, 0, ary.length - 1);
};
/*≠≠ node_modules/source-map/lib/quick-sort.js ≠≠*/

/*== node_modules/source-map/lib/binary-search.js ==*/
$m['source-map/lib/binary-search.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

$m['source-map/lib/binary-search.js#0.5.6'].exports.GREATEST_LOWER_BOUND = 1;
$m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function _sourcemaplibbinarysearchjs056_recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return _sourcemaplibbinarysearchjs056_recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == $m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return _sourcemaplibbinarysearchjs056_recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == $m['source-map/lib/binary-search.js#0.5.6'].exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
$m['source-map/lib/binary-search.js#0.5.6'].exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = _sourcemaplibbinarysearchjs056_recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || $m['source-map/lib/binary-search.js#0.5.6'].exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};
/*≠≠ node_modules/source-map/lib/binary-search.js ≠≠*/

/*== node_modules/source-map/lib/source-map-consumer.js ==*/
$m['source-map/lib/source-map-consumer.js#0.5.6'] = { exports: {} };
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var _sourcemaplibsourcemapconsumerjs056_util = $m['source-map/lib/util.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_binarySearch = $m['source-map/lib/binary-search.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_ArraySet = $m['source-map/lib/array-set.js#0.5.6'].exports.ArraySet;
var _sourcemaplibsourcemapconsumerjs056_base64VLQ = $m['source-map/lib/base64-vlq.js#0.5.6'].exports;
var _sourcemaplibsourcemapconsumerjs056_quickSort = $m['source-map/lib/quick-sort.js#0.5.6'].exports.quickSort;

function _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null ? new _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer(sourceMap) : new _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer(sourceMap);
}

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.fromSourceMap = function (aSourceMap) {
  return _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.fromSourceMap(aSourceMap);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER = 1;
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.ORIGINAL_ORDER = 2;

_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
    case _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    if (source != null && sourceRoot != null) {
      source = _sourcemaplibsourcemapconsumerjs056_util.join(sourceRoot, source);
    }
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column', 0)
  };

  if (this.sourceRoot != null) {
    needle.source = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, needle.source);
  }
  if (!this._sources.has(needle.source)) {
    return [];
  }
  needle.source = this._sources.indexOf(needle.source);

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions, _sourcemaplibsourcemapconsumerjs056_binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
          column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
          lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
          column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
          lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.SourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'version');
  var sources = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'names', []);
  var sourceRoot = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'mappings');
  var file = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(_sourcemaplibsourcemapconsumerjs056_util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && _sourcemaplibsourcemapconsumerjs056_util.isAbsolute(sourceRoot) && _sourcemaplibsourcemapconsumerjs056_util.isAbsolute(source) ? _sourcemaplibsourcemapconsumerjs056_util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(names.map(String), true);
  this._sources = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype = Object.create(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype);
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.consumer = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
  var smc = Object.create(_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype);

  var names = smc._names = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = _sourcemaplibsourcemapconsumerjs056_ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new _sourcemaplibsourcemapconsumerjs056_Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(smc.__originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);

  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? _sourcemaplibsourcemapconsumerjs056_util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function _sourcemaplibsourcemapconsumerjs056_Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new _sourcemaplibsourcemapconsumerjs056_Mapping();
      mapping.generatedLine = generatedLine;

      // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);

      segment = cachedSegments[str];
      if (segment) {
        index += str.length;
      } else {
        segment = [];
        while (index < end) {
          _sourcemaplibsourcemapconsumerjs056_base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(generatedMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  _sourcemaplibsourcemapconsumerjs056_quickSort(originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return _sourcemaplibsourcemapconsumerjs056_binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    generatedColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated, _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'bias', _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        if (this.sourceRoot != null) {
          source = _sourcemaplibsourcemapconsumerjs056_util.join(this.sourceRoot, source);
        }
      }
      var name = _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'originalLine', null),
        column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  if (this.sourceRoot != null) {
    aSource = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, aSource);
  }

  if (this._sources.has(aSource)) {
    return this.sourcesContent[this._sources.indexOf(aSource)];
  }

  var url;
  if (this.sourceRoot != null && (url = _sourcemaplibsourcemapconsumerjs056_util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + aSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source');
  if (this.sourceRoot != null) {
    source = _sourcemaplibsourcemapconsumerjs056_util.relative(this.sourceRoot, source);
  }
  if (!this._sources.has(source)) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  source = this._sources.indexOf(source);

  var needle = {
    source: source,
    originalLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    originalColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions, _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'bias', _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedLine', null),
        column: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'generatedColumn', null),
        lastColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.BasicSourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'version');
  var sections = _sourcemaplibsourcemapconsumerjs056_util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new _sourcemaplibsourcemapconsumerjs056_ArraySet();
  this._names = new _sourcemaplibsourcemapconsumerjs056_ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = _sourcemaplibsourcemapconsumerjs056_util.getArg(s, 'offset');
    var offsetLine = _sourcemaplibsourcemapconsumerjs056_util.getArg(offset, 'line');
    var offsetColumn = _sourcemaplibsourcemapconsumerjs056_util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer(_sourcemaplibsourcemapconsumerjs056_util.getArg(s, 'map'))
    };
  });
}

_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype = Object.create(_sourcemaplibsourcemapconsumerjs056_SourceMapConsumer.prototype);
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.constructor = _sourcemaplibsourcemapconsumerjs056_SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'line'),
    generatedColumn: _sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = _sourcemaplibsourcemapconsumerjs056_binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer.sources.indexOf(_sourcemaplibsourcemapconsumerjs056_util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
_sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);
      if (section.consumer.sourceRoot !== null) {
        source = _sourcemaplibsourcemapconsumerjs056_util.join(section.consumer.sourceRoot, source);
      }
      this._sources.add(source);
      source = this._sources.indexOf(source);

      var name = section.consumer._names.at(mapping.name);
      this._names.add(name);
      name = this._names.indexOf(name);

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  _sourcemaplibsourcemapconsumerjs056_quickSort(this.__generatedMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByGeneratedPositionsDeflated);
  _sourcemaplibsourcemapconsumerjs056_quickSort(this.__originalMappings, _sourcemaplibsourcemapconsumerjs056_util.compareByOriginalPositions);
};

$m['source-map/lib/source-map-consumer.js#0.5.6'].exports.IndexedSourceMapConsumer = _sourcemaplibsourcemapconsumerjs056_IndexedSourceMapConsumer;
/*≠≠ node_modules/source-map/lib/source-map-consumer.js ≠≠*/

/*== node_modules/source-map/source-map.js ==*/
$m['source-map/source-map.js#0.5.6'] = { exports: {} };
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
$m['source-map/source-map.js#0.5.6'].exports.SourceMapGenerator = $m['source-map/lib/source-map-generator.js#0.5.6'].exports.SourceMapGenerator;
$m['source-map/source-map.js#0.5.6'].exports.SourceMapConsumer = $m['source-map/lib/source-map-consumer.js#0.5.6'].exports.SourceMapConsumer;
$m['source-map/source-map.js#0.5.6'].exports.SourceNode = $m['source-map/lib/source-node.js#0.5.6'].exports.SourceNode;
/*≠≠ node_modules/source-map/source-map.js ≠≠*/

/*== node_modules/csso/lib/utils/translateWithSourceMap.js ==*/
$m['csso/lib/utils/translateWithSourceMap.js#2.2.1'] = { exports: {} };
var _cssolibutilstranslateWithSourceMapjs221_SourceMapGenerator = $m['source-map/source-map.js#0.5.6'].exports.SourceMapGenerator;
var _cssolibutilstranslateWithSourceMapjs221_SourceNode = $m['source-map/source-map.js#0.5.6'].exports.SourceNode;

// Our own implementation of SourceNode#toStringWithSourceMap,
// since SourceNode doesn't allow multiple references to original source.
// Also, as we know structure of result we could be optimize generation
// (currently it's ~40% faster).
function _cssolibutilstranslateWithSourceMapjs221_walk(node, fn) {
    for (var chunk, i = 0; i < node.children.length; i++) {
        chunk = node.children[i];

        if (chunk instanceof _cssolibutilstranslateWithSourceMapjs221_SourceNode) {
            // this is a hack, because source maps doesn't support for 1(generated):N(original)
            // if (chunk.merged) {
            //     fn('', chunk);
            // }

            _cssolibutilstranslateWithSourceMapjs221_walk(chunk, fn);
        } else {
            fn(chunk, node);
        }
    }
}

function _cssolibutilstranslateWithSourceMapjs221_generateSourceMap(root) {
    var map = new _cssolibutilstranslateWithSourceMapjs221_SourceMapGenerator();
    var css = '';
    var sourceMappingActive = false;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastIndexOfNewline;
    var generated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: generated
    };

    _cssolibutilstranslateWithSourceMapjs221_walk(root, function (chunk, original) {
        if (original.line !== null && original.column !== null) {
            if (lastOriginalLine !== original.line || lastOriginalColumn !== original.column) {
                map.addMapping({
                    source: original.source,
                    original: original,
                    generated: generated
                });
            }

            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            sourceMappingActive = true;
        } else if (sourceMappingActive) {
            map.addMapping(activatedMapping);
            sourceMappingActive = false;
        }

        css += chunk;

        lastIndexOfNewline = chunk.lastIndexOf('\n');
        if (lastIndexOfNewline !== -1) {
            generated.line += chunk.match(/\n/g).length;
            generated.column = chunk.length - lastIndexOfNewline - 1;
        } else {
            generated.column += chunk.length;
        }
    });

    return {
        css: css,
        map: map
    };
}

function _cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode(children) {
    return new _cssolibutilstranslateWithSourceMapjs221_SourceNode(null, null, null, children);
}

function _cssolibutilstranslateWithSourceMapjs221_createSourceNode(info, children) {
    if (info.primary) {
        // special marker node to add several references to original
        // var merged = createSourceNode(info.merged, []);
        // merged.merged = true;
        // children.unshift(merged);

        // use recursion, because primary can also has a primary/merged info
        return _cssolibutilstranslateWithSourceMapjs221_createSourceNode(info.primary, children);
    }

    return new _cssolibutilstranslateWithSourceMapjs221_SourceNode(info.line, info.column - 1, info.source, children);
}

function _cssolibutilstranslateWithSourceMapjs221_each(list) {
    if (list.head === null) {
        return '';
    }

    if (list.head === list.tail) {
        return _cssolibutilstranslateWithSourceMapjs221_translate(list.head.data);
    }

    return list.map(_cssolibutilstranslateWithSourceMapjs221_translate).join('');
}

function _cssolibutilstranslateWithSourceMapjs221_eachDelim(list, delimeter) {
    if (list.head === null) {
        return '';
    }

    if (list.head === list.tail) {
        return _cssolibutilstranslateWithSourceMapjs221_translate(list.head.data);
    }

    return list.map(_cssolibutilstranslateWithSourceMapjs221_translate).join(delimeter);
}

function _cssolibutilstranslateWithSourceMapjs221_translate(node) {
    switch (node.type) {
        case 'StyleSheet':
            return _cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode(node.rules.map(_cssolibutilstranslateWithSourceMapjs221_translate));

        case 'Atrule':
            var nodes = ['@', node.name];

            if (node.expression && !node.expression.sequence.isEmpty()) {
                nodes.push(' ', _cssolibutilstranslateWithSourceMapjs221_translate(node.expression));
            }

            if (node.block) {
                nodes.push('{', _cssolibutilstranslateWithSourceMapjs221_translate(node.block), '}');
            } else {
                nodes.push(';');
            }

            return _cssolibutilstranslateWithSourceMapjs221_createSourceNode(node.info, nodes);

        case 'Ruleset':
            return _cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode([_cssolibutilstranslateWithSourceMapjs221_translate(node.selector), '{', _cssolibutilstranslateWithSourceMapjs221_translate(node.block), '}']);

        case 'Selector':
            return _cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode(node.selectors.map(_cssolibutilstranslateWithSourceMapjs221_translate)).join(',');

        case 'SimpleSelector':
            var nodes = node.sequence.map(function (node) {
                // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced
                if (node.type === 'Combinator' && node.name === '/deep/') {
                    return ' ' + _cssolibutilstranslateWithSourceMapjs221_translate(node) + ' ';
                }

                return _cssolibutilstranslateWithSourceMapjs221_translate(node);
            });

            return _cssolibutilstranslateWithSourceMapjs221_createSourceNode(node.info, nodes);

        case 'Block':
            return _cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode(node.declarations.map(_cssolibutilstranslateWithSourceMapjs221_translate)).join(';');

        case 'Declaration':
            return _cssolibutilstranslateWithSourceMapjs221_createSourceNode(node.info, [_cssolibutilstranslateWithSourceMapjs221_translate(node.property), ':', _cssolibutilstranslateWithSourceMapjs221_translate(node.value)]);

        case 'Property':
            return node.name;

        case 'Value':
            return node.important ? _cssolibutilstranslateWithSourceMapjs221_each(node.sequence) + '!important' : _cssolibutilstranslateWithSourceMapjs221_each(node.sequence);

        case 'Attribute':
            var result = _cssolibutilstranslateWithSourceMapjs221_translate(node.name);
            var flagsPrefix = ' ';

            if (node.operator !== null) {
                result += node.operator;

                if (node.value !== null) {
                    result += _cssolibutilstranslateWithSourceMapjs221_translate(node.value);

                    // space between string and flags is not required
                    if (node.value.type === 'String') {
                        flagsPrefix = '';
                    }
                }
            }

            if (node.flags !== null) {
                result += flagsPrefix + node.flags;
            }

            return '[' + result + ']';

        case 'FunctionalPseudo':
            return ':' + node.name + '(' + _cssolibutilstranslateWithSourceMapjs221_eachDelim(node.arguments, ',') + ')';

        case 'Function':
            return node.name + '(' + _cssolibutilstranslateWithSourceMapjs221_eachDelim(node.arguments, ',') + ')';

        case 'Negation':
            return ':not(' + _cssolibutilstranslateWithSourceMapjs221_eachDelim(node.sequence, ',') + ')';

        case 'Braces':
            return node.open + _cssolibutilstranslateWithSourceMapjs221_each(node.sequence) + node.close;

        case 'Argument':
        case 'AtruleExpression':
            return _cssolibutilstranslateWithSourceMapjs221_each(node.sequence);

        case 'Url':
            return 'url(' + _cssolibutilstranslateWithSourceMapjs221_translate(node.value) + ')';

        case 'Progid':
            return _cssolibutilstranslateWithSourceMapjs221_translate(node.value);

        case 'Combinator':
            return node.name;

        case 'Identifier':
            return node.name;

        case 'PseudoClass':
            return ':' + node.name;

        case 'PseudoElement':
            return '::' + node.name;

        case 'Class':
            return '.' + node.name;

        case 'Id':
            return '#' + node.name;

        case 'Hash':
            return '#' + node.value;

        case 'Dimension':
            return node.value + node.unit;

        case 'Nth':
            return node.value;

        case 'Number':
            return node.value;

        case 'String':
            return node.value;

        case 'Operator':
            return node.value;

        case 'Raw':
            return node.value;

        case 'Unknown':
            return node.value;

        case 'Percentage':
            return node.value + '%';

        case 'Space':
            return ' ';

        case 'Comment':
            return '/*' + node.value + '*/';

        default:
            throw new Error('Unknown node type: ' + node.type);
    }
}

$m['csso/lib/utils/translateWithSourceMap.js#2.2.1'].exports = function (node) {
    return _cssolibutilstranslateWithSourceMapjs221_generateSourceMap(_cssolibutilstranslateWithSourceMapjs221_createAnonymousSourceNode(_cssolibutilstranslateWithSourceMapjs221_translate(node)));
};
/*≠≠ node_modules/csso/lib/utils/translateWithSourceMap.js ≠≠*/

/*== node_modules/csso/lib/utils/translate.js ==*/
$m['csso/lib/utils/translate.js#2.2.1'] = { exports: {} };
function _cssolibutilstranslatejs221_each(list) {
    if (list.head === null) {
        return '';
    }

    if (list.head === list.tail) {
        return _cssolibutilstranslatejs221_translate(list.head.data);
    }

    return list.map(_cssolibutilstranslatejs221_translate).join('');
}

function _cssolibutilstranslatejs221_eachDelim(list, delimeter) {
    if (list.head === null) {
        return '';
    }

    if (list.head === list.tail) {
        return _cssolibutilstranslatejs221_translate(list.head.data);
    }

    return list.map(_cssolibutilstranslatejs221_translate).join(delimeter);
}

function _cssolibutilstranslatejs221_translate(node) {
    switch (node.type) {
        case 'StyleSheet':
            return _cssolibutilstranslatejs221_each(node.rules);

        case 'Atrule':
            var nodes = ['@', node.name];

            if (node.expression && !node.expression.sequence.isEmpty()) {
                nodes.push(' ', _cssolibutilstranslatejs221_translate(node.expression));
            }

            if (node.block) {
                nodes.push('{', _cssolibutilstranslatejs221_translate(node.block), '}');
            } else {
                nodes.push(';');
            }

            return nodes.join('');

        case 'Ruleset':
            return _cssolibutilstranslatejs221_translate(node.selector) + '{' + _cssolibutilstranslatejs221_translate(node.block) + '}';

        case 'Selector':
            return _cssolibutilstranslatejs221_eachDelim(node.selectors, ',');

        case 'SimpleSelector':
            var nodes = node.sequence.map(function (node) {
                // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced
                if (node.type === 'Combinator' && node.name === '/deep/') {
                    return ' ' + _cssolibutilstranslatejs221_translate(node) + ' ';
                }

                return _cssolibutilstranslatejs221_translate(node);
            });

            return nodes.join('');

        case 'Block':
            return _cssolibutilstranslatejs221_eachDelim(node.declarations, ';');

        case 'Declaration':
            return _cssolibutilstranslatejs221_translate(node.property) + ':' + _cssolibutilstranslatejs221_translate(node.value);

        case 'Property':
            return node.name;

        case 'Value':
            return node.important ? _cssolibutilstranslatejs221_each(node.sequence) + '!important' : _cssolibutilstranslatejs221_each(node.sequence);

        case 'Attribute':
            var result = _cssolibutilstranslatejs221_translate(node.name);
            var flagsPrefix = ' ';

            if (node.operator !== null) {
                result += node.operator;

                if (node.value !== null) {
                    result += _cssolibutilstranslatejs221_translate(node.value);

                    // space between string and flags is not required
                    if (node.value.type === 'String') {
                        flagsPrefix = '';
                    }
                }
            }

            if (node.flags !== null) {
                result += flagsPrefix + node.flags;
            }

            return '[' + result + ']';

        case 'FunctionalPseudo':
            return ':' + node.name + '(' + _cssolibutilstranslatejs221_eachDelim(node.arguments, ',') + ')';

        case 'Function':
            return node.name + '(' + _cssolibutilstranslatejs221_eachDelim(node.arguments, ',') + ')';

        case 'Negation':
            return ':not(' + _cssolibutilstranslatejs221_eachDelim(node.sequence, ',') + ')';

        case 'Braces':
            return node.open + _cssolibutilstranslatejs221_each(node.sequence) + node.close;

        case 'Argument':
        case 'AtruleExpression':
            return _cssolibutilstranslatejs221_each(node.sequence);

        case 'Url':
            return 'url(' + _cssolibutilstranslatejs221_translate(node.value) + ')';

        case 'Progid':
            return _cssolibutilstranslatejs221_translate(node.value);

        case 'Combinator':
            return node.name;

        case 'Identifier':
            return node.name;

        case 'PseudoClass':
            return ':' + node.name;

        case 'PseudoElement':
            return '::' + node.name;

        case 'Class':
            return '.' + node.name;

        case 'Id':
            return '#' + node.name;

        case 'Hash':
            return '#' + node.value;

        case 'Dimension':
            return node.value + node.unit;

        case 'Nth':
            return node.value;

        case 'Number':
            return node.value;

        case 'String':
            return node.value;

        case 'Operator':
            return node.value;

        case 'Raw':
            return node.value;

        case 'Unknown':
            return node.value;

        case 'Percentage':
            return node.value + '%';

        case 'Space':
            return ' ';

        case 'Comment':
            return '/*' + node.value + '*/';

        default:
            throw new Error('Unknown node type: ' + node.type);
    }
}

$m['csso/lib/utils/translate.js#2.2.1'].exports = _cssolibutilstranslatejs221_translate;
/*≠≠ node_modules/csso/lib/utils/translate.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/utils.js ==*/
$m['csso/lib/compressor/restructure/utils.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructureutilsjs221_hasOwnProperty = Object.prototype.hasOwnProperty;

function _cssolibcompressorrestructureutilsjs221_isEqualLists(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function _cssolibcompressorrestructureutilsjs221_isEqualDeclarations(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function _cssolibcompressorrestructureutilsjs221_compareDeclarations(declarations1, declarations2) {
    var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    var fingerprints = Object.create(null);
    var declarations2hash = Object.create(null);

    for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        declarations2hash[cursor.data.id] = true;
    }

    for (var cursor = declarations1.head; cursor; cursor = cursor.next) {
        var data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.value.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        var data = cursor.data;

        if (declarations2hash[data.id]) {
            // if declarations1 has overriding declaration, this is not a difference
            // but take in account !important - prev should be equal or greater than follow
            if (_cssolibcompressorrestructureutilsjs221_hasOwnProperty.call(fingerprints, data.fingerprint) && Number(fingerprints[data.fingerprint]) >= Number(data.value.important)) {
                result.ne2overrided.push(data);
            } else {
                result.ne2.push(data);
            }
        }
    }

    return result;
}

function _cssolibcompressorrestructureutilsjs221_addSelectors(dest, source) {
    source.each(function (sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;

        while (cursor) {
            var nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function _cssolibcompressorrestructureutilsjs221_hasSimilarSelectors(selectors1, selectors2) {
    return selectors1.some(function (a) {
        return selectors2.some(function (b) {
            return a.compareMarker === b.compareMarker;
        });
    });
}

// test node can't to be skipped
function _cssolibcompressorrestructureutilsjs221_unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Ruleset':
            // unsafe skip ruleset with selector similarities
            return _cssolibcompressorrestructureutilsjs221_hasSimilarSelectors(node.selector.selectors, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // non-stylesheet blocks are safe to skip since have no selectors
                if (node.block.type !== 'StyleSheet') {
                    return false;
                }

                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.rules.some(_cssolibcompressorrestructureutilsjs221_unsafeToSkipNode, this);
            }
            break;
    }

    // unsafe by default
    return true;
}

$m['csso/lib/compressor/restructure/utils.js#2.2.1'].exports = {
    isEqualLists: _cssolibcompressorrestructureutilsjs221_isEqualLists,
    isEqualDeclarations: _cssolibcompressorrestructureutilsjs221_isEqualDeclarations,
    compareDeclarations: _cssolibcompressorrestructureutilsjs221_compareDeclarations,
    addSelectors: _cssolibcompressorrestructureutilsjs221_addSelectors,
    hasSimilarSelectors: _cssolibcompressorrestructureutilsjs221_hasSimilarSelectors,
    unsafeToSkipNode: _cssolibcompressorrestructureutilsjs221_unsafeToSkipNode
};
/*≠≠ node_modules/csso/lib/compressor/restructure/utils.js ≠≠*/

/*== node_modules/csso/lib/compress...structure/8-restructRuleset.js ==*/
$m['csso/lib/compressor/restructure/8-restructRuleset.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure8restructRulesetjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibcompressorrestructure8restructRulesetjs221_utils = $m['csso/lib/compressor/restructure/utils.js#2.2.1'].exports;
var _cssolibcompressorrestructure8restructRulesetjs221_walkRulesRight = $m['csso/lib/utils/walk.js#2.2.1'].exports.rulesRight;

function _cssolibcompressorrestructure8restructRulesetjs221_calcSelectorLength(list) {
    var length = 0;

    list.each(function (data) {
        length += data.id.length + 1;
    });

    return length - 1;
}

function _cssolibcompressorrestructure8restructRulesetjs221_calcDeclarationsLength(tokens) {
    var length = 0;

    for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
    }

    return length + // declarations
    tokens.length - 1 // delimeters
    ;
}

function _cssolibcompressorrestructure8restructRulesetjs221_processRuleset(node, item, list) {
    var avoidRulesMerge = this.stylesheet.avoidRulesMerge;
    var selectors = node.selector.selectors;
    var block = node.block;
    var disallowDownMarkers = Object.create(null);
    var allowMergeUp = true;
    var allowMergeDown = true;

    list.prevUntil(item.prev, function (prev, prevItem) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Ruleset') {
            return _cssolibcompressorrestructure8restructRulesetjs221_utils.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.selector.selectors;
        var prevBlock = prev.block;

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        allowMergeDown = !prevSelectors.some(function (selector) {
            return selector.compareMarker in disallowDownMarkers;
        });

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && _cssolibcompressorrestructure8restructRulesetjs221_utils.isEqualLists(prevSelectors, selectors)) {
            prevBlock.declarations.appendList(block.declarations);
            list.remove(item);
            return true;
        }

        // try to join by properties
        var diff = _cssolibcompressorrestructure8restructRulesetjs221_utils.compareDeclarations(block.declarations, prevBlock.declarations);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    _cssolibcompressorrestructure8restructRulesetjs221_utils.addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) {
                /* probably we don't need to prevent those merges for @keyframes
                   TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    var selectorLength = _cssolibcompressorrestructure8restructRulesetjs221_calcSelectorLength(selectors);
                    var blockLength = _cssolibcompressorrestructure8restructRulesetjs221_calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        _cssolibcompressorrestructure8restructRulesetjs221_utils.addSelectors(prevSelectors, selectors);
                        block.declarations = new _cssolibcompressorrestructure8restructRulesetjs221_List(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    var selectorLength = _cssolibcompressorrestructure8restructRulesetjs221_calcSelectorLength(prevSelectors);
                    var blockLength = _cssolibcompressorrestructure8restructRulesetjs221_calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        _cssolibcompressorrestructure8restructRulesetjs221_utils.addSelectors(selectors, prevSelectors);
                        prevBlock.declarations = new _cssolibcompressorrestructure8restructRulesetjs221_List(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    var newSelector = {
                        type: 'Selector',
                        info: {},
                        selectors: _cssolibcompressorrestructure8restructRulesetjs221_utils.addSelectors(prevSelectors.copy(), selectors)
                    };
                    var newBlockLength = _cssolibcompressorrestructure8restructRulesetjs221_calcSelectorLength(newSelector.selectors) + 2; // selectors length + curly braces length
                    var blockLength = _cssolibcompressorrestructure8restructRulesetjs221_calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (allowMergeDown && blockLength >= newBlockLength) {
                        var newRuleset = {
                            type: 'Ruleset',
                            info: {},
                            pseudoSignature: node.pseudoSignature,
                            selector: newSelector,
                            block: {
                                type: 'Block',
                                info: {},
                                declarations: new _cssolibcompressorrestructure8restructRulesetjs221_List(diff.eq)
                            }
                        };

                        block.declarations = new _cssolibcompressorrestructure8restructRulesetjs221_List(diff.ne1);
                        prevBlock.declarations = new _cssolibcompressorrestructure8restructRulesetjs221_List(diff.ne2.concat(diff.ne2overrided));
                        list.insert(list.createItem(newRuleset), prevItem);
                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some(function (prevSelector) {
                return selectors.some(function (selector) {
                    return selector.compareMarker === prevSelector.compareMarker;
                });
            });
        }

        prevSelectors.each(function (data) {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
};

$m['csso/lib/compressor/restructure/8-restructRuleset.js#2.2.1'].exports = function restructRuleset(ast) {
    _cssolibcompressorrestructure8restructRulesetjs221_walkRulesRight(ast, function (node, item, list) {
        if (node.type === 'Ruleset') {
            _cssolibcompressorrestructure8restructRulesetjs221_processRuleset.call(this, node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compress...structure/8-restructRuleset.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/7-mergeRuleset.js ==*/
$m['csso/lib/compressor/restructure/7-mergeRuleset.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure7mergeRulesetjs221_utils = $m['csso/lib/compressor/restructure/utils.js#2.2.1'].exports;
var _cssolibcompressorrestructure7mergeRulesetjs221_walkRules = $m['csso/lib/utils/walk.js#2.2.1'].exports.rules;

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function _cssolibcompressorrestructure7mergeRulesetjs221_processRuleset(node, item, list) {
    var selectors = node.selector.selectors;
    var declarations = node.block.declarations;
    var nodeCompareMarker = selectors.first().compareMarker;
    var skippedCompareMarkers = {};

    list.nextUntil(item.next, function (next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Ruleset') {
            return _cssolibcompressorrestructure7mergeRulesetjs221_utils.unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        var nextFirstSelector = next.selector.selectors.head;
        var nextDeclarations = next.block.declarations;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (_cssolibcompressorrestructure7mergeRulesetjs221_utils.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;

            selectors.some(function (data, item) {
                var curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
};

$m['csso/lib/compressor/restructure/7-mergeRuleset.js#2.2.1'].exports = function mergeRuleset(ast) {
    _cssolibcompressorrestructure7mergeRulesetjs221_walkRules(ast, function (node, item, list) {
        if (node.type === 'Ruleset') {
            _cssolibcompressorrestructure7mergeRulesetjs221_processRuleset(node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compressor/restructure/7-mergeRuleset.js ≠≠*/

/*== node_modules/csso/lib/utils/names.js ==*/
$m['csso/lib/utils/names.js#2.2.1'] = { exports: {} };
var _cssolibutilsnamesjs221_hasOwnProperty = Object.prototype.hasOwnProperty;
var _cssolibutilsnamesjs221_knownKeywords = Object.create(null);
var _cssolibutilsnamesjs221_knownProperties = Object.create(null);

function _cssolibutilsnamesjs221_getVendorPrefix(string) {
    if (string[0] === '-') {
        // skip 2 chars to avoid wrong match with variables names
        var secondDashIndex = string.indexOf('-', 2);

        if (secondDashIndex !== -1) {
            return string.substr(0, secondDashIndex + 1);
        }
    }

    return '';
}

function _cssolibutilsnamesjs221_getKeywordInfo(keyword) {
    if (_cssolibutilsnamesjs221_hasOwnProperty.call(_cssolibutilsnamesjs221_knownKeywords, keyword)) {
        return _cssolibutilsnamesjs221_knownKeywords[keyword];
    }

    var lowerCaseKeyword = keyword.toLowerCase();
    var vendor = _cssolibutilsnamesjs221_getVendorPrefix(lowerCaseKeyword);
    var name = lowerCaseKeyword;

    if (vendor) {
        name = name.substr(vendor.length);
    }

    return _cssolibutilsnamesjs221_knownKeywords[keyword] = Object.freeze({
        vendor: vendor,
        prefix: vendor,
        name: name
    });
}

function _cssolibutilsnamesjs221_getPropertyInfo(property) {
    if (_cssolibutilsnamesjs221_hasOwnProperty.call(_cssolibutilsnamesjs221_knownProperties, property)) {
        return _cssolibutilsnamesjs221_knownProperties[property];
    }

    var lowerCaseProperty = property.toLowerCase();
    var hack = lowerCaseProperty[0];

    if (hack === '*' || hack === '_' || hack === '$') {
        lowerCaseProperty = lowerCaseProperty.substr(1);
    } else if (hack === '/' && property[1] === '/') {
        hack = '//';
        lowerCaseProperty = lowerCaseProperty.substr(2);
    } else {
        hack = '';
    }

    var vendor = _cssolibutilsnamesjs221_getVendorPrefix(lowerCaseProperty);
    var name = lowerCaseProperty;

    if (vendor) {
        name = name.substr(vendor.length);
    }

    return _cssolibutilsnamesjs221_knownProperties[property] = Object.freeze({
        hack: hack,
        vendor: vendor,
        prefix: hack + vendor,
        name: name
    });
}

$m['csso/lib/utils/names.js#2.2.1'].exports = {
    keyword: _cssolibutilsnamesjs221_getKeywordInfo,
    property: _cssolibutilsnamesjs221_getPropertyInfo
};
/*≠≠ node_modules/csso/lib/utils/names.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/6-restructBlock.js ==*/
$m['csso/lib/compressor/restructure/6-restructBlock.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure6restructBlockjs221_resolveProperty = $m['csso/lib/utils/names.js#2.2.1'].exports.property;
var _cssolibcompressorrestructure6restructBlockjs221_resolveKeyword = $m['csso/lib/utils/names.js#2.2.1'].exports.keyword;
var _cssolibcompressorrestructure6restructBlockjs221_walkRulesRight = $m['csso/lib/utils/walk.js#2.2.1'].exports.rulesRight;
var _cssolibcompressorrestructure6restructBlockjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;
var _cssolibcompressorrestructure6restructBlockjs221_dontRestructure = {
    'src': 1 // https://github.com/afelix/csso/issues/50
};

var _cssolibcompressorrestructure6restructBlockjs221_DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

var _cssolibcompressorrestructure6restructBlockjs221_CURSOR_SAFE_VALUE = ['auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll', 'col-resize', 'row-resize'];

var _cssolibcompressorrestructure6restructBlockjs221_NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function _cssolibcompressorrestructure6restructBlockjs221_getPropertyFingerprint(propertyName, declaration, fingerprints) {
    var realName = _cssolibcompressorrestructure6restructBlockjs221_resolveProperty(propertyName).name;

    if (realName === 'background' || realName === 'filter' && declaration.value.sequence.first().type === 'Progid') {
        return propertyName + ':' + _cssolibcompressorrestructure6restructBlockjs221_translate(declaration.value);
    }

    var declarationId = declaration.id;
    var fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        var vendorId = '';
        var hack9 = '';
        var special = {};

        declaration.value.sequence.each(function walk(node) {
            switch (node.type) {
                case 'Argument':
                case 'Value':
                case 'Braces':
                    node.sequence.each(walk);
                    break;

                case 'Identifier':
                    var name = node.name;

                    if (!vendorId) {
                        vendorId = _cssolibcompressorrestructure6restructBlockjs221_resolveKeyword(name).vendor;
                    }

                    if (/\\9/.test(name)) {
                        hack9 = name;
                    }

                    if (realName === 'cursor') {
                        if (_cssolibcompressorrestructure6restructBlockjs221_CURSOR_SAFE_VALUE.indexOf(name) === -1) {
                            special[name] = true;
                        }
                    } else if (_cssolibcompressorrestructure6restructBlockjs221_DONT_MIX_VALUE.hasOwnProperty(realName)) {
                        if (_cssolibcompressorrestructure6restructBlockjs221_DONT_MIX_VALUE[realName].test(name)) {
                            special[name] = true;
                        }
                    }

                    break;

                case 'Function':
                    var name = node.name;

                    if (!vendorId) {
                        vendorId = _cssolibcompressorrestructure6restructBlockjs221_resolveKeyword(name).vendor;
                    }

                    if (name === 'rect') {
                        // there are 2 forms of rect:
                        //   rect(<top>, <right>, <bottom>, <left>) - standart
                        //   rect(<top> <right> <bottom> <left>) – backwards compatible syntax
                        // only the same form values can be merged
                        if (node.arguments.size < 4) {
                            name = 'rect-backward';
                        }
                    }

                    special[name + '()'] = true;

                    // check nested tokens too
                    node.arguments.each(walk);

                    break;

                case 'Dimension':
                    var unit = node.unit;

                    switch (unit) {
                        // is not supported until IE11
                        case 'rem':

                        // v* units is too buggy across browsers and better
                        // don't merge values with those units
                        case 'vw':
                        case 'vh':
                        case 'vmin':
                        case 'vmax':
                        case 'vm':
                            // IE9 supporting "vm" instead of "vmin".
                            special[unit] = true;
                            break;
                    }
                    break;
            }
        });

        fingerprint = '|' + Object.keys(special).sort() + '|' + hack9 + vendorId;

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function _cssolibcompressorrestructure6restructBlockjs221_needless(props, declaration, fingerprints) {
    var property = _cssolibcompressorrestructure6restructBlockjs221_resolveProperty(declaration.property.name);

    if (_cssolibcompressorrestructure6restructBlockjs221_NEEDLESS_TABLE.hasOwnProperty(property.name)) {
        var table = _cssolibcompressorrestructure6restructBlockjs221_NEEDLESS_TABLE[property.name];

        for (var i = 0; i < table.length; i++) {
            var ppre = _cssolibcompressorrestructure6restructBlockjs221_getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
            var prev = props[ppre];

            if (prev && (!declaration.value.important || prev.item.data.value.important)) {
                return prev;
            }
        }
    }
}

function _cssolibcompressorrestructure6restructBlockjs221_processRuleset(ruleset, item, list, props, fingerprints) {
    var declarations = ruleset.block.declarations;

    declarations.eachRight(function (declaration, declarationItem) {
        var property = declaration.property.name;
        var fingerprint = _cssolibcompressorrestructure6restructBlockjs221_getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];

        if (prev && !_cssolibcompressorrestructure6restructBlockjs221_dontRestructure.hasOwnProperty(property)) {
            if (declaration.value.important && !prev.item.data.value.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);
                declaration.info = {
                    primary: declaration.info,
                    merged: prev.item.data.info
                };
            } else {
                declarations.remove(declarationItem);
                prev.item.data.info = {
                    primary: prev.item.data.info,
                    merged: declaration.info
                };
            }
        } else {
            var prev = _cssolibcompressorrestructure6restructBlockjs221_needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);
                prev.item.data.info = {
                    primary: prev.item.data.info,
                    merged: declaration.info
                };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty()) {
        list.remove(item);
    }
};

$m['csso/lib/compressor/restructure/6-restructBlock.js#2.2.1'].exports = function restructBlock(ast) {
    var stylesheetMap = {};
    var fingerprints = Object.create(null);

    _cssolibcompressorrestructure6restructBlockjs221_walkRulesRight(ast, function (node, item, list) {
        if (node.type !== 'Ruleset') {
            return;
        }

        var stylesheet = this.stylesheet;
        var rulesetId = (node.pseudoSignature || '') + '|' + node.selector.selectors.first().id;
        var rulesetMap;
        var props;

        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            rulesetMap = {};
            stylesheetMap[stylesheet.id] = rulesetMap;
        } else {
            rulesetMap = stylesheetMap[stylesheet.id];
        }

        if (rulesetMap.hasOwnProperty(rulesetId)) {
            props = rulesetMap[rulesetId];
        } else {
            props = {};
            rulesetMap[rulesetId] = props;
        }

        _cssolibcompressorrestructure6restructBlockjs221_processRuleset.call(this, node, item, list, props, fingerprints);
    });
};
/*≠≠ node_modules/csso/lib/compressor/restructure/6-restructBlock.js ≠≠*/

/*== node_modules/csso/lib/compress...ructure/4-restructShorthand.js ==*/
$m['csso/lib/compressor/restructure/4-restructShorthand.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure4restructShorthandjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibcompressorrestructure4restructShorthandjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;
var _cssolibcompressorrestructure4restructShorthandjs221_walkRulesRight = $m['csso/lib/utils/walk.js#2.2.1'].exports.rulesRight;

var _cssolibcompressorrestructure4restructShorthandjs221_REPLACE = 1;
var _cssolibcompressorrestructure4restructShorthandjs221_REMOVE = 2;
var _cssolibcompressorrestructure4restructShorthandjs221_TOP = 0;
var _cssolibcompressorrestructure4restructShorthandjs221_RIGHT = 1;
var _cssolibcompressorrestructure4restructShorthandjs221_BOTTOM = 2;
var _cssolibcompressorrestructure4restructShorthandjs221_LEFT = 3;
var _cssolibcompressorrestructure4restructShorthandjs221_SIDES = ['top', 'right', 'bottom', 'left'];
var _cssolibcompressorrestructure4restructShorthandjs221_SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
var _cssolibcompressorrestructure4restructShorthandjs221_MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

function _cssolibcompressorrestructure4restructShorthandjs221_TRBL(name) {
    this.name = name;
    this.info = null;
    this.iehack = undefined;
    this.sides = {
        'top': null,
        'right': null,
        'bottom': null,
        'left': null
    };
}

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.getValueSequence = function (value, count) {
    var values = [];
    var iehack = false;
    var hasBadValues = value.sequence.some(function (child) {
        var special = false;

        switch (child.type) {
            case 'Identifier':
                switch (child.name) {
                    case '\\9':
                        iehack = true;
                        return;

                    case 'inherit':
                    case 'initial':
                    case 'unset':
                    case 'revert':
                        special = child.name;
                        break;
                }
                break;

            case 'Dimension':
                switch (child.unit) {
                    // is not supported until IE11
                    case 'rem':

                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case 'vw':
                    case 'vh':
                    case 'vmin':
                    case 'vmax':
                    case 'vm':
                        // IE9 supporting "vm" instead of "vmin".
                        special = child.unit;
                        break;
                }
                break;

            case 'Hash': // color
            case 'Number':
            case 'Percentage':
                break;

            case 'Function':
                special = child.name;
                break;

            case 'Space':
                return false; // ignore space

            default:
                return true; // bad value
        }

        values.push({
            node: child,
            special: special,
            important: value.important
        });
    });

    if (hasBadValues || values.length > count) {
        return false;
    }

    if (typeof this.iehack === 'boolean' && this.iehack !== iehack) {
        return false;
    }

    this.iehack = iehack; // move outside

    return values;
};

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.canOverride = function (side, value) {
    var currentValue = this.sides[side];

    return !currentValue || value.important && !currentValue.important;
};

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.add = function (name, value, info) {
    function attemptToAdd() {
        var sides = this.sides;
        var side = _cssolibcompressorrestructure4restructShorthandjs221_SIDE[name];

        if (side) {
            if (side in sides === false) {
                return false;
            }

            var values = this.getValueSequence(value, 1);

            if (!values || !values.length) {
                return false;
            }

            // can mix only if specials are equal
            for (var key in sides) {
                if (sides[key] !== null && sides[key].special !== values[0].special) {
                    return false;
                }
            }

            if (!this.canOverride(side, values[0])) {
                return true;
            }

            sides[side] = values[0];
            return true;
        } else if (name === this.name) {
            var values = this.getValueSequence(value, 4);

            if (!values || !values.length) {
                return false;
            }

            switch (values.length) {
                case 1:
                    values[_cssolibcompressorrestructure4restructShorthandjs221_RIGHT] = values[_cssolibcompressorrestructure4restructShorthandjs221_TOP];
                    values[_cssolibcompressorrestructure4restructShorthandjs221_BOTTOM] = values[_cssolibcompressorrestructure4restructShorthandjs221_TOP];
                    values[_cssolibcompressorrestructure4restructShorthandjs221_LEFT] = values[_cssolibcompressorrestructure4restructShorthandjs221_TOP];
                    break;

                case 2:
                    values[_cssolibcompressorrestructure4restructShorthandjs221_BOTTOM] = values[_cssolibcompressorrestructure4restructShorthandjs221_TOP];
                    values[_cssolibcompressorrestructure4restructShorthandjs221_LEFT] = values[_cssolibcompressorrestructure4restructShorthandjs221_RIGHT];
                    break;

                case 3:
                    values[_cssolibcompressorrestructure4restructShorthandjs221_LEFT] = values[_cssolibcompressorrestructure4restructShorthandjs221_RIGHT];
                    break;
            }

            // can mix only if specials are equal
            for (var i = 0; i < 4; i++) {
                for (var key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[i].special) {
                        return false;
                    }
                }
            }

            for (var i = 0; i < 4; i++) {
                if (this.canOverride(_cssolibcompressorrestructure4restructShorthandjs221_SIDES[i], values[i])) {
                    sides[_cssolibcompressorrestructure4restructShorthandjs221_SIDES[i]] = values[i];
                }
            }

            return true;
        }
    }

    if (!attemptToAdd.call(this)) {
        return false;
    }

    if (this.info) {
        this.info = {
            primary: this.info,
            merged: info
        };
    } else {
        this.info = info;
    }

    return true;
};

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.isOkToMinimize = function () {
    var top = this.sides.top;
    var right = this.sides.right;
    var bottom = this.sides.bottom;
    var left = this.sides.left;

    if (top && right && bottom && left) {
        var important = top.important + right.important + bottom.important + left.important;

        return important === 0 || important === 4;
    }

    return false;
};

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.getValue = function () {
    var result = [];
    var sides = this.sides;
    var values = [sides.top, sides.right, sides.bottom, sides.left];
    var stringValues = [_cssolibcompressorrestructure4restructShorthandjs221_translate(sides.top.node), _cssolibcompressorrestructure4restructShorthandjs221_translate(sides.right.node), _cssolibcompressorrestructure4restructShorthandjs221_translate(sides.bottom.node), _cssolibcompressorrestructure4restructShorthandjs221_translate(sides.left.node)];

    if (stringValues[_cssolibcompressorrestructure4restructShorthandjs221_LEFT] === stringValues[_cssolibcompressorrestructure4restructShorthandjs221_RIGHT]) {
        values.pop();
        if (stringValues[_cssolibcompressorrestructure4restructShorthandjs221_BOTTOM] === stringValues[_cssolibcompressorrestructure4restructShorthandjs221_TOP]) {
            values.pop();
            if (stringValues[_cssolibcompressorrestructure4restructShorthandjs221_RIGHT] === stringValues[_cssolibcompressorrestructure4restructShorthandjs221_TOP]) {
                values.pop();
            }
        }
    }

    for (var i = 0; i < values.length; i++) {
        if (i) {
            result.push({ type: 'Space' });
        }

        result.push(values[i].node);
    }

    if (this.iehack) {
        result.push({ type: 'Space' }, {
            type: 'Identifier',
            info: {},
            name: '\\9'
        });
    }

    return {
        type: 'Value',
        info: {},
        important: sides.top.important,
        sequence: new _cssolibcompressorrestructure4restructShorthandjs221_List(result)
    };
};

_cssolibcompressorrestructure4restructShorthandjs221_TRBL.prototype.getProperty = function () {
    return {
        type: 'Property',
        info: {},
        name: this.name
    };
};

function _cssolibcompressorrestructure4restructShorthandjs221_processRuleset(ruleset, shorts, shortDeclarations, lastShortSelector) {
    var declarations = ruleset.block.declarations;
    var selector = ruleset.selector.selectors.first().id;

    ruleset.block.declarations.eachRight(function (declaration, item) {
        var property = declaration.property.name;

        if (!_cssolibcompressorrestructure4restructShorthandjs221_MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        var key = _cssolibcompressorrestructure4restructShorthandjs221_MAIN_PROPERTY[property];
        var shorthand;
        var operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = _cssolibcompressorrestructure4restructShorthandjs221_REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration.value, declaration.info)) {
            operation = _cssolibcompressorrestructure4restructShorthandjs221_REPLACE;
            shorthand = new _cssolibcompressorrestructure4restructShorthandjs221_TRBL(key);

            // if can't parse value ignore it and break shorthand sequence
            if (!shorthand.add(property, declaration.value, declaration.info)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation: operation,
            block: declarations,
            item: item,
            shorthand: shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
};

function _cssolibcompressorrestructure4restructShorthandjs221_processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function (item) {
        var shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === _cssolibcompressorrestructure4restructShorthandjs221_REPLACE) {
            item.item.data = markDeclaration({
                type: 'Declaration',
                info: shorthand.info,
                property: shorthand.getProperty(),
                value: shorthand.getValue(),
                id: 0,
                length: 0,
                fingerprint: null
            });
        } else {
            item.block.remove(item.item);
        }
    });
};

$m['csso/lib/compressor/restructure/4-restructShorthand.js#2.2.1'].exports = function restructBlock(ast, indexer) {
    var stylesheetMap = {};
    var shortDeclarations = [];

    _cssolibcompressorrestructure4restructShorthandjs221_walkRulesRight(ast, function (node) {
        if (node.type !== 'Ruleset') {
            return;
        }

        var stylesheet = this.stylesheet;
        var rulesetId = (node.pseudoSignature || '') + '|' + node.selector.selectors.first().id;
        var rulesetMap;
        var shorts;

        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            rulesetMap = {
                lastShortSelector: null
            };
            stylesheetMap[stylesheet.id] = rulesetMap;
        } else {
            rulesetMap = stylesheetMap[stylesheet.id];
        }

        if (rulesetMap.hasOwnProperty(rulesetId)) {
            shorts = rulesetMap[rulesetId];
        } else {
            shorts = {};
            rulesetMap[rulesetId] = shorts;
        }

        rulesetMap.lastShortSelector = _cssolibcompressorrestructure4restructShorthandjs221_processRuleset.call(this, node, shorts, shortDeclarations, rulesetMap.lastShortSelector);
    });

    _cssolibcompressorrestructure4restructShorthandjs221_processShorthands(shortDeclarations, indexer.declaration);
};
/*≠≠ node_modules/csso/lib/compress...ructure/4-restructShorthand.js ≠≠*/

/*== node_modules/csso/lib/compress...estructure/3-disjoinRuleset.js ==*/
$m['csso/lib/compressor/restructure/3-disjoinRuleset.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure3disjoinRulesetjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibcompressorrestructure3disjoinRulesetjs221_walkRulesRight = $m['csso/lib/utils/walk.js#2.2.1'].exports.rulesRight;

function _cssolibcompressorrestructure3disjoinRulesetjs221_processRuleset(node, item, list) {
    var selectors = node.selector.selectors;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        var newSelectors = new _cssolibcompressorrestructure3disjoinRulesetjs221_List();
        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Ruleset',
            info: node.info,
            pseudoSignature: node.pseudoSignature,
            selector: {
                type: 'Selector',
                info: node.selector.info,
                selectors: newSelectors
            },
            block: {
                type: 'Block',
                info: node.block.info,
                declarations: node.block.declarations.copy()
            }
        }), item);
    }
};

$m['csso/lib/compressor/restructure/3-disjoinRuleset.js#2.2.1'].exports = function disjoinRuleset(ast) {
    _cssolibcompressorrestructure3disjoinRulesetjs221_walkRulesRight(ast, function (node, item, list) {
        if (node.type === 'Ruleset') {
            _cssolibcompressorrestructure3disjoinRulesetjs221_processRuleset(node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compress...estructure/3-disjoinRuleset.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/2-mergeAtrule.js ==*/
$m['csso/lib/compressor/restructure/2-mergeAtrule.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure2mergeAtrulejs221_walkRulesRight = $m['csso/lib/utils/walk.js#2.2.1'].exports.rulesRight;

function _cssolibcompressorrestructure2mergeAtrulejs221_isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function _cssolibcompressorrestructure2mergeAtrulejs221_processAtrule(node, item, list) {
    if (!_cssolibcompressorrestructure2mergeAtrulejs221_isMediaRule(node)) {
        return;
    }

    var prev = item.prev && item.prev.data;

    if (!prev || !_cssolibcompressorrestructure2mergeAtrulejs221_isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.expression.id === prev.expression.id) {
        prev.block.rules.appendList(node.block.rules);
        prev.info = {
            primary: prev.info,
            merged: node.info
        };
        list.remove(item);
    }
};

$m['csso/lib/compressor/restructure/2-mergeAtrule.js#2.2.1'].exports = function rejoinAtrule(ast) {
    _cssolibcompressorrestructure2mergeAtrulejs221_walkRulesRight(ast, function (node, item, list) {
        if (node.type === 'Atrule') {
            _cssolibcompressorrestructure2mergeAtrulejs221_processAtrule(node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compressor/restructure/2-mergeAtrule.js ≠≠*/

/*== node_modules/csso/lib/compress...cture/1-initialMergeRuleset.js ==*/
$m['csso/lib/compressor/restructure/1-initialMergeRuleset.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructure1initialMergeRulesetjs221_utils = $m['csso/lib/compressor/restructure/utils.js#2.2.1'].exports;
var _cssolibcompressorrestructure1initialMergeRulesetjs221_walkRules = $m['csso/lib/utils/walk.js#2.2.1'].exports.rules;

function _cssolibcompressorrestructure1initialMergeRulesetjs221_processRuleset(node, item, list) {
    var selectors = node.selector.selectors;
    var declarations = node.block.declarations;

    list.prevUntil(item.prev, function (prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Ruleset') {
            return _cssolibcompressorrestructure1initialMergeRulesetjs221_utils.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.selector.selectors;
        var prevDeclarations = prev.block.declarations;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (_cssolibcompressorrestructure1initialMergeRulesetjs221_utils.isEqualLists(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (_cssolibcompressorrestructure1initialMergeRulesetjs221_utils.isEqualDeclarations(declarations, prevDeclarations)) {
                _cssolibcompressorrestructure1initialMergeRulesetjs221_utils.addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return _cssolibcompressorrestructure1initialMergeRulesetjs221_utils.hasSimilarSelectors(selectors, prevSelectors);
    });
};

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
$m['csso/lib/compressor/restructure/1-initialMergeRuleset.js#2.2.1'].exports = function initialMergeRuleset(ast) {
    _cssolibcompressorrestructure1initialMergeRulesetjs221_walkRules(ast, function (node, item, list) {
        if (node.type === 'Ruleset') {
            _cssolibcompressorrestructure1initialMergeRulesetjs221_processRuleset(node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compress...cture/1-initialMergeRuleset.js ≠≠*/

/*== node_modules/csso/lib/compress...ructure/prepare/specificity.js ==*/
$m['csso/lib/compressor/restructure/prepare/specificity.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/restructure/prepare/specificity.js#2.2.1'].exports = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.sequence.each(function walk(data) {
        switch (data.type) {
            case 'SimpleSelector':
            case 'Negation':
                data.sequence.each(walk);
                break;

            case 'Id':
                A++;
                break;

            case 'Class':
            case 'Attribute':
            case 'FunctionalPseudo':
                B++;
                break;

            case 'Identifier':
                if (data.name !== '*') {
                    C++;
                }
                break;

            case 'PseudoElement':
                C++;
                break;

            case 'PseudoClass':
                var name = data.name.toLowerCase();
                if (name === 'before' || name === 'after' || name === 'first-line' || name === 'first-letter') {
                    C++;
                } else {
                    B++;
                }
                break;
        }
    });

    return [A, B, C];
};
/*≠≠ node_modules/csso/lib/compress...ructure/prepare/specificity.js ≠≠*/

/*== node_modules/csso/lib/compress...ure/prepare/processSelector.js ==*/
$m['csso/lib/compressor/restructure/prepare/processSelector.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructureprepareprocessSelectorjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;
var _cssolibcompressorrestructureprepareprocessSelectorjs221_specificity = $m['csso/lib/compressor/restructure/prepare/specificity.js#2.2.1'].exports;

var _cssolibcompressorrestructureprepareprocessSelectorjs221_nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var _cssolibcompressorrestructureprepareprocessSelectorjs221_nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

$m['csso/lib/compressor/restructure/prepare/processSelector.js#2.2.1'].exports = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.selector.selectors.each(function (simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.sequence.some(function (node) {
            switch (node.type) {
                case 'Class':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + _cssolibcompressorrestructureprepareprocessSelectorjs221_translate(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClass':
                    if (!_cssolibcompressorrestructureprepareprocessSelectorjs221_nonFreezePseudoClasses.hasOwnProperty(node.name)) {
                        pseudos[node.name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElement':
                    if (!_cssolibcompressorrestructureprepareprocessSelectorjs221_nonFreezePseudoElements.hasOwnProperty(node.name)) {
                        pseudos[node.name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'FunctionalPseudo':
                    pseudos[node.name] = true;
                    hasPseudo = true;
                    break;

                case 'Negation':
                    pseudos.not = true;
                    hasPseudo = true;
                    break;

                case 'Identifier':
                    tagName = node.name;
                    break;

                case 'Attribute':
                    if (node.flags) {
                        pseudos['[' + node.flags + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.id = _cssolibcompressorrestructureprepareprocessSelectorjs221_translate(simpleSelector);
        simpleSelector.compareMarker = _cssolibcompressorrestructureprepareprocessSelectorjs221_specificity(simpleSelector).toString();

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    if (hasPseudo) {
        node.pseudoSignature = Object.keys(pseudos).sort().join(',');
    }
};
/*≠≠ node_modules/csso/lib/compress...ure/prepare/processSelector.js ≠≠*/

/*== node_modules/csso/lib/compress...re/createDeclarationIndexer.js ==*/
$m['csso/lib/compressor/restructure/prepare/createDeclarationIndexer.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;

function _cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_Index() {
    this.seed = 0;
    this.map = Object.create(null);
}

_cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_Index.prototype.resolve = function (str) {
    var index = this.map[str];

    if (!index) {
        index = ++this.seed;
        this.map[str] = index;
    }

    return index;
};

$m['csso/lib/compressor/restructure/prepare/createDeclarationIndexer.js#2.2.1'].exports = function createDeclarationIndexer() {
    var names = new _cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_Index();
    var values = new _cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_Index();

    return function markDeclaration(node) {
        var property = node.property.name;
        var value = _cssolibcompressorrestructurepreparecreateDeclarationIndexerjs221_translate(node.value);

        node.id = names.resolve(property) + (values.resolve(value) << 12);
        node.length = property.length + 1 + value.length;

        return node;
    };
};
/*≠≠ node_modules/csso/lib/compress...re/createDeclarationIndexer.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/prepare/index.js ==*/
$m['csso/lib/compressor/restructure/prepare/index.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructureprepareindexjs221_resolveKeyword = $m['csso/lib/utils/names.js#2.2.1'].exports.keyword;
var _cssolibcompressorrestructureprepareindexjs221_walkRules = $m['csso/lib/utils/walk.js#2.2.1'].exports.rules;
var _cssolibcompressorrestructureprepareindexjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;
var _cssolibcompressorrestructureprepareindexjs221_createDeclarationIndexer = $m['csso/lib/compressor/restructure/prepare/createDeclarationIndexer.js#2.2.1'].exports;
var _cssolibcompressorrestructureprepareindexjs221_processSelector = $m['csso/lib/compressor/restructure/prepare/processSelector.js#2.2.1'].exports;

function _cssolibcompressorrestructureprepareindexjs221_walk(node, markDeclaration, usageData) {
    switch (node.type) {
        case 'Ruleset':
            node.block.declarations.each(markDeclaration);
            _cssolibcompressorrestructureprepareindexjs221_processSelector(node, usageData);
            break;

        case 'Atrule':
            if (node.expression) {
                node.expression.id = _cssolibcompressorrestructureprepareindexjs221_translate(node.expression);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (_cssolibcompressorrestructureprepareindexjs221_resolveKeyword(node.name).name === 'keyframes') {
                node.block.avoidRulesMerge = true; /* probably we don't need to prevent those merges for @keyframes
                                                      TODO: need to be checked */
                node.block.rules.each(function (ruleset) {
                    ruleset.selector.selectors.each(function (simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
            break;
    }
};

$m['csso/lib/compressor/restructure/prepare/index.js#2.2.1'].exports = function prepare(ast, usageData) {
    var markDeclaration = _cssolibcompressorrestructureprepareindexjs221_createDeclarationIndexer();

    _cssolibcompressorrestructureprepareindexjs221_walkRules(ast, function (node) {
        _cssolibcompressorrestructureprepareindexjs221_walk(node, markDeclaration, usageData);
    });

    return {
        declaration: markDeclaration
    };
};
/*≠≠ node_modules/csso/lib/compressor/restructure/prepare/index.js ≠≠*/

/*== node_modules/csso/lib/compressor/restructure/index.js ==*/
$m['csso/lib/compressor/restructure/index.js#2.2.1'] = { exports: {} };
var _cssolibcompressorrestructureindexjs221_prepare = $m['csso/lib/compressor/restructure/prepare/index.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_initialMergeRuleset = $m['csso/lib/compressor/restructure/1-initialMergeRuleset.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_mergeAtrule = $m['csso/lib/compressor/restructure/2-mergeAtrule.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_disjoinRuleset = $m['csso/lib/compressor/restructure/3-disjoinRuleset.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_restructShorthand = $m['csso/lib/compressor/restructure/4-restructShorthand.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_restructBlock = $m['csso/lib/compressor/restructure/6-restructBlock.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_mergeRuleset = $m['csso/lib/compressor/restructure/7-mergeRuleset.js#2.2.1'].exports;
var _cssolibcompressorrestructureindexjs221_restructRuleset = $m['csso/lib/compressor/restructure/8-restructRuleset.js#2.2.1'].exports;

$m['csso/lib/compressor/restructure/index.js#2.2.1'].exports = function (ast, usageData, debug) {
    // prepare ast for restructing
    var indexer = _cssolibcompressorrestructureindexjs221_prepare(ast, usageData);
    debug('prepare', ast);

    _cssolibcompressorrestructureindexjs221_initialMergeRuleset(ast);
    debug('initialMergeRuleset', ast);

    _cssolibcompressorrestructureindexjs221_mergeAtrule(ast);
    debug('mergeAtrule', ast);

    _cssolibcompressorrestructureindexjs221_disjoinRuleset(ast);
    debug('disjoinRuleset', ast);

    _cssolibcompressorrestructureindexjs221_restructShorthand(ast, indexer);
    debug('restructShorthand', ast);

    _cssolibcompressorrestructureindexjs221_restructBlock(ast);
    debug('restructBlock', ast);

    _cssolibcompressorrestructureindexjs221_mergeRuleset(ast);
    debug('mergeRuleset', ast);

    _cssolibcompressorrestructureindexjs221_restructRuleset(ast);
    debug('restructRuleset', ast);
};
/*≠≠ node_modules/csso/lib/compressor/restructure/index.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Number.js ==*/
$m['csso/lib/compressor/compress/Number.js#2.2.1'] = { exports: {} };
function _cssolibcompressorcompressNumberjs221_packNumber(value) {
    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100'
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    value = String(value).replace(/^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/, '$1$2$3');

    if (value.length === 0 || value === '-') {
        value = '0';
    }

    return value;
};

$m['csso/lib/compressor/compress/Number.js#2.2.1'].exports = function (node) {
    node.value = _cssolibcompressorcompressNumberjs221_packNumber(node.value);
};
$m['csso/lib/compressor/compress/Number.js#2.2.1'].exports.pack = _cssolibcompressorcompressNumberjs221_packNumber;
/*≠≠ node_modules/csso/lib/compressor/compress/Number.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/color.js ==*/
$m['csso/lib/compressor/compress/color.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompresscolorjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibcompressorcompresscolorjs221_packNumber = $m['csso/lib/compressor/compress/Number.js#2.2.1'].exports.pack;

// http://www.w3.org/TR/css3-color/#svg-color
var _cssolibcompressorcompresscolorjs221_NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

var _cssolibcompressorcompresscolorjs221_HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function _cssolibcompressorcompresscolorjs221_hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function _cssolibcompressorcompresscolorjs221_hslToRgb(h, s, l, a) {
    var r;
    var g;
    var b;

    if (s == 0) {
        r = g = b = l; // achromatic
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = _cssolibcompressorcompresscolorjs221_hueToRgb(p, q, h + 1 / 3);
        g = _cssolibcompressorcompresscolorjs221_hueToRgb(p, q, h);
        b = _cssolibcompressorcompresscolorjs221_hueToRgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a];
}

function _cssolibcompressorcompresscolorjs221_toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? '0' + value : value;
}

function _cssolibcompressorcompresscolorjs221_parseFunctionArgs(functionArgs, count, rgb) {
    var argument = functionArgs.head;
    var args = [];

    while (argument !== null) {
        var argumentPart = argument.data.sequence.head;
        var wasValue = false;

        while (argumentPart !== null) {
            var value = argumentPart.data;
            var type = value.type;

            switch (type) {
                case 'Number':
                case 'Percentage':
                    if (wasValue) {
                        return;
                    }

                    wasValue = true;
                    args.push({
                        type: type,
                        value: Number(value.value)
                    });
                    break;

                case 'Operator':
                    if (wasValue || value.value !== '+') {
                        return;
                    }
                    break;

                default:
                    // something we couldn't understand
                    return;
            }

            argumentPart = argumentPart.next;
        }

        argument = argument.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' || args[1].type !== 'Percentage' || args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function (arg) {
        var value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (value % 360 + 360) % 360 / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function _cssolibcompressorcompresscolorjs221_compressFunction(node, item, list) {
    var functionName = node.name;
    var args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = _cssolibcompressorcompresscolorjs221_parseFunctionArgs(node.arguments, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = _cssolibcompressorcompresscolorjs221_hslToRgb.apply(null, args);
            node.name = 'rgba';
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.arguments.each(function (argument) {
                var item = argument.sequence.head;

                if (item.data.type === 'Operator') {
                    item = item.next;
                }

                argument.sequence = new _cssolibcompressorcompresscolorjs221_List([{
                    type: 'Number',
                    info: item.data.info,
                    value: _cssolibcompressorcompresscolorjs221_packNumber(args.shift())
                }]);
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || _cssolibcompressorcompresscolorjs221_parseFunctionArgs(node.arguments, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = _cssolibcompressorcompresscolorjs221_hslToRgb.apply(null, args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || _cssolibcompressorcompresscolorjs221_parseFunctionArgs(node.arguments, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        // check if color is not at the end and not followed by space
        var next = item.next;
        if (next && next.data.type !== 'Space') {
            list.insert(list.createItem({
                type: 'Space'
            }), next);
        }

        item.data = {
            type: 'Hash',
            info: node.info,
            value: _cssolibcompressorcompresscolorjs221_toHex(args[0]) + _cssolibcompressorcompresscolorjs221_toHex(args[1]) + _cssolibcompressorcompresscolorjs221_toHex(args[2])
        };

        _cssolibcompressorcompresscolorjs221_compressHex(item.data, item);
    }
}

function _cssolibcompressorcompresscolorjs221_compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    var color = node.name.toLowerCase();

    if (_cssolibcompressorcompresscolorjs221_NAME_TO_HEX.hasOwnProperty(color)) {
        var hex = _cssolibcompressorcompresscolorjs221_NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'Hash',
                info: node.info,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function _cssolibcompressorcompresscolorjs221_compressHex(node, item) {
    var color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (_cssolibcompressorcompresscolorjs221_HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            info: node.info,
            name: _cssolibcompressorcompresscolorjs221_HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

$m['csso/lib/compressor/compress/color.js#2.2.1'].exports = {
    compressFunction: _cssolibcompressorcompresscolorjs221_compressFunction,
    compressIdent: _cssolibcompressorcompresscolorjs221_compressIdent,
    compressHex: _cssolibcompressorcompresscolorjs221_compressHex
};
/*≠≠ node_modules/csso/lib/compressor/compress/color.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Url.js ==*/
$m['csso/lib/compressor/compress/Url.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompressUrljs221_UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
var _cssolibcompressorcompressUrljs221_ESCAPE = '(' + _cssolibcompressorcompressUrljs221_UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
var _cssolibcompressorcompressUrljs221_NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
var _cssolibcompressorcompressUrljs221_SAFE_URL = new RegExp('^(' + _cssolibcompressorcompressUrljs221_ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + _cssolibcompressorcompressUrljs221_NONPRINTABLE + '])*$', 'i');

$m['csso/lib/compressor/compress/Url.js#2.2.1'].exports = function (node) {
    var value = node.value;

    if (value.type !== 'String') {
        return;
    }

    var quote = value.value[0];
    var url = value.value.substr(1, value.value.length - 2);

    // convert `\\` to `/`
    url = url.replace(/\\\\/g, '/');

    // remove quotes when safe
    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
    if (_cssolibcompressorcompressUrljs221_SAFE_URL.test(url)) {
        node.value = {
            type: 'Raw',
            info: node.value.info,
            value: url
        };
    } else {
        // use double quotes if string has no double quotes
        // otherwise use original quotes
        // TODO: make better quote type selection
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/Url.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/String.js ==*/
$m['csso/lib/compressor/compress/String.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/compress/String.js#2.2.1'].exports = function (node) {
    var value = node.value;

    // remove escaped \n, i.e.
    // .a { content: "foo\
    // bar"}
    // ->
    // .a { content: "foobar" }
    value = value.replace(/\\\n/g, '');

    node.value = value;
};
/*≠≠ node_modules/csso/lib/compressor/compress/String.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Dimension.js ==*/
$m['csso/lib/compressor/compress/Dimension.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompressDimensionjs221_packNumber = $m['csso/lib/compressor/compress/Number.js#2.2.1'].exports.pack;
var _cssolibcompressorcompressDimensionjs221_LENGTH_UNIT = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

$m['csso/lib/compressor/compress/Dimension.js#2.2.1'].exports = function compressDimension(node, item) {
    var value = _cssolibcompressorcompressDimensionjs221_packNumber(node.value);

    node.value = value;

    if (value === '0' && this.declaration) {
        var unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!_cssolibcompressorcompressDimensionjs221_LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
        }

        // issue #200: don't remove units in flex property as it could change value meaning
        if (this.declaration.property.name === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this['function'] && this['function'].name === 'calc') {
            return;
        }

        item.data = {
            type: 'Number',
            info: node.info,
            value: value
        };
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/Dimension.js ≠≠*/

/*== node_modules/csso/lib/compress...ompress/property/background.js ==*/
$m['csso/lib/compressor/compress/property/background.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompresspropertybackgroundjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;

$m['csso/lib/compressor/compress/property/background.js#2.2.1'].exports = function compressBackground(node) {
    function lastType() {
        if (buffer.length) {
            return buffer[buffer.length - 1].type;
        }
    }

    function flush() {
        if (lastType() === 'Space') {
            buffer.pop();
        }

        if (!buffer.length) {
            buffer.unshift({
                type: 'Number',
                value: '0'
            }, {
                type: 'Space'
            }, {
                type: 'Number',
                value: '0'
            });
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    var newValue = [];
    var buffer = [];

    node.sequence.each(function (node) {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' || node.name === 'none' || node.name === 'repeat' || node.name === 'scroll') {
                return;
            }
        }

        // don't add redundant spaces
        if (node.type === 'Space' && (!buffer.length || lastType() === 'Space')) {
            return;
        }

        buffer.push(node);
    });

    flush();
    node.sequence = new _cssolibcompressorcompresspropertybackgroundjs221_List(newValue);
};
/*≠≠ node_modules/csso/lib/compress...ompress/property/background.js ≠≠*/

/*== node_modules/csso/lib/compress...mpress/property/font-weight.js ==*/
$m['csso/lib/compressor/compress/property/font-weight.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/compress/property/font-weight.js#2.2.1'].exports = function compressFontWeight(node) {
    var value = node.sequence.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.sequence.head.data = {
                    type: 'Number',
                    info: value.info,
                    value: '400'
                };
                break;
            case 'bold':
                node.sequence.head.data = {
                    type: 'Number',
                    info: value.info,
                    value: '700'
                };
                break;
        }
    }
};
/*≠≠ node_modules/csso/lib/compress...mpress/property/font-weight.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/property/font.js ==*/
$m['csso/lib/compressor/compress/property/font.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/compress/property/font.js#2.2.1'].exports = function compressFont(node) {
    var list = node.sequence;

    list.eachRight(function (node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    info: node.info,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                var prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            } else if (node.name === 'medium') {
                var next = item.next;

                if (!next || next.data.type !== 'Operator') {
                    this.remove(item);
                }
            }
        }
    });

    // remove redundant spaces
    list.each(function (node, item) {
        if (node.type === 'Space') {
            if (!item.prev || !item.next || item.next.data.type === 'Space') {
                this.remove(item);
            }
        }
    });

    if (list.isEmpty()) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/property/font.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Value.js ==*/
$m['csso/lib/compressor/compress/Value.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompressValuejs221_resolveName = $m['csso/lib/utils/names.js#2.2.1'].exports.property;
var _cssolibcompressorcompressValuejs221_handlers = {
    'font': $m['csso/lib/compressor/compress/property/font.js#2.2.1'].exports,
    'font-weight': $m['csso/lib/compressor/compress/property/font-weight.js#2.2.1'].exports,
    'background': $m['csso/lib/compressor/compress/property/background.js#2.2.1'].exports
};

$m['csso/lib/compressor/compress/Value.js#2.2.1'].exports = function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    var property = _cssolibcompressorcompressValuejs221_resolveName(this.declaration.property.name);

    if (_cssolibcompressorcompressValuejs221_handlers.hasOwnProperty(property.name)) {
        _cssolibcompressorcompressValuejs221_handlers[property.name](node);
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/Value.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Attribute.js ==*/
$m['csso/lib/compressor/compress/Attribute.js#2.2.1'] = { exports: {} };
// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
var _cssolibcompressorcompressAttributejs221_escapesRx = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?|\\./g;
var _cssolibcompressorcompressAttributejs221_blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function _cssolibcompressorcompressAttributejs221_canUnquote(value) {
    if (value === '' || value === '-') {
        return;
    }

    // Escapes are valid, so replace them with a valid non-empty string
    value = value.replace(_cssolibcompressorcompressAttributejs221_escapesRx, 'a');

    return !_cssolibcompressorcompressAttributejs221_blockUnquoteRx.test(value);
}

$m['csso/lib/compressor/compress/Attribute.js#2.2.1'].exports = function (node) {
    var attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
    if (_cssolibcompressorcompressAttributejs221_canUnquote(unquotedValue)) {
        node.value = {
            type: 'Identifier',
            info: attrValue.info,
            name: unquotedValue
        };
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/Attribute.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/atrule/keyframes.js ==*/
$m['csso/lib/compressor/compress/atrule/keyframes.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/compress/atrule/keyframes.js#2.2.1'].exports = function (node) {
    node.block.rules.each(function (ruleset) {
        ruleset.selector.selectors.each(function (simpleselector) {
            simpleselector.sequence.each(function (data, item) {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'Identifier',
                        info: data.info,
                        name: 'to'
                    };
                } else if (data.type === 'Identifier' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        info: data.info,
                        value: '0'
                    };
                }
            });
        });
    });
};
/*≠≠ node_modules/csso/lib/compressor/compress/atrule/keyframes.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/Atrule.js ==*/
$m['csso/lib/compressor/compress/Atrule.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompressAtrulejs221_resolveKeyword = $m['csso/lib/utils/names.js#2.2.1'].exports.keyword;
var _cssolibcompressorcompressAtrulejs221_compressKeyframes = $m['csso/lib/compressor/compress/atrule/keyframes.js#2.2.1'].exports;

$m['csso/lib/compressor/compress/Atrule.js#2.2.1'].exports = function (node) {
    // compress @keyframe selectors
    if (_cssolibcompressorcompressAtrulejs221_resolveKeyword(node.name).name === 'keyframes') {
        _cssolibcompressorcompressAtrulejs221_compressKeyframes(node);
    }
};
/*≠≠ node_modules/csso/lib/compressor/compress/Atrule.js ≠≠*/

/*== node_modules/csso/lib/compressor/compress/index.js ==*/
$m['csso/lib/compressor/compress/index.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcompressindexjs221_walk = $m['csso/lib/utils/walk.js#2.2.1'].exports.all;
var _cssolibcompressorcompressindexjs221_handlers = {
    Atrule: $m['csso/lib/compressor/compress/Atrule.js#2.2.1'].exports,
    Attribute: $m['csso/lib/compressor/compress/Attribute.js#2.2.1'].exports,
    Value: $m['csso/lib/compressor/compress/Value.js#2.2.1'].exports,
    Dimension: $m['csso/lib/compressor/compress/Dimension.js#2.2.1'].exports,
    Percentage: $m['csso/lib/compressor/compress/Number.js#2.2.1'].exports,
    Number: $m['csso/lib/compressor/compress/Number.js#2.2.1'].exports,
    String: $m['csso/lib/compressor/compress/String.js#2.2.1'].exports,
    Url: $m['csso/lib/compressor/compress/Url.js#2.2.1'].exports,
    Hash: $m['csso/lib/compressor/compress/color.js#2.2.1'].exports.compressHex,
    Identifier: $m['csso/lib/compressor/compress/color.js#2.2.1'].exports.compressIdent,
    Function: $m['csso/lib/compressor/compress/color.js#2.2.1'].exports.compressFunction
};

$m['csso/lib/compressor/compress/index.js#2.2.1'].exports = function (ast) {
    _cssolibcompressorcompressindexjs221_walk(ast, function (node, item, list) {
        if (_cssolibcompressorcompressindexjs221_handlers.hasOwnProperty(node.type)) {
            _cssolibcompressorcompressindexjs221_handlers[node.type].call(this, node, item, list);
        }
    });
};
/*≠≠ node_modules/csso/lib/compressor/compress/index.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Comment.js ==*/
$m['csso/lib/compressor/clean/Comment.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/clean/Comment.js#2.2.1'].exports = function cleanComment(data, item, list) {
    list.remove(item);
};
/*≠≠ node_modules/csso/lib/compressor/clean/Comment.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Identifier.js ==*/
$m['csso/lib/compressor/clean/Identifier.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/clean/Identifier.js#2.2.1'].exports = function cleanIdentifier(node, item, list) {
    // remove useless universal selector
    if (this.selector !== null && node.name === '*') {
        // remove when universal selector isn't last
        if (item.next && item.next.data.type !== 'Combinator') {
            list.remove(item);
        }
    }
};
/*≠≠ node_modules/csso/lib/compressor/clean/Identifier.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Declaration.js ==*/
$m['csso/lib/compressor/clean/Declaration.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/clean/Declaration.js#2.2.1'].exports = function cleanDeclartion(node, item, list) {
    if (node.value.sequence.isEmpty()) {
        list.remove(item);
    }
};
/*≠≠ node_modules/csso/lib/compressor/clean/Declaration.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Ruleset.js ==*/
$m['csso/lib/compressor/clean/Ruleset.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcleanRulesetjs221_hasOwnProperty = Object.prototype.hasOwnProperty;

function _cssolibcompressorcleanRulesetjs221_cleanUnused(node, usageData) {
    return node.selector.selectors.each(function (selector, item, list) {
        var hasUnused = selector.sequence.some(function (node) {
            switch (node.type) {
                case 'Class':
                    return usageData.classes && !_cssolibcompressorcleanRulesetjs221_hasOwnProperty.call(usageData.classes, node.name);

                case 'Id':
                    return usageData.ids && !_cssolibcompressorcleanRulesetjs221_hasOwnProperty.call(usageData.ids, node.name);

                case 'Identifier':
                    // ignore universal selector
                    if (node.name !== '*') {
                        // TODO: remove toLowerCase when type selectors will be normalized
                        return usageData.tags && !_cssolibcompressorcleanRulesetjs221_hasOwnProperty.call(usageData.tags, node.name.toLowerCase());
                    }

                    break;
            }
        });

        if (hasUnused) {
            list.remove(item);
        }
    });
}

$m['csso/lib/compressor/clean/Ruleset.js#2.2.1'].exports = function cleanRuleset(node, item, list, usageData) {
    if (usageData) {
        _cssolibcompressorcleanRulesetjs221_cleanUnused(node, usageData);
    }

    if (node.selector.selectors.isEmpty() || node.block.declarations.isEmpty()) {
        list.remove(item);
    }
};
/*≠≠ node_modules/csso/lib/compressor/clean/Ruleset.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Atrule.js ==*/
$m['csso/lib/compressor/clean/Atrule.js#2.2.1'] = { exports: {} };
$m['csso/lib/compressor/clean/Atrule.js#2.2.1'].exports = function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        this.root.firstAtrulesAllowed = false;

        if (node.block.type === 'Block' && node.block.declarations.isEmpty()) {
            list.remove(item);
            return;
        }

        if (node.block.type === 'StyleSheet' && node.block.rules.isEmpty()) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (node.expression.sequence.isEmpty()) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (!this.root.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function (rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
            }, this);

            break;
    }
};
/*≠≠ node_modules/csso/lib/compressor/clean/Atrule.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/Space.js ==*/
$m['csso/lib/compressor/clean/Space.js#2.2.1'] = { exports: {} };
function _cssolibcompressorcleanSpacejs221_canCleanWhitespace(node) {
    if (node.type !== 'Operator') {
        return false;
    }

    return node.value !== '+' && node.value !== '-';
}

$m['csso/lib/compressor/clean/Space.js#2.2.1'].exports = function cleanWhitespace(node, item, list) {
    var prev = item.prev && item.prev.data;
    var next = item.next && item.next.data;

    if (_cssolibcompressorcleanSpacejs221_canCleanWhitespace(prev) || _cssolibcompressorcleanSpacejs221_canCleanWhitespace(next)) {
        list.remove(item);
    }
};
/*≠≠ node_modules/csso/lib/compressor/clean/Space.js ≠≠*/

/*== node_modules/csso/lib/compressor/clean/index.js ==*/
$m['csso/lib/compressor/clean/index.js#2.2.1'] = { exports: {} };
var _cssolibcompressorcleanindexjs221_walk = $m['csso/lib/utils/walk.js#2.2.1'].exports.all;
var _cssolibcompressorcleanindexjs221_handlers = {
    Space: $m['csso/lib/compressor/clean/Space.js#2.2.1'].exports,
    Atrule: $m['csso/lib/compressor/clean/Atrule.js#2.2.1'].exports,
    Ruleset: $m['csso/lib/compressor/clean/Ruleset.js#2.2.1'].exports,
    Declaration: $m['csso/lib/compressor/clean/Declaration.js#2.2.1'].exports,
    Identifier: $m['csso/lib/compressor/clean/Identifier.js#2.2.1'].exports,
    Comment: $m['csso/lib/compressor/clean/Comment.js#2.2.1'].exports
};

$m['csso/lib/compressor/clean/index.js#2.2.1'].exports = function (ast, usageData) {
    _cssolibcompressorcleanindexjs221_walk(ast, function (node, item, list) {
        if (_cssolibcompressorcleanindexjs221_handlers.hasOwnProperty(node.type)) {
            _cssolibcompressorcleanindexjs221_handlers[node.type].call(this, node, item, list, usageData);
        }
    });
};
/*≠≠ node_modules/csso/lib/compressor/clean/index.js ≠≠*/

/*== node_modules/csso/lib/compressor/usage.js ==*/
$m['csso/lib/compressor/usage.js#2.2.1'] = { exports: {} };
var _cssolibcompressorusagejs221_hasOwnProperty = Object.prototype.hasOwnProperty;

function _cssolibcompressorusagejs221_buildMap(list, caseInsensitive) {
    var map = Object.create(null);

    if (!Array.isArray(list)) {
        return false;
    }

    for (var i = 0; i < list.length; i++) {
        var name = list[i];

        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function _cssolibcompressorusagejs221_buildIndex(data) {
    var scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (var j = 0; j < list.length; j++) {
                var name = list[j];

                if (_cssolibcompressorusagejs221_hasOwnProperty.call(scopes, name)) {
                    throw new Error('Class can\'t be used for several scopes: ' + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        tags: _cssolibcompressorusagejs221_buildMap(data.tags, true),
        ids: _cssolibcompressorusagejs221_buildMap(data.ids),
        classes: _cssolibcompressorusagejs221_buildMap(data.classes),
        scopes: scopes
    };
}

$m['csso/lib/compressor/usage.js#2.2.1'].exports = {
    buildIndex: _cssolibcompressorusagejs221_buildIndex
};
/*≠≠ node_modules/csso/lib/compressor/usage.js ≠≠*/

/*== node_modules/csso/lib/compressor/index.js ==*/
$m['csso/lib/compressor/index.js#2.2.1'] = { exports: {} };
var _cssolibcompressorindexjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_clone = $m['csso/lib/utils/clone.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_usageUtils = $m['csso/lib/compressor/usage.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_clean = $m['csso/lib/compressor/clean/index.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_compress = $m['csso/lib/compressor/compress/index.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_restructureBlock = $m['csso/lib/compressor/restructure/index.js#2.2.1'].exports;
var _cssolibcompressorindexjs221_walkRules = $m['csso/lib/utils/walk.js#2.2.1'].exports.rules;

function _cssolibcompressorindexjs221_readRulesChunk(rules, specialComments) {
    var buffer = new _cssolibcompressorindexjs221_List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    rules.nextUntil(rules.head, function (node, item, list) {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;
            return;
        }

        if (node.type !== 'Space') {
            nonSpaceTokenInBuffer = true;
        }

        buffer.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            info: null,
            rules: buffer
        }
    };
}

function _cssolibcompressorindexjs221_compressChunk(ast, firstAtrulesAllowed, usageData, num, logger) {
    logger('Compress block #' + num, null, true);

    var seed = 1;
    _cssolibcompressorindexjs221_walkRules(ast, function markStylesheets() {
        if ('id' in this.stylesheet === false) {
            this.stylesheet.firstAtrulesAllowed = firstAtrulesAllowed;
            this.stylesheet.id = seed++;
        }
    });
    logger('init', ast);

    // remove redundant
    _cssolibcompressorindexjs221_clean(ast, usageData);
    logger('clean', ast);

    // compress nodes
    _cssolibcompressorindexjs221_compress(ast, usageData);
    logger('compress', ast);

    return ast;
}

function _cssolibcompressorindexjs221_getCommentsOption(options) {
    var comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function _cssolibcompressorindexjs221_getRestructureOption(options) {
    return 'restructure' in options ? options.restructure : 'restructuring' in options ? options.restructuring : true;
}

function _cssolibcompressorindexjs221_wrapBlock(block) {
    return new _cssolibcompressorindexjs221_List([{
        type: 'Ruleset',
        selector: {
            type: 'Selector',
            selectors: new _cssolibcompressorindexjs221_List([{
                type: 'SimpleSelector',
                sequence: new _cssolibcompressorindexjs221_List([{
                    type: 'Identifier',
                    name: 'x'
                }])
            }])
        },
        block: block
    }]);
}

$m['csso/lib/compressor/index.js#2.2.1'].exports = function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', info: null, rules: new _cssolibcompressorindexjs221_List() };
    options = options || {};

    var logger = typeof options.logger === 'function' ? options.logger : Function();
    var specialComments = _cssolibcompressorindexjs221_getCommentsOption(options);
    var restructuring = _cssolibcompressorindexjs221_getRestructureOption(options);
    var firstAtrulesAllowed = true;
    var usageData = false;
    var inputRules;
    var outputRules = new _cssolibcompressorindexjs221_List();
    var chunk;
    var chunkNum = 1;
    var chunkRules;

    if (options.clone) {
        ast = _cssolibcompressorindexjs221_clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        inputRules = ast.rules;
        ast.rules = outputRules;
    } else {
        inputRules = _cssolibcompressorindexjs221_wrapBlock(ast);
    }

    if (options.usage) {
        usageData = _cssolibcompressorindexjs221_usageUtils.buildIndex(options.usage);
    }

    do {
        chunk = _cssolibcompressorindexjs221_readRulesChunk(inputRules, Boolean(specialComments));

        _cssolibcompressorindexjs221_compressChunk(chunk.stylesheet, firstAtrulesAllowed, usageData, chunkNum++, logger);

        // structure optimisations
        if (restructuring) {
            _cssolibcompressorindexjs221_restructureBlock(chunk.stylesheet, usageData, logger);
        }

        chunkRules = chunk.stylesheet.rules;

        if (chunk.comment) {
            // add \n before comment if there is another content in outputRules
            if (!outputRules.isEmpty()) {
                outputRules.insert(_cssolibcompressorindexjs221_List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            outputRules.insert(_cssolibcompressorindexjs221_List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkRules.isEmpty()) {
                outputRules.insert(_cssolibcompressorindexjs221_List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkRules.isEmpty()) {
            var lastRule = chunkRules.last();

            if (lastRule.type !== 'Atrule' || lastRule.name !== 'import' && lastRule.name !== 'charset') {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        outputRules.appendList(chunkRules);
    } while (!inputRules.isEmpty());

    return {
        ast: ast
    };
};
/*≠≠ node_modules/csso/lib/compressor/index.js ≠≠*/

/*== node_modules/csso/lib/parser/const.js ==*/
$m['csso/lib/parser/const.js#2.2.1'] = { exports: {} };
$m['csso/lib/parser/const.js#2.2.1'].exports.TokenType = {
    String: 'String',
    Comment: 'Comment',
    Unknown: 'Unknown',
    Newline: 'Newline',
    Space: 'Space',
    Tab: 'Tab',
    ExclamationMark: 'ExclamationMark', // !
    QuotationMark: 'QuotationMark', // "
    NumberSign: 'NumberSign', // #
    DollarSign: 'DollarSign', // $
    PercentSign: 'PercentSign', // %
    Ampersand: 'Ampersand', // &
    Apostrophe: 'Apostrophe', // '
    LeftParenthesis: 'LeftParenthesis', // (
    RightParenthesis: 'RightParenthesis', // )
    Asterisk: 'Asterisk', // *
    PlusSign: 'PlusSign', // +
    Comma: 'Comma', // ,
    HyphenMinus: 'HyphenMinus', // -
    FullStop: 'FullStop', // .
    Solidus: 'Solidus', // /
    Colon: 'Colon', // :
    Semicolon: 'Semicolon', // ;
    LessThanSign: 'LessThanSign', // <
    EqualsSign: 'EqualsSign', // =
    GreaterThanSign: 'GreaterThanSign', // >
    QuestionMark: 'QuestionMark', // ?
    CommercialAt: 'CommercialAt', // @
    LeftSquareBracket: 'LeftSquareBracket', // [
    ReverseSolidus: 'ReverseSolidus', // \
    RightSquareBracket: 'RightSquareBracket', // ]
    CircumflexAccent: 'CircumflexAccent', // ^
    LowLine: 'LowLine', // _
    LeftCurlyBracket: 'LeftCurlyBracket', // {
    VerticalLine: 'VerticalLine', // |
    RightCurlyBracket: 'RightCurlyBracket', // }
    Tilde: 'Tilde', // ~
    Identifier: 'Identifier',
    DecimalNumber: 'DecimalNumber'
};

// var i = 1;
// for (var key in exports.TokenType) {
//     exports.TokenType[key] = i++;
// }
/*≠≠ node_modules/csso/lib/parser/const.js ≠≠*/

/*== node_modules/csso/lib/parser/scanner.js ==*/
$m['csso/lib/parser/scanner.js#2.2.1'] = { exports: {} };
'use strict';

var _cssolibparserscannerjs221_TokenType = $m['csso/lib/parser/const.js#2.2.1'].exports.TokenType;

var _cssolibparserscannerjs221_TAB = 9;
var _cssolibparserscannerjs221_N = 10;
var _cssolibparserscannerjs221_F = 12;
var _cssolibparserscannerjs221_R = 13;
var _cssolibparserscannerjs221_SPACE = 32;
var _cssolibparserscannerjs221_DOUBLE_QUOTE = 34;
var _cssolibparserscannerjs221_QUOTE = 39;
var _cssolibparserscannerjs221_RIGHT_PARENTHESIS = 41;
var _cssolibparserscannerjs221_STAR = 42;
var _cssolibparserscannerjs221_SLASH = 47;
var _cssolibparserscannerjs221_BACK_SLASH = 92;
var _cssolibparserscannerjs221_UNDERSCORE = 95;
var _cssolibparserscannerjs221_LEFT_CURLY_BRACE = 123;
var _cssolibparserscannerjs221_RIGHT_CURLY_BRACE = 125;

var _cssolibparserscannerjs221_WHITESPACE = 1;
var _cssolibparserscannerjs221_PUNCTUATOR = 2;
var _cssolibparserscannerjs221_DIGIT = 3;
var _cssolibparserscannerjs221_STRING = 4;

var _cssolibparserscannerjs221_PUNCTUATION = {
    9: _cssolibparserscannerjs221_TokenType.Tab, // '\t'
    10: _cssolibparserscannerjs221_TokenType.Newline, // '\n'
    13: _cssolibparserscannerjs221_TokenType.Newline, // '\r'
    32: _cssolibparserscannerjs221_TokenType.Space, // ' '
    33: _cssolibparserscannerjs221_TokenType.ExclamationMark, // '!'
    34: _cssolibparserscannerjs221_TokenType.QuotationMark, // '"'
    35: _cssolibparserscannerjs221_TokenType.NumberSign, // '#'
    36: _cssolibparserscannerjs221_TokenType.DollarSign, // '$'
    37: _cssolibparserscannerjs221_TokenType.PercentSign, // '%'
    38: _cssolibparserscannerjs221_TokenType.Ampersand, // '&'
    39: _cssolibparserscannerjs221_TokenType.Apostrophe, // '\''
    40: _cssolibparserscannerjs221_TokenType.LeftParenthesis, // '('
    41: _cssolibparserscannerjs221_TokenType.RightParenthesis, // ')'
    42: _cssolibparserscannerjs221_TokenType.Asterisk, // '*'
    43: _cssolibparserscannerjs221_TokenType.PlusSign, // '+'
    44: _cssolibparserscannerjs221_TokenType.Comma, // ','
    45: _cssolibparserscannerjs221_TokenType.HyphenMinus, // '-'
    46: _cssolibparserscannerjs221_TokenType.FullStop, // '.'
    47: _cssolibparserscannerjs221_TokenType.Solidus, // '/'
    58: _cssolibparserscannerjs221_TokenType.Colon, // ':'
    59: _cssolibparserscannerjs221_TokenType.Semicolon, // ';'
    60: _cssolibparserscannerjs221_TokenType.LessThanSign, // '<'
    61: _cssolibparserscannerjs221_TokenType.EqualsSign, // '='
    62: _cssolibparserscannerjs221_TokenType.GreaterThanSign, // '>'
    63: _cssolibparserscannerjs221_TokenType.QuestionMark, // '?'
    64: _cssolibparserscannerjs221_TokenType.CommercialAt, // '@'
    91: _cssolibparserscannerjs221_TokenType.LeftSquareBracket, // '['
    93: _cssolibparserscannerjs221_TokenType.RightSquareBracket, // ']'
    94: _cssolibparserscannerjs221_TokenType.CircumflexAccent, // '^'
    95: _cssolibparserscannerjs221_TokenType.LowLine, // '_'
    123: _cssolibparserscannerjs221_TokenType.LeftCurlyBracket, // '{'
    124: _cssolibparserscannerjs221_TokenType.VerticalLine, // '|'
    125: _cssolibparserscannerjs221_TokenType.RightCurlyBracket, // '}'
    126: _cssolibparserscannerjs221_TokenType.Tilde // '~'
};
var _cssolibparserscannerjs221_SYMBOL_CATEGORY_LENGTH = Math.max.apply(null, Object.keys(_cssolibparserscannerjs221_PUNCTUATION)) + 1;
var _cssolibparserscannerjs221_SYMBOL_CATEGORY = new Uint32Array(_cssolibparserscannerjs221_SYMBOL_CATEGORY_LENGTH);
var _cssolibparserscannerjs221_IS_PUNCTUATOR = new Uint32Array(_cssolibparserscannerjs221_SYMBOL_CATEGORY_LENGTH);

// fill categories
Object.keys(_cssolibparserscannerjs221_PUNCTUATION).forEach(function (key) {
    _cssolibparserscannerjs221_SYMBOL_CATEGORY[Number(key)] = _cssolibparserscannerjs221_PUNCTUATOR;
    _cssolibparserscannerjs221_IS_PUNCTUATOR[Number(key)] = _cssolibparserscannerjs221_PUNCTUATOR;
}, _cssolibparserscannerjs221_SYMBOL_CATEGORY);

// don't treat as punctuator
_cssolibparserscannerjs221_IS_PUNCTUATOR[_cssolibparserscannerjs221_UNDERSCORE] = 0;

for (var _cssolibparserscannerjs221_i = 48; _cssolibparserscannerjs221_i <= 57; _cssolibparserscannerjs221_i++) {
    _cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_i] = _cssolibparserscannerjs221_DIGIT;
}

_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_SPACE] = _cssolibparserscannerjs221_WHITESPACE;
_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_TAB] = _cssolibparserscannerjs221_WHITESPACE;
_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_N] = _cssolibparserscannerjs221_WHITESPACE;
_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_R] = _cssolibparserscannerjs221_WHITESPACE;
_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_F] = _cssolibparserscannerjs221_WHITESPACE;

_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_QUOTE] = _cssolibparserscannerjs221_STRING;
_cssolibparserscannerjs221_SYMBOL_CATEGORY[_cssolibparserscannerjs221_DOUBLE_QUOTE] = _cssolibparserscannerjs221_STRING;

//
// scanner
//

var _cssolibparserscannerjs221_Scanner = function (source, initBlockMode, initLine, initColumn) {
    this.source = source;

    this.pos = source.charCodeAt(0) === 0xFEFF ? 1 : 0;
    this.eof = this.pos === this.source.length;
    this.line = typeof initLine === 'undefined' ? 1 : initLine;
    this.lineStartPos = typeof initColumn === 'undefined' ? -1 : -initColumn;

    this.minBlockMode = initBlockMode ? 1 : 0;
    this.blockMode = this.minBlockMode;
    this.urlMode = false;

    this.prevToken = null;
    this.token = null;
    this.buffer = [];
};

_cssolibparserscannerjs221_Scanner.prototype = {
    lookup: function (offset) {
        if (offset === 0) {
            return this.token;
        }

        for (var i = this.buffer.length; !this.eof && i < offset; i++) {
            this.buffer.push(this.getToken());
        }

        return offset <= this.buffer.length ? this.buffer[offset - 1] : null;
    },
    lookupType: function (offset, type) {
        var token = this.lookup(offset);

        return token !== null && token.type === type;
    },
    next: function () {
        var newToken = null;

        if (this.buffer.length !== 0) {
            newToken = this.buffer.shift();
        } else if (!this.eof) {
            newToken = this.getToken();
        }

        this.prevToken = this.token;
        this.token = newToken;

        return newToken;
    },

    tokenize: function () {
        var tokens = [];

        for (; this.pos < this.source.length; this.pos++) {
            tokens.push(this.getToken());
        }

        return tokens;
    },

    getToken: function () {
        var code = this.source.charCodeAt(this.pos);
        var line = this.line;
        var column = this.pos - this.lineStartPos;
        var offset = this.pos;
        var next;
        var type;
        var value;

        switch (code < _cssolibparserscannerjs221_SYMBOL_CATEGORY_LENGTH ? _cssolibparserscannerjs221_SYMBOL_CATEGORY[code] : 0) {
            case _cssolibparserscannerjs221_DIGIT:
                type = _cssolibparserscannerjs221_TokenType.DecimalNumber;
                value = this.readDecimalNumber();
                break;

            case _cssolibparserscannerjs221_STRING:
                type = _cssolibparserscannerjs221_TokenType.String;
                value = this.readString(code);
                break;

            case _cssolibparserscannerjs221_WHITESPACE:
                type = _cssolibparserscannerjs221_TokenType.Space;
                value = this.readSpaces();
                break;

            case _cssolibparserscannerjs221_PUNCTUATOR:
                if (code === _cssolibparserscannerjs221_SLASH) {
                    next = this.pos + 1 < this.source.length ? this.source.charCodeAt(this.pos + 1) : 0;

                    if (next === _cssolibparserscannerjs221_STAR) {
                        // /*
                        type = _cssolibparserscannerjs221_TokenType.Comment;
                        value = this.readComment();
                        break;
                    } else if (next === _cssolibparserscannerjs221_SLASH && !this.urlMode) {
                        // //
                        if (this.blockMode > 0) {
                            var skip = 2;

                            while (this.source.charCodeAt(this.pos + 2) === _cssolibparserscannerjs221_SLASH) {
                                skip++;
                            }

                            type = _cssolibparserscannerjs221_TokenType.Identifier;
                            value = this.readIdentifier(skip);

                            this.urlMode = this.urlMode || value === 'url';
                        } else {
                            type = _cssolibparserscannerjs221_TokenType.Unknown;
                            value = this.readUnknown();
                        }
                        break;
                    }
                }

                type = _cssolibparserscannerjs221_PUNCTUATION[code];
                value = String.fromCharCode(code);
                this.pos++;

                if (code === _cssolibparserscannerjs221_RIGHT_PARENTHESIS) {
                    this.urlMode = false;
                } else if (code === _cssolibparserscannerjs221_LEFT_CURLY_BRACE) {
                    this.blockMode++;
                } else if (code === _cssolibparserscannerjs221_RIGHT_CURLY_BRACE) {
                    if (this.blockMode > this.minBlockMode) {
                        this.blockMode--;
                    }
                }

                break;

            default:
                type = _cssolibparserscannerjs221_TokenType.Identifier;
                value = this.readIdentifier(0);

                this.urlMode = this.urlMode || value === 'url';
        }

        this.eof = this.pos === this.source.length;

        return {
            type: type,
            value: value,

            offset: offset,
            line: line,
            column: column
        };
    },

    isNewline: function (code) {
        if (code === _cssolibparserscannerjs221_N || code === _cssolibparserscannerjs221_F || code === _cssolibparserscannerjs221_R) {
            if (code === _cssolibparserscannerjs221_R && this.pos + 1 < this.source.length && this.source.charCodeAt(this.pos + 1) === _cssolibparserscannerjs221_N) {
                this.pos++;
            }

            this.line++;
            this.lineStartPos = this.pos;
            return true;
        }

        return false;
    },

    readSpaces: function () {
        var start = this.pos;

        for (; this.pos < this.source.length; this.pos++) {
            var code = this.source.charCodeAt(this.pos);

            if (!this.isNewline(code) && code !== _cssolibparserscannerjs221_SPACE && code !== _cssolibparserscannerjs221_TAB) {
                break;
            }
        }

        return this.source.substring(start, this.pos);
    },

    readComment: function () {
        var start = this.pos;

        for (this.pos += 2; this.pos < this.source.length; this.pos++) {
            var code = this.source.charCodeAt(this.pos);

            if (code === _cssolibparserscannerjs221_STAR) {
                // */
                if (this.source.charCodeAt(this.pos + 1) === _cssolibparserscannerjs221_SLASH) {
                    this.pos += 2;
                    break;
                }
            } else {
                this.isNewline(code);
            }
        }

        return this.source.substring(start, this.pos);
    },

    readUnknown: function () {
        var start = this.pos;

        for (this.pos += 2; this.pos < this.source.length; this.pos++) {
            if (this.isNewline(this.source.charCodeAt(this.pos), this.source)) {
                break;
            }
        }

        return this.source.substring(start, this.pos);
    },

    readString: function (quote) {
        var start = this.pos;
        var res = '';

        for (this.pos++; this.pos < this.source.length; this.pos++) {
            var code = this.source.charCodeAt(this.pos);

            if (code === _cssolibparserscannerjs221_BACK_SLASH) {
                var end = this.pos++;

                if (this.isNewline(this.source.charCodeAt(this.pos), this.source)) {
                    res += this.source.substring(start, end);
                    start = this.pos + 1;
                }
            } else if (code === quote) {
                this.pos++;
                break;
            }
        }

        return res + this.source.substring(start, this.pos);
    },

    readDecimalNumber: function () {
        var start = this.pos;
        var code;

        for (this.pos++; this.pos < this.source.length; this.pos++) {
            code = this.source.charCodeAt(this.pos);

            if (code < 48 || code > 57) {
                // 0 .. 9
                break;
            }
        }

        return this.source.substring(start, this.pos);
    },

    readIdentifier: function (skip) {
        var start = this.pos;

        for (this.pos += skip; this.pos < this.source.length; this.pos++) {
            var code = this.source.charCodeAt(this.pos);

            if (code === _cssolibparserscannerjs221_BACK_SLASH) {
                this.pos++;

                // skip escaped unicode sequence that can ends with space
                // [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
                for (var i = 0; i < 7 && this.pos + i < this.source.length; i++) {
                    code = this.source.charCodeAt(this.pos + i);

                    if (i !== 6) {
                        if (code >= 48 && code <= 57 || // 0 .. 9
                        code >= 65 && code <= 70 || // A .. F
                        code >= 97 && code <= 102) {
                            // a .. f
                            continue;
                        }
                    }

                    if (i > 0) {
                        this.pos += i - 1;
                        if (code === _cssolibparserscannerjs221_SPACE || code === _cssolibparserscannerjs221_TAB || this.isNewline(code)) {
                            this.pos++;
                        }
                    }

                    break;
                }
            } else if (code < _cssolibparserscannerjs221_SYMBOL_CATEGORY_LENGTH && _cssolibparserscannerjs221_IS_PUNCTUATOR[code] === _cssolibparserscannerjs221_PUNCTUATOR) {
                break;
            }
        }

        return this.source.substring(start, this.pos);
    }
};

// warm up tokenizer to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new _cssolibparserscannerjs221_Scanner('\n\r\r\n\f//""\'\'/**/1a;.{url(a)}').lookup(1e3);

$m['csso/lib/parser/scanner.js#2.2.1'].exports = _cssolibparserscannerjs221_Scanner;
/*≠≠ node_modules/csso/lib/parser/scanner.js ≠≠*/

/*== node_modules/csso/lib/parser/index.js ==*/
$m['csso/lib/parser/index.js#2.2.1'] = { exports: {} };
'use strict';

var _cssolibparserindexjs221_TokenType = $m['csso/lib/parser/const.js#2.2.1'].exports.TokenType;
var _cssolibparserindexjs221_Scanner = $m['csso/lib/parser/scanner.js#2.2.1'].exports;
var _cssolibparserindexjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;
var _cssolibparserindexjs221_needPositions;
var _cssolibparserindexjs221_filename;
var _cssolibparserindexjs221_scanner;

var _cssolibparserindexjs221_SCOPE_ATRULE_EXPRESSION = 1;
var _cssolibparserindexjs221_SCOPE_SELECTOR = 2;
var _cssolibparserindexjs221_SCOPE_VALUE = 3;

var _cssolibparserindexjs221_specialFunctions = {};
_cssolibparserindexjs221_specialFunctions[_cssolibparserindexjs221_SCOPE_ATRULE_EXPRESSION] = {
    url: _cssolibparserindexjs221_getUri
};
_cssolibparserindexjs221_specialFunctions[_cssolibparserindexjs221_SCOPE_SELECTOR] = {
    url: _cssolibparserindexjs221_getUri,
    not: _cssolibparserindexjs221_getNotFunction
};
_cssolibparserindexjs221_specialFunctions[_cssolibparserindexjs221_SCOPE_VALUE] = {
    url: _cssolibparserindexjs221_getUri,
    expression: _cssolibparserindexjs221_getOldIEExpression,
    var: _cssolibparserindexjs221_getVarFunction
};

var _cssolibparserindexjs221_initialContext = {
    stylesheet: _cssolibparserindexjs221_getStylesheet,
    atrule: _cssolibparserindexjs221_getAtrule,
    atruleExpression: _cssolibparserindexjs221_getAtruleExpression,
    ruleset: _cssolibparserindexjs221_getRuleset,
    selector: _cssolibparserindexjs221_getSelector,
    simpleSelector: _cssolibparserindexjs221_getSimpleSelector,
    block: _cssolibparserindexjs221_getBlock,
    declaration: _cssolibparserindexjs221_getDeclaration,
    value: _cssolibparserindexjs221_getValue
};

var _cssolibparserindexjs221_blockMode = {
    'declaration': true,
    'property': true
};

function _cssolibparserindexjs221_parseError(message) {
    var error = new Error(message);
    var offset = 0;
    var line = 1;
    var column = 1;
    var lines;

    if (_cssolibparserindexjs221_scanner.token !== null) {
        offset = _cssolibparserindexjs221_scanner.token.offset;
        line = _cssolibparserindexjs221_scanner.token.line;
        column = _cssolibparserindexjs221_scanner.token.column;
    } else if (_cssolibparserindexjs221_scanner.prevToken !== null) {
        lines = _cssolibparserindexjs221_scanner.prevToken.value.trimRight();
        offset = _cssolibparserindexjs221_scanner.prevToken.offset + lines.length;
        lines = lines.split(/\n|\r\n?|\f/);
        line = _cssolibparserindexjs221_scanner.prevToken.line + lines.length - 1;
        column = lines.length > 1 ? lines[lines.length - 1].length + 1 : _cssolibparserindexjs221_scanner.prevToken.column + lines[lines.length - 1].length;
    }

    error.name = 'CssSyntaxError';
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    throw error;
}

function _cssolibparserindexjs221_eat(tokenType) {
    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === tokenType) {
        _cssolibparserindexjs221_scanner.next();
        return true;
    }

    _cssolibparserindexjs221_parseError(tokenType + ' is expected');
}

function _cssolibparserindexjs221_expectIdentifier(name, eat) {
    if (_cssolibparserindexjs221_scanner.token !== null) {
        if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier && _cssolibparserindexjs221_scanner.token.value.toLowerCase() === name) {
            if (eat) {
                _cssolibparserindexjs221_scanner.next();
            }

            return true;
        }
    }

    _cssolibparserindexjs221_parseError('Identifier `' + name + '` is expected');
}

function _cssolibparserindexjs221_expectAny(what) {
    if (_cssolibparserindexjs221_scanner.token !== null) {
        for (var i = 1, type = _cssolibparserindexjs221_scanner.token.type; i < arguments.length; i++) {
            if (type === arguments[i]) {
                return true;
            }
        }
    }

    _cssolibparserindexjs221_parseError(what + ' is expected');
}

function _cssolibparserindexjs221_getInfo() {
    if (_cssolibparserindexjs221_needPositions && _cssolibparserindexjs221_scanner.token) {
        return {
            source: _cssolibparserindexjs221_filename,
            offset: _cssolibparserindexjs221_scanner.token.offset,
            line: _cssolibparserindexjs221_scanner.token.line,
            column: _cssolibparserindexjs221_scanner.token.column
        };
    }

    return null;
}

function _cssolibparserindexjs221_removeTrailingSpaces(list) {
    while (list.tail) {
        if (list.tail.data.type === 'Space') {
            list.remove(list.tail);
        } else {
            break;
        }
    }
}

function _cssolibparserindexjs221_getStylesheet(nested) {
    var child = null;
    var node = {
        type: 'StyleSheet',
        info: _cssolibparserindexjs221_getInfo(),
        rules: new _cssolibparserindexjs221_List()
    };

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.Space:
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                // ignore comments except exclamation comments on top level
                if (nested || _cssolibparserindexjs221_scanner.token.value.charAt(2) !== '!') {
                    _cssolibparserindexjs221_scanner.next();
                    child = null;
                } else {
                    child = _cssolibparserindexjs221_getComment();
                }
                break;

            case _cssolibparserindexjs221_TokenType.Unknown:
                child = _cssolibparserindexjs221_getUnknown();
                break;

            case _cssolibparserindexjs221_TokenType.CommercialAt:
                child = _cssolibparserindexjs221_getAtrule();
                break;

            case _cssolibparserindexjs221_TokenType.RightCurlyBracket:
                if (!nested) {
                    _cssolibparserindexjs221_parseError('Unexpected right curly brace');
                }

                break scan;

            default:
                child = _cssolibparserindexjs221_getRuleset();
        }

        if (child !== null) {
            node.rules.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    return node;
}

// '//' ...
// TODO: remove it as wrong thing
function _cssolibparserindexjs221_getUnknown() {
    var info = _cssolibparserindexjs221_getInfo();
    var value = _cssolibparserindexjs221_scanner.token.value;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Unknown);

    return {
        type: 'Unknown',
        info: info,
        value: value
    };
}

function _cssolibparserindexjs221_isBlockAtrule() {
    for (var offset = 1, cursor; cursor = _cssolibparserindexjs221_scanner.lookup(offset); offset++) {
        var type = cursor.type;

        if (type === _cssolibparserindexjs221_TokenType.RightCurlyBracket) {
            return true;
        }

        if (type === _cssolibparserindexjs221_TokenType.LeftCurlyBracket || type === _cssolibparserindexjs221_TokenType.CommercialAt) {
            return false;
        }
    }

    return true;
}

function _cssolibparserindexjs221_getAtruleExpression() {
    var child = null;
    var node = {
        type: 'AtruleExpression',
        info: _cssolibparserindexjs221_getInfo(),
        sequence: new _cssolibparserindexjs221_List()
    };

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.Semicolon:
                break scan;

            case _cssolibparserindexjs221_TokenType.LeftCurlyBracket:
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
                if (node.sequence.isEmpty()) {
                    _cssolibparserindexjs221_scanner.next(); // ignore spaces in beginning
                    child = null;
                } else {
                    child = _cssolibparserindexjs221_getS();
                }
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                // ignore comments
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.Comma:
                child = _cssolibparserindexjs221_getOperator();
                break;

            case _cssolibparserindexjs221_TokenType.Colon:
                child = _cssolibparserindexjs221_getPseudo();
                break;

            case _cssolibparserindexjs221_TokenType.LeftParenthesis:
                child = _cssolibparserindexjs221_getBraces(_cssolibparserindexjs221_SCOPE_ATRULE_EXPRESSION);
                break;

            default:
                child = _cssolibparserindexjs221_getAny(_cssolibparserindexjs221_SCOPE_ATRULE_EXPRESSION);
        }

        if (child !== null) {
            node.sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    _cssolibparserindexjs221_removeTrailingSpaces(node.sequence);

    return node;
}

function _cssolibparserindexjs221_getAtrule() {
    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.CommercialAt);

    var node = {
        type: 'Atrule',
        info: _cssolibparserindexjs221_getInfo(),
        name: _cssolibparserindexjs221_readIdent(false),
        expression: _cssolibparserindexjs221_getAtruleExpression(),
        block: null
    };

    if (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.Semicolon:
                _cssolibparserindexjs221_scanner.next(); // {
                break;

            case _cssolibparserindexjs221_TokenType.LeftCurlyBracket:
                _cssolibparserindexjs221_scanner.next(); // {

                if (_cssolibparserindexjs221_isBlockAtrule()) {
                    node.block = _cssolibparserindexjs221_getBlock();
                } else {
                    node.block = _cssolibparserindexjs221_getStylesheet(true);
                }

                _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightCurlyBracket);
                break;

            default:
                _cssolibparserindexjs221_parseError('Unexpected input');
        }
    }

    return node;
}

function _cssolibparserindexjs221_getRuleset() {
    return {
        type: 'Ruleset',
        info: _cssolibparserindexjs221_getInfo(),
        selector: _cssolibparserindexjs221_getSelector(),
        block: _cssolibparserindexjs221_getBlockWithBrackets()
    };
}

function _cssolibparserindexjs221_getSelector() {
    var isBadSelector = false;
    var lastComma = true;
    var node = {
        type: 'Selector',
        info: _cssolibparserindexjs221_getInfo(),
        selectors: new _cssolibparserindexjs221_List()
    };

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.LeftCurlyBracket:
                break scan;

            case _cssolibparserindexjs221_TokenType.Comma:
                if (lastComma) {
                    isBadSelector = true;
                }

                lastComma = true;
                _cssolibparserindexjs221_scanner.next();
                break;

            default:
                if (!lastComma) {
                    isBadSelector = true;
                }

                lastComma = false;
                node.selectors.insert(_cssolibparserindexjs221_List.createItem(_cssolibparserindexjs221_getSimpleSelector()));

                if (node.selectors.tail.data.sequence.isEmpty()) {
                    isBadSelector = true;
                }
        }
    }

    if (lastComma) {
        isBadSelector = true;
        // parseError('Unexpected trailing comma');
    }

    if (isBadSelector) {
        node.selectors = new _cssolibparserindexjs221_List();
    }

    return node;
}

function _cssolibparserindexjs221_getSimpleSelector(nested) {
    var child = null;
    var combinator = null;
    var node = {
        type: 'SimpleSelector',
        info: _cssolibparserindexjs221_getInfo(),
        sequence: new _cssolibparserindexjs221_List()
    };

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.Comma:
                break scan;

            case _cssolibparserindexjs221_TokenType.LeftCurlyBracket:
                if (nested) {
                    _cssolibparserindexjs221_parseError('Unexpected input');
                }

                break scan;

            case _cssolibparserindexjs221_TokenType.RightParenthesis:
                if (!nested) {
                    _cssolibparserindexjs221_parseError('Unexpected input');
                }

                break scan;

            case _cssolibparserindexjs221_TokenType.Comment:
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.Space:
                child = null;
                if (!combinator && node.sequence.head) {
                    combinator = _cssolibparserindexjs221_getCombinator();
                } else {
                    _cssolibparserindexjs221_scanner.next();
                }
                break;

            case _cssolibparserindexjs221_TokenType.PlusSign:
            case _cssolibparserindexjs221_TokenType.GreaterThanSign:
            case _cssolibparserindexjs221_TokenType.Tilde:
            case _cssolibparserindexjs221_TokenType.Solidus:
                if (combinator && combinator.name !== ' ') {
                    _cssolibparserindexjs221_parseError('Unexpected combinator');
                }

                child = null;
                combinator = _cssolibparserindexjs221_getCombinator();
                break;

            case _cssolibparserindexjs221_TokenType.FullStop:
                child = _cssolibparserindexjs221_getClass();
                break;

            case _cssolibparserindexjs221_TokenType.LeftSquareBracket:
                child = _cssolibparserindexjs221_getAttribute();
                break;

            case _cssolibparserindexjs221_TokenType.NumberSign:
                child = _cssolibparserindexjs221_getShash();
                break;

            case _cssolibparserindexjs221_TokenType.Colon:
                child = _cssolibparserindexjs221_getPseudo();
                break;

            case _cssolibparserindexjs221_TokenType.LowLine:
            case _cssolibparserindexjs221_TokenType.Identifier:
            case _cssolibparserindexjs221_TokenType.Asterisk:
                child = _cssolibparserindexjs221_getNamespacedIdentifier(false);
                break;

            case _cssolibparserindexjs221_TokenType.HyphenMinus:
            case _cssolibparserindexjs221_TokenType.DecimalNumber:
                child = _cssolibparserindexjs221_tryGetPercentage() || _cssolibparserindexjs221_getNamespacedIdentifier(false);
                break;

            default:
                _cssolibparserindexjs221_parseError('Unexpected input');
        }

        if (child !== null) {
            if (combinator !== null) {
                node.sequence.insert(_cssolibparserindexjs221_List.createItem(combinator));
                combinator = null;
            }

            node.sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    if (combinator && combinator.name !== ' ') {
        _cssolibparserindexjs221_parseError('Unexpected combinator');
    }

    return node;
}

function _cssolibparserindexjs221_getDeclarations() {
    var child = null;
    var declarations = new _cssolibparserindexjs221_List();

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.RightCurlyBracket:
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
            case _cssolibparserindexjs221_TokenType.Comment:
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.Semicolon:
                // ;
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            default:
                child = _cssolibparserindexjs221_getDeclaration();
        }

        if (child !== null) {
            declarations.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    return declarations;
}

function _cssolibparserindexjs221_getBlockWithBrackets() {
    var info = _cssolibparserindexjs221_getInfo();
    var node;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftCurlyBracket);
    node = {
        type: 'Block',
        info: info,
        declarations: _cssolibparserindexjs221_getDeclarations()
    };
    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightCurlyBracket);

    return node;
}

function _cssolibparserindexjs221_getBlock() {
    return {
        type: 'Block',
        info: _cssolibparserindexjs221_getInfo(),
        declarations: _cssolibparserindexjs221_getDeclarations()
    };
}

function _cssolibparserindexjs221_getDeclaration(nested) {
    var info = _cssolibparserindexjs221_getInfo();
    var property = _cssolibparserindexjs221_getProperty();
    var value;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Colon);

    // check it's a filter
    if (/filter$/.test(property.name.toLowerCase()) && _cssolibparserindexjs221_checkProgid()) {
        value = _cssolibparserindexjs221_getFilterValue();
    } else {
        value = _cssolibparserindexjs221_getValue(nested);
    }

    return {
        type: 'Declaration',
        info: info,
        property: property,
        value: value
    };
}

function _cssolibparserindexjs221_getProperty() {
    var name = '';
    var node = {
        type: 'Property',
        info: _cssolibparserindexjs221_getInfo(),
        name: null
    };

    for (; _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
        var type = _cssolibparserindexjs221_scanner.token.type;

        if (type !== _cssolibparserindexjs221_TokenType.Solidus && type !== _cssolibparserindexjs221_TokenType.Asterisk && type !== _cssolibparserindexjs221_TokenType.DollarSign) {
            break;
        }

        name += _cssolibparserindexjs221_scanner.token.value;
    }

    node.name = name + _cssolibparserindexjs221_readIdent(true);

    _cssolibparserindexjs221_readSC();

    return node;
}

function _cssolibparserindexjs221_getValue(nested) {
    var child = null;
    var node = {
        type: 'Value',
        info: _cssolibparserindexjs221_getInfo(),
        important: false,
        sequence: new _cssolibparserindexjs221_List()
    };

    _cssolibparserindexjs221_readSC();

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.RightCurlyBracket:
            case _cssolibparserindexjs221_TokenType.Semicolon:
                break scan;

            case _cssolibparserindexjs221_TokenType.RightParenthesis:
                if (!nested) {
                    _cssolibparserindexjs221_parseError('Unexpected input');
                }
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
                child = _cssolibparserindexjs221_getS();
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                // ignore comments
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.NumberSign:
                child = _cssolibparserindexjs221_getVhash();
                break;

            case _cssolibparserindexjs221_TokenType.Solidus:
            case _cssolibparserindexjs221_TokenType.Comma:
                child = _cssolibparserindexjs221_getOperator();
                break;

            case _cssolibparserindexjs221_TokenType.LeftParenthesis:
            case _cssolibparserindexjs221_TokenType.LeftSquareBracket:
                child = _cssolibparserindexjs221_getBraces(_cssolibparserindexjs221_SCOPE_VALUE);
                break;

            case _cssolibparserindexjs221_TokenType.ExclamationMark:
                node.important = _cssolibparserindexjs221_getImportant();
                child = null;
                break;

            default:
                // check for unicode range: U+0F00, U+0F00-0FFF, u+0F00??
                if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier) {
                    var prefix = _cssolibparserindexjs221_scanner.token.value;
                    if (prefix === 'U' || prefix === 'u') {
                        if (_cssolibparserindexjs221_scanner.lookupType(1, _cssolibparserindexjs221_TokenType.PlusSign)) {
                            _cssolibparserindexjs221_scanner.next(); // U or u
                            _cssolibparserindexjs221_scanner.next(); // +

                            child = {
                                type: 'Identifier',
                                info: _cssolibparserindexjs221_getInfo(), // FIXME: wrong position
                                name: prefix + '+' + _cssolibparserindexjs221_readUnicodeRange(true)
                            };
                        }
                        break;
                    }
                }

                child = _cssolibparserindexjs221_getAny(_cssolibparserindexjs221_SCOPE_VALUE);
        }

        if (child !== null) {
            node.sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    _cssolibparserindexjs221_removeTrailingSpaces(node.sequence);

    return node;
}

// any = string | percentage | dimension | number | uri | functionExpression | funktion | unary | operator | ident
function _cssolibparserindexjs221_getAny(scope) {
    switch (_cssolibparserindexjs221_scanner.token.type) {
        case _cssolibparserindexjs221_TokenType.String:
            return _cssolibparserindexjs221_getString();

        case _cssolibparserindexjs221_TokenType.LowLine:
        case _cssolibparserindexjs221_TokenType.Identifier:
            break;

        case _cssolibparserindexjs221_TokenType.FullStop:
        case _cssolibparserindexjs221_TokenType.DecimalNumber:
        case _cssolibparserindexjs221_TokenType.HyphenMinus:
        case _cssolibparserindexjs221_TokenType.PlusSign:
            var number = _cssolibparserindexjs221_tryGetNumber();

            if (number !== null) {
                if (_cssolibparserindexjs221_scanner.token !== null) {
                    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.PercentSign) {
                        return _cssolibparserindexjs221_getPercentage(number);
                    } else if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier) {
                        return _cssolibparserindexjs221_getDimension(number.value);
                    }
                }

                return number;
            }

            if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus) {
                var next = _cssolibparserindexjs221_scanner.lookup(1);
                if (next && (next.type === _cssolibparserindexjs221_TokenType.Identifier || next.type === _cssolibparserindexjs221_TokenType.HyphenMinus)) {
                    break;
                }
            }

            if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus || _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.PlusSign) {
                return _cssolibparserindexjs221_getOperator();
            }

            _cssolibparserindexjs221_parseError('Unexpected input');

        default:
            _cssolibparserindexjs221_parseError('Unexpected input');
    }

    var ident = _cssolibparserindexjs221_getIdentifier(false);

    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.LeftParenthesis) {
        return _cssolibparserindexjs221_getFunction(scope, ident);
    }

    return ident;
}

function _cssolibparserindexjs221_readAttrselector() {
    _cssolibparserindexjs221_expectAny('Attribute selector (=, ~=, ^=, $=, *=, |=)', _cssolibparserindexjs221_TokenType.EqualsSign, // =
    _cssolibparserindexjs221_TokenType.Tilde, // ~=
    _cssolibparserindexjs221_TokenType.CircumflexAccent, // ^=
    _cssolibparserindexjs221_TokenType.DollarSign, // $=
    _cssolibparserindexjs221_TokenType.Asterisk, // *=
    _cssolibparserindexjs221_TokenType.VerticalLine // |=
    );

    var name;

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.EqualsSign) {
        name = '=';
        _cssolibparserindexjs221_scanner.next();
    } else {
        name = _cssolibparserindexjs221_scanner.token.value + '=';
        _cssolibparserindexjs221_scanner.next();
        _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.EqualsSign);
    }

    return name;
}

// '[' S* attrib_name ']'
// '[' S* attrib_name S* attrib_match S* [ IDENT | STRING ] S* attrib_flags? S* ']'
function _cssolibparserindexjs221_getAttribute() {
    var node = {
        type: 'Attribute',
        info: _cssolibparserindexjs221_getInfo(),
        name: null,
        operator: null,
        value: null,
        flags: null
    };

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftSquareBracket);

    _cssolibparserindexjs221_readSC();

    node.name = _cssolibparserindexjs221_getNamespacedIdentifier(true);

    _cssolibparserindexjs221_readSC();

    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type !== _cssolibparserindexjs221_TokenType.RightSquareBracket) {
        // avoid case `[name i]`
        if (_cssolibparserindexjs221_scanner.token.type !== _cssolibparserindexjs221_TokenType.Identifier) {
            node.operator = _cssolibparserindexjs221_readAttrselector();

            _cssolibparserindexjs221_readSC();

            if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.String) {
                node.value = _cssolibparserindexjs221_getString();
            } else {
                node.value = _cssolibparserindexjs221_getIdentifier(false);
            }

            _cssolibparserindexjs221_readSC();
        }

        // attribute flags
        if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier) {
            node.flags = _cssolibparserindexjs221_scanner.token.value;

            _cssolibparserindexjs221_scanner.next();
            _cssolibparserindexjs221_readSC();
        }
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightSquareBracket);

    return node;
}

function _cssolibparserindexjs221_getBraces(scope) {
    var close;
    var child = null;
    var node = {
        type: 'Braces',
        info: _cssolibparserindexjs221_getInfo(),
        open: _cssolibparserindexjs221_scanner.token.value,
        close: null,
        sequence: new _cssolibparserindexjs221_List()
    };

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.LeftParenthesis) {
        close = _cssolibparserindexjs221_TokenType.RightParenthesis;
    } else {
        close = _cssolibparserindexjs221_TokenType.RightSquareBracket;
    }

    // left brace
    _cssolibparserindexjs221_scanner.next();

    _cssolibparserindexjs221_readSC();

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case close:
                node.close = _cssolibparserindexjs221_scanner.token.value;
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
                child = _cssolibparserindexjs221_getS();
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.NumberSign:
                // ??
                child = _cssolibparserindexjs221_getVhash();
                break;

            case _cssolibparserindexjs221_TokenType.LeftParenthesis:
            case _cssolibparserindexjs221_TokenType.LeftSquareBracket:
                child = _cssolibparserindexjs221_getBraces(scope);
                break;

            case _cssolibparserindexjs221_TokenType.Solidus:
            case _cssolibparserindexjs221_TokenType.Asterisk:
            case _cssolibparserindexjs221_TokenType.Comma:
            case _cssolibparserindexjs221_TokenType.Colon:
                child = _cssolibparserindexjs221_getOperator();
                break;

            default:
                child = _cssolibparserindexjs221_getAny(scope);
        }

        if (child !== null) {
            node.sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    _cssolibparserindexjs221_removeTrailingSpaces(node.sequence);

    // right brace
    _cssolibparserindexjs221_eat(close);

    return node;
}

// '.' ident
function _cssolibparserindexjs221_getClass() {
    var info = _cssolibparserindexjs221_getInfo();

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.FullStop);

    return {
        type: 'Class',
        info: info,
        name: _cssolibparserindexjs221_readIdent(false)
    };
}

// '#' ident
function _cssolibparserindexjs221_getShash() {
    var info = _cssolibparserindexjs221_getInfo();

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.NumberSign);

    return {
        type: 'Id',
        info: info,
        name: _cssolibparserindexjs221_readIdent(false)
    };
}

// + | > | ~ | /deep/
function _cssolibparserindexjs221_getCombinator() {
    var info = _cssolibparserindexjs221_getInfo();
    var combinator;

    switch (_cssolibparserindexjs221_scanner.token.type) {
        case _cssolibparserindexjs221_TokenType.Space:
            combinator = ' ';
            _cssolibparserindexjs221_scanner.next();
            break;

        case _cssolibparserindexjs221_TokenType.PlusSign:
        case _cssolibparserindexjs221_TokenType.GreaterThanSign:
        case _cssolibparserindexjs221_TokenType.Tilde:
            combinator = _cssolibparserindexjs221_scanner.token.value;
            _cssolibparserindexjs221_scanner.next();
            break;

        case _cssolibparserindexjs221_TokenType.Solidus:
            combinator = '/deep/';
            _cssolibparserindexjs221_scanner.next();

            _cssolibparserindexjs221_expectIdentifier('deep', true);

            _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Solidus);
            break;

        default:
            _cssolibparserindexjs221_parseError('Combinator (+, >, ~, /deep/) is expected');
    }

    return {
        type: 'Combinator',
        info: info,
        name: combinator
    };
}

// '/*' .* '*/'
function _cssolibparserindexjs221_getComment() {
    var info = _cssolibparserindexjs221_getInfo();
    var value = _cssolibparserindexjs221_scanner.token.value;
    var len = value.length;

    if (len > 4 && value.charAt(len - 2) === '*' && value.charAt(len - 1) === '/') {
        len -= 2;
    }

    _cssolibparserindexjs221_scanner.next();

    return {
        type: 'Comment',
        info: info,
        value: value.substring(2, len)
    };
}

// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
function _cssolibparserindexjs221_readUnit() {
    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier) {
        var unit = _cssolibparserindexjs221_scanner.token.value;
        var backSlashPos = unit.indexOf('\\');

        // no backslash in unit name
        if (backSlashPos === -1) {
            _cssolibparserindexjs221_scanner.next();
            return unit;
        }

        // patch token
        _cssolibparserindexjs221_scanner.token.value = unit.substr(backSlashPos);
        _cssolibparserindexjs221_scanner.token.offset += backSlashPos;
        _cssolibparserindexjs221_scanner.token.column += backSlashPos;

        // return unit w/o backslash part
        return unit.substr(0, backSlashPos);
    }

    _cssolibparserindexjs221_parseError('Identifier is expected');
}

// number ident
function _cssolibparserindexjs221_getDimension(number) {
    return {
        type: 'Dimension',
        info: _cssolibparserindexjs221_getInfo(),
        value: number || _cssolibparserindexjs221_readNumber(),
        unit: _cssolibparserindexjs221_readUnit()
    };
}

// number "%"
function _cssolibparserindexjs221_tryGetPercentage() {
    var number = _cssolibparserindexjs221_tryGetNumber();

    if (number && _cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.PercentSign) {
        return _cssolibparserindexjs221_getPercentage(number);
    }

    return null;
}

function _cssolibparserindexjs221_getPercentage(number) {
    var info;

    if (!number) {
        info = _cssolibparserindexjs221_getInfo();
        number = _cssolibparserindexjs221_readNumber();
    } else {
        info = number.info;
        number = number.value;
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.PercentSign);

    return {
        type: 'Percentage',
        info: info,
        value: number
    };
}

// ident '(' functionBody ')' |
// not '(' <simpleSelector>* ')'
function _cssolibparserindexjs221_getFunction(scope, ident) {
    var defaultArguments = _cssolibparserindexjs221_getFunctionArguments;

    if (!ident) {
        ident = _cssolibparserindexjs221_getIdentifier(false);
    }

    // parse special functions
    var name = ident.name.toLowerCase();

    if (_cssolibparserindexjs221_specialFunctions.hasOwnProperty(scope)) {
        if (_cssolibparserindexjs221_specialFunctions[scope].hasOwnProperty(name)) {
            return _cssolibparserindexjs221_specialFunctions[scope][name](scope, ident);
        }
    }

    return _cssolibparserindexjs221_getFunctionInternal(defaultArguments, scope, ident);
}

function _cssolibparserindexjs221_getFunctionInternal(functionArgumentsReader, scope, ident) {
    var args;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftParenthesis);
    args = functionArgumentsReader(scope);
    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis);

    return {
        type: scope === _cssolibparserindexjs221_SCOPE_SELECTOR ? 'FunctionalPseudo' : 'Function',
        info: ident.info,
        name: ident.name,
        arguments: args
    };
}

function _cssolibparserindexjs221_getFunctionArguments(scope) {
    var args = new _cssolibparserindexjs221_List();
    var argument = null;
    var child = null;

    _cssolibparserindexjs221_readSC();

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.RightParenthesis:
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
                child = _cssolibparserindexjs221_getS();
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                // ignore comments
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.NumberSign:
                // TODO: not sure it should be here
                child = _cssolibparserindexjs221_getVhash();
                break;

            case _cssolibparserindexjs221_TokenType.LeftParenthesis:
            case _cssolibparserindexjs221_TokenType.LeftSquareBracket:
                child = _cssolibparserindexjs221_getBraces(scope);
                break;

            case _cssolibparserindexjs221_TokenType.Comma:
                _cssolibparserindexjs221_removeTrailingSpaces(argument.sequence);
                _cssolibparserindexjs221_scanner.next();
                _cssolibparserindexjs221_readSC();
                argument = null;
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.Solidus:
            case _cssolibparserindexjs221_TokenType.Asterisk:
            case _cssolibparserindexjs221_TokenType.Colon:
            case _cssolibparserindexjs221_TokenType.EqualsSign:
                child = _cssolibparserindexjs221_getOperator();
                break;

            default:
                child = _cssolibparserindexjs221_getAny(scope);
        }

        if (argument === null) {
            argument = {
                type: 'Argument',
                sequence: new _cssolibparserindexjs221_List()
            };
            args.insert(_cssolibparserindexjs221_List.createItem(argument));
        }

        if (child !== null) {
            argument.sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    if (argument !== null) {
        _cssolibparserindexjs221_removeTrailingSpaces(argument.sequence);
    }

    return args;
}

function _cssolibparserindexjs221_getVarFunction(scope, ident) {
    return _cssolibparserindexjs221_getFunctionInternal(_cssolibparserindexjs221_getVarFunctionArguments, scope, ident);
}

function _cssolibparserindexjs221_getNotFunctionArguments() {
    var args = new _cssolibparserindexjs221_List();
    var wasSelector = false;

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.RightParenthesis:
                if (!wasSelector) {
                    _cssolibparserindexjs221_parseError('Simple selector is expected');
                }

                break scan;

            case _cssolibparserindexjs221_TokenType.Comma:
                if (!wasSelector) {
                    _cssolibparserindexjs221_parseError('Simple selector is expected');
                }

                wasSelector = false;
                _cssolibparserindexjs221_scanner.next();
                break;

            default:
                wasSelector = true;
                args.insert(_cssolibparserindexjs221_List.createItem(_cssolibparserindexjs221_getSimpleSelector(true)));
        }
    }

    return args;
}

function _cssolibparserindexjs221_getNotFunction(scope, ident) {
    var args;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftParenthesis);
    args = _cssolibparserindexjs221_getNotFunctionArguments(scope);
    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis);

    return {
        type: 'Negation',
        info: ident.info,
        // name: ident.name,  // TODO: add name?
        sequence: args // FIXME: -> arguments?
    };
}

// var '(' ident (',' <declaration-value>)? ')'
function _cssolibparserindexjs221_getVarFunctionArguments() {
    // TODO: special type Variable?
    var args = new _cssolibparserindexjs221_List();

    _cssolibparserindexjs221_readSC();

    args.insert(_cssolibparserindexjs221_List.createItem({
        type: 'Argument',
        sequence: new _cssolibparserindexjs221_List([_cssolibparserindexjs221_getIdentifier(true)])
    }));

    _cssolibparserindexjs221_readSC();

    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Comma) {
        _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Comma);
        _cssolibparserindexjs221_readSC();

        args.insert(_cssolibparserindexjs221_List.createItem({
            type: 'Argument',
            sequence: new _cssolibparserindexjs221_List([_cssolibparserindexjs221_getValue(true)])
        }));

        _cssolibparserindexjs221_readSC();
    }

    return args;
}

// url '(' ws* (string | raw) ws* ')'
function _cssolibparserindexjs221_getUri(scope, ident) {
    var node = {
        type: 'Url',
        info: ident.info,
        // name: ident.name,
        value: null
    };

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftParenthesis); // (

    _cssolibparserindexjs221_readSC();

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.String) {
        node.value = _cssolibparserindexjs221_getString();
        _cssolibparserindexjs221_readSC();
    } else {
        var rawInfo = _cssolibparserindexjs221_getInfo();
        var raw = '';

        for (; _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
            var type = _cssolibparserindexjs221_scanner.token.type;

            if (type === _cssolibparserindexjs221_TokenType.Space || type === _cssolibparserindexjs221_TokenType.LeftParenthesis || type === _cssolibparserindexjs221_TokenType.RightParenthesis) {
                break;
            }

            raw += _cssolibparserindexjs221_scanner.token.value;
        }

        node.value = {
            type: 'Raw',
            info: rawInfo,
            value: raw
        };

        _cssolibparserindexjs221_readSC();
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis); // )

    return node;
}

// expression '(' raw ')'
function _cssolibparserindexjs221_getOldIEExpression(scope, ident) {
    var balance = 0;
    var raw = '';

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftParenthesis);

    for (; _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
        if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.RightParenthesis) {
            if (balance === 0) {
                break;
            }

            balance--;
        } else if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.LeftParenthesis) {
            balance++;
        }

        raw += _cssolibparserindexjs221_scanner.token.value;
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis);

    return {
        type: 'Function',
        info: ident.info,
        name: ident.name,
        arguments: new _cssolibparserindexjs221_List([{
            type: 'Argument',
            sequence: new _cssolibparserindexjs221_List([{
                type: 'Raw',
                value: raw
            }])
        }])
    };
}

function _cssolibparserindexjs221_readUnicodeRange(tryNext) {
    var hex = '';

    for (; _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
        if (_cssolibparserindexjs221_scanner.token.type !== _cssolibparserindexjs221_TokenType.DecimalNumber && _cssolibparserindexjs221_scanner.token.type !== _cssolibparserindexjs221_TokenType.Identifier) {
            break;
        }

        hex += _cssolibparserindexjs221_scanner.token.value;
    }

    if (!/^[0-9a-f]{1,6}$/i.test(hex)) {
        _cssolibparserindexjs221_parseError('Unexpected input');
    }

    // U+abc???
    if (tryNext) {
        for (; hex.length < 6 && _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
            if (_cssolibparserindexjs221_scanner.token.type !== _cssolibparserindexjs221_TokenType.QuestionMark) {
                break;
            }

            hex += _cssolibparserindexjs221_scanner.token.value;
            tryNext = false;
        }
    }

    // U+aaa-bbb
    if (tryNext) {
        if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus) {
            _cssolibparserindexjs221_scanner.next();

            var next = _cssolibparserindexjs221_readUnicodeRange(false);

            if (!next) {
                _cssolibparserindexjs221_parseError('Unexpected input');
            }

            hex += '-' + next;
        }
    }

    return hex;
}

function _cssolibparserindexjs221_readIdent(varAllowed) {
    var name = '';

    // optional first -
    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus) {
        name = '-';
        _cssolibparserindexjs221_scanner.next();

        if (varAllowed && _cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus) {
            name = '--';
            _cssolibparserindexjs221_scanner.next();
        }
    }

    _cssolibparserindexjs221_expectAny('Identifier', _cssolibparserindexjs221_TokenType.LowLine, _cssolibparserindexjs221_TokenType.Identifier);

    if (_cssolibparserindexjs221_scanner.token !== null) {
        name += _cssolibparserindexjs221_scanner.token.value;
        _cssolibparserindexjs221_scanner.next();

        for (; _cssolibparserindexjs221_scanner.token !== null; _cssolibparserindexjs221_scanner.next()) {
            var type = _cssolibparserindexjs221_scanner.token.type;

            if (type !== _cssolibparserindexjs221_TokenType.LowLine && type !== _cssolibparserindexjs221_TokenType.Identifier && type !== _cssolibparserindexjs221_TokenType.DecimalNumber && type !== _cssolibparserindexjs221_TokenType.HyphenMinus) {
                break;
            }

            name += _cssolibparserindexjs221_scanner.token.value;
        }
    }

    return name;
}

function _cssolibparserindexjs221_getNamespacedIdentifier(checkColon) {
    if (_cssolibparserindexjs221_scanner.token === null) {
        _cssolibparserindexjs221_parseError('Unexpected end of input');
    }

    var info = _cssolibparserindexjs221_getInfo();
    var name;

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Asterisk) {
        checkColon = false;
        name = '*';
        _cssolibparserindexjs221_scanner.next();
    } else {
        name = _cssolibparserindexjs221_readIdent(false);
    }

    if (_cssolibparserindexjs221_scanner.token !== null) {
        if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.VerticalLine && _cssolibparserindexjs221_scanner.lookupType(1, _cssolibparserindexjs221_TokenType.EqualsSign) === false) {
            name += '|';

            if (_cssolibparserindexjs221_scanner.next() !== null) {
                if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.HyphenMinus || _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Identifier || _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.LowLine) {
                    name += _cssolibparserindexjs221_readIdent(false);
                } else if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Asterisk) {
                    checkColon = false;
                    name += '*';
                    _cssolibparserindexjs221_scanner.next();
                }
            }
        }
    }

    if (checkColon && _cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.Colon) {
        _cssolibparserindexjs221_scanner.next();
        name += ':' + _cssolibparserindexjs221_readIdent(false);
    }

    return {
        type: 'Identifier',
        info: info,
        name: name
    };
}

function _cssolibparserindexjs221_getIdentifier(varAllowed) {
    return {
        type: 'Identifier',
        info: _cssolibparserindexjs221_getInfo(),
        name: _cssolibparserindexjs221_readIdent(varAllowed)
    };
}

// ! ws* important
function _cssolibparserindexjs221_getImportant() {
    // TODO?
    // var info = getInfo();

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.ExclamationMark);

    _cssolibparserindexjs221_readSC();

    // return {
    //     type: 'Identifier',
    //     info: info,
    //     name: readIdent(false)
    // };

    _cssolibparserindexjs221_expectIdentifier('important');

    _cssolibparserindexjs221_readIdent(false);

    // should return identifier in future for original source restoring as is
    // returns true for now since it's fit to optimizer purposes
    return true;
}

// odd | even | number? n
function _cssolibparserindexjs221_getNth() {
    _cssolibparserindexjs221_expectAny('Number, odd or even', _cssolibparserindexjs221_TokenType.Identifier, _cssolibparserindexjs221_TokenType.DecimalNumber);

    var info = _cssolibparserindexjs221_getInfo();
    var value = _cssolibparserindexjs221_scanner.token.value;
    var cmpValue;

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.DecimalNumber) {
        var next = _cssolibparserindexjs221_scanner.lookup(1);
        if (next !== null && next.type === _cssolibparserindexjs221_TokenType.Identifier && next.value.toLowerCase() === 'n') {
            value += next.value;
            _cssolibparserindexjs221_scanner.next();
        }
    } else {
        var cmpValue = value.toLowerCase();
        if (cmpValue !== 'odd' && cmpValue !== 'even' && cmpValue !== 'n') {
            _cssolibparserindexjs221_parseError('Unexpected identifier');
        }
    }

    _cssolibparserindexjs221_scanner.next();

    return {
        type: 'Nth',
        info: info,
        value: value
    };
}

function _cssolibparserindexjs221_getNthSelector() {
    var info = _cssolibparserindexjs221_getInfo();
    var sequence = new _cssolibparserindexjs221_List();
    var node;
    var child = null;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Colon);
    _cssolibparserindexjs221_expectIdentifier('nth', false);

    node = {
        type: 'FunctionalPseudo',
        info: info,
        name: _cssolibparserindexjs221_readIdent(false),
        arguments: new _cssolibparserindexjs221_List([{
            type: 'Argument',
            sequence: sequence
        }])
    };

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.LeftParenthesis);

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.RightParenthesis:
                break scan;

            case _cssolibparserindexjs221_TokenType.Space:
            case _cssolibparserindexjs221_TokenType.Comment:
                _cssolibparserindexjs221_scanner.next();
                child = null;
                break;

            case _cssolibparserindexjs221_TokenType.HyphenMinus:
            case _cssolibparserindexjs221_TokenType.PlusSign:
                child = _cssolibparserindexjs221_getOperator();
                break;

            default:
                child = _cssolibparserindexjs221_getNth();
        }

        if (child !== null) {
            sequence.insert(_cssolibparserindexjs221_List.createItem(child));
        }
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis);

    return node;
}

function _cssolibparserindexjs221_readNumber() {
    var wasDigits = false;
    var number = '';
    var offset = 0;

    if (_cssolibparserindexjs221_scanner.lookupType(offset, _cssolibparserindexjs221_TokenType.HyphenMinus)) {
        number = '-';
        offset++;
    }

    if (_cssolibparserindexjs221_scanner.lookupType(offset, _cssolibparserindexjs221_TokenType.DecimalNumber)) {
        wasDigits = true;
        number += _cssolibparserindexjs221_scanner.lookup(offset).value;
        offset++;
    }

    if (_cssolibparserindexjs221_scanner.lookupType(offset, _cssolibparserindexjs221_TokenType.FullStop)) {
        number += '.';
        offset++;
    }

    if (_cssolibparserindexjs221_scanner.lookupType(offset, _cssolibparserindexjs221_TokenType.DecimalNumber)) {
        wasDigits = true;
        number += _cssolibparserindexjs221_scanner.lookup(offset).value;
        offset++;
    }

    if (wasDigits) {
        while (offset--) {
            _cssolibparserindexjs221_scanner.next();
        }

        return number;
    }

    return null;
}

function _cssolibparserindexjs221_tryGetNumber() {
    var info = _cssolibparserindexjs221_getInfo();
    var number = _cssolibparserindexjs221_readNumber();

    if (number !== null) {
        return {
            type: 'Number',
            info: info,
            value: number
        };
    }

    return null;
}

// '/' | '*' | ',' | ':' | '=' | '+' | '-'
// TODO: remove '=' since it's wrong operator, but theat as operator
// to make old things like `filter: alpha(opacity=0)` works
function _cssolibparserindexjs221_getOperator() {
    var node = {
        type: 'Operator',
        info: _cssolibparserindexjs221_getInfo(),
        value: _cssolibparserindexjs221_scanner.token.value
    };

    _cssolibparserindexjs221_scanner.next();

    return node;
}

function _cssolibparserindexjs221_getFilterValue() {
    // TODO
    var progid;
    var node = {
        type: 'Value',
        info: _cssolibparserindexjs221_getInfo(),
        important: false,
        sequence: new _cssolibparserindexjs221_List()
    };

    while (progid = _cssolibparserindexjs221_checkProgid()) {
        node.sequence.insert(_cssolibparserindexjs221_List.createItem(_cssolibparserindexjs221_getProgid(progid)));
    }

    _cssolibparserindexjs221_readSC(node);

    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.ExclamationMark) {
        node.important = _cssolibparserindexjs221_getImportant();
    }

    return node;
}

// 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'
function _cssolibparserindexjs221_checkProgid() {
    function checkSC(offset) {
        for (var cursor; cursor = _cssolibparserindexjs221_scanner.lookup(offset); offset++) {
            if (cursor.type !== _cssolibparserindexjs221_TokenType.Space && cursor.type !== _cssolibparserindexjs221_TokenType.Comment) {
                break;
            }
        }

        return offset;
    }

    var offset = checkSC(0);

    if (_cssolibparserindexjs221_scanner.lookup(offset + 1) === null || _cssolibparserindexjs221_scanner.lookup(offset + 0).value.toLowerCase() !== 'progid' || _cssolibparserindexjs221_scanner.lookup(offset + 1).type !== _cssolibparserindexjs221_TokenType.Colon) {
        return false; // fail
    }

    offset += 2;
    offset = checkSC(offset);

    if (_cssolibparserindexjs221_scanner.lookup(offset + 5) === null || _cssolibparserindexjs221_scanner.lookup(offset + 0).value.toLowerCase() !== 'dximagetransform' || _cssolibparserindexjs221_scanner.lookup(offset + 1).type !== _cssolibparserindexjs221_TokenType.FullStop || _cssolibparserindexjs221_scanner.lookup(offset + 2).value.toLowerCase() !== 'microsoft' || _cssolibparserindexjs221_scanner.lookup(offset + 3).type !== _cssolibparserindexjs221_TokenType.FullStop || _cssolibparserindexjs221_scanner.lookup(offset + 4).type !== _cssolibparserindexjs221_TokenType.Identifier) {
        return false; // fail
    }

    offset += 5;
    offset = checkSC(offset);

    if (_cssolibparserindexjs221_scanner.lookupType(offset, _cssolibparserindexjs221_TokenType.LeftParenthesis) === false) {
        return false; // fail
    }

    for (var cursor; cursor = _cssolibparserindexjs221_scanner.lookup(offset); offset++) {
        if (cursor.type === _cssolibparserindexjs221_TokenType.RightParenthesis) {
            return cursor;
        }
    }

    return false;
}

function _cssolibparserindexjs221_getProgid(progidEnd) {
    var value = '';
    var node = {
        type: 'Progid',
        info: _cssolibparserindexjs221_getInfo(),
        value: null
    };

    if (!progidEnd) {
        progidEnd = _cssolibparserindexjs221_checkProgid();
    }

    if (!progidEnd) {
        _cssolibparserindexjs221_parseError('progid is expected');
    }

    _cssolibparserindexjs221_readSC(node);

    var rawInfo = _cssolibparserindexjs221_getInfo();
    for (; _cssolibparserindexjs221_scanner.token && _cssolibparserindexjs221_scanner.token !== progidEnd; _cssolibparserindexjs221_scanner.next()) {
        value += _cssolibparserindexjs221_scanner.token.value;
    }

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.RightParenthesis);
    value += ')';

    node.value = {
        type: 'Raw',
        info: rawInfo,
        value: value
    };

    _cssolibparserindexjs221_readSC(node);

    return node;
}

// <pseudo-element> | <nth-selector> | <pseudo-class>
function _cssolibparserindexjs221_getPseudo() {
    var next = _cssolibparserindexjs221_scanner.lookup(1);

    if (next === null) {
        _cssolibparserindexjs221_scanner.next();
        _cssolibparserindexjs221_parseError('Colon or identifier is expected');
    }

    if (next.type === _cssolibparserindexjs221_TokenType.Colon) {
        return _cssolibparserindexjs221_getPseudoElement();
    }

    if (next.type === _cssolibparserindexjs221_TokenType.Identifier && next.value.toLowerCase() === 'nth') {
        return _cssolibparserindexjs221_getNthSelector();
    }

    return _cssolibparserindexjs221_getPseudoClass();
}

// :: ident
function _cssolibparserindexjs221_getPseudoElement() {
    var info = _cssolibparserindexjs221_getInfo();

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Colon);
    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Colon);

    return {
        type: 'PseudoElement',
        info: info,
        name: _cssolibparserindexjs221_readIdent(false)
    };
}

// : ( ident | function )
function _cssolibparserindexjs221_getPseudoClass() {
    var info = _cssolibparserindexjs221_getInfo();
    var ident = _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.Colon) && _cssolibparserindexjs221_getIdentifier(false);

    if (_cssolibparserindexjs221_scanner.token !== null && _cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.LeftParenthesis) {
        return _cssolibparserindexjs221_getFunction(_cssolibparserindexjs221_SCOPE_SELECTOR, ident);
    }

    return {
        type: 'PseudoClass',
        info: info,
        name: ident.name
    };
}

// ws
function _cssolibparserindexjs221_getS() {
    var node = {
        type: 'Space'
        // value: scanner.token.value
    };

    _cssolibparserindexjs221_scanner.next();

    return node;
}

function _cssolibparserindexjs221_readSC() {
    // var nodes = [];

    scan: while (_cssolibparserindexjs221_scanner.token !== null) {
        switch (_cssolibparserindexjs221_scanner.token.type) {
            case _cssolibparserindexjs221_TokenType.Space:
                _cssolibparserindexjs221_scanner.next();
                // nodes.push(getS());
                break;

            case _cssolibparserindexjs221_TokenType.Comment:
                _cssolibparserindexjs221_scanner.next();
                // nodes.push(getComment());
                break;

            default:
                break scan;
        }
    }

    return null;

    // return nodes.length ? new List(nodes) : null;
}

// node: String
function _cssolibparserindexjs221_getString() {
    var node = {
        type: 'String',
        info: _cssolibparserindexjs221_getInfo(),
        value: _cssolibparserindexjs221_scanner.token.value
    };

    _cssolibparserindexjs221_scanner.next();

    return node;
}

// # ident
function _cssolibparserindexjs221_getVhash() {
    var info = _cssolibparserindexjs221_getInfo();
    var value;

    _cssolibparserindexjs221_eat(_cssolibparserindexjs221_TokenType.NumberSign);

    _cssolibparserindexjs221_expectAny('Number or identifier', _cssolibparserindexjs221_TokenType.DecimalNumber, _cssolibparserindexjs221_TokenType.Identifier);

    value = _cssolibparserindexjs221_scanner.token.value;

    if (_cssolibparserindexjs221_scanner.token.type === _cssolibparserindexjs221_TokenType.DecimalNumber && _cssolibparserindexjs221_scanner.lookupType(1, _cssolibparserindexjs221_TokenType.Identifier)) {
        _cssolibparserindexjs221_scanner.next();
        value += _cssolibparserindexjs221_scanner.token.value;
    }

    _cssolibparserindexjs221_scanner.next();

    return {
        type: 'Hash',
        info: info,
        value: value
    };
}

$m['csso/lib/parser/index.js#2.2.1'].exports = function parse(source, options) {
    var ast;

    if (!options || typeof options !== 'object') {
        options = {};
    }

    var context = options.context || 'stylesheet';
    _cssolibparserindexjs221_needPositions = Boolean(options.positions);
    _cssolibparserindexjs221_filename = options.filename || '<unknown>';

    if (!_cssolibparserindexjs221_initialContext.hasOwnProperty(context)) {
        throw new Error('Unknown context `' + context + '`');
    }

    _cssolibparserindexjs221_scanner = new _cssolibparserindexjs221_Scanner(source, _cssolibparserindexjs221_blockMode.hasOwnProperty(context), options.line, options.column);
    _cssolibparserindexjs221_scanner.next();
    ast = _cssolibparserindexjs221_initialContext[context]();

    _cssolibparserindexjs221_scanner = null;

    // console.log(JSON.stringify(ast, null, 4));
    return ast;
};
/*≠≠ node_modules/csso/lib/parser/index.js ≠≠*/

/*== node_modules/csso/lib/index.js ==*/
$m['csso/lib/index.js#2.2.1'] = { exports: {} };
var _cssolibindexjs221_parse = $m['csso/lib/parser/index.js#2.2.1'].exports;
var _cssolibindexjs221_compress = $m['csso/lib/compressor/index.js#2.2.1'].exports;
var _cssolibindexjs221_translate = $m['csso/lib/utils/translate.js#2.2.1'].exports;
var _cssolibindexjs221_translateWithSourceMap = $m['csso/lib/utils/translateWithSourceMap.js#2.2.1'].exports;
var _cssolibindexjs221_walkers = $m['csso/lib/utils/walk.js#2.2.1'].exports;
var _cssolibindexjs221_clone = $m['csso/lib/utils/clone.js#2.2.1'].exports;
var _cssolibindexjs221_List = $m['csso/lib/utils/list.js#2.2.1'].exports;

function _cssolibindexjs221_debugOutput(name, options, startTime, data) {
  if (options.debug) {
    console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
  }

  return data;
}

function _cssolibindexjs221_createDefaultLogger(level) {
  var lastDebug;

  return function logger(title, ast) {
    var line = title;

    if (ast) {
      line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
    }

    if (level > 1 && ast) {
      var css = _cssolibindexjs221_translate(ast, true);

      // when level 2, limit css to 256 symbols
      if (level === 2 && css.length > 256) {
        css = css.substr(0, 256) + '...';
      }

      line += '\n  ' + css + '\n';
    }

    console.error(line);
    lastDebug = Date.now();
  };
}

function _cssolibindexjs221_copy(obj) {
  var result = {};

  for (var key in obj) {
    result[key] = obj[key];
  }

  return result;
}

function _cssolibindexjs221_buildCompressOptions(options) {
  options = _cssolibindexjs221_copy(options);

  if (typeof options.logger !== 'function' && options.debug) {
    options.logger = _cssolibindexjs221_createDefaultLogger(options.debug);
  }

  return options;
}

function _cssolibindexjs221_minify(context, source, options) {
  options = options || {};

  var filename = options.filename || '<unknown>';
  var result;

  // parse
  var ast = _cssolibindexjs221_debugOutput('parsing', options, Date.now(), _cssolibindexjs221_parse(source, {
    context: context,
    filename: filename,
    positions: Boolean(options.sourceMap)
  }));

  // compress
  var compressResult = _cssolibindexjs221_debugOutput('compress', options, Date.now(), _cssolibindexjs221_compress(ast, _cssolibindexjs221_buildCompressOptions(options)));

  // translate
  if (options.sourceMap) {
    result = _cssolibindexjs221_debugOutput('translateWithSourceMap', options, Date.now(), function () {
      var tmp = _cssolibindexjs221_translateWithSourceMap(compressResult.ast);
      tmp.map._file = filename; // since other tools can relay on file in source map transform chain
      tmp.map.setSourceContent(filename, source);
      return tmp;
    }());
  } else {
    result = _cssolibindexjs221_debugOutput('translate', options, Date.now(), {
      css: _cssolibindexjs221_translate(compressResult.ast),
      map: null
    });
  }

  return result;
}

function _cssolibindexjs221_minifyStylesheet(source, options) {
  return _cssolibindexjs221_minify('stylesheet', source, options);
};

function _cssolibindexjs221_minifyBlock(source, options) {
  return _cssolibindexjs221_minify('block', source, options);
}

$m['csso/lib/index.js#2.2.1'].exports = {
  version: {
    "_args": [[{
      "raw": "csso@2.2.1",
      "scope": null,
      "escapedName": "csso",
      "name": "csso",
      "rawSpec": "2.2.1",
      "spec": "2.2.1",
      "type": "version"
    }, "/Users/n23618/PROJECTS/buddy/node_modules/inline-source"]],
    "_from": "csso@2.2.1",
    "_id": "csso@2.2.1",
    "_inCache": true,
    "_location": "/csso",
    "_nodeVersion": "6.2.1",
    "_npmOperationalInternal": {
      "host": "packages-12-west.internal.npmjs.com",
      "tmp": "tmp/csso-2.2.1.tgz_1469398647720_0.4500888998154551"
    },
    "_npmUser": {
      "name": "lahmatiy",
      "email": "rdvornov@gmail.com"
    },
    "_npmVersion": "3.10.4",
    "_phantomChildren": {},
    "_requested": {
      "raw": "csso@2.2.1",
      "scope": null,
      "escapedName": "csso",
      "name": "csso",
      "rawSpec": "2.2.1",
      "spec": "2.2.1",
      "type": "version"
    },
    "_requiredBy": ["/inline-source", "/svgo"],
    "_resolved": "https://registry.npmjs.org/csso/-/csso-2.2.1.tgz",
    "_shasum": "51fbb5347e50e81e6ed51668a48490ae6fe2afe2",
    "_shrinkwrap": null,
    "_spec": "csso@2.2.1",
    "_where": "/Users/n23618/PROJECTS/buddy/node_modules/inline-source",
    "author": {
      "name": "Sergey Kryzhanovsky",
      "email": "skryzhanovsky@ya.ru",
      "url": "https://github.com/afelix"
    },
    "bin": {
      "csso": "./bin/csso"
    },
    "bugs": {
      "url": "https://github.com/css/csso/issues"
    },
    "dependencies": {
      "clap": "^1.0.9",
      "source-map": "^0.5.3"
    },
    "description": "CSSO (CSS Optimizer) is a CSS minifier with structural optimisations",
    "devDependencies": {
      "browserify": "^13.0.0",
      "coveralls": "^2.11.6",
      "eslint": "^2.2.0",
      "istanbul": "^0.4.2",
      "jscs": "~2.10.0",
      "mocha": "~2.4.2",
      "uglify-js": "^2.6.1"
    },
    "directories": {},
    "dist": {
      "shasum": "51fbb5347e50e81e6ed51668a48490ae6fe2afe2",
      "tarball": "https://registry.npmjs.org/csso/-/csso-2.2.1.tgz"
    },
    "engines": {
      "node": ">=0.10.0"
    },
    "eslintConfig": {
      "env": {
        "node": true,
        "mocha": true,
        "es6": true
      },
      "rules": {
        "no-duplicate-case": 2,
        "no-undef": 2,
        "no-unused-vars": [2, {
          "vars": "all",
          "args": "after-used"
        }]
      }
    },
    "files": ["bin", "dist/csso-browser.js", "lib", "HISTORY.md", "LICENSE", "README.md"],
    "gitHead": "62bf7207f117e4726decc8f1da272e77ac0f3ea5",
    "homepage": "https://github.com/css/csso",
    "keywords": ["css", "minifier", "minify", "compress", "optimisation"],
    "license": "MIT",
    "main": "./lib/index",
    "maintainers": [{
      "name": "afelix",
      "email": "skryzhanovsky@gmail.com"
    }, {
      "name": "lahmatiy",
      "email": "rdvornov@gmail.com"
    }, {
      "name": "tadatuta",
      "email": "i@tadatuta.com"
    }],
    "name": "csso",
    "optionalDependencies": {},
    "readme": "ERROR: No README data found!",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/css/csso.git"
    },
    "scripts": {
      "browserify": "browserify --standalone csso lib/index.js | uglifyjs --compress --mangle -o dist/csso-browser.js",
      "codestyle": "jscs lib && eslint lib test",
      "codestyle-and-test": "npm run codestyle && npm test",
      "coverage": "istanbul cover _mocha -- -R dot",
      "coveralls": "istanbul cover _mocha --report lcovonly -- -R dot && cat ./coverage/lcov.info | coveralls",
      "gh-pages": "git clone -b gh-pages https://github.com/css/csso.git .gh-pages && npm run browserify && cp dist/csso-browser.js .gh-pages/ && cd .gh-pages && git commit -am \"update\" && git push && cd .. && rm -rf .gh-pages",
      "hydrogen": "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
      "prepublish": "npm run browserify",
      "test": "mocha --reporter dot",
      "travis": "npm run codestyle-and-test && npm run coveralls"
    },
    "version": "2.2.1"
  }.version,

  // classes
  List: _cssolibindexjs221_List,

  // main methods
  minify: _cssolibindexjs221_minifyStylesheet,
  minifyBlock: _cssolibindexjs221_minifyBlock,

  // step by step
  parse: _cssolibindexjs221_parse,
  compress: _cssolibindexjs221_compress,
  translate: _cssolibindexjs221_translate,
  translateWithSourceMap: _cssolibindexjs221_translateWithSourceMap,

  // walkers
  walk: _cssolibindexjs221_walkers.all,
  walkRules: _cssolibindexjs221_walkers.rules,
  walkRulesRight: _cssolibindexjs221_walkers.rulesRight,

  // utils
  clone: _cssolibindexjs221_clone
};
/*≠≠ node_modules/csso/lib/index.js ≠≠*/

/*== node_modules/inline-source/lib/css.js ==*/
$m['inline-source/lib/css.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibcssjs510_csso = $m['csso/lib/index.js#2.2.1'].exports;
const _inlinesourcelibcssjs510_noop = $m['inline-source/lib/utils.js#5.1.0'].exports.noop;

/**
 * Handle CSS content
 * @param {Object} source
 * @param {Object} context
 * @param {Function} [next]
 * @returns {null}
 */
$m['inline-source/lib/css.js#5.1.0'].exports = function css(source, context, next) {
  // Handle sync
  next = next || _inlinesourcelibcssjs510_noop;

  if (source.fileContent && !source.content && source.type == 'css') {
    try {
      source.content = source.compress ? _inlinesourcelibcssjs510_csso.minify(source.fileContent).css : source.fileContent;
      // Change tag type
      source.tag = 'style';
      next();
    } catch (err) {
      return next(err);
    }
  } else {
    next();
  }
};
/*≠≠ node_modules/inline-source/lib/css.js ≠≠*/

/*== node_modules/lodash/assign.js ==*/
$m['lodash/assign.js#4.15.0'] = { exports: {} };
var _lodashassignjs4150_assignValue = $m['lodash/_assignValue.js#4.15.0'].exports,
    _lodashassignjs4150_copyObject = $m['lodash/_copyObject.js#4.15.0'].exports,
    _lodashassignjs4150_createAssigner = $m['lodash/_createAssigner.js#4.15.0'].exports,
    _lodashassignjs4150_isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports,
    _lodashassignjs4150_isPrototype = $m['lodash/_isPrototype.js#4.15.0'].exports,
    _lodashassignjs4150_keys = $m['lodash/keys.js#4.15.0'].exports;

/** Used for built-in method references. */
var _lodashassignjs4150_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _lodashassignjs4150_hasOwnProperty = _lodashassignjs4150_objectProto.hasOwnProperty;

/** Built-in value references. */
var _lodashassignjs4150_propertyIsEnumerable = _lodashassignjs4150_objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var _lodashassignjs4150_nonEnumShadows = !_lodashassignjs4150_propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var _lodashassignjs4150_assign = _lodashassignjs4150_createAssigner(function (object, source) {
  if (_lodashassignjs4150_nonEnumShadows || _lodashassignjs4150_isPrototype(source) || _lodashassignjs4150_isArrayLike(source)) {
    _lodashassignjs4150_copyObject(source, _lodashassignjs4150_keys(source), object);
    return;
  }
  for (var key in source) {
    if (_lodashassignjs4150_hasOwnProperty.call(source, key)) {
      _lodashassignjs4150_assignValue(object, key, source[key]);
    }
  }
});

$m['lodash/assign.js#4.15.0'].exports = _lodashassignjs4150_assign;
/*≠≠ node_modules/lodash/assign.js ≠≠*/

/*== node_modules/inline-source/lib/context.js ==*/
$m['inline-source/lib/context.js#5.1.0'] = { exports: {} };
'use strict';

const _inlinesourcelibcontextjs510_assign = $m['lodash/assign.js#4.15.0'].exports;
const _inlinesourcelibcontextjs510_css = $m['inline-source/lib/css.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_fs = require('fs');
const _inlinesourcelibcontextjs510_inline = $m['inline-source/lib/inline.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_js = $m['inline-source/lib/js.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_img = $m['inline-source/lib/img.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_load = $m['inline-source/lib/load.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_path = require('path');
const _inlinesourcelibcontextjs510_utils = $m['inline-source/lib/utils.js#5.1.0'].exports;
const _inlinesourcelibcontextjs510_wrap = $m['inline-source/lib/wrap.js#5.1.0'].exports;

const _inlinesourcelibcontextjs510_DEFAULT = {
  attribute: 'inline',
  compress: true,
  ignore: [],
  pretty: false,
  swallowErrors: false,
  svgAsImage: false
};

/**
 * Retrieve context from 'options'
 * @param {Object} options
 *  - {String} attribute
 *  - {Boolean} compress
 *  - {Object} fs
 *  - {Array} handlers
 *  - {Array} ignore
 *  - {Boolean} pretty
 *  - {String} rootpath
 *  - {Boolean} swallowErrors
 *  - {Boolean} saveAsImage
 * @returns {Object}
 */
$m['inline-source/lib/context.js#5.1.0'].exports.create = function create(options) {
  options = options || {};

  let context = _inlinesourcelibcontextjs510_assign({
    // Allow overriding 'fs' implementation
    fs: _inlinesourcelibcontextjs510_fs,
    html: '',
    htmlpath: '',
    rootpath: process.cwd(),
    sources: []
  }, _inlinesourcelibcontextjs510_DEFAULT, options);

  if (options.rootpath) context.rootpath = _inlinesourcelibcontextjs510_path.resolve(options.rootpath);
  if (options.pretty == true && context.compress == false) context.pretty = true;
  context.re = _inlinesourcelibcontextjs510_utils.getTagRegExp(context.attribute);
  // Prepare stack
  context.stack = [_inlinesourcelibcontextjs510_load];
  if (options.handlers) context.stack = context.stack.concat(options.handlers);
  context.stack.push(_inlinesourcelibcontextjs510_js, _inlinesourcelibcontextjs510_css, _inlinesourcelibcontextjs510_img, _inlinesourcelibcontextjs510_wrap, _inlinesourcelibcontextjs510_inline);

  return context;
};
/*≠≠ node_modules/inline-source/lib/context.js ≠≠*/

/*== lib/plugins/html/index.js ==*/
$m['lib/plugins/html/index.js'] = { exports: {} };
'use strict';

const { debug: _libpluginshtmlindexjs_debug, strong: _libpluginshtmlindexjs_strong, warn: _libpluginshtmlindexjs_warn } = $m['lib/utils/cnsl.js'].exports;
const _libpluginshtmlindexjs_fs = require('fs');
const _libpluginshtmlindexjs_inlineContext = $m['inline-source/lib/context.js#5.1.0'].exports;
const _libpluginshtmlindexjs_inlineParse = $m['inline-source/lib/parse.js#5.1.0'].exports;
const _libpluginshtmlindexjs_inlineRun = $m['inline-source/lib/run.js#5.1.0'].exports;
const _libpluginshtmlindexjs_path = require('path');

const _libpluginshtmlindexjs_FILE_EXTENSIONS = ['html', 'htm'];
const _libpluginshtmlindexjs_WORKFLOW_WRITEABLE = ['inline'];

$m['lib/plugins/html/index.js'].exports = {
  name: 'html',
  type: 'html',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginshtmlindexjs_define, _libpluginshtmlindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginshtmlindexjs_define(File, utils) {
  return class HTMLFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'html', options);

      this.workflows.writeable = [_libpluginshtmlindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    parse(buildOptions, fn) {
      let context = _libpluginshtmlindexjs_inlineContext.create({ compress: false });

      context.html = this.content;
      context.htmlpath = this.filepath;
      _libpluginshtmlindexjs_inlineParse(context, err => {
        if (err) return fn(err);

        super.addDependencies(context.sources.slice(), buildOptions);
        fn();
      });
    }

    /**
     * Parse sidecar data file
     * @returns {Object}
     */
    parseSidecarDependency() {
      const filepath = _libpluginshtmlindexjs_path.resolve(_libpluginshtmlindexjs_path.dirname(this.filepath), this.name.replace(`.${ this.extension }`, '.json'));

      if (_libpluginshtmlindexjs_fs.existsSync(filepath)) return { context: '', filepath, match: '' };
    }

    /**
     * Retrieve sidecar data dependency
     * @returns {Object}
     */
    findSidecarDependency() {
      let data = {};

      // Find sidecar data
      this.dependencies.some(dependency => {
        if (dependency.type == 'json') {
          try {
            data = JSON.parse(dependency.content);
          } catch (err) {
            _libpluginshtmlindexjs_warn(`malformed json file: ${ _libpluginshtmlindexjs_strong(dependency.filepath) }`);
          }
          return true;
        }
      });

      return data;
    }

    /**
     * Inline css/img/js dependency content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    inline(buildOptions, fn) {
      const inlineDependencyReferences = this.dependencyReferences.filter(reference => reference.file.isInline);
      const inlineDependencies = inlineDependencyReferences.map(reference => reference.file);

      this.runForDependencies('inlineable', buildOptions, inlineDependencies, err => {
        if (err) return fn(err);
        if (!inlineDependencyReferences.length) return fn();

        // Prepare for inline-source
        inlineDependencyReferences.forEach(reference => {
          // Copy to override inline-source behaviour
          reference.fileContent = reference.file.content;
          reference.compress = buildOptions.compress;
        });

        // Update transformed html content
        let context = inlineDependencyReferences[0].parentContext;

        context.html = this.content;
        _libpluginshtmlindexjs_inlineRun(context, inlineDependencyReferences, false, (err, content) => {
          if (err) return fn(err);

          _libpluginshtmlindexjs_debug(`inline: ${ _libpluginshtmlindexjs_strong(this.relpath) }`, 4);
          this.content = content;
          fn();
        });
      });
    }
  };
}
/*≠≠ lib/plugins/html/index.js ≠≠*/

/*== lib/plugins/flow/index.js ==*/
$m['lib/plugins/flow/index.js'] = { exports: {} };
'use strict';

const _libpluginsflowindexjs_PLUGINS = ['babel-plugin-syntax-flow',
// Experimental, but needed for type syntax in Class constructors
'babel-plugin-transform-class-properties', 'babel-plugin-transform-flow-strip-types'];

$m['lib/plugins/flow/index.js'].exports = {
  name: 'flow',
  type: 'js',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerTargetVersionForType(this.name, _libpluginsflowindexjs_PLUGINS, this.type);
  }
};
/*≠≠ lib/plugins/flow/index.js ≠≠*/

/*== lib/plugins/css/index.js ==*/
$m['lib/plugins/css/index.js'] = { exports: {} };
'use strict';

const { commentStrip: _libpluginscssindexjs_commentStrip, uniqueMatch: _libpluginscssindexjs_uniqueMatch } = $m['lib/utils/string.js'].exports;
const { debug: _libpluginscssindexjs_debug, strong: _libpluginscssindexjs_strong } = $m['lib/utils/cnsl.js'].exports;

const _libpluginscssindexjs_FILE_EXTENSIONS = ['css'];
// TODO: add support for 'url(*)' syntax
const _libpluginscssindexjs_RE_IMPORT = /@import\s['"]([^'"]+)['"];?/g;
const _libpluginscssindexjs_WORKFLOW_INLINEABLE = ['load', 'compress:compress'];
const _libpluginscssindexjs_WORKFLOW_WRITEABLE = ['inline', 'compress:compress'];

$m['lib/plugins/css/index.js'].exports = {
  name: 'css',
  type: 'css',

  /**
   * Register plugin
   * @param {Config} config
   */
  register(config) {
    config.registerFileDefinitionAndExtensionsForType(_libpluginscssindexjs_define, _libpluginscssindexjs_FILE_EXTENSIONS, this.type);
  }
};

/**
 * Extend 'File' with new behaviour
 * @param {Class} File
 * @param {Object} utils
 * @returns {Class}
 */
function _libpluginscssindexjs_define(File, utils) {
  return class CSSFile extends File {
    /**
     * Constructor
     * @param {String} id
     * @param {String} filepath
     * @param {Object} options
     *  - {Object} caches
     *  - {Object} fileExtensions
     *  - {Function} fileFactory
     *  - {Object} globalAliases
     *  - {Array} npmModulepaths
     *  - {Object} pluginOptions
     *  - {Object} runtimeOptions
     */
    constructor(id, filepath, options) {
      super(id, filepath, 'css', options);

      this.workflows.inlineable = [_libpluginscssindexjs_WORKFLOW_INLINEABLE];
      this.workflows.writeable = [_libpluginscssindexjs_WORKFLOW_WRITEABLE];
    }

    /**
     * Parse file contents for dependency references
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    parse(buildOptions, fn) {
      super.addDependencies(_libpluginscssindexjs_uniqueMatch(_libpluginscssindexjs_commentStrip(this.content), _libpluginscssindexjs_RE_IMPORT).map(match => {
        match.id = match.match;
        return match;
      }), buildOptions);
      fn();
    }

    /**
     * Inline '@import' content
     * @param {Object} buildOptions
     *  - {Boolean} batch
     *  - {Boolean} bootstrap
     *  - {Boolean} boilerplate
     *  - {Boolean} browser
     *  - {Boolean} bundle
     *  - {Boolean} compress
     *  - {Array} ignoredFiles
     *  - {Boolean} helpers
     *  - {Boolean} watchOnly
     * @param {Function} fn(err)
     */
    inline(buildOptions, fn) {
      super.inlineDependencyReferences();
      _libpluginscssindexjs_debug(`inline: ${ _libpluginscssindexjs_strong(this.relpath) }`, 4);
      fn();
    }
  };
}
/*≠≠ lib/plugins/css/index.js ≠≠*/

/*== lib/config/pluginLoader.js ==*/
$m['lib/config/pluginLoader.js'] = { exports: {} };
'use strict';

const { error: _libconfigpluginLoaderjs_error, print: _libconfigpluginLoaderjs_print, strong: _libconfigpluginLoaderjs_strong, warn: _libconfigpluginLoaderjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { execSync: _libconfigpluginLoaderjs_exec } = require('child_process');
const _libconfigpluginLoaderjs_fs = require('fs');
const _libconfigpluginLoaderjs_path = require('path');

const _libconfigpluginLoaderjs_BABEL_PRESET_2016 = ['babel-plugin-syntax-trailing-function-commas', 'babel-plugin-transform-async-to-generator'];
const _libconfigpluginLoaderjs_BABEL_PRESET_2015 = ['babel-plugin-transform-exponentiation-operator'];
const _libconfigpluginLoaderjs_BABEL_PRESET_ES5 = ['babel-plugin-transform-es5-property-mutators', 'babel-plugin-transform-es2015-arrow-functions', 'babel-plugin-transform-es2015-block-scoped-functions', 'babel-plugin-transform-es2015-block-scoping', ['babel-plugin-transform-es2015-classes', { loose: true }], ['babel-plugin-transform-es2015-computed-properties', { loose: true }], ['babel-plugin-transform-es2015-destructuring', { loose: true }], 'babel-plugin-transform-es2015-duplicate-keys', ['babel-plugin-transform-es2015-for-of', { loose: true }], 'babel-plugin-transform-es2015-function-name', 'babel-plugin-transform-es2015-literals', ['babel-plugin-transform-es2015-modules-commonjs', { loose: true }], 'babel-plugin-transform-es2015-object-super', 'babel-plugin-transform-es2015-parameters', 'babel-plugin-transform-es2015-shorthand-properties', ['babel-plugin-transform-es2015-spread', { loose: true }], 'babel-plugin-transform-es2015-sticky-regex', ['babel-plugin-transform-es2015-template-literals', { loose: true }],
// babel-plugin-transform-es2015-typeof-symbol,
'babel-plugin-transform-es2015-unicode-regex'
// babel-plugin-transform-regenerator
];
const _libconfigpluginLoaderjs_BABEL_PRESET_NODE6 = [['babel-plugin-transform-es2015-modules-commonjs', { loose: true }]];
const _libconfigpluginLoaderjs_BABEL_PRESET_NODE4 = [['babel-plugin-transform-es2015-destructuring', { loose: true }], 'babel-plugin-transform-es2015-function-name', ['babel-plugin-transform-es2015-modules-commonjs', { loose: true }], 'babel-plugin-transform-es2015-parameters', 'babel-plugin-transform-es2015-shorthand-properties', ['babel-plugin-transform-es2015-spread', { loose: true }], 'babel-plugin-transform-es2015-sticky-regex', 'babel-plugin-transform-es2015-unicode-regex'];
// const BABEL_PRESET_DEFAULT = ['babel-plugin-external-helpers'];
const _libconfigpluginLoaderjs_BABEL_PRESET_DEFAULT = [];
// Require here to allow for bundling
const _libconfigpluginLoaderjs_DEFAULT_PLUGINS = [$m['lib/plugins/css/index.js'].exports, $m['lib/plugins/flow/index.js'].exports, $m['lib/plugins/html/index.js'].exports, $m['lib/plugins/img/index.js'].exports, $m['lib/plugins/js/index.js'].exports, $m['lib/plugins/json/index.js'].exports, $m['lib/plugins/react/index.js'].exports];
const _libconfigpluginLoaderjs_POSTCSS_PRESET_DEFAULT = [];
const _libconfigpluginLoaderjs_RE_JS_FILE = /\.js$/;
const _libconfigpluginLoaderjs_RE_NODE_VERSION = /^node|^server/;
const _libconfigpluginLoaderjs_RE_PLUGIN = /^buddy-plugin-/;

const _libconfigpluginLoaderjs_babel = {
  default: _libconfigpluginLoaderjs_BABEL_PRESET_DEFAULT,
  es5: _libconfigpluginLoaderjs_BABEL_PRESET_ES5.concat(_libconfigpluginLoaderjs_BABEL_PRESET_2015, _libconfigpluginLoaderjs_BABEL_PRESET_2016),
  es2015: _libconfigpluginLoaderjs_BABEL_PRESET_2015.concat(_libconfigpluginLoaderjs_BABEL_PRESET_2016),
  es2016: _libconfigpluginLoaderjs_BABEL_PRESET_2016,
  node4: _libconfigpluginLoaderjs_BABEL_PRESET_NODE4,
  node6: _libconfigpluginLoaderjs_BABEL_PRESET_NODE6
};
const _libconfigpluginLoaderjs_postcss = {
  default: _libconfigpluginLoaderjs_POSTCSS_PRESET_DEFAULT
};

// Alias
_libconfigpluginLoaderjs_babel.es6 = _libconfigpluginLoaderjs_babel.es2015;
_libconfigpluginLoaderjs_babel.es7 = _libconfigpluginLoaderjs_babel.es2016;

$m['lib/config/pluginLoader.js'].exports = {
  /**
   * Add 'preset' definition for 'type'
   * @param {String} type
   * @param {String} name
   * @param {Array} preset
   */
  addPreset(type, name, preset) {
    if (type == 'babel') {
      _libconfigpluginLoaderjs_babel[name] = preset;
    } else if (type == 'postcss') {
      _libconfigpluginLoaderjs_postcss[name] = preset;
    }
  },

  /**
   * Load default/global buddy plugins
   * @param {Object} config
   * @param {Array} [additionalPluginModules]
   */
  loadPluginModules(config, additionalPluginModules = []) {
    const cwd = process.cwd();
    const projectModules = _libconfigpluginLoaderjs_path.join(cwd, 'node_modules');
    const projectPluginModules = _libconfigpluginLoaderjs_path.join(cwd, 'buddy-plugins');

    // Load default and additional modules
    _libconfigpluginLoaderjs_DEFAULT_PLUGINS.concat(additionalPluginModules).forEach(module => {
      _libconfigpluginLoaderjs_registerPluginModule(module, config);
    });
    // Load from project node_modules dir
    _libconfigpluginLoaderjs_loadPluginModulesFromDir(projectModules, config);
    // Load from project buddy-plugins dir
    if (_libconfigpluginLoaderjs_fs.existsSync(projectPluginModules)) _libconfigpluginLoaderjs_loadPluginModulesFromDir(projectPluginModules, config);
  },

  /**
   * Load external plugins based on build target 'version' and 'options'
   * @param {Object} options
   * @param {Array} version
   * @returns {Boolean}
   */
  loadBuildPlugins(options, version = []) {
    if (!Array.isArray(version)) version = [version];
    options.babel = options.babel || {};
    options.babel.plugins = options.babel.plugins || [];

    let browser = true;
    // Add Babel plugins based on version preset
    let plugins = version.reduce((plugins, preset) => {
      preset = preset.toLowerCase();
      // Flag node builds
      if (_libconfigpluginLoaderjs_RE_NODE_VERSION.test(preset)) browser = false;
      // Ignore generic without warning
      if (preset == 'node' || preset == 'server') return plugins;
      if (!_libconfigpluginLoaderjs_babel[preset]) {
        _libconfigpluginLoaderjs_warn(`${ _libconfigpluginLoaderjs_strong(preset) } is not a recognised build target version. Additional versions can be installed with npm`);
        return plugins;
      }
      return plugins.concat(_libconfigpluginLoaderjs_babel[preset]);
    }, _libconfigpluginLoaderjs_babel.default.slice());

    options.babel.plugins.forEach(plugin => {
      const pluginName = Array.isArray(plugin) ? plugin[0] : plugin;
      let exists = false;

      plugins.some((existingPlugin, idx) => {
        const existingPluginName = Array.isArray(existingPlugin) ? existingPlugin[0] : existingPlugin;

        // Overwrite if exists
        if (pluginName == existingPluginName) {
          plugins[idx] = plugin;
          exists = true;
        }

        return exists;
      });

      if (!exists) plugins.push(plugin);
    });
    options.babel.plugins = plugins;

    let dependencies = [];

    for (const prop in options) {
      dependencies = dependencies.concat(_libconfigpluginLoaderjs_extractDependencyStrings(options[prop]));
    }

    const missingDependenciesString = dependencies.filter(dependency => {
      try {
        require.resolve(dependency);
        return false;
      } catch (err) {
        return true;
      }
    }).join(' ');

    if (missingDependenciesString) {
      try {
        _libconfigpluginLoaderjs_print(`installing the following missing dependencies: ${ _libconfigpluginLoaderjs_strong(missingDependenciesString) }`);
        _libconfigpluginLoaderjs_exec(`npm --save-dev --save-exact install ${ missingDependenciesString }`);
      } catch (err) {
        _libconfigpluginLoaderjs_error(err);
      }
    }

    for (const prop in options) {
      _libconfigpluginLoaderjs_resolveDependecyStrings(options[prop]);
    }

    return browser;
  }
};

/**
 * Load plugins in 'dir'
 * @param {String} dir
 * @param {Object} config
 */
function _libconfigpluginLoaderjs_loadPluginModulesFromDir(dir, config) {
  if (!_libconfigpluginLoaderjs_fs.existsSync(dir)) return;

  _libconfigpluginLoaderjs_fs.readdirSync(dir).filter(resource => {
    if (_libconfigpluginLoaderjs_path.basename(dir) != 'plugins') return _libconfigpluginLoaderjs_RE_PLUGIN.test(resource);
    return _libconfigpluginLoaderjs_RE_JS_FILE.test(resource) || _libconfigpluginLoaderjs_fs.statSync(_libconfigpluginLoaderjs_path.join(dir, resource)).isDirectory();
  }).forEach(resource => {
    _libconfigpluginLoaderjs_registerPluginModule(_libconfigpluginLoaderjs_path.join(dir, resource), config);
  });
}

/**
 * Register plugin 'resource'
 * @param {String} resource
 * @param {Object} config
 * @returns {null}
 */
function _libconfigpluginLoaderjs_registerPluginModule(resource, config) {
  let module;

  try {
    module = 'string' == typeof resource ? require(resource) : resource;
  } catch (err) {
    return _libconfigpluginLoaderjs_warn(`unable to load plugin ${ _libconfigpluginLoaderjs_strong(resource) }`);
  }

  if (!('register' in module)) return _libconfigpluginLoaderjs_warn(`invalid plugin ${ _libconfigpluginLoaderjs_strong(resource) }`);

  module.register(config);
  _libconfigpluginLoaderjs_print(`registered plugin ${ _libconfigpluginLoaderjs_strong(module.name) }`, 0);
}

/**
 * Extract dependency strings from 'optionsItem'
 * @param {Object} optionsItem
 * @returns {Array}
 */
function _libconfigpluginLoaderjs_extractDependencyStrings(optionsItem) {
  let dependencies = [];

  function extract(items) {
    // Invalid if not Array
    if (Array.isArray(items)) {
      items.reduce((dependencies, item) => {
        // Items can be Array with depedency as first param
        const dep = Array.isArray(item) ? item[0] : item;

        // Only gather string references, not functions/modules
        if ('string' == typeof dep) dependencies.push(dep);
        return dependencies;
      }, dependencies);
    }
  }

  if (optionsItem.plugins) extract(optionsItem.plugins);
  if (optionsItem.presets) extract(optionsItem.presets);

  return dependencies;
}

/**
 * Resolve dependency strings in 'optionsItem' to modules
 * @param {Object} optionsItem
 */
function _libconfigpluginLoaderjs_resolveDependecyStrings(optionsItem) {
  function resolve(items) {
    // Invalid if not Array
    if (Array.isArray(items)) {
      items.forEach((item, idx, items) => {
        if (Array.isArray(item) && 'string' == typeof item[0]) {
          item[0] = require(item[0]);
        } else if ('string' == typeof item) {
          items[idx] = require(item);
        }
      });
    }
  }

  if (optionsItem.plugins) resolve(optionsItem.plugins);
  if (optionsItem.presets) resolve(optionsItem.presets);
}
/*≠≠ lib/config/pluginLoader.js ≠≠*/

/*== node_modules/yaw/index.js ==*/
$m['yaw/index.js#0.1.1'] = { exports: {} };
var _yawindexjs011_fs = require('fs'),
    _yawindexjs011_path = require('path'),
    _yawindexjs011_util = require("util"),
    _yawindexjs011_EventEmitter = require('events').EventEmitter,
    _yawindexjs011_existsSync = _yawindexjs011_fs.existsSync || _yawindexjs011_path.existsSync,
    _yawindexjs011_RE_IGNORE = /^[.~]|~$/,
    _yawindexjs011_THROTTLE_TIMEOUT = 100;

$m['yaw/index.js#0.1.1'].exports = _yawindexjs011_Watcher;

/**
 * Constructor
 */
function _yawindexjs011_Watcher() {
	_yawindexjs011_EventEmitter.call(this);

	this.watchers = {};
	this._throttling = {
		'create': 0,
		'delete': 0,
		'change': 0
	};
}

// Inherit
_yawindexjs011_util.inherits(_yawindexjs011_Watcher, _yawindexjs011_EventEmitter);

/**
 * Watch a 'source' file or directory for changes
 * @param {String} source
 */
_yawindexjs011_Watcher.prototype.watch = function (source) {
	var self = this;

	if (!_yawindexjs011_RE_IGNORE.test(_yawindexjs011_path.basename(source))) {
		_yawindexjs011_fs.stat(source, function (err, stats) {
			var lastChange;
			if (err) {
				self.emit('error', err);
			} else {
				lastChange = stats.mtime.getTime();
				// Recursively parse items in directory
				if (stats.isDirectory()) {
					_yawindexjs011_fs.readdir(source, function (err, files) {
						if (err) self.emit('error', err);
						files.forEach(function (file) {
							self.watch(_yawindexjs011_path.resolve(source, file));
						});
					});
				}
			}

			// Store watcher objects
			self.watchers[source] = _yawindexjs011_fs.watch(source, function (evt, filename) {
				if (_yawindexjs011_existsSync(source)) {
					_yawindexjs011_fs.stat(source, function (err, stats) {
						if (err) {
							self.emit('error', err);
						} else {
							if (stats.isFile()) {
								// Notify if changed
								if (stats.mtime.getTime() !== lastChange) {
									self._throttleEvent('change', source, stats);
								}
								lastChange = stats.mtime.getTime();
							} else if (stats.isDirectory()) {
								_yawindexjs011_fs.readdir(source, function (err, files) {
									if (err) {
										self.emit('error', err);
									} else {
										files.forEach(function (file) {
											var item = _yawindexjs011_path.resolve(source, file);
											// New file or directory
											if (!_yawindexjs011_RE_IGNORE.test(_yawindexjs011_path.basename(item)) && !self.watchers[item]) {
												_yawindexjs011_fs.stat(item, function (err, stats) {
													self._throttleEvent('create', item, stats);
													self.watch(item);
												});
											}
										});
									}
								});
							}
						}
					});
					// Deleted
				} else {
					self.unwatch(source);
					self._throttleEvent('delete', source);
				}
			});
		});
	}
};

/**
 * Stop watching a 'source' file or directory for changes
 * @param {String} source
 */
_yawindexjs011_Watcher.prototype.unwatch = function (source) {
	var watcher = this.watchers[source];
	if (watcher) {
		delete this.watchers[source];
		try {
			watcher.close();
		} catch (err) {}
	}
};

/**
 * Stop watching all sources for changes
 */
_yawindexjs011_Watcher.prototype.clean = function () {
	for (var source in this.watchers) {
		this.unwatch(source);
	}
	for (var type in this._throttling) {
		clearInterval(this._throttling[type]);
		this._throttling[type] = 0;
	}
};

/**
 * Protect against mutiple event emits
 * @param {String} type
 * @param [props]
 */
_yawindexjs011_Watcher.prototype._throttleEvent = function (type) {
	var self = this,
	    props = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
	if (!this._throttling[type]) {
		this.emit.apply(this, [type].concat(props));
		this._throttling[type] = setTimeout(function () {
			self._throttling[type] = 0;
		}, _yawindexjs011_THROTTLE_TIMEOUT);
	}
};
/*≠≠ node_modules/yaw/index.js ≠≠*/

/*== lib/config/fileCache.js ==*/
$m['lib/config/fileCache.js'] = { exports: {} };
'use strict';

const _libconfigfileCachejs_EventEmitter = require('events').EventEmitter;
const _libconfigfileCachejs_path = require('path');
const _libconfigfileCachejs_Watcher = $m['yaw/index.js#0.1.1'].exports;

// Export
$m['lib/config/fileCache.js'].exports = function fileCacheFactory(watch) {
  return new _libconfigfileCachejs_FileCache(watch);
};

class _libconfigfileCachejs_FileCache extends _libconfigfileCachejs_EventEmitter {
  /**
   * Constructor
   * @param {Boolean} watch
   */
  constructor(watch) {
    super();

    this._cache = {};
    this._dirs = [];
    this.watching = watch;

    if (watch) {
      this.watcher = new _libconfigfileCachejs_Watcher();
      this.watcher.on('change', this.onWatchChange.bind(this));
      this.watcher.on('delete', this.onWatchDelete.bind(this));
      this.watcher.on('error', this.onWatchError.bind(this));
    }
  }

  /**
   * Store a 'file' in the cache
   * @param {File} file
   * @returns {File}
   */
  addFile(file) {
    if (!this._cache[file.filepath]) {
      const dir = _libconfigfileCachejs_path.dirname(file.filepath);

      this._cache[file.filepath] = file;
      if (!this._dirs.includes(dir)) this._dirs.push(dir);
      if (this.watching) this.watcher.watch(file.filepath);
    }

    return file;
  }

  /**
   * Remove a file from the cache by it's 'filepath'
   * @param {Object} file
   * @returns {File}
   */
  removeFile(file) {
    delete this._cache[file.filepath];
    if (this.watching) this.watcher.unwatch(file.filepath);
    return file;
  }

  /**
   * Retrieve a file from the cache by 'key' (filepath or type:id)
   * @param {String} key
   * @returns {Object}
   */
  getFile(key) {
    return this._cache[key];
  }

  /**
   * Determine if the cache contains a file by 'key' (filepath or type:id)
   * @param {String} key
   * @returns {Boolean}
   */
  hasFile(key) {
    return this._cache[key] != null;
  }

  /**
   * Retrieve all file paths
   * @returns {Array}
   */
  getPaths() {
    return Object.keys(this._cache);
  }

  /**
   * Retrieve all unique directories
   * @returns {Array}
   */
  getDirs() {
    return this._dirs;
  }

  /**
   * Flush the cache
   */
  flush() {
    if (this.watching) this.watcher.clean();
    this._cache = {};
    this._dirs = [];
  }

  /**
   * Handle changes to watched files
   * @param {String} filepath
   * @param {Stats} stats
   */
  onWatchChange(filepath, stats) {
    const file = this._cache[filepath];

    // Reset file
    if (file) {
      // Hard reset
      file.reset(true);
      this.emit('change', file);
    }
  }

  /**
   * Handle deleted watched files
   * @param {String} filepath
   */
  onWatchDelete(filepath) {
    const file = this._cache[filepath];

    // Destroy file
    if (file) {
      file.destroy();
      this.removeFile(file);
    }
  }

  /**
   * Handle error watching files
   * @param {Error} err
   */
  onWatchError(err) {
    this.emit('error', err);
  }
}
/*≠≠ lib/config/fileCache.js ≠≠*/

/*== node_modules/lodash/uniq.js ==*/
$m['lodash/uniq.js#4.15.0'] = { exports: {} };
var _lodashuniqjs4150_baseUniq = $m['lodash/_baseUniq.js#4.15.0'].exports;

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function _lodashuniqjs4150_uniq(array) {
  return array && array.length ? _lodashuniqjs4150_baseUniq(array) : [];
}

$m['lodash/uniq.js#4.15.0'].exports = _lodashuniqjs4150_uniq;
/*≠≠ node_modules/lodash/uniq.js ≠≠*/

/*== node_modules/lodash/before.js ==*/
$m['lodash/before.js#4.15.0'] = { exports: {} };
var _lodashbeforejs4150_toInteger = $m['lodash/toInteger.js#4.15.0'].exports;

/** Used as the `TypeError` message for "Functions" methods. */
var _lodashbeforejs4150_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function _lodashbeforejs4150_before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(_lodashbeforejs4150_FUNC_ERROR_TEXT);
  }
  n = _lodashbeforejs4150_toInteger(n);
  return function () {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

$m['lodash/before.js#4.15.0'].exports = _lodashbeforejs4150_before;
/*≠≠ node_modules/lodash/before.js ≠≠*/

/*== node_modules/lodash/once.js ==*/
$m['lodash/once.js#4.15.0'] = { exports: {} };
var _lodashoncejs4150_before = $m['lodash/before.js#4.15.0'].exports;

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function _lodashoncejs4150_once(func) {
  return _lodashoncejs4150_before(2, func);
}

$m['lodash/once.js#4.15.0'].exports = _lodashoncejs4150_once;
/*≠≠ node_modules/lodash/once.js ≠≠*/

/*== node_modules/async/eachOf.js ==*/
$m['async/eachOf.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/eachOf.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/eachOf.js#2.0.1'].exports.default = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _asynceachOfjs201__isArrayLike2.default)(coll) ? _asynceachOfjs201_eachOfArrayLike : _asynceachOfjs201_eachOfGeneric;
    eachOfImplementation(coll, iteratee, callback);
};

var _asynceachOfjs201__isArrayLike = $m['lodash/isArrayLike.js#4.15.0'].exports;

var _asynceachOfjs201__isArrayLike2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__isArrayLike);

var _asynceachOfjs201__eachOfLimit = $m['async/eachOfLimit.js#2.0.1'].exports;

var _asynceachOfjs201__eachOfLimit2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__eachOfLimit);

var _asynceachOfjs201__doLimit = $m['async/internal/doLimit.js#2.0.1'].exports;

var _asynceachOfjs201__doLimit2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__doLimit);

var _asynceachOfjs201__noop = $m['lodash/noop.js#4.15.0'].exports;

var _asynceachOfjs201__noop2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__noop);

var _asynceachOfjs201__once = $m['lodash/once.js#4.15.0'].exports;

var _asynceachOfjs201__once2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__once);

var _asynceachOfjs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asynceachOfjs201__onlyOnce2 = _asynceachOfjs201__interopRequireDefault(_asynceachOfjs201__onlyOnce);

function _asynceachOfjs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

// eachOf implementation optimized for array-likes
function _asynceachOfjs201_eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _asynceachOfjs201__once2.default)(callback || _asynceachOfjs201__noop2.default);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err) {
        if (err) {
            callback(err);
        } else if (++completed === length) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _asynceachOfjs201__onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var _asynceachOfjs201_eachOfGeneric = (0, _asynceachOfjs201__doLimit2.default)(_asynceachOfjs201__eachOfLimit2.default, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array. The iteratee is passed a `callback(err)` which must be called once it
 * has completed. If no error has occurred, the callback should be run without
 * arguments or with an explicit `null` argument. Invoked with
 * (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
$m['async/eachOf.js#2.0.1'].exports = $m['async/eachOf.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/eachOf.js ≠≠*/

/*== node_modules/async/parallel.js ==*/
$m['async/parallel.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/parallel.js#2.0.1'].exports, "__esModule", {
  value: true
});
$m['async/parallel.js#2.0.1'].exports.default = _asyncparalleljs201_parallelLimit;

var _asyncparalleljs201__eachOf = $m['async/eachOf.js#2.0.1'].exports;

var _asyncparalleljs201__eachOf2 = _asyncparalleljs201__interopRequireDefault(_asyncparalleljs201__eachOf);

var _asyncparalleljs201__parallel = $m['async/internal/parallel.js#2.0.1'].exports;

var _asyncparalleljs201__parallel2 = _asyncparalleljs201__interopRequireDefault(_asyncparalleljs201__parallel);

function _asyncparalleljs201__interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
 * Each function is passed a `callback(err, result)` which it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function _asyncparalleljs201_parallelLimit(tasks, callback) {
  (0, _asyncparalleljs201__parallel2.default)(_asyncparalleljs201__eachOf2.default, tasks, callback);
}
$m['async/parallel.js#2.0.1'].exports = $m['async/parallel.js#2.0.1'].exports['default'];
/*≠≠ node_modules/async/parallel.js ≠≠*/

/*== node_modules/is-buffer/index.js ==*/
$m['is-buffer/index.js#1.1.4'] = { exports: {} };
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
$m['is-buffer/index.js#1.1.4'].exports = function (obj) {
  return obj != null && (_isbufferindexjs114_isBuffer(obj) || _isbufferindexjs114_isSlowBuffer(obj) || !!obj._isBuffer);
};

function _isbufferindexjs114_isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function _isbufferindexjs114_isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && _isbufferindexjs114_isBuffer(obj.slice(0, 0));
}
/*≠≠ node_modules/is-buffer/index.js ≠≠*/

/*== node_modules/charenc/charenc.js ==*/
$m['charenc/charenc.js#0.0.1'] = { exports: {} };
var _charenccharencjs001_charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function (str) {
      return _charenccharencjs001_charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function (bytes) {
      return decodeURIComponent(escape(_charenccharencjs001_charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function (str) {
      for (var bytes = [], i = 0; i < str.length; i++) bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function (bytes) {
      for (var str = [], i = 0; i < bytes.length; i++) str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

$m['charenc/charenc.js#0.0.1'].exports = _charenccharencjs001_charenc;
/*≠≠ node_modules/charenc/charenc.js ≠≠*/

/*== node_modules/crypt/crypt.js ==*/
$m['crypt/crypt.js#0.0.1'] = { exports: {} };
(function () {
  var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      crypt = {
    // Bit-wise rotation left
    rotl: function (n, b) {
      return n << b | n >>> 32 - b;
    },

    // Bit-wise rotation right
    rotr: function (n, b) {
      return n << 32 - b | n >>> b;
    },

    // Swap big-endian to little-endian and vice versa
    endian: function (n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++) n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function (n) {
      for (var bytes = []; n > 0; n--) bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function (bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) words[b >>> 5] |= bytes[i] << 24 - b % 32;
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function (words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8) bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function (bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function (hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function (bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
        for (var j = 0; j < 4; j++) if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));else base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function (base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
      }
      return bytes;
    }
  };

  $m['crypt/crypt.js#0.0.1'].exports = crypt;
})();
/*≠≠ node_modules/crypt/crypt.js ≠≠*/

/*== node_modules/md5/md5.js ==*/
$m['md5/md5.js#2.2.1'] = { exports: {} };
(function () {
  var crypt = $m['crypt/crypt.js#0.0.1'].exports,
      utf8 = $m['charenc/charenc.js#0.0.1'].exports.utf8,
      isBuffer = $m['is-buffer/index.js#1.1.4'].exports,
      bin = $m['charenc/charenc.js#0.0.1'].exports.bin,


  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String) {
      if (options && options.encoding === 'binary') message = bin.stringToBytes(message);else message = utf8.stringToBytes(message);
    } else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);else if (!Array.isArray(message)) message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a = 1732584193,
        b = -271733879,
        c = -1732584194,
        d = 271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << l % 32;
    m[(l + 64 >>> 9 << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i + 0], 7, -680876936);
      d = FF(d, a, b, c, m[i + 1], 12, -389564586);
      c = FF(c, d, a, b, m[i + 2], 17, 606105819);
      b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i + 4], 7, -176418897);
      d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
      c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i + 7], 22, -45705983);
      a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
      d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i + 10], 17, -42063);
      b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
      a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
      d = FF(d, a, b, c, m[i + 13], 12, -40341101);
      c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
      b = FF(b, c, d, a, m[i + 15], 22, 1236535329);

      a = GG(a, b, c, d, m[i + 1], 5, -165796510);
      d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
      c = GG(c, d, a, b, m[i + 11], 14, 643717713);
      b = GG(b, c, d, a, m[i + 0], 20, -373897302);
      a = GG(a, b, c, d, m[i + 5], 5, -701558691);
      d = GG(d, a, b, c, m[i + 10], 9, 38016083);
      c = GG(c, d, a, b, m[i + 15], 14, -660478335);
      b = GG(b, c, d, a, m[i + 4], 20, -405537848);
      a = GG(a, b, c, d, m[i + 9], 5, 568446438);
      d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
      c = GG(c, d, a, b, m[i + 3], 14, -187363961);
      b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
      a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
      d = GG(d, a, b, c, m[i + 2], 9, -51403784);
      c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
      b = GG(b, c, d, a, m[i + 12], 20, -1926607734);

      a = HH(a, b, c, d, m[i + 5], 4, -378558);
      d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
      b = HH(b, c, d, a, m[i + 14], 23, -35309556);
      a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
      d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
      c = HH(c, d, a, b, m[i + 7], 16, -155497632);
      b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
      a = HH(a, b, c, d, m[i + 13], 4, 681279174);
      d = HH(d, a, b, c, m[i + 0], 11, -358537222);
      c = HH(c, d, a, b, m[i + 3], 16, -722521979);
      b = HH(b, c, d, a, m[i + 6], 23, 76029189);
      a = HH(a, b, c, d, m[i + 9], 4, -640364487);
      d = HH(d, a, b, c, m[i + 12], 11, -421815835);
      c = HH(c, d, a, b, m[i + 15], 16, 530742520);
      b = HH(b, c, d, a, m[i + 2], 23, -995338651);

      a = II(a, b, c, d, m[i + 0], 6, -198630844);
      d = II(d, a, b, c, m[i + 7], 10, 1126891415);
      c = II(c, d, a, b, m[i + 14], 15, -1416354905);
      b = II(b, c, d, a, m[i + 5], 21, -57434055);
      a = II(a, b, c, d, m[i + 12], 6, 1700485571);
      d = II(d, a, b, c, m[i + 3], 10, -1894986606);
      c = II(c, d, a, b, m[i + 10], 15, -1051523);
      b = II(b, c, d, a, m[i + 1], 21, -2054922799);
      a = II(a, b, c, d, m[i + 8], 6, 1873313359);
      d = II(d, a, b, c, m[i + 15], 10, -30611744);
      c = II(c, d, a, b, m[i + 6], 15, -1560198380);
      b = II(b, c, d, a, m[i + 13], 21, 1309151649);
      a = II(a, b, c, d, m[i + 4], 6, -145523070);
      d = II(d, a, b, c, m[i + 11], 10, -1120210379);
      c = II(c, d, a, b, m[i + 2], 15, 718787259);
      b = II(b, c, d, a, m[i + 9], 21, -343485551);

      a = a + aa >>> 0;
      b = b + bb >>> 0;
      c = c + cc >>> 0;
      d = d + dd >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._gg = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._hh = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };
  md5._ii = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return (n << s | n >>> 32 - s) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  $m['md5/md5.js#2.2.1'].exports = function (message, options) {
    if (message === undefined || message === null) throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
  };
})();
/*≠≠ node_modules/md5/md5.js ≠≠*/

/*== node_modules/recur-fs/lib/walk.js ==*/
$m['recur-fs/lib/walk.js#2.2.3'] = { exports: {} };
var _recurfslibwalkjs223_fs = require('fs'),
    _recurfslibwalkjs223_path = require('path');

/**
 * Walk directory tree from 'dir', passing all resources to 'visitor'.
 * Stops walking if 'visitor' calls next(true), or root directory reached.
 * @param {String} dir
 * @param {Function} visitor(resource, stat, next)
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/walk.js#2.2.3'].exports = function walk(dir, visitor, fn) {
	dir = _recurfslibwalkjs223_path.resolve(dir);

	function visit(dir) {
		function next(finished) {
			var parent = _recurfslibwalkjs223_path.resolve(dir, '..');

			// Stop if finished or we can no longer go up a level
			if (finished || parent.toLowerCase() === dir.toLowerCase()) return fn();

			// Up one level
			visit(parent);
		}

		_recurfslibwalkjs223_fs.readdir(dir, function (err, files) {
			if (err) return fn(err);

			var outstanding = files.length,
			    finished = false;

			files.forEach(function (file) {
				file = _recurfslibwalkjs223_path.join(dir, file);
				_recurfslibwalkjs223_fs.stat(file, function (err, stat) {
					if (!finished) {
						// Skip on error
						if (err) return ! --outstanding ? next(finished) : null;

						visitor(file, stat, function (stop) {
							if (stop === true) finished = true;

							if (! --outstanding) next(finished);
						});

						// Already finished
					} else {
						if (! --outstanding) return fn();
					}
				});
			});
		});
	}

	visit(dir);
};

/**
 * Synchronously walk directory tree from 'directory', passing all resources to 'visitor'.
 * Stops walking when root directory reached or `true` is returned from 'visitor'.
 * @param {String} dir
 * @param {Function} visitor(resource)
 */
$m['recur-fs/lib/walk.js#2.2.3'].exports.sync = function walkSync(directory, visitor) {
	directory = _recurfslibwalkjs223_path.resolve(directory);

	function visit(dir) {
		function next() {
			var parent = _recurfslibwalkjs223_path.resolve(dir, '..');

			// Stop if we can no longer go up a level
			if (parent.toLowerCase() === dir.toLowerCase()) return;

			// Up one level
			visit(parent);
		}

		var files = _recurfslibwalkjs223_fs.readdirSync(dir),
		    outstanding = files.length,
		    finished = false;

		files.forEach(function (file) {
			file = _recurfslibwalkjs223_path.join(dir, file);
			try {
				var stat = _recurfslibwalkjs223_fs.statSync(file);
			} catch (err) {
				// Skip if error
				return ! --outstanding ? next() : null;
			}

			if (!finished) {
				var stop = visitor(file, stat);
				if (stop === true) finished = true;
				if (! --outstanding && !finished) return next();
			}
		});
	}

	visit(directory);
};
/*≠≠ node_modules/recur-fs/lib/walk.js ≠≠*/

/*== node_modules/balanced-match/index.js ==*/
$m['balanced-match/index.js#0.4.2'] = { exports: {} };
$m['balanced-match/index.js#0.4.2'].exports = _balancedmatchindexjs042_balanced;
function _balancedmatchindexjs042_balanced(a, b, str) {
  if (a instanceof RegExp) a = _balancedmatchindexjs042_maybeMatch(a, str);
  if (b instanceof RegExp) b = _balancedmatchindexjs042_maybeMatch(b, str);

  var r = _balancedmatchindexjs042_range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function _balancedmatchindexjs042_maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

_balancedmatchindexjs042_balanced.range = _balancedmatchindexjs042_range;
function _balancedmatchindexjs042_range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [left, right];
    }
  }

  return result;
}
/*≠≠ node_modules/balanced-match/index.js ≠≠*/

/*== node_modules/concat-map/index.js ==*/
$m['concat-map/index.js#0.0.1'] = { exports: {} };
$m['concat-map/index.js#0.0.1'].exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (_concatmapindexjs001_isArray(x)) res.push.apply(res, x);else res.push(x);
    }
    return res;
};

var _concatmapindexjs001_isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};
/*≠≠ node_modules/concat-map/index.js ≠≠*/

/*== node_modules/brace-expansion/index.js ==*/
$m['brace-expansion/index.js#1.1.6'] = { exports: {} };
var _braceexpansionindexjs116_concatMap = $m['concat-map/index.js#0.0.1'].exports;
var _braceexpansionindexjs116_balanced = $m['balanced-match/index.js#0.4.2'].exports;

$m['brace-expansion/index.js#1.1.6'].exports = _braceexpansionindexjs116_expandTop;

var _braceexpansionindexjs116_escSlash = '\0SLASH' + Math.random() + '\0';
var _braceexpansionindexjs116_escOpen = '\0OPEN' + Math.random() + '\0';
var _braceexpansionindexjs116_escClose = '\0CLOSE' + Math.random() + '\0';
var _braceexpansionindexjs116_escComma = '\0COMMA' + Math.random() + '\0';
var _braceexpansionindexjs116_escPeriod = '\0PERIOD' + Math.random() + '\0';

function _braceexpansionindexjs116_numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function _braceexpansionindexjs116_escapeBraces(str) {
  return str.split('\\\\').join(_braceexpansionindexjs116_escSlash).split('\\{').join(_braceexpansionindexjs116_escOpen).split('\\}').join(_braceexpansionindexjs116_escClose).split('\\,').join(_braceexpansionindexjs116_escComma).split('\\.').join(_braceexpansionindexjs116_escPeriod);
}

function _braceexpansionindexjs116_unescapeBraces(str) {
  return str.split(_braceexpansionindexjs116_escSlash).join('\\').split(_braceexpansionindexjs116_escOpen).join('{').split(_braceexpansionindexjs116_escClose).join('}').split(_braceexpansionindexjs116_escComma).join(',').split(_braceexpansionindexjs116_escPeriod).join('.');
}

// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function _braceexpansionindexjs116_parseCommaParts(str) {
  if (!str) return [''];

  var parts = [];
  var m = _braceexpansionindexjs116_balanced('{', '}', str);

  if (!m) return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length - 1] += '{' + body + '}';
  var postParts = _braceexpansionindexjs116_parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function _braceexpansionindexjs116_expandTop(str) {
  if (!str) return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return _braceexpansionindexjs116_expand(_braceexpansionindexjs116_escapeBraces(str), true).map(_braceexpansionindexjs116_unescapeBraces);
}

function _braceexpansionindexjs116_identity(e) {
  return e;
}

function _braceexpansionindexjs116_embrace(str) {
  return '{' + str + '}';
}
function _braceexpansionindexjs116_isPadded(el) {
  return (/^-?0\d/.test(el)
  );
}

function _braceexpansionindexjs116_lte(i, y) {
  return i <= y;
}
function _braceexpansionindexjs116_gte(i, y) {
  return i >= y;
}

function _braceexpansionindexjs116_expand(str, isTop) {
  var expansions = [];

  var m = _braceexpansionindexjs116_balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + _braceexpansionindexjs116_escClose + m.post;
      return _braceexpansionindexjs116_expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = _braceexpansionindexjs116_parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = _braceexpansionindexjs116_expand(n[0], false).map(_braceexpansionindexjs116_embrace);
      if (n.length === 1) {
        var post = m.post.length ? _braceexpansionindexjs116_expand(m.post, false) : [''];
        return post.map(function (p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length ? _braceexpansionindexjs116_expand(m.post, false) : [''];

  var N;

  if (isSequence) {
    var x = _braceexpansionindexjs116_numeric(n[0]);
    var y = _braceexpansionindexjs116_numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(_braceexpansionindexjs116_numeric(n[2])) : 1;
    var test = _braceexpansionindexjs116_lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = _braceexpansionindexjs116_gte;
    }
    var pad = n.some(_braceexpansionindexjs116_isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\') c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = _braceexpansionindexjs116_concatMap(n, function (el) {
      return _braceexpansionindexjs116_expand(el, false);
    });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion) expansions.push(expansion);
    }
  }

  return expansions;
}
/*≠≠ node_modules/brace-expansion/index.js ≠≠*/

/*== node_modules/recur-fs/node_modules/minimatch/minimatch.js ==*/
$m['minimatch/minimatch.js#3.0.2'] = { exports: {} };
$m['minimatch/minimatch.js#3.0.2'].exports = _minimatchminimatchjs302_minimatch;
_minimatchminimatchjs302_minimatch.Minimatch = _minimatchminimatchjs302_Minimatch;

var _minimatchminimatchjs302_path = { sep: '/' };
try {
  _minimatchminimatchjs302_path = require('path');
} catch (er) {}

var _minimatchminimatchjs302_GLOBSTAR = _minimatchminimatchjs302_minimatch.GLOBSTAR = _minimatchminimatchjs302_Minimatch.GLOBSTAR = {};
var _minimatchminimatchjs302_expand = $m['brace-expansion/index.js#1.1.6'].exports;

// any single thing other than /
// don't need to escape / when using new RegExp()
var _minimatchminimatchjs302_qmark = '[^/]';

// * => any number of characters
var _minimatchminimatchjs302_star = _minimatchminimatchjs302_qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var _minimatchminimatchjs302_twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var _minimatchminimatchjs302_twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var _minimatchminimatchjs302_reSpecials = _minimatchminimatchjs302_charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function _minimatchminimatchjs302_charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var _minimatchminimatchjs302_slashSplit = /\/+/;

_minimatchminimatchjs302_minimatch.filter = _minimatchminimatchjs302_filter;
function _minimatchminimatchjs302_filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return _minimatchminimatchjs302_minimatch(p, pattern, options);
  };
}

function _minimatchminimatchjs302_ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t;
}

_minimatchminimatchjs302_minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs302_minimatch;

  var orig = _minimatchminimatchjs302_minimatch;

  var m = function minimatch(p, pattern, options) {
    return orig.minimatch(p, pattern, _minimatchminimatchjs302_ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, _minimatchminimatchjs302_ext(def, options));
  };

  return m;
};

_minimatchminimatchjs302_Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs302_Minimatch;
  return _minimatchminimatchjs302_minimatch.defaults(def).Minimatch;
};

function _minimatchminimatchjs302_minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === '';

  return new _minimatchminimatchjs302_Minimatch(pattern, options).match(p);
}

function _minimatchminimatchjs302_Minimatch(pattern, options) {
  if (!(this instanceof _minimatchminimatchjs302_Minimatch)) {
    return new _minimatchminimatchjs302_Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (_minimatchminimatchjs302_path.sep !== '/') {
    pattern = pattern.split(_minimatchminimatchjs302_path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

_minimatchminimatchjs302_Minimatch.prototype.debug = function () {};

_minimatchminimatchjs302_Minimatch.prototype.make = _minimatchminimatchjs302_make;
function _minimatchminimatchjs302_make() {
  // don't do it more than once.
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(_minimatchminimatchjs302_slashSplit);
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

_minimatchminimatchjs302_Minimatch.prototype.parseNegate = _minimatchminimatchjs302_parseNegate;
function _minimatchminimatchjs302_parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
_minimatchminimatchjs302_minimatch.braceExpand = function (pattern, options) {
  return _minimatchminimatchjs302_braceExpand(pattern, options);
};

_minimatchminimatchjs302_Minimatch.prototype.braceExpand = _minimatchminimatchjs302_braceExpand;

function _minimatchminimatchjs302_braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof _minimatchminimatchjs302_Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern];
  }

  return _minimatchminimatchjs302_expand(pattern);
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
_minimatchminimatchjs302_Minimatch.prototype.parse = _minimatchminimatchjs302_parse;
var _minimatchminimatchjs302_SUBPARSE = {};
function _minimatchminimatchjs302_parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long');
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return _minimatchminimatchjs302_GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var plType;
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += _minimatchminimatchjs302_star;
          hasMagic = true;
          break;
        case '?':
          re += _minimatchminimatchjs302_qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && _minimatchminimatchjs302_reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false;

      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;

      case '(':
        if (inClass) {
          re += '(';
          continue;
        }

        if (!stateChar) {
          re += '\\(';
          continue;
        }

        plType = stateChar;
        patternListStack.push({
          type: plType,
          start: i - 1,
          reStart: re.length
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }

        clearStateChar();
        hasMagic = true;
        re += ')';
        var pl = patternListStack.pop();
        plType = pl.type;
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case '!':
            negativeLists.push(pl);
            re += ')[^/]*?)';
            pl.reEnd = re.length;
            break;
          case '?':
          case '+':
          case '*':
            re += plType;
            break;
          case '@':
            break; // the default anyway
        }
        continue;

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }

        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue;
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, _minimatchminimatchjs302_SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (_minimatchminimatchjs302_reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, _minimatchminimatchjs302_SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });

    this.debug('tail=%j\n   %s', tail, tail);
    var t = pl.type === '*' ? _minimatchminimatchjs302_star : pl.type === '?' ? _minimatchminimatchjs302_qmark : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== _minimatchminimatchjs302_SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === _minimatchminimatchjs302_SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return _minimatchminimatchjs302_globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

_minimatchminimatchjs302_minimatch.makeRe = function (pattern, options) {
  return new _minimatchminimatchjs302_Minimatch(pattern, options || {}).makeRe();
};

_minimatchminimatchjs302_Minimatch.prototype.makeRe = _minimatchminimatchjs302_makeRe;
function _minimatchminimatchjs302_makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? _minimatchminimatchjs302_star : options.dot ? _minimatchminimatchjs302_twoStarDot : _minimatchminimatchjs302_twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === _minimatchminimatchjs302_GLOBSTAR ? twoStar : typeof p === 'string' ? _minimatchminimatchjs302_regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}

_minimatchminimatchjs302_minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new _minimatchminimatchjs302_Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};

_minimatchminimatchjs302_Minimatch.prototype.match = _minimatchminimatchjs302_match;
function _minimatchminimatchjs302_match(f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;

  // windows: need to use /, not \
  if (_minimatchminimatchjs302_path.sep !== '/') {
    f = f.split(_minimatchminimatchjs302_path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(_minimatchminimatchjs302_slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
_minimatchminimatchjs302_Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false;

    if (p === _minimatchminimatchjs302_GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
    return emptyFileEnd;
  }

  // should be unreachable.
  throw new Error('wtf?');
};

// replace stuff like \* with *
function _minimatchminimatchjs302_globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function _minimatchminimatchjs302_regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/*≠≠ node_modules/recur-fs/node_modules/minimatch/minimatch.js ≠≠*/

/*== node_modules/recur-fs/lib/hunt.js ==*/
$m['recur-fs/lib/hunt.js#2.2.3'] = { exports: {} };
var _recurfslibhuntjs223_fs = require('fs'),
    _recurfslibhuntjs223_Minimatch = $m['minimatch/minimatch.js#3.0.2'].exports.Minimatch,
    _recurfslibhuntjs223_path = require('path'),
    _recurfslibhuntjs223_walk = $m['recur-fs/lib/walk.js#2.2.3'].exports;

/**
 * Walk directory tree from 'directory', returning all resources matching 'matcher'.
 * 'matcher' can be glob string, or function that returns 'isMatch'.
 * Stops walking when root directory reached, on first match if 'stopOnFirstMatch',
 * or if "true" is returned as second argument from 'next'.
 * @param {String} directory
 * @param {String|Function} matcher(resource, stat, next)
 * @param {Boolean} stopOnFirstMatch
 * @param {Function} fn(err, matches)
 */
$m['recur-fs/lib/hunt.js#2.2.3'].exports = function hunt(directory, matcher, stopOnFirstMatch, fn) {
	directory = _recurfslibhuntjs223_path.resolve(directory);

	// Convert glob string to async matcher function
	if ('string' == typeof matcher) {
		var match = new _recurfslibhuntjs223_Minimatch(matcher, { matchBase: true });
		matcher = function matcher(resource, stat, done) {
			done(match.match(resource));
		};
	}

	var matches = [],
	    finished = false;

	// Walk and match each resource
	_recurfslibhuntjs223_walk(directory, function (resource, stat, next) {
		if (!finished) {
			matcher(resource, stat, function (isMatch, stop) {
				if (isMatch) {
					matches.push(resource);
					finished = stopOnFirstMatch;
				}

				if (stop === true) finished = true;

				// Stop walking if finished
				next(finished);
			});
		}
	}, function (err) {
		if (err) return fn(err);
		return fn(null, stopOnFirstMatch ? matches[0] : matches);
	});
};

/**
 * Synchronously walk directory tree from 'directory', returning all resources matching 'matcher'.
 * 'matcher' can be glob string, or function that returns 'isMatch'.
 * Stops walking when root directory reached, or on first match if 'stopOnFirstMatch'.
 * @param {String} directory
 * @param {String|Function} matcher(resource, next)
 * @param {Boolean} stopOnFirstMatch
 * @returns (Array|String}
 */
$m['recur-fs/lib/hunt.js#2.2.3'].exports.sync = function huntSync(directory, matcher, stopOnFirstMatch) {
	directory = _recurfslibhuntjs223_path.resolve(directory);

	if ('string' == typeof matcher) {
		var match = new _recurfslibhuntjs223_Minimatch(matcher, { matchBase: true });
		matcher = function matcher(resource) {
			return match.match(resource);
		};
	}

	var matches = [],
	    finished = false;

	// Walk and match each resource
	_recurfslibhuntjs223_walk.sync(directory, function (resource, stat) {
		if (!finished) {
			var isMatch = matcher(resource, stat);
			if (isMatch) {
				matches.push(resource);
				finished = stopOnFirstMatch;
				if (finished) return true;
			}
		}
	});

	return stopOnFirstMatch ? matches[0] : matches;
};
/*≠≠ node_modules/recur-fs/lib/hunt.js ≠≠*/

/*== node_modules/wrappy/wrappy.js ==*/
$m['wrappy/wrappy.js#1.0.2'] = { exports: {} };
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
$m['wrappy/wrappy.js#1.0.2'].exports = _wrappywrappyjs102_wrappy;
function _wrappywrappyjs102_wrappy(fn, cb) {
  if (fn && cb) return _wrappywrappyjs102_wrappy(fn)(cb);

  if (typeof fn !== 'function') throw new TypeError('need wrapper function');

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret;
  }
}
/*≠≠ node_modules/wrappy/wrappy.js ≠≠*/

/*== node_modules/once/once.js ==*/
$m['once/once.js#1.4.0'] = { exports: {} };
var _onceoncejs140_wrappy = $m['wrappy/wrappy.js#1.0.2'].exports;
$m['once/once.js#1.4.0'].exports = _onceoncejs140_wrappy(_onceoncejs140_once);
$m['once/once.js#1.4.0'].exports.strict = _onceoncejs140_wrappy(_onceoncejs140_onceStrict);

_onceoncejs140_once.proto = _onceoncejs140_once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return _onceoncejs140_once(this);
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return _onceoncejs140_onceStrict(this);
    },
    configurable: true
  });
});

function _onceoncejs140_once(fn) {
  var f = function () {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}

function _onceoncejs140_onceStrict(fn) {
  var f = function () {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
/*≠≠ node_modules/once/once.js ≠≠*/

/*== node_modules/inflight/inflight.js ==*/
$m['inflight/inflight.js#1.0.5'] = { exports: {} };
var _inflightinflightjs105_wrappy = $m['wrappy/wrappy.js#1.0.2'].exports;
var _inflightinflightjs105_reqs = Object.create(null);
var _inflightinflightjs105_once = $m['once/once.js#1.4.0'].exports;

$m['inflight/inflight.js#1.0.5'].exports = _inflightinflightjs105_wrappy(_inflightinflightjs105_inflight);

function _inflightinflightjs105_inflight(key, cb) {
  if (_inflightinflightjs105_reqs[key]) {
    _inflightinflightjs105_reqs[key].push(cb);
    return null;
  } else {
    _inflightinflightjs105_reqs[key] = [cb];
    return _inflightinflightjs105_makeres(key);
  }
}

function _inflightinflightjs105_makeres(key) {
  return _inflightinflightjs105_once(function RES() {
    var cbs = _inflightinflightjs105_reqs[key];
    var len = cbs.length;
    var args = _inflightinflightjs105_slice(arguments);
    for (var i = 0; i < len; i++) {
      cbs[i].apply(null, args);
    }
    if (cbs.length > len) {
      // added more in the interim.
      // de-zalgo, just in case, but don't call again.
      cbs.splice(0, len);
      process.nextTick(function () {
        RES.apply(null, args);
      });
    } else {
      delete _inflightinflightjs105_reqs[key];
    }
  });
}

function _inflightinflightjs105_slice(args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];
  return array;
}
/*≠≠ node_modules/inflight/inflight.js ≠≠*/

/*== node_modules/path-is-absolute/index.js ==*/
$m['path-is-absolute/index.js#1.0.0'] = { exports: {} };
'use strict';

function _pathisabsoluteindexjs100_posix(path) {
	return path.charAt(0) === '/';
};

function _pathisabsoluteindexjs100_win32(path) {
	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = !!device && device.charAt(1) !== ':';

	// UNC paths are always absolute
	return !!result[2] || isUnc;
};

$m['path-is-absolute/index.js#1.0.0'].exports = process.platform === 'win32' ? _pathisabsoluteindexjs100_win32 : _pathisabsoluteindexjs100_posix;
$m['path-is-absolute/index.js#1.0.0'].exports.posix = _pathisabsoluteindexjs100_posix;
$m['path-is-absolute/index.js#1.0.0'].exports.win32 = _pathisabsoluteindexjs100_win32;
/*≠≠ node_modules/path-is-absolute/index.js ≠≠*/

/*== node_modules/minimatch/minimatch.js ==*/
$m['minimatch/minimatch.js#3.0.3'] = { exports: {} };
$m['minimatch/minimatch.js#3.0.3'].exports = _minimatchminimatchjs303_minimatch;
_minimatchminimatchjs303_minimatch.Minimatch = _minimatchminimatchjs303_Minimatch;

var _minimatchminimatchjs303_path = { sep: '/' };
try {
  _minimatchminimatchjs303_path = require('path');
} catch (er) {}

var _minimatchminimatchjs303_GLOBSTAR = _minimatchminimatchjs303_minimatch.GLOBSTAR = _minimatchminimatchjs303_Minimatch.GLOBSTAR = {};
var _minimatchminimatchjs303_expand = $m['brace-expansion/index.js#1.1.6'].exports;

var _minimatchminimatchjs303_plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var _minimatchminimatchjs303_qmark = '[^/]';

// * => any number of characters
var _minimatchminimatchjs303_star = _minimatchminimatchjs303_qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var _minimatchminimatchjs303_twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var _minimatchminimatchjs303_twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var _minimatchminimatchjs303_reSpecials = _minimatchminimatchjs303_charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function _minimatchminimatchjs303_charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var _minimatchminimatchjs303_slashSplit = /\/+/;

_minimatchminimatchjs303_minimatch.filter = _minimatchminimatchjs303_filter;
function _minimatchminimatchjs303_filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return _minimatchminimatchjs303_minimatch(p, pattern, options);
  };
}

function _minimatchminimatchjs303_ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t;
}

_minimatchminimatchjs303_minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs303_minimatch;

  var orig = _minimatchminimatchjs303_minimatch;

  var m = function minimatch(p, pattern, options) {
    return orig.minimatch(p, pattern, _minimatchminimatchjs303_ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, _minimatchminimatchjs303_ext(def, options));
  };

  return m;
};

_minimatchminimatchjs303_Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return _minimatchminimatchjs303_Minimatch;
  return _minimatchminimatchjs303_minimatch.defaults(def).Minimatch;
};

function _minimatchminimatchjs303_minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === '';

  return new _minimatchminimatchjs303_Minimatch(pattern, options).match(p);
}

function _minimatchminimatchjs303_Minimatch(pattern, options) {
  if (!(this instanceof _minimatchminimatchjs303_Minimatch)) {
    return new _minimatchminimatchjs303_Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (_minimatchminimatchjs303_path.sep !== '/') {
    pattern = pattern.split(_minimatchminimatchjs303_path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

_minimatchminimatchjs303_Minimatch.prototype.debug = function () {};

_minimatchminimatchjs303_Minimatch.prototype.make = _minimatchminimatchjs303_make;
function _minimatchminimatchjs303_make() {
  // don't do it more than once.
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(_minimatchminimatchjs303_slashSplit);
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

_minimatchminimatchjs303_Minimatch.prototype.parseNegate = _minimatchminimatchjs303_parseNegate;
function _minimatchminimatchjs303_parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
_minimatchminimatchjs303_minimatch.braceExpand = function (pattern, options) {
  return _minimatchminimatchjs303_braceExpand(pattern, options);
};

_minimatchminimatchjs303_Minimatch.prototype.braceExpand = _minimatchminimatchjs303_braceExpand;

function _minimatchminimatchjs303_braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof _minimatchminimatchjs303_Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern];
  }

  return _minimatchminimatchjs303_expand(pattern);
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
_minimatchminimatchjs303_Minimatch.prototype.parse = _minimatchminimatchjs303_parse;
var _minimatchminimatchjs303_SUBPARSE = {};
function _minimatchminimatchjs303_parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long');
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return _minimatchminimatchjs303_GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += _minimatchminimatchjs303_star;
          hasMagic = true;
          break;
        case '?':
          re += _minimatchminimatchjs303_qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && _minimatchminimatchjs303_reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false;

      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;

      case '(':
        if (inClass) {
          re += '(';
          continue;
        }

        if (!stateChar) {
          re += '\\(';
          continue;
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: _minimatchminimatchjs303_plTypes[stateChar].open,
          close: _minimatchminimatchjs303_plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }

        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue;
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, _minimatchminimatchjs303_SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (_minimatchminimatchjs303_reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, _minimatchminimatchjs303_SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });

    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? _minimatchminimatchjs303_star : pl.type === '?' ? _minimatchminimatchjs303_qmark : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== _minimatchminimatchjs303_SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === _minimatchminimatchjs303_SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return _minimatchminimatchjs303_globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

_minimatchminimatchjs303_minimatch.makeRe = function (pattern, options) {
  return new _minimatchminimatchjs303_Minimatch(pattern, options || {}).makeRe();
};

_minimatchminimatchjs303_Minimatch.prototype.makeRe = _minimatchminimatchjs303_makeRe;
function _minimatchminimatchjs303_makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? _minimatchminimatchjs303_star : options.dot ? _minimatchminimatchjs303_twoStarDot : _minimatchminimatchjs303_twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === _minimatchminimatchjs303_GLOBSTAR ? twoStar : typeof p === 'string' ? _minimatchminimatchjs303_regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}

_minimatchminimatchjs303_minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new _minimatchminimatchjs303_Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};

_minimatchminimatchjs303_Minimatch.prototype.match = _minimatchminimatchjs303_match;
function _minimatchminimatchjs303_match(f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;

  // windows: need to use /, not \
  if (_minimatchminimatchjs303_path.sep !== '/') {
    f = f.split(_minimatchminimatchjs303_path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(_minimatchminimatchjs303_slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
_minimatchminimatchjs303_Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false;

    if (p === _minimatchminimatchjs303_GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
    return emptyFileEnd;
  }

  // should be unreachable.
  throw new Error('wtf?');
};

// replace stuff like \* with *
function _minimatchminimatchjs303_globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function _minimatchminimatchjs303_regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/*≠≠ node_modules/minimatch/minimatch.js ≠≠*/

/*== node_modules/glob/common.js ==*/
$m['glob/common.js#7.0.6'] = { exports: {} };
$m['glob/common.js#7.0.6'].exports.alphasort = _globcommonjs706_alphasort;
$m['glob/common.js#7.0.6'].exports.alphasorti = _globcommonjs706_alphasorti;
$m['glob/common.js#7.0.6'].exports.setopts = _globcommonjs706_setopts;
$m['glob/common.js#7.0.6'].exports.ownProp = _globcommonjs706_ownProp;
$m['glob/common.js#7.0.6'].exports.makeAbs = _globcommonjs706_makeAbs;
$m['glob/common.js#7.0.6'].exports.finish = _globcommonjs706_finish;
$m['glob/common.js#7.0.6'].exports.mark = _globcommonjs706_mark;
$m['glob/common.js#7.0.6'].exports.isIgnored = _globcommonjs706_isIgnored;
$m['glob/common.js#7.0.6'].exports.childrenIgnored = _globcommonjs706_childrenIgnored;

function _globcommonjs706_ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}

var _globcommonjs706_path = require("path");
var _globcommonjs706_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globcommonjs706_isAbsolute = $m['path-is-absolute/index.js#1.0.0'].exports;
var _globcommonjs706_Minimatch = _globcommonjs706_minimatch.Minimatch;

function _globcommonjs706_alphasorti(a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase());
}

function _globcommonjs706_alphasort(a, b) {
  return a.localeCompare(b);
}

function _globcommonjs706_setupIgnores(self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(_globcommonjs706_ignoreMap);
  }
}

// ignore patterns are always in dot:true mode.
function _globcommonjs706_ignoreMap(pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
    gmatcher = new _globcommonjs706_Minimatch(gpattern, { dot: true });
  }

  return {
    matcher: new _globcommonjs706_Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  };
}

function _globcommonjs706_setopts(self, pattern, options) {
  if (!options) options = {};

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir) self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  _globcommonjs706_setupIgnores(self, options);

  self.changedCwd = false;
  var cwd = process.cwd();
  if (!_globcommonjs706_ownProp(options, "cwd")) self.cwd = cwd;else {
    self.cwd = _globcommonjs706_path.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || _globcommonjs706_path.resolve(self.cwd, "/");
  self.root = _globcommonjs706_path.resolve(self.root);
  if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/");

  self.cwdAbs = _globcommonjs706_makeAbs(self, self.cwd);
  self.nomount = !!options.nomount;

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true;
  options.nocomment = true;

  self.minimatch = new _globcommonjs706_Minimatch(pattern, options);
  self.options = self.minimatch.options;
}

function _globcommonjs706_finish(self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i++) {
    var matches = self.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou) all.push(literal);else all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou) all.push.apply(all, m);else m.forEach(function (m) {
        all[m] = true;
      });
    }
  }

  if (!nou) all = Object.keys(all);

  if (!self.nosort) all = all.sort(self.nocase ? _globcommonjs706_alphasorti : _globcommonjs706_alphasort);

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !/\/$/.test(e);
        var c = self.cache[e] || self.cache[_globcommonjs706_makeAbs(self, e)];
        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir;
      });
    }
  }

  if (self.ignore.length) all = all.filter(function (m) {
    return !_globcommonjs706_isIgnored(self, m);
  });

  self.found = all;
}

function _globcommonjs706_mark(self, p) {
  var abs = _globcommonjs706_makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';

    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);

    if (m !== p) {
      var mabs = _globcommonjs706_makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m;
}

// lotta situps...
function _globcommonjs706_makeAbs(self, f) {
  var abs = f;
  if (f.charAt(0) === '/') {
    abs = _globcommonjs706_path.join(self.root, f);
  } else if (_globcommonjs706_isAbsolute(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = _globcommonjs706_path.resolve(self.cwd, f);
  } else {
    abs = _globcommonjs706_path.resolve(f);
  }

  if (process.platform === 'win32') abs = abs.replace(/\\/g, '/');

  return abs;
}

// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function _globcommonjs706_isIgnored(self, path) {
  if (!self.ignore.length) return false;

  return self.ignore.some(function (item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
  });
}

function _globcommonjs706_childrenIgnored(self, path) {
  if (!self.ignore.length) return false;

  return self.ignore.some(function (item) {
    return !!(item.gmatcher && item.gmatcher.match(path));
  });
}
/*≠≠ node_modules/glob/common.js ≠≠*/

/*== node_modules/fs.realpath/old.js ==*/
$m['fs.realpath/old.js#1.0.0'] = { exports: {} };
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var _fsrealpatholdjs100_pathModule = require('path');
var _fsrealpatholdjs100_isWindows = process.platform === 'win32';
var _fsrealpatholdjs100_fs = require('fs');

// JavaScript implementation of realpath, ported from node pre-v6

var _fsrealpatholdjs100_DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function _fsrealpatholdjs100_rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (_fsrealpatholdjs100_DEBUG) {
    var backtrace = new Error();
    callback = debugCallback;
  } else callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process.traceDeprecation) console.trace(msg);else console.error(msg);
        }
    }
  }
}

function _fsrealpatholdjs100_maybeCallback(cb) {
  return typeof cb === 'function' ? cb : _fsrealpatholdjs100_rethrow();
}

var _fsrealpatholdjs100_normalize = _fsrealpatholdjs100_pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (_fsrealpatholdjs100_isWindows) {
  var _fsrealpatholdjs100_nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var _fsrealpatholdjs100_nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (_fsrealpatholdjs100_isWindows) {
  var _fsrealpatholdjs100_splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var _fsrealpatholdjs100_splitRootRe = /^[\/]*/;
}

$m['fs.realpath/old.js#1.0.0'].exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = _fsrealpatholdjs100_pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = _fsrealpatholdjs100_splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (_fsrealpatholdjs100_isWindows && !knownHard[base]) {
      _fsrealpatholdjs100_fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    _fsrealpatholdjs100_nextPartRe.lastIndex = pos;
    var result = _fsrealpatholdjs100_nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = _fsrealpatholdjs100_nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || cache && cache[base] === base) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = _fsrealpatholdjs100_fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!_fsrealpatholdjs100_isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        _fsrealpatholdjs100_fs.statSync(base);
        linkTarget = _fsrealpatholdjs100_fs.readlinkSync(base);
      }
      resolvedLink = _fsrealpatholdjs100_pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!_fsrealpatholdjs100_isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = _fsrealpatholdjs100_pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};

$m['fs.realpath/old.js#1.0.0'].exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = _fsrealpatholdjs100_maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = _fsrealpatholdjs100_pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = _fsrealpatholdjs100_splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (_fsrealpatholdjs100_isWindows && !knownHard[base]) {
      _fsrealpatholdjs100_fs.lstat(base, function (err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    _fsrealpatholdjs100_nextPartRe.lastIndex = pos;
    var result = _fsrealpatholdjs100_nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = _fsrealpatholdjs100_nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || cache && cache[base] === base) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return _fsrealpatholdjs100_fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!_fsrealpatholdjs100_isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    _fsrealpatholdjs100_fs.stat(base, function (err) {
      if (err) return cb(err);

      _fsrealpatholdjs100_fs.readlink(base, function (err, target) {
        if (!_fsrealpatholdjs100_isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = _fsrealpatholdjs100_pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = _fsrealpatholdjs100_pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
/*≠≠ node_modules/fs.realpath/old.js ≠≠*/

/*== node_modules/fs.realpath/index.js ==*/
$m['fs.realpath/index.js#1.0.0'] = { exports: {} };
$m['fs.realpath/index.js#1.0.0'].exports = _fsrealpathindexjs100_realpath;
_fsrealpathindexjs100_realpath.realpath = _fsrealpathindexjs100_realpath;
_fsrealpathindexjs100_realpath.sync = _fsrealpathindexjs100_realpathSync;
_fsrealpathindexjs100_realpath.realpathSync = _fsrealpathindexjs100_realpathSync;
_fsrealpathindexjs100_realpath.monkeypatch = _fsrealpathindexjs100_monkeypatch;
_fsrealpathindexjs100_realpath.unmonkeypatch = _fsrealpathindexjs100_unmonkeypatch;

var _fsrealpathindexjs100_fs = require('fs');
var _fsrealpathindexjs100_origRealpath = _fsrealpathindexjs100_fs.realpath;
var _fsrealpathindexjs100_origRealpathSync = _fsrealpathindexjs100_fs.realpathSync;

var _fsrealpathindexjs100_version = process.version;
var _fsrealpathindexjs100_ok = /^v[0-5]\./.test(_fsrealpathindexjs100_version);
var _fsrealpathindexjs100_old = $m['fs.realpath/old.js#1.0.0'].exports;

function _fsrealpathindexjs100_newError(er) {
  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
}

function _fsrealpathindexjs100_realpath(p, cache, cb) {
  if (_fsrealpathindexjs100_ok) {
    return _fsrealpathindexjs100_origRealpath(p, cache, cb);
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }
  _fsrealpathindexjs100_origRealpath(p, cache, function (er, result) {
    if (_fsrealpathindexjs100_newError(er)) {
      _fsrealpathindexjs100_old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function _fsrealpathindexjs100_realpathSync(p, cache) {
  if (_fsrealpathindexjs100_ok) {
    return _fsrealpathindexjs100_origRealpathSync(p, cache);
  }

  try {
    return _fsrealpathindexjs100_origRealpathSync(p, cache);
  } catch (er) {
    if (_fsrealpathindexjs100_newError(er)) {
      return _fsrealpathindexjs100_old.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}

function _fsrealpathindexjs100_monkeypatch() {
  _fsrealpathindexjs100_fs.realpath = _fsrealpathindexjs100_realpath;
  _fsrealpathindexjs100_fs.realpathSync = _fsrealpathindexjs100_realpathSync;
}

function _fsrealpathindexjs100_unmonkeypatch() {
  _fsrealpathindexjs100_fs.realpath = _fsrealpathindexjs100_origRealpath;
  _fsrealpathindexjs100_fs.realpathSync = _fsrealpathindexjs100_origRealpathSync;
}
/*≠≠ node_modules/fs.realpath/index.js ≠≠*/

/*== node_modules/glob/sync.js ==*/
$m['glob/sync.js#7.0.6'] = function () {
$m['glob/sync.js#7.0.6'] = { exports: {} };
$m['glob/sync.js#7.0.6'].exports = _globsyncjs706_globSync;
_globsyncjs706_globSync.GlobSync = _globsyncjs706_GlobSync;

var _globsyncjs706_fs = require('fs');
var _globsyncjs706_rp = $m['fs.realpath/index.js#1.0.0'].exports;
var _globsyncjs706_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globsyncjs706_Minimatch = _globsyncjs706_minimatch.Minimatch;
var _globsyncjs706_Glob = $m['glob/glob.js#7.0.6'].exports.Glob;
var _globsyncjs706_util = require('util');
var _globsyncjs706_path = require('path');
var _globsyncjs706_assert = require('assert');
var _globsyncjs706_isAbsolute = $m['path-is-absolute/index.js#1.0.0'].exports;
var _globsyncjs706_common = $m['glob/common.js#7.0.6'].exports;
var _globsyncjs706_alphasort = _globsyncjs706_common.alphasort;
var _globsyncjs706_alphasorti = _globsyncjs706_common.alphasorti;
var _globsyncjs706_setopts = _globsyncjs706_common.setopts;
var _globsyncjs706_ownProp = _globsyncjs706_common.ownProp;
var _globsyncjs706_childrenIgnored = _globsyncjs706_common.childrenIgnored;

function _globsyncjs706_globSync(pattern, options) {
  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

  return new _globsyncjs706_GlobSync(pattern, options).found;
}

function _globsyncjs706_GlobSync(pattern, options) {
  if (!pattern) throw new Error('must provide pattern');

  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

  if (!(this instanceof _globsyncjs706_GlobSync)) return new _globsyncjs706_GlobSync(pattern, options);

  _globsyncjs706_setopts(this, pattern, options);

  if (this.noprocess) return this;

  var n = this.minimatch.set.length;
  this.matches = new Array(n);
  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false);
  }
  this._finish();
}

_globsyncjs706_GlobSync.prototype._finish = function () {
  _globsyncjs706_assert(this instanceof _globsyncjs706_GlobSync);
  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);
      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = _globsyncjs706_rp.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;
        }
      }
    });
  }
  _globsyncjs706_common.finish(this);
};

_globsyncjs706_GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  _globsyncjs706_assert(this instanceof _globsyncjs706_GlobSync);

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n++;
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);
      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null) read = '.';else if (_globsyncjs706_isAbsolute(prefix) || _globsyncjs706_isAbsolute(pattern.join('/'))) {
    if (!prefix || !_globsyncjs706_isAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip processing
  if (_globsyncjs706_childrenIgnored(this, read)) return;

  var isGlobStar = remain[0] === _globsyncjs706_minimatch.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};

_globsyncjs706_GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar);

  // if the abs isn't a dir, then nothing can match!
  if (!entries) return;

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m) matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0) return;

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = _globsyncjs706_path.join(this.root, e);
      }
      this.matches[index][e] = true;
    }
    // This was the last one, and no stats were needed
    return;
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) newPattern = [prefix, e];else newPattern = [e];
    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};

_globsyncjs706_GlobSync.prototype._emitMatch = function (index, e) {
  var abs = this._makeAbs(e);
  if (this.mark) e = this._mark(e);

  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[this._makeAbs(e)];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;
  if (this.stat) this._stat(e);
};

_globsyncjs706_GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow) return this._readdir(abs, false);

  var entries;
  var lstat;
  var stat;
  try {
    lstat = _globsyncjs706_fs.lstatSync(abs);
  } catch (er) {
    // lstat failed, doesn't exist
    return null;
  }

  var isSym = lstat.isSymbolicLink();
  this.symlinks[abs] = isSym;

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);

  return entries;
};

_globsyncjs706_GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries;

  if (inGlobStar && !_globsyncjs706_ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);

  if (_globsyncjs706_ownProp(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return null;

    if (Array.isArray(c)) return c;
  }

  try {
    return this._readdirEntries(abs, _globsyncjs706_fs.readdirSync(abs));
  } catch (er) {
    this._readdirError(abs, er);
    return null;
  }
};

_globsyncjs706_GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;

  // mark and cache dir-ness
  return entries;
};

_globsyncjs706_GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error;
      }
      break;

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) throw er;
      if (!this.silent) console.error('glob error', er);
      break;
  }
};

_globsyncjs706_GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar);

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return;

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs];

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar) return;

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue;

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true);
  }
};

_globsyncjs706_GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index]) this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists) return;

  if (prefix && _globsyncjs706_isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = _globsyncjs706_path.join(this.root, prefix);
    } else {
      prefix = _globsyncjs706_path.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this.matches[index][prefix] = true;
};

// Returns either 'DIR', 'FILE', or false
_globsyncjs706_GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength) return false;

  if (!this.stat && _globsyncjs706_ownProp(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c)) c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR') return c;

    if (needDir && c === 'FILE') return false;

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (!stat) {
    var lstat;
    try {
      lstat = _globsyncjs706_fs.lstatSync(abs);
    } catch (er) {
      return false;
    }

    if (lstat.isSymbolicLink()) {
      try {
        stat = _globsyncjs706_fs.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;

  var c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c !== 'DIR') return false;

  return c;
};

_globsyncjs706_GlobSync.prototype._mark = function (p) {
  return _globsyncjs706_common.mark(this, p);
};

_globsyncjs706_GlobSync.prototype._makeAbs = function (f) {
  return _globsyncjs706_common.makeAbs(this, f);
};
};
/*≠≠ node_modules/glob/sync.js ≠≠*/

/*== node_modules/glob/glob.js ==*/
$m['glob/glob.js#7.0.6'] = { exports: {} };
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

$m['glob/glob.js#7.0.6'].exports = _globglobjs706_glob;

var _globglobjs706_fs = require('fs');
var _globglobjs706_rp = $m['fs.realpath/index.js#1.0.0'].exports;
var _globglobjs706_minimatch = $m['minimatch/minimatch.js#3.0.3'].exports;
var _globglobjs706_Minimatch = _globglobjs706_minimatch.Minimatch;
var _globglobjs706_inherits = $m['inherits/inherits_browser.js#2.0.3'].exports;
var _globglobjs706_EE = require('events').EventEmitter;
var _globglobjs706_path = require('path');
var _globglobjs706_assert = require('assert');
var _globglobjs706_isAbsolute = $m['path-is-absolute/index.js#1.0.0'].exports;
var _globglobjs706_globSync = require('glob/sync.js#7.0.6');
var _globglobjs706_common = $m['glob/common.js#7.0.6'].exports;
var _globglobjs706_alphasort = _globglobjs706_common.alphasort;
var _globglobjs706_alphasorti = _globglobjs706_common.alphasorti;
var _globglobjs706_setopts = _globglobjs706_common.setopts;
var _globglobjs706_ownProp = _globglobjs706_common.ownProp;
var _globglobjs706_inflight = $m['inflight/inflight.js#1.0.5'].exports;
var _globglobjs706_util = require('util');
var _globglobjs706_childrenIgnored = _globglobjs706_common.childrenIgnored;
var _globglobjs706_isIgnored = _globglobjs706_common.isIgnored;

var _globglobjs706_once = $m['once/once.js#1.4.0'].exports;

function _globglobjs706_glob(pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return _globglobjs706_globSync(pattern, options);
  }

  return new _globglobjs706_Glob(pattern, options, cb);
}

_globglobjs706_glob.sync = _globglobjs706_globSync;
var _globglobjs706_GlobSync = _globglobjs706_glob.GlobSync = _globglobjs706_globSync.GlobSync;

// old api surface
_globglobjs706_glob.glob = _globglobjs706_glob;

function _globglobjs706_extend(origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin;
  }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

_globglobjs706_glob.hasMagic = function (pattern, options_) {
  var options = _globglobjs706_extend({}, options_);
  options.noprocess = true;

  var g = new _globglobjs706_Glob(pattern, options);
  var set = g.minimatch.set;

  if (!pattern) return false;

  if (set.length > 1) return true;

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string') return true;
  }

  return false;
};

_globglobjs706_glob.Glob = _globglobjs706_Glob;
_globglobjs706_inherits(_globglobjs706_Glob, _globglobjs706_EE);
function _globglobjs706_Glob(pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return new _globglobjs706_GlobSync(pattern, options);
  }

  if (!(this instanceof _globglobjs706_Glob)) return new _globglobjs706_Glob(pattern, options, cb);

  _globglobjs706_setopts(this, pattern, options);
  this._didRealPath = false;

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length;

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = _globglobjs706_once(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  var n = this.minimatch.set.length;
  this._processing = 0;
  this.matches = new Array(n);

  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;

  if (this.noprocess) return this;

  if (n === 0) return done();

  var sync = true;
  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false, done);
  }
  sync = false;

  function done() {
    --self._processing;
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

_globglobjs706_Glob.prototype._finish = function () {
  _globglobjs706_assert(this instanceof _globglobjs706_Glob);
  if (this.aborted) return;

  if (this.realpath && !this._didRealpath) return this._realpath();

  _globglobjs706_common.finish(this);
  this.emit('end', this.found);
};

_globglobjs706_Glob.prototype._realpath = function () {
  if (this._didRealpath) return;

  this._didRealpath = true;

  var n = this.matches.length;
  if (n === 0) return this._finish();

  var self = this;
  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);

  function next() {
    if (--n === 0) self._finish();
  }
};

_globglobjs706_Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset) return cb();

  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;

  if (n === 0) return cb();

  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    _globglobjs706_rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

_globglobjs706_Glob.prototype._mark = function (p) {
  return _globglobjs706_common.mark(this, p);
};

_globglobjs706_Glob.prototype._makeAbs = function (f) {
  return _globglobjs706_common.makeAbs(this, f);
};

_globglobjs706_Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

_globglobjs706_Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

_globglobjs706_Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);
      this._emitQueue.length = 0;
      for (var i = 0; i < eq.length; i++) {
        var e = eq[i];
        this._emitMatch(e[0], e[1]);
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);
      this._processQueue.length = 0;
      for (var i = 0; i < pq.length; i++) {
        var p = pq[i];
        this._processing--;
        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

_globglobjs706_Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  _globglobjs706_assert(this instanceof _globglobjs706_Glob);
  _globglobjs706_assert(typeof cb === 'function');

  if (this.aborted) return;

  this._processing++;
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);
    return;
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n++;
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);
      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null) read = '.';else if (_globglobjs706_isAbsolute(prefix) || _globglobjs706_isAbsolute(pattern.join('/'))) {
    if (!prefix || !_globglobjs706_isAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip _processing
  if (_globglobjs706_childrenIgnored(this, read)) return cb();

  var isGlobStar = remain[0] === _globglobjs706_minimatch.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

_globglobjs706_Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

_globglobjs706_Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries) return cb();

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m) matchedEntries.push(e);
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0) return cb();

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = _globglobjs706_path.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return cb();
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) {
      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
    }
    this._process([e].concat(remain), index, inGlobStar, cb);
  }
  cb();
};

_globglobjs706_Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted) return;

  if (this.matches[index][e]) return;

  if (_globglobjs706_isIgnored(this, e)) return;

  if (this.paused) {
    this._emitQueue.push([index, e]);
    return;
  }

  var abs = this._makeAbs(e);

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  if (this.mark) e = this._mark(e);

  this.matches[index][e] = true;

  var st = this.statCache[abs];
  if (st) this.emit('stat', e, st);

  this.emit('match', e);
};

_globglobjs706_Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted) return;

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow) return this._readdir(abs, false, cb);

  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = _globglobjs706_inflight(lstatkey, lstatcb_);

  if (lstatcb) _globglobjs706_fs.lstat(abs, lstatcb);

  function lstatcb_(er, lstat) {
    if (er) return cb();

    var isSym = lstat.isSymbolicLink();
    self.symlinks[abs] = isSym;

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else self._readdir(abs, false, cb);
  }
};

_globglobjs706_Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted) return;

  cb = _globglobjs706_inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
  if (!cb) return;

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !_globglobjs706_ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

  if (_globglobjs706_ownProp(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return cb();

    if (Array.isArray(c)) return cb(null, c);
  }

  var self = this;
  _globglobjs706_fs.readdir(abs, _globglobjs706_readdirCb(this, abs, cb));
};

function _globglobjs706_readdirCb(self, abs, cb) {
  return function (er, entries) {
    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
  };
}

_globglobjs706_Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted) return;

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries);
};

_globglobjs706_Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted) return;

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }
      break;

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) {
        this.emit('error', er);
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort();
      }
      if (!this.silent) console.error('glob error', er);
      break;
  }

  return cb();
};

_globglobjs706_Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

_globglobjs706_Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return cb();

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length;

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar) return cb();

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue;

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true, cb);
  }

  cb();
};

_globglobjs706_Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};
_globglobjs706_Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index]) this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists) return cb();

  if (prefix && _globglobjs706_isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = _globglobjs706_path.join(this.root, prefix);
    } else {
      prefix = _globglobjs706_path.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
  cb();
};

// Returns either 'DIR', 'FILE', or false
_globglobjs706_Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength) return cb();

  if (!this.stat && _globglobjs706_ownProp(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c)) c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR') return cb(null, c);

    if (needDir && c === 'FILE') return cb();

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (stat !== undefined) {
    if (stat === false) return cb(null, stat);else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
    }
  }

  var self = this;
  var statcb = _globglobjs706_inflight('stat\0' + abs, lstatcb_);
  if (statcb) _globglobjs706_fs.lstat(abs, statcb);

  function lstatcb_(er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return _globglobjs706_fs.stat(abs, function (er, stat) {
        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
      });
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

_globglobjs706_Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er) {
    this.statCache[abs] = false;
    return cb();
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;

  if (abs.slice(-1) === '/' && !stat.isDirectory()) return cb(null, false, stat);

  var c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c !== 'DIR') return cb();

  return cb(null, c, stat);
};
/*≠≠ node_modules/glob/glob.js ≠≠*/

/*== node_modules/recur-fs/node_modules/rimraf/rimraf.js ==*/
$m['rimraf/rimraf.js#2.5.2'] = { exports: {} };
$m['rimraf/rimraf.js#2.5.2'].exports = _rimrafrimrafjs252_rimraf;
_rimrafrimrafjs252_rimraf.sync = _rimrafrimrafjs252_rimrafSync;

var _rimrafrimrafjs252_assert = require("assert");
var _rimrafrimrafjs252_path = require("path");
var _rimrafrimrafjs252_fs = require("fs");
var _rimrafrimrafjs252_glob = $m['glob/glob.js#7.0.6'].exports;

var _rimrafrimrafjs252_defaultGlobOpts = {
  nosort: true,
  silent: true
};

// for EMFILE handling
var _rimrafrimrafjs252_timeout = 0;

var _rimrafrimrafjs252_isWindows = process.platform === "win32";

function _rimrafrimrafjs252_defaults(options) {
  var methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
  methods.forEach(function (m) {
    options[m] = options[m] || _rimrafrimrafjs252_fs[m];
    m = m + 'Sync';
    options[m] = options[m] || _rimrafrimrafjs252_fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
  options.emfileWait = options.emfileWait || 1000;
  if (options.glob === false) {
    options.disableGlob = true;
  }
  options.disableGlob = options.disableGlob || false;
  options.glob = options.glob || _rimrafrimrafjs252_defaultGlobOpts;
}

function _rimrafrimrafjs252_rimraf(p, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  _rimrafrimrafjs252_assert(p, 'rimraf: missing path');
  _rimrafrimrafjs252_assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  _rimrafrimrafjs252_assert(options, 'rimraf: missing options');
  _rimrafrimrafjs252_assert.equal(typeof options, 'object', 'rimraf: options should be object');
  _rimrafrimrafjs252_assert.equal(typeof cb, 'function', 'rimraf: callback function required');

  _rimrafrimrafjs252_defaults(options);

  var busyTries = 0;
  var errState = null;
  var n = 0;

  if (options.disableGlob || !_rimrafrimrafjs252_glob.hasMagic(p)) return afterGlob(null, [p]);

  _rimrafrimrafjs252_fs.lstat(p, function (er, stat) {
    if (!er) return afterGlob(null, [p]);

    _rimrafrimrafjs252_glob(p, options.glob, afterGlob);
  });

  function next(er) {
    errState = errState || er;
    if (--n === 0) cb(errState);
  }

  function afterGlob(er, results) {
    if (er) return cb(er);

    n = results.length;
    if (n === 0) return cb();

    results.forEach(function (p) {
      _rimrafrimrafjs252_rimraf_(p, options, function CB(er) {
        if (er) {
          if (_rimrafrimrafjs252_isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            var time = busyTries * 100;
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              _rimrafrimrafjs252_rimraf_(p, options, CB);
            }, time);
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && _rimrafrimrafjs252_timeout < options.emfileWait) {
            return setTimeout(function () {
              _rimrafrimrafjs252_rimraf_(p, options, CB);
            }, _rimrafrimrafjs252_timeout++);
          }

          // already gone
          if (er.code === "ENOENT") er = null;
        }

        _rimrafrimrafjs252_timeout = 0;
        next(er);
      });
    });
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function _rimrafrimrafjs252_rimraf_(p, options, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT") return cb(null);

    if (st && st.isDirectory()) return _rimrafrimrafjs252_rmdir(p, options, er, cb);

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT") return cb(null);
        if (er.code === "EPERM") return _rimrafrimrafjs252_isWindows ? _rimrafrimrafjs252_fixWinEPERM(p, options, er, cb) : _rimrafrimrafjs252_rmdir(p, options, er, cb);
        if (er.code === "EISDIR") return _rimrafrimrafjs252_rmdir(p, options, er, cb);
      }
      return cb(er);
    });
  });
}

function _rimrafrimrafjs252_fixWinEPERM(p, options, er, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');
  if (er) _rimrafrimrafjs252_assert(er instanceof Error);

  options.chmod(p, 666, function (er2) {
    if (er2) cb(er2.code === "ENOENT" ? null : er);else options.stat(p, function (er3, stats) {
      if (er3) cb(er3.code === "ENOENT" ? null : er);else if (stats.isDirectory()) _rimrafrimrafjs252_rmdir(p, options, er, cb);else options.unlink(p, cb);
    });
  });
}

function _rimrafrimrafjs252_fixWinEPERMSync(p, options, er) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (er) _rimrafrimrafjs252_assert(er instanceof Error);

  try {
    options.chmodSync(p, 666);
  } catch (er2) {
    if (er2.code === "ENOENT") return;else throw er;
  }

  try {
    var stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") return;else throw er;
  }

  if (stats.isDirectory()) _rimrafrimrafjs252_rmdirSync(p, options, er);else options.unlinkSync(p);
}

function _rimrafrimrafjs252_rmdir(p, options, originalEr, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (originalEr) _rimrafrimrafjs252_assert(originalEr instanceof Error);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) _rimrafrimrafjs252_rmkids(p, options, cb);else if (er && er.code === "ENOTDIR") cb(originalEr);else cb(er);
  });
}

function _rimrafrimrafjs252_rmkids(p, options, cb) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  _rimrafrimrafjs252_assert(typeof cb === 'function');

  options.readdir(p, function (er, files) {
    if (er) return cb(er);
    var n = files.length;
    if (n === 0) return options.rmdir(p, cb);
    var errState;
    files.forEach(function (f) {
      _rimrafrimrafjs252_rimraf(_rimrafrimrafjs252_path.join(p, f), options, function (er) {
        if (errState) return;
        if (er) return cb(errState = er);
        if (--n === 0) options.rmdir(p, cb);
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function _rimrafrimrafjs252_rimrafSync(p, options) {
  options = options || {};
  _rimrafrimrafjs252_defaults(options);

  _rimrafrimrafjs252_assert(p, 'rimraf: missing path');
  _rimrafrimrafjs252_assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  _rimrafrimrafjs252_assert(options, 'rimraf: missing options');
  _rimrafrimrafjs252_assert.equal(typeof options, 'object', 'rimraf: options should be object');

  var results;

  if (options.disableGlob || !_rimrafrimrafjs252_glob.hasMagic(p)) {
    results = [p];
  } else {
    try {
      _rimrafrimrafjs252_fs.lstatSync(p);
      results = [p];
    } catch (er) {
      results = _rimrafrimrafjs252_glob.sync(p, options.glob);
    }
  }

  if (!results.length) return;

  for (var i = 0; i < results.length; i++) {
    var p = results[i];

    try {
      var st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") return;
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory()) _rimrafrimrafjs252_rmdirSync(p, options, null);else options.unlinkSync(p);
    } catch (er) {
      if (er.code === "ENOENT") return;
      if (er.code === "EPERM") return _rimrafrimrafjs252_isWindows ? _rimrafrimrafjs252_fixWinEPERMSync(p, options, er) : _rimrafrimrafjs252_rmdirSync(p, options, er);
      if (er.code !== "EISDIR") throw er;
      _rimrafrimrafjs252_rmdirSync(p, options, er);
    }
  }
}

function _rimrafrimrafjs252_rmdirSync(p, options, originalEr) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  if (originalEr) _rimrafrimrafjs252_assert(originalEr instanceof Error);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT") return;
    if (er.code === "ENOTDIR") throw originalEr;
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") _rimrafrimrafjs252_rmkidsSync(p, options);
  }
}

function _rimrafrimrafjs252_rmkidsSync(p, options) {
  _rimrafrimrafjs252_assert(p);
  _rimrafrimrafjs252_assert(options);
  options.readdirSync(p).forEach(function (f) {
    _rimrafrimrafjs252_rimrafSync(_rimrafrimrafjs252_path.join(p, f), options);
  });
  options.rmdirSync(p, options);
}
/*≠≠ node_modules/recur-fs/node_modules/rimraf/rimraf.js ≠≠*/

/*== node_modules/recur-fs/lib/rm.js ==*/
$m['recur-fs/lib/rm.js#2.2.3'] = { exports: {} };
var _recurfslibrmjs223_fs = require('fs'),
    _recurfslibrmjs223_rimraf = $m['rimraf/rimraf.js#2.5.2'].exports;

/**
 * Recursive remove file or directory
 * Makes sure only project sources are removed
 * @param {String} source
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/rm.js#2.2.3'].exports = function rm(source, fn) {
	if (_recurfslibrmjs223_fs.existsSync(source)) {
		if (~source.indexOf(process.cwd())) {
			_recurfslibrmjs223_rimraf(source, function (err) {
				if (err) return fn(err);else return fn();
			});
		} else {
			fn(new Error('cannot rm source outside of project path: ' + source));
		}
	} else {
		fn(new Error('cannot rm non-existant source: ' + source));
	}
};

/**
 * Synchronously recursive remove file or directory
 * Makes sure only project sources are removed
 * @param {String} source
 */
$m['recur-fs/lib/rm.js#2.2.3'].exports.sync = function rmSync(source) {
	if (_recurfslibrmjs223_fs.existsSync(source)) {
		if (~source.indexOf(process.cwd())) {
			_recurfslibrmjs223_rimraf.sync(source);
		} else {
			throw new Error('cannot rm source outside of project path: ' + source);
		}
	} else {
		throw new Error('cannot rm non-existant source: ' + source);
	}
};
/*≠≠ node_modules/recur-fs/lib/rm.js ≠≠*/

/*== node_modules/recur-fs/lib/readdir.js ==*/
$m['recur-fs/lib/readdir.js#2.2.3'] = { exports: {} };
var _recurfslibreaddirjs223_fs = require('fs'),
    _recurfslibreaddirjs223_path = require('path');

/**
 * Read the contents of 'directory', returning all resources.
 * 'visitor' is optional function called on each resource,
 * and resource is skipped if next() returns "false"
 * @param {String} dir
 * @param {Function} [visitor(resource, stat, next)]
 * @param {Function} fn(err, resources)
 */
$m['recur-fs/lib/readdir.js#2.2.3'].exports = function readdir(directory, visitor, fn) {
	if (arguments.length == 2) {
		fn = visitor;
		// Noop
		visitor = function (resource, stat, next) {
			next();
		};
	}

	var resources = [],
	    outstanding = 0,
	    done = function () {
		if (! --outstanding) fn(null, resources);
	};

	function visit(dir) {
		outstanding++;

		_recurfslibreaddirjs223_fs.readdir(dir, function (err, files) {
			if (err) {
				// Skip if not found, otherwise exit
				if (err.code === 'ENOENT') return done();
				return fn(err);
			}

			// Include dir
			outstanding += files.length - 1;

			files.forEach(function (file) {
				file = _recurfslibreaddirjs223_path.join(dir, file);
				_recurfslibreaddirjs223_fs.stat(file, function (err, stat) {
					if (err) {
						// Skip if not found, otherwise exit
						if (err.code === 'ENOENT') return done();
						return fn(err);
					}

					visitor(file, stat, function next(include) {
						// Store
						if (include !== false) resources.push(file);
						// Recurse child directory
						if (stat.isDirectory()) visit(file);
						done();
					});
				});
			});
		});
	}

	visit(directory);
};

/**
 * Synchronously read the contents of 'directory', returning all resources.
 * 'visitor' is optional function called on each resource,
 * and resource is skipped if visitor returns "false"
 * @param {String} dir
 * @param {Function} [visitor(resource, stat)]
 * @returns {Array}
 */
$m['recur-fs/lib/readdir.js#2.2.3'].exports.sync = function readdirSync(directory, visitor) {
	visitor = visitor || function (resource, stat, next) {};

	var resources = [];

	function visit(dir) {
		if (_recurfslibreaddirjs223_fs.existsSync(dir)) {
			_recurfslibreaddirjs223_fs.readdirSync(dir).forEach(function (file) {
				file = _recurfslibreaddirjs223_path.resolve(dir, file);
				try {
					var stat = _recurfslibreaddirjs223_fs.statSync(file);
				} catch (err) {
					// Skip if file not found, otherwise throw
					if (err.code === 'ENOENT') {
						return;
					} else {
						throw err;
					}
				}

				// Store
				var include = visitor(file, stat);
				if (include !== false) resources.push(file);

				// Recurse child directory
				if (stat.isDirectory()) visit(file);
			});
		}
	}

	visit(directory);

	return resources;
};
/*≠≠ node_modules/recur-fs/lib/readdir.js ≠≠*/

/*== node_modules/mkdirp/index.js ==*/
$m['mkdirp/index.js#0.5.1'] = { exports: {} };
var _mkdirpindexjs051_path = require('path');
var _mkdirpindexjs051_fs = require('fs');
var _mkdirpindexjs051__0777 = parseInt('0777', 8);

$m['mkdirp/index.js#0.5.1'].exports = _mkdirpindexjs051_mkdirP.mkdirp = _mkdirpindexjs051_mkdirP.mkdirP = _mkdirpindexjs051_mkdirP;

function _mkdirpindexjs051_mkdirP(p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    } else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || _mkdirpindexjs051_fs;

    if (mode === undefined) {
        mode = _mkdirpindexjs051__0777 & ~process.umask();
    }
    if (!made) made = null;

    var cb = f || function () {};
    p = _mkdirpindexjs051_path.resolve(p);

    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                _mkdirpindexjs051_mkdirP(_mkdirpindexjs051_path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);else _mkdirpindexjs051_mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made);else cb(null, made);
                });
                break;
        }
    });
}

_mkdirpindexjs051_mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || _mkdirpindexjs051_fs;

    if (mode === undefined) {
        mode = _mkdirpindexjs051__0777 & ~process.umask();
    }
    if (!made) made = null;

    p = _mkdirpindexjs051_path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    } catch (err0) {
        switch (err0.code) {
            case 'ENOENT':
                made = sync(_mkdirpindexjs051_path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                } catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};
/*≠≠ node_modules/mkdirp/index.js ≠≠*/

/*== node_modules/recur-fs/lib/mkdir.js ==*/
$m['recur-fs/lib/mkdir.js#2.2.3'] = { exports: {} };
var _recurfslibmkdirjs223_fs = require('fs'),
    _recurfslibmkdirjs223_mkdirp = $m['mkdirp/index.js#0.5.1'].exports,
    _recurfslibmkdirjs223_path = require('path');

/**
 * Recursively create 'directory'
 * @param {String} directory
 * @param {Function} fn(err)
 */
$m['recur-fs/lib/mkdir.js#2.2.3'].exports = function mkdir(directory, fn) {
	// Resolve directory name if passed a file
	directory = _recurfslibmkdirjs223_path.extname(directory) ? _recurfslibmkdirjs223_path.dirname(directory) : directory;

	if (!_recurfslibmkdirjs223_fs.existsSync(directory)) {
		_recurfslibmkdirjs223_mkdirp(directory, function (err) {
			if (err) return fn(err);
			return fn();
		});
	} else {
		return fn();
	}
};

/**
 * Synchronously create 'directory'
 * @param {String} directory
 */
$m['recur-fs/lib/mkdir.js#2.2.3'].exports.sync = function mkdirSync(directory) {
	// Resolve directory name if passed a file
	directory = _recurfslibmkdirjs223_path.extname(directory) ? _recurfslibmkdirjs223_path.dirname(directory) : directory;

	if (!_recurfslibmkdirjs223_fs.existsSync(directory)) {
		_recurfslibmkdirjs223_mkdirp.sync(directory);
	}
};
/*≠≠ node_modules/recur-fs/lib/mkdir.js ≠≠*/

/*== node_modules/recur-fs/lib/mv.js ==*/
$m['recur-fs/lib/mv.js#2.2.3'] = { exports: {} };
var _recurfslibmvjs223_fs = require('fs'),
    _recurfslibmvjs223_mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports,
    _recurfslibmvjs223_path = require('path'),
    _recurfslibmvjs223_rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;

/**
 * Move file or directory 'source' to 'destination'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @param {Function} fn(err, filepath)
 */
$m['recur-fs/lib/mv.js#2.2.3'].exports = function mv(source, destination, force, fn) {
	if (force == null) force = false;

	_recurfslibmvjs223_mkdir(destination, function (err) {
		if (err) {
			return fn(err);
		} else {
			var filepath = _recurfslibmvjs223_path.resolve(destination, _recurfslibmvjs223_path.basename(source));

			if (!force && _recurfslibmvjs223_fs.existsSync(filepath)) {
				return fn(null, filepath);
			} else {
				_recurfslibmvjs223_rm(filepath, function (err) {
					// Ignore rm errors
					_recurfslibmvjs223_fs.rename(source, filepath, function (err) {
						if (err) return fn(err);
						return fn(null, filepath);
					});
				});
			}
		}
	});
};

/**
 * Synchronously move file or directory 'source' to 'destination'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @returns {String}
 */
$m['recur-fs/lib/mv.js#2.2.3'].exports.sync = function mvSync(source, destination, force) {
	if (force == null) force = false;

	if (!_recurfslibmvjs223_fs.existsSync(destination)) _recurfslibmvjs223_mkdir.sync(destination);

	var filepath = _recurfslibmvjs223_path.resolve(destination, _recurfslibmvjs223_path.basename(source));

	if (_recurfslibmvjs223_fs.existsSync(filepath)) {
		if (!force) return filepath;
		_recurfslibmvjs223_rm.sync(filepath);
	}
	_recurfslibmvjs223_fs.renameSync(source, filepath);

	return filepath;
};
/*≠≠ node_modules/recur-fs/lib/mv.js ≠≠*/

/*== node_modules/recur-fs/lib/indir.js ==*/
$m['recur-fs/lib/indir.js#2.2.3'] = { exports: {} };
var _recurfslibindirjs223_path = require('path');

/**
 * Check that a 'filepath' is likely a child of a given directory
 * Applies to nested directories
 * Only makes String comparison. Does not check for existance
 * @param {String} directory
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['recur-fs/lib/indir.js#2.2.3'].exports = function indir(directory, filepath) {
	if (directory && filepath) {
		directory = _recurfslibindirjs223_path.resolve(directory);
		filepath = _recurfslibindirjs223_path.resolve(filepath);

		if (~filepath.indexOf(directory)) {
			return !~_recurfslibindirjs223_path.relative(directory, filepath).indexOf('..');
		}
	}

	return false;
};
/*≠≠ node_modules/recur-fs/lib/indir.js ≠≠*/

/*== node_modules/recur-fs/lib/cp.js ==*/
$m['recur-fs/lib/cp.js#2.2.3'] = { exports: {} };
var _recurfslibcpjs223_fs = require('fs'),
    _recurfslibcpjs223_mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports,
    _recurfslibcpjs223_path = require('path'),
    _recurfslibcpjs223_rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;

/**
 * Copy file or directory 'source' to 'destination'
 * Copies contents of 'source' if directory and ends in trailing '/'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @param {Function} fn(err, filepath)
 */
$m['recur-fs/lib/cp.js#2.2.3'].exports = function cp(source, destination, force, fn) {
	var filepath = '',
	    first = true,
	    outstanding = 0;

	if (force == null) force = false;

	function copy(source, destination) {
		outstanding++;
		_recurfslibcpjs223_fs.stat(source, function (err, stat) {
			var isDestFile;
			outstanding--;
			// Exit if proper error, otherwise skip
			if (err) {
				if (err.code === 'ENOENT') return;
				return fn(err);
			} else {
				isDestFile = _recurfslibcpjs223_path.extname(destination).length;
				// File
				if (stat.isFile()) {
					// Handle file or directory as destination
					var destDir = isDestFile ? _recurfslibcpjs223_path.dirname(destination) : destination,
					    destName = isDestFile ? _recurfslibcpjs223_path.basename(destination) : _recurfslibcpjs223_path.basename(source),
					    filepath = _recurfslibcpjs223_path.resolve(destDir, destName);
					// Write file if it doesn't already exist
					if (!force && _recurfslibcpjs223_fs.existsSync(filepath)) {
						if (!outstanding) return fn(null, filepath);
					} else {
						_recurfslibcpjs223_rm(filepath, function (err) {
							// Ignore rm errors
							var file;
							outstanding++;
							// Return the new path for the first source
							if (first) {
								filepath = filepath;
								first = false;
							}
							// Pipe stream
							_recurfslibcpjs223_fs.createReadStream(source).pipe(file = _recurfslibcpjs223_fs.createWriteStream(filepath));
							file.on('error', function (err) {
								return fn(err);
							});
							file.on('close', function () {
								outstanding--;
								// Return if no outstanding
								if (!outstanding) return fn(null, filepath);
							});
						});
					}
					// Directory
				} else {
					// Guard against invalid directory to file copy
					if (isDestFile) {
						fn(new Error('invalid destination for copy: ' + destination));
					} else {
						// Copy contents only if source ends in '/'
						var contentsOnly = first && /\\$|\/$/.test(source),
						    dest = contentsOnly ? destination : _recurfslibcpjs223_path.resolve(destination, _recurfslibcpjs223_path.basename(source));

						// Create in destination
						outstanding++;
						_recurfslibcpjs223_mkdir(dest, function (err) {
							outstanding--;
							if (err) {
								return fn(err);
							} else {
								// Loop through contents
								outstanding++;
								_recurfslibcpjs223_fs.readdir(source, function (err, files) {
									outstanding--;
									// Exit if proper error, otherwise skip
									if (err) {
										if (err.code === 'ENOENT') return;else return fn(err);
									} else {
										// Return the new path for the first source
										if (first) {
											filepath = dest;
											first = false;
										}
										// Loop through files and cp
										files.forEach(function (file) {
											copy(_recurfslibcpjs223_path.resolve(source, file), dest);
										});
										// Return if no outstanding
										if (!outstanding) return fn(null, filepath);
									}
								});
							}
						});
					}
				}
			}
		});
		// Return if no outstanding
		if (!outstanding) return fn(null, filepath);
	};

	return copy(source, destination);
};

/**
 * Synchronously copy file or directory 'source' to 'destination'
 * Copies contents of 'source' if directory and ends in trailing '/'
 * @param {String} source
 * @param {String} destination
 * @param {Boolean} force
 * @returns {String}
 */
$m['recur-fs/lib/cp.js#2.2.3'].exports.sync = function cpSync(source, destination, force) {
	var filepath = '',
	    first = true;

	if (force == null) force = false;

	function copy(source, destination) {
		if (_recurfslibcpjs223_fs.existsSync(source)) {
			var stat = _recurfslibcpjs223_fs.statSync(source),
			    isDestFile = _recurfslibcpjs223_path.extname(destination).length;

			// File
			if (stat.isFile()) {
				// Handle file or directory as destination
				var destDir = isDestFile ? _recurfslibcpjs223_path.dirname(destination) : destination,
				    destName = isDestFile ? _recurfslibcpjs223_path.basename(destination) : _recurfslibcpjs223_path.basename(source),
				    filepath = _recurfslibcpjs223_path.resolve(destDir, destName);

				// Return the new path for the first source
				if (first) {
					filepath = filepath;
					first = false;
				}
				// Write file only if it doesn't already exist
				if (_recurfslibcpjs223_fs.existsSync(filepath)) {
					if (!force) return filepath;
					_recurfslibcpjs223_rm.sync(filepath);
				}
				_recurfslibcpjs223_fs.writeFileSync(filepath, _recurfslibcpjs223_fs.readFileSync(source));

				// Directory
			} else {
				// Guard against invalid directory to file copy
				if (isDestFile) throw new Error('invalid destination for copy: ' + destination);
				// Copy contents only if source ends in '/'
				var contentsOnly = first && /\\$|\/$/.test(source),
				    dest = contentsOnly ? destination : _recurfslibcpjs223_path.resolve(destination, _recurfslibcpjs223_path.basename(source));

				// Return the new path for the first source
				if (first) {
					filepath = dest;
					first = false;
				}
				// Create in destination
				_recurfslibcpjs223_mkdir.sync(dest);
				// Loop through files and copy
				var files = _recurfslibcpjs223_fs.readdirSync(source);
				files.forEach(function (file) {
					copy(_recurfslibcpjs223_path.resolve(source, file), dest);
				});
			}
		}
		return filepath;
	};

	return copy(source, destination);
};
/*≠≠ node_modules/recur-fs/lib/cp.js ≠≠*/

/*== node_modules/recur-fs/index.js ==*/
$m['recur-fs/index.js#2.2.3'] = { exports: {} };
$m['recur-fs/index.js#2.2.3'].exports.cp = $m['recur-fs/lib/cp.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.indir = $m['recur-fs/lib/indir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.mkdir = $m['recur-fs/lib/mkdir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.mv = $m['recur-fs/lib/mv.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.readdir = $m['recur-fs/lib/readdir.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.rm = $m['recur-fs/lib/rm.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.walk = $m['recur-fs/lib/walk.js#2.2.3'].exports;
$m['recur-fs/index.js#2.2.3'].exports.hunt = $m['recur-fs/lib/hunt.js#2.2.3'].exports;
/*≠≠ node_modules/recur-fs/index.js ≠≠*/

/*== lib/dependency-resolver/nativeModules.js ==*/
$m['lib/dependency-resolver/nativeModules.js'] = { exports: {} };
'use strict';

$m['lib/dependency-resolver/nativeModules.js'].exports = require('repl')._builtinLibs.concat('repl', 'module');
/*≠≠ lib/dependency-resolver/nativeModules.js ≠≠*/

/*== node_modules/lodash/union.js ==*/
$m['lodash/union.js#4.15.0'] = { exports: {} };
var _lodashunionjs4150_baseFlatten = $m['lodash/_baseFlatten.js#4.15.0'].exports,
    _lodashunionjs4150_baseRest = $m['lodash/_baseRest.js#4.15.0'].exports,
    _lodashunionjs4150_baseUniq = $m['lodash/_baseUniq.js#4.15.0'].exports,
    _lodashunionjs4150_isArrayLikeObject = $m['lodash/isArrayLikeObject.js#4.15.0'].exports;

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var _lodashunionjs4150_union = _lodashunionjs4150_baseRest(function (arrays) {
  return _lodashunionjs4150_baseUniq(_lodashunionjs4150_baseFlatten(arrays, 1, _lodashunionjs4150_isArrayLikeObject, true));
});

$m['lodash/union.js#4.15.0'].exports = _lodashunionjs4150_union;
/*≠≠ node_modules/lodash/union.js ≠≠*/

/*== lib/dependency-resolver/utils.js ==*/
$m['lib/dependency-resolver/utils.js'] = { exports: {} };
'use strict';

const _libdependencyresolverutilsjs_fs = require('fs');
const _libdependencyresolverutilsjs_path = require('path');

/**
 * Determine if 'filepath' is relative
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isRelativeFilepath = function (filepath) {
  return 'string' == typeof filepath && filepath.charAt(0) == '.';
};

/**
 * Determine if 'filepath' is absolute
 * @param {String} filepath
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isAbsoluteFilepath = function (filepath) {
  return 'string' == typeof filepath && _libdependencyresolverutilsjs_path.resolve(filepath) == filepath;
};

/**
 * Determine if 'str' is a filepath or package reference
 * @param {String} str
 * @returns {Boolean}
 */
$m['lib/dependency-resolver/utils.js'].exports.isFilepath = function (str) {
  return $m['lib/dependency-resolver/utils.js'].exports.isAbsoluteFilepath(str) || $m['lib/dependency-resolver/utils.js'].exports.isRelativeFilepath(str);
};

/**
 * Determine file type for 'filepath'
 * @param {String} filepath
 * @param {Object} fileExtensions
 * @returns {String}
 */
$m['lib/dependency-resolver/utils.js'].exports.deriveType = function (filepath, fileExtensions) {
  const ext = _libdependencyresolverutilsjs_path.extname(filepath).slice(1);

  // Match input extension to type
  for (const type in fileExtensions) {
    const exts = fileExtensions[type];

    for (let i = 0, n = exts.length; i < n; i++) {
      if (ext == exts[i]) return type;
    }
  }
};

/**
 * Check the location of 'filepath'
 * @param {String} filepath
 * @param {String} type
 * @param {Array} fileExtensions
 * @returns {String}
 */
$m['lib/dependency-resolver/utils.js'].exports.findFile = function (filepath, type, fileExtensions) {
  if ('string' == typeof filepath) {
    // Already have full filepath
    if (_libdependencyresolverutilsjs_path.extname(filepath)) {
      try {
        if (_libdependencyresolverutilsjs_fs.statSync(filepath).isFile()) return filepath;
      } catch (err) {/* File doesn't exist */}
    }

    let ext, fp;

    // Loop through fileExtensions and locate file
    for (let i = 0, n = fileExtensions[type].length; i < n; i++) {
      ext = fileExtensions[type][i];
      // Add extension
      fp = filepath + '.' + ext;
      if (_libdependencyresolverutilsjs_fs.existsSync(fp)) return fp;
      // Try 'index' + extension
      fp = _libdependencyresolverutilsjs_path.resolve(filepath, 'index.' + ext);
      if (_libdependencyresolverutilsjs_fs.existsSync(fp)) return fp;
    }

    return '';
  }

  return filepath;
};
/*≠≠ lib/dependency-resolver/utils.js ≠≠*/

/*== lib/dependency-resolver/alias.js ==*/
$m['lib/dependency-resolver/alias.js'] = { exports: {} };
'use strict';

const { isFilepath: _libdependencyresolveraliasjs_isFilepath, isRelativeFilepath: _libdependencyresolveraliasjs_isRelativeFilepath } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolveraliasjs_fs = require('fs');
const _libdependencyresolveraliasjs_path = require('path');

/**
 * Parse 'aliases' relative to 'pkgpath'
 * @param {String} pkgpath
 * @param {Object} aliases
 * @returns {Object}
 */
$m['lib/dependency-resolver/alias.js'].exports = {
  parse(pkgpath, aliases) {
    let parsedAliases = {};

    for (const key in aliases) {
      const value = aliases[key];
      let rKey = _libdependencyresolveraliasjs_path.resolve(pkgpath, key);
      let rValue;

      // Fix for missing relative path prefix
      if (!_libdependencyresolveraliasjs_isRelativeFilepath(key) && !_libdependencyresolveraliasjs_fs.existsSync(rKey)) rKey = key;
      if ('string' == typeof value) {
        rValue = _libdependencyresolveraliasjs_path.resolve(pkgpath, value);
        if (!_libdependencyresolveraliasjs_isRelativeFilepath(value) && !_libdependencyresolveraliasjs_fs.existsSync(rValue)) rValue = value;
      } else {
        rValue = value;
      }

      parsedAliases[key] = value;
      // Resolve relative
      if (key != rKey || value != rValue) parsedAliases[rKey] = rValue;
    }

    return parsedAliases;
  },

  /**
   * Resolve alias for 'id'
   * @param {Object} pkgDetails
   * @param {String} id
   * @returns {String}
   */
  resolve(pkgDetails, id) {
    if (!pkgDetails || !id) return id;

    const { aliases } = pkgDetails;

    if (id in aliases) return aliases[id];

    // Match packages
    if (!_libdependencyresolveraliasjs_isFilepath(id)) {
      const parts = id.split(_libdependencyresolveraliasjs_path.sep);
      // Handle scoped
      const pkg = parts.slice(0, parts[0].charAt(0) == '@' ? 2 : 1).join(_libdependencyresolveraliasjs_path.sep);

      // Disable whole package
      if (aliases[pkg] === false) return false;
    }

    return id;
  }
};
/*≠≠ lib/dependency-resolver/alias.js ≠≠*/

/*== lib/dependency-resolver/config.js ==*/
$m['lib/dependency-resolver/config.js'] = { exports: {} };
'use strict';

const { execSync: _libdependencyresolverconfigjs_exec } = require('child_process');
const _libdependencyresolverconfigjs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverconfigjs_nativeModules = $m['lib/dependency-resolver/nativeModules.js'].exports;
const _libdependencyresolverconfigjs_path = require('path');
const _libdependencyresolverconfigjs_union = $m['lodash/union.js#4.15.0'].exports;

const _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS = {
  js: ['js', 'json'],
  css: ['css'],
  html: ['html']
};

/**
 * Parse and format 'options'
 * @param {Object} [options]
 *  - {Object} fileExtensions
 *  - {Object} globalAliases
 * @returns {Object}
 */
$m['lib/dependency-resolver/config.js'].exports = function config(options) {
  options = options || {};
  options.fileExtensions = options.fileExtensions || {};

  return {
    fileExtensions: {
      js: _libdependencyresolverconfigjs_union(options.fileExtensions.js || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.js),
      css: _libdependencyresolverconfigjs_union(options.fileExtensions.css || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.css),
      html: _libdependencyresolverconfigjs_union(options.fileExtensions.html || [], _libdependencyresolverconfigjs_DEFAULT_EXTENSIONS.html)
    },
    globalAliases: _libdependencyresolverconfigjs_alias.parse(process.cwd(), options.globalAliases || {}),
    globalSources: $m['lib/dependency-resolver/config.js'].exports.globalSources,
    nativeModules: _libdependencyresolverconfigjs_nativeModules,
    sources: $m['lib/dependency-resolver/config.js'].exports.sources
  };
};

// Expose
$m['lib/dependency-resolver/config.js'].exports.globalSources = _libdependencyresolverconfigjs_resolveSources(true);
$m['lib/dependency-resolver/config.js'].exports.sources = _libdependencyresolverconfigjs_resolveSources(false);
$m['lib/dependency-resolver/config.js'].exports.VERSION_DELIMITER = '#';

/**
 * Resolve sources
 * @param {Boolean} global
 * @returns {Array}
 */
function _libdependencyresolverconfigjs_resolveSources(global) {
  const sources = global
  // Get global path from npm config
  ? [_libdependencyresolverconfigjs_path.join(process.env.npm_config_prefix || _libdependencyresolverconfigjs_exec('npm config get prefix', { encoding: 'utf8' }), 'lib/node_modules')] : [..._libdependencyresolverconfigjs_resolveEnvSources('NODE_PATH'), ..._libdependencyresolverconfigjs_resolveEnvSources('BROWSER_PATH')];

  return sources.map(source => _libdependencyresolverconfigjs_path.resolve(source));
}

/**
 * Resolve environment variable sources for 'env'
 * @param {String} env
 * @returns {Array}
 */
function _libdependencyresolverconfigjs_resolveEnvSources(env) {
  let paths = [];

  if (process.env[env]) {
    paths = ~process.env[env].indexOf(':') ? process.env[env].split(':') : [process.env[env]];
  }

  return paths;
}
/*≠≠ lib/dependency-resolver/config.js ≠≠*/

/*== lib/dependency-resolver/cache.js ==*/
$m['lib/dependency-resolver/cache.js'] = { exports: {} };
'use strict';

const { VERSION_DELIMITER: _libdependencyresolvercachejs_VERSION_DELIMITER } = $m['lib/dependency-resolver/config.js'].exports;
let _libdependencyresolvercachejs_packageCache = {};
let _libdependencyresolvercachejs_versionedFileCache = {};
let _libdependencyresolvercachejs_fileCache = {};

$m['lib/dependency-resolver/cache.js'].exports = {
  /**
   * Retrieve id or filepath for 'key'
   * @param {String} key
   * @returns {String}
   */
  getFile(key) {
    return _libdependencyresolvercachejs_fileCache[key];
  },

  /**
   * Add 'file' to cache
   * @param {Object} file
   */
  setFile(file) {
    // Make sure not to overwrite
    if (file.path && file.id && !_libdependencyresolvercachejs_fileCache[file.path] && !_libdependencyresolvercachejs_fileCache[file.id]) {
      _libdependencyresolvercachejs_fileCache[file.path] = file.id;
      _libdependencyresolvercachejs_fileCache[file.id] = file.path;
      // Store in versioned cash to enable multiple version check
      if (~file.id.indexOf(_libdependencyresolvercachejs_VERSION_DELIMITER)) {
        const name = file.id.split(_libdependencyresolvercachejs_VERSION_DELIMITER)[0];

        if (!_libdependencyresolvercachejs_versionedFileCache[name]) {
          _libdependencyresolvercachejs_versionedFileCache[name] = 1;
        } else {
          _libdependencyresolvercachejs_versionedFileCache[name]++;
        }
      }
    }
  },

  /**
   * Retrieve package details for 'key',
   * where 'key' is one of pakcage id or path
   * @param {String} key
   * @returns {Object}
   */
  getPackage(key) {
    return _libdependencyresolvercachejs_packageCache[key];
  },

  /**
   * Add 'pkg' to cache
   * @param {Object} pkg
   */
  setPackage(pkg) {
    // Make sure not to overwrite
    if (!_libdependencyresolvercachejs_packageCache[pkg.pkgpath] && !_libdependencyresolvercachejs_packageCache[pkg.id]) {
      _libdependencyresolvercachejs_packageCache[pkg.pkgpath] = pkg;
      _libdependencyresolvercachejs_packageCache[pkg.id] = pkg;
    }
  },

  /**
   * Determine if there is more than one version of 'id'
   * @param {String} id
   * @returns {Boolean}
   */
  hasMultipleVersions(id) {
    if (~id.indexOf(_libdependencyresolvercachejs_VERSION_DELIMITER)) {
      return _libdependencyresolvercachejs_versionedFileCache[id.split(_libdependencyresolvercachejs_VERSION_DELIMITER)[0]] > 1;
    }
    return false;
  },

  /**
   * Clear the cache
   */
  clear() {
    _libdependencyresolvercachejs_fileCache = {};
    _libdependencyresolvercachejs_packageCache = {};
    _libdependencyresolvercachejs_versionedFileCache = {};
  }
};
/*≠≠ lib/dependency-resolver/cache.js ≠≠*/

/*== lib/dependency-resolver/package.js ==*/
$m['lib/dependency-resolver/package.js'] = { exports: {} };
'use strict';

const { VERSION_DELIMITER: _libdependencyresolverpackagejs_VERSION_DELIMITER } = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolverpackagejs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverpackagejs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolverpackagejs_fs = require('fs');
const _libdependencyresolverpackagejs_path = require('path');

const _libdependencyresolverpackagejs_MAX_FS_DEPTH = 10;
const _libdependencyresolverpackagejs_RE_TRAILING = /\/+$|\\+$/g;

$m['lib/dependency-resolver/package.js'].exports = {
  resolveId: _libdependencyresolverpackagejs_resolveId,
  resolveName: _libdependencyresolverpackagejs_resolveName,
  resolvePath: _libdependencyresolverpackagejs_resolvePath,

  /**
   * Retrieve package details for 'filepath'
   * @param {String} filepath
   * @param {Object} options
   *  - {Object} fileExtensions
   *  - {Object} globalAliases
   *  - {Array} globalSources
   *  - {Array} nativeModules
   *  - {Array} sources
   * @returns {Object}
   */
  getDetails(filepath, options) {
    options = options || {};

    const pkgpath = _libdependencyresolverpackagejs_resolvePath(filepath);
    const pkgname = _libdependencyresolverpackagejs_resolveName(pkgpath);
    const manifestpath = _libdependencyresolverpackagejs_path.resolve(pkgpath, 'package.json');
    let details, existingPkg, json;

    if (!_libdependencyresolverpackagejs_fs.existsSync(pkgpath)) return;

    // Pull from cache
    if (details = _libdependencyresolverpackagejs_cache.getPackage(pkgpath)) return details;

    details = {
      aliases: Object.assign({}, options.globalAliases),
      dirname: _libdependencyresolverpackagejs_path.dirname(pkgpath),
      id: '',
      isRoot: pkgpath == process.cwd(),
      manifestpath: '',
      main: '',
      name: pkgname,
      paths: [],
      pkgpath: pkgpath,
      version: ''
    };

    // Parse manifest
    if (_libdependencyresolverpackagejs_fs.existsSync(manifestpath)) {
      try {
        json = require(manifestpath);
      } catch (err) {/* no file */}

      if (json) {
        details.manifestpath = manifestpath;
        details.name = json.name || pkgname;
        details.version = json.version;
        if (json.main) {
          details.main = _libdependencyresolverpackagejs_path.resolve(pkgpath, json.main);
        } else {
          const fp = _libdependencyresolverpackagejs_path.join(pkgpath, 'index.js');

          if (_libdependencyresolverpackagejs_fs.existsSync(fp)) details.main = fp;
        }
        // Resolve json.browser aliasing
        if (json.browser) {
          if ('string' == typeof json.browser) {
            details.main = _libdependencyresolverpackagejs_path.resolve(pkgpath, json.browser);
          } else {
            details.aliases = Object.assign(details.aliases, _libdependencyresolverpackagejs_alias.parse(pkgpath, json.browser));
            // Handle 'main' aliasing
            for (const key in details.aliases) {
              if (key == details.main) details.main = details.aliases[key];
            }
          }
        }
        // Store main as alias
        if (details.main) details.aliases[pkgpath] = details.main;
      }
    }

    // Set id
    // Ignore version if root package
    details.id = details.name + (!details.isRoot && details.version ? _libdependencyresolverpackagejs_VERSION_DELIMITER + details.version : '');

    // Retrieve existing pkg with same id
    if (existingPkg = _libdependencyresolverpackagejs_cache.getPackage(details.id)) return existingPkg;

    // Handle scoped
    if (_libdependencyresolverpackagejs_path.basename(details.dirname).indexOf('@') == 0) details.dirname = _libdependencyresolverpackagejs_path.dirname(details.dirname);

    // Gather all reachable paths
    // Adding 'pkgpath' breaks Node semantics
    details.paths = [..._libdependencyresolverpackagejs_resolveNodeModules(pkgpath), ...options.sources, pkgpath, ...options.globalSources];

    // Cache
    _libdependencyresolverpackagejs_cache.setPackage(details);

    return details;
  }
};

/**
 * Resolve package path from 'filepath'
 * @param {String} filepath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolvePath(filepath) {
  filepath = filepath.replace(_libdependencyresolverpackagejs_RE_TRAILING, '');

  const cwd = process.cwd();

  if (~filepath.indexOf('node_modules')) {
    const parts = filepath.split(_libdependencyresolverpackagejs_path.sep);
    let idx = parts.lastIndexOf('node_modules');

    if (idx < parts.length - 1) idx += 2;
    // Handle scoped
    if (parts[idx - 1].charAt(0) == '@') idx++;

    return parts.slice(0, idx).join(_libdependencyresolverpackagejs_path.sep);
  } else if (~filepath.indexOf(cwd)) {
    return cwd;
  }

  // TODO: handle files from outside project path?
  return filepath;
}

/**
 * Resolve package name from 'pkgpath'
 * @param {String} pkgpath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolveName(pkgpath) {
  pkgpath = pkgpath.replace(_libdependencyresolverpackagejs_RE_TRAILING, '');

  const parts = pkgpath.split(_libdependencyresolverpackagejs_path.sep);
  const len = parts.length;

  // Handle scoped
  const idx = parts[len - 2].charAt(0) == '@' ? 2 : 1;

  return parts.slice(len - idx).join(_libdependencyresolverpackagejs_path.sep);
}

/**
 * Resolve id for 'filepath'
 * @param {Object} details
 * @param {String} filepath
 * @returns {String}
 */
function _libdependencyresolverpackagejs_resolveId(details, filepath) {
  let name = '';

  if ('string' == typeof filepath) {
    if (details.isRoot && filepath == details.main) return details.id;

    const version = !details.isRoot && details.version ? _libdependencyresolverpackagejs_VERSION_DELIMITER + details.version : '';

    details.paths.some(sourcepath => {
      if (~filepath.indexOf(sourcepath)) {
        name = _libdependencyresolverpackagejs_path.relative(sourcepath, filepath);
        return true;
      }
    });

    name = (process.platform == 'win32' ? name.replace(/\\/g, '/') : name) + version;
  }

  return name;
}

/**
 * Gather all node_modules directories reachable from 'pkgpath'
 * @param {String} pkgpath
 * @returns {Array}
 */
function _libdependencyresolverpackagejs_resolveNodeModules(pkgpath) {
  let dir = pkgpath;
  let dirs = [];
  let depth = _libdependencyresolverpackagejs_MAX_FS_DEPTH;
  let parent, nodeModulespath;

  while (true) {
    parent = _libdependencyresolverpackagejs_path.dirname(dir);
    // Stop if we hit max file system depth or root
    // Convert to lowercase to fix problems on Windows
    if (! --depth || parent.toLowerCase() === dir.toLowerCase()) {
      break;
    }

    nodeModulespath = _libdependencyresolverpackagejs_path.resolve(dir, 'node_modules');
    if (_libdependencyresolverpackagejs_fs.existsSync(nodeModulespath)) dirs.push(nodeModulespath);

    // Walk
    dir = parent;
  }

  return dirs;
}
/*≠≠ lib/dependency-resolver/package.js ≠≠*/

/*== lib/dependency-resolver/resolve.js ==*/
$m['lib/dependency-resolver/resolve.js'] = { exports: {} };
'use strict';

const { deriveType: _libdependencyresolverresolvejs_deriveType, isAbsoluteFilepath: _libdependencyresolverresolvejs_isAbsoluteFilepath, isRelativeFilepath: _libdependencyresolverresolvejs_isRelativeFilepath, findFile: _libdependencyresolverresolvejs_findFile } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolverresolvejs_alias = $m['lib/dependency-resolver/alias.js'].exports;
const _libdependencyresolverresolvejs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolverresolvejs_config = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolverresolvejs_fs = require('fs');
const _libdependencyresolverresolvejs_pkg = $m['lib/dependency-resolver/package.js'].exports;
const _libdependencyresolverresolvejs_path = require('path');

/**
 * Resolve the path for 'id' from 'sourcepath'
 * @param {String} sourcepath
 * @param {String} id
 * @param {Object} [options]
 *  - {Object} fileExtensions
 * @returns {String|Boolean}
 */
$m['lib/dependency-resolver/resolve.js'].exports = function resolve(sourcepath, id, options) {
  if (!_libdependencyresolverresolvejs_fs.existsSync(sourcepath)) return '';

  options = _libdependencyresolverresolvejs_config(options);

  const type = _libdependencyresolverresolvejs_deriveType(sourcepath, options.fileExtensions);
  const sourcedir = _libdependencyresolverresolvejs_path.dirname(sourcepath);
  let filepath = '';

  // Implied relative path for css/html
  if (type != 'js' && !_libdependencyresolverresolvejs_isRelativeFilepath(id)) {
    filepath = _libdependencyresolverresolvejs_find(`./${ id }`, type, sourcedir, options);
  }

  if (filepath === '') filepath = _libdependencyresolverresolvejs_find(id, type, sourcedir, options);

  return filepath;
};

/**
 * Find filepath for 'id' in 'sourcedir' directory
 * @param {String} id
 * @param {String} type
 * @param {String} sourcedir
 * @param {Object} options
 *  - {Object} fileExtensions
 *  - {Array} nativeModules
 *  - {Array} sources
 * @returns {String|Boolean}
 */
function _libdependencyresolverresolvejs_find(id, type, sourcedir, options) {
  const pkgDetails = _libdependencyresolverresolvejs_pkg.getDetails(sourcedir, options);
  let filepath;

  // Resolve relative paths,
  if (_libdependencyresolverresolvejs_isRelativeFilepath(id)) id = _libdependencyresolverresolvejs_path.resolve(sourcedir, id);

  // Redirect if cached version
  if (pkgDetails && !~sourcedir.indexOf(pkgDetails.pkgpath)) {
    // Replace source path root with details root
    id = _libdependencyresolverresolvejs_path.resolve(pkgDetails.dirname, _libdependencyresolverresolvejs_path.relative(_libdependencyresolverresolvejs_path.dirname(_libdependencyresolverresolvejs_pkg.resolvePath(sourcedir)), sourcedir));
  }

  // Handle aliases
  id = _libdependencyresolverresolvejs_alias.resolve(pkgDetails, id);
  // Handle root package shortcut id
  if (pkgDetails && pkgDetails.isRoot && pkgDetails.id == id) return pkgDetails.main;
  // Handle disabled or native modules
  if (id === false || options.nativeModules.includes(id)) return false;

  if (_libdependencyresolverresolvejs_isAbsoluteFilepath(id)) {
    filepath = _libdependencyresolverresolvejs_findFile(id, type, options.fileExtensions);
    filepath = _libdependencyresolverresolvejs_alias.resolve(pkgDetails, filepath);
    // File doesn't exist or is disabled
    if (filepath == '' || filepath === false) return filepath;
    // File found
    if (_libdependencyresolverresolvejs_isAbsoluteFilepath(filepath)) {
      // Cache
      _libdependencyresolverresolvejs_cache.setFile({
        path: filepath,
        id: _libdependencyresolverresolvejs_pkg.resolveId(pkgDetails, filepath)
      });

      return filepath;
    }

    // Continue
    id = filepath;
  }

  // Search source paths for matches
  let fp;

  pkgDetails.paths.some(sourcepath => {
    if (id && sourcedir != sourcepath) {
      fp = _libdependencyresolverresolvejs_path.resolve(sourcepath, id);
      fp = _libdependencyresolverresolvejs_find(fp, type, fp, options);
      if (fp !== '') {
        filepath = fp;
        return true;
      }
      filepath = '';
    }
  });

  return filepath;
}
/*≠≠ lib/dependency-resolver/resolve.js ≠≠*/

/*== lib/dependency-resolver/identify.js ==*/
$m['lib/dependency-resolver/identify.js'] = { exports: {} };
'use strict';

const { isAbsoluteFilepath: _libdependencyresolveridentifyjs_isAbsoluteFilepath } = $m['lib/dependency-resolver/utils.js'].exports;
const _libdependencyresolveridentifyjs_cache = $m['lib/dependency-resolver/cache.js'].exports;
const _libdependencyresolveridentifyjs_config = $m['lib/dependency-resolver/config.js'].exports;
const _libdependencyresolveridentifyjs_fs = require('fs');
const _libdependencyresolveridentifyjs_pkg = $m['lib/dependency-resolver/package.js'].exports;

/**
 * Retrieve id for 'filepath'
 * @param {String} filepath
 * @param {Object} [options]
 * @returns {String}
 */
$m['lib/dependency-resolver/identify.js'].exports = function indentify(filepath, options) {
  options = _libdependencyresolveridentifyjs_config(options);

  let id = '';

  if (!_libdependencyresolveridentifyjs_fs.existsSync(filepath) || !_libdependencyresolveridentifyjs_isAbsoluteFilepath(filepath)) return id;

  // Return from cache
  if (id = _libdependencyresolveridentifyjs_cache.getFile(filepath)) return id;

  const pkgDetails = _libdependencyresolveridentifyjs_pkg.getDetails(filepath, options);

  // Handle aliases
  if (filepath in pkgDetails.aliases) {
    const fp = pkgDetails.aliases[filepath];

    // Only follow alias if not disabled
    if (fp !== false) filepath = fp;
  }

  if (id = _libdependencyresolveridentifyjs_pkg.resolveId(pkgDetails, filepath)) {
    if (process.platform == 'win32') id = id.replace(/\\/g, '/');
    // Cache
    _libdependencyresolveridentifyjs_cache.setFile({ path: filepath, id });
  }

  return id;
};
/*≠≠ lib/dependency-resolver/identify.js ≠≠*/

/*== lib/dependency-resolver/index.js ==*/
$m['lib/dependency-resolver/index.js'] = { exports: {} };
'use strict';

const { clear: _libdependencyresolverindexjs_clear, hasMultipleVersions: _libdependencyresolverindexjs_hasMultipleVersions } = $m['lib/dependency-resolver/cache.js'].exports;

$m['lib/dependency-resolver/index.js'].exports.identify = $m['lib/dependency-resolver/identify.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.resolve = $m['lib/dependency-resolver/resolve.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.nativeModules = $m['lib/dependency-resolver/nativeModules.js'].exports;
$m['lib/dependency-resolver/index.js'].exports.hasMultipleVersions = _libdependencyresolverindexjs_hasMultipleVersions;
$m['lib/dependency-resolver/index.js'].exports.clearCache = _libdependencyresolverindexjs_clear;
/*≠≠ lib/dependency-resolver/index.js ≠≠*/

/*== lib/File.js ==*/
$m['lib/File.js'] = { exports: {} };
'use strict';

const { debug: _libFilejs_debug, print: _libFilejs_print, strong: _libFilejs_strong, warn: _libFilejs_warn } = $m['lib/utils/cnsl.js'].exports;
const { regexpEscape: _libFilejs_regexpEscape, truncate: _libFilejs_truncate } = $m['lib/utils/string.js'].exports;
const { resolve: _libFilejs_resolve, nativeModules: _libFilejs_nativeModules } = $m['lib/dependency-resolver/index.js'].exports;
const { readFileSync: _libFilejs_readFile, writeFileSync: _libFilejs_writeFile } = require('fs');
const { mkdir: { sync: _libFilejs_mkdir } } = $m['recur-fs/index.js#2.2.3'].exports;
const _libFilejs_callable = $m['lib/utils/callable.js'].exports;
const _libFilejs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libFilejs_md5 = $m['md5/md5.js#2.2.1'].exports;
const _libFilejs_parallel = $m['async/parallel.js#2.0.1'].exports;
const _libFilejs_path = require('path');
const _libFilejs_series = $m['async/series.js#2.0.1'].exports;
const _libFilejs_unique = $m['lodash/uniq.js#4.15.0'].exports;

const _libFilejs_RE_ESCAPE_ID = /[#._-\s/\\]/g;
const _libFilejs_WORKFLOW_INLINEABLE = ['load'];
const _libFilejs_WORKFLOW_STANDARD = ['load', 'parse', 'runWorkflowForDependencies'];
const _libFilejs_WORKFLOWS = {
  standard: 1,
  inlineable: 2,
  writeable: 4
};

$m['lib/File.js'].exports = class File {
  /**
   * Constructor
   * @param {String} id
   * @param {String} filepath
   * @param {String} type
   * @param {Object} options
   *  - {Object} caches
   *  - {Object} fileExtensions
   *  - {Function} fileFactory
   *  - {Object} globalAliases
   *  - {Array} npmModulepaths
   *  - {Object} pluginOptions
   *  - {Object} runtimeOptions
   */
  constructor(id, filepath, type, options) {
    this.content = '';
    this.encoding = 'utf8';
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.fileContent = '';
    this.filepath = filepath;
    this.hash = '';
    this.helpers = [];
    this.id = id;
    // TODO: short name when compressed?
    this.idSafe = id.replace(_libFilejs_RE_ESCAPE_ID, '');
    this.isCircularDependency = false;
    this.isDependency = false;
    this.isInline = false;
    this.isLocked = false;
    this.options = options;
    this.ran = 0;
    this.type = type;
    this.workflows = {
      standard: [_libFilejs_WORKFLOW_STANDARD],
      inlineable: [_libFilejs_WORKFLOW_INLINEABLE],
      writeable: [[]]
    };

    this.extension = _libFilejs_path.extname(this.filepath).slice(1);
    this.relpath = _libFilejs_truncate(_libFilejs_path.relative(process.cwd(), filepath));
    this.name = _libFilejs_path.basename(this.filepath);

    // Force generation of hash
    this.load();

    _libFilejs_debug(`created File instance ${ _libFilejs_strong(this.relpath) }`, 3);
  }

  /**
   * Retrieve writeable state
   * @param {Boolean} batch
   * @returns {Boolean}
   */
  isWriteable(batch) {
    return !this.isInline
    // Only writeable if not node_module in batch mode
    && batch ? !~this.filepath.indexOf('node_modules') : !this.isDependency;
  }

  /**
   * Retrieve inlineable state
   * @returns {Boolean}
   */
  isInlineable() {
    return this.isInline;
  }

  /**
   * Retrieve parsed workflows for 'buildOptions'
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @returns {Array}
   */
  parseWorkflow(type, index, buildOptions) {
    if (!this.workflows[type] || !this.workflows[type][index]) return [];

    return this.workflows[type][index].reduce((tasks, task) => {
      if (~task.indexOf(':')) {
        let conditions = task.split(':');

        task = conditions.pop();
        const passed = conditions.every(condition => {
          return condition.charAt(0) == '!' ? !buildOptions[condition.slice(1)] : buildOptions[condition];
        });

        if (!passed) return tasks;
      }
      tasks.push(task);
      return tasks;
    }, []);
  }

  /**
   * Retrieve flattened dependency tree
   * @param {Boolean} asReferences
   * @returns {Array}
   */
  getAllDependencies(asReferences) {
    const key = asReferences ? 'dependencyReferences' : 'dependencies';
    const root = this;
    let deps = [];
    let depsUnique = [];

    function add(dependency, dependant) {
      const file = dependency.file || dependency;

      if (file !== root) {
        deps.push(dependency);
        // Add children
        if (key in file) {
          file[key].forEach(function (dep) {
            // Protect against circular references
            if ((dep.instance || dep) != dependant) add(dep, dependency);
          });
        }
      }
    }

    this[key].forEach(add);

    // Reverse and filter unique
    // Prefer deeply nested duplicates
    for (let i = deps.length - 1; i >= 0; i--) {
      if (!depsUnique.includes(deps[i])) depsUnique.push(deps[i]);
    }

    return depsUnique;
  }

  /**
   * Retrieve flattened helpers
   * @returns {Array}
   */
  getAllHelpers() {
    let helpers = [...this.helpers];

    function add(dependency) {
      helpers.push(...dependency.helpers);
      // Add children
      dependency.dependencies.forEach(add);
    }

    this.dependencies.forEach(add);

    return _libFilejs_unique(helpers);
  }

  /**
   * Add 'dependencies'
   * @param {Array} dependencies
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   */
  addDependencies(dependencies, buildOptions) {
    if (!Array.isArray(dependencies)) dependencies = [dependencies];

    const { browser = true, ignoredFiles = [], watchOnly = false } = buildOptions;
    const resolveOptions = {
      fileExtensions: this.options.fileExtensions,
      globalAliases: this.options.globalAliases
    };

    dependencies.forEach(dependency => {
      // Inlined/sidecar dependencies are pre-resolved
      const filepath = dependency.filepath || _libFilejs_resolve(this.filepath, dependency.id, resolveOptions);

      // Unable to resolve filepath or create instance
      if (filepath === '') {
        _libFilejs_warn(`dependency ${ _libFilejs_strong(dependency.id) } for ${ _libFilejs_strong(this.id) } not found`, 3);
        return;
      }

      this.dependencyReferences.push(dependency);
      // Handle disabled, including native modules (force ignore of node_modules when watch only build)
      if (filepath === false || watchOnly && ~filepath.indexOf('node_modules')) {
        // Don't disable native modules on server
        dependency.isDisabled = browser ? true : !_libFilejs_nativeModules.includes(dependency.id);
        return;
      }

      const instance = this.options.fileFactory(filepath, this.options);

      dependency.file = instance;
      // Ignore if parent file or ignored child file
      if (instance.isLocked || ignoredFiles.includes(filepath)) {
        dependency.isIgnored = true;
        // Allow special handling for circular
      } else if (instance.dependencies.includes(this)) {
        // Flag in parent
        instance.dependencyReferences.some(dependency => {
          if (dependency.file == this) {
            dependency.isCircular = true;
            this.isCircularDependency = true;
            return true;
          }
        });
      } else if (!this.dependencies.includes(instance)) {
        instance.isDependency = true;
        // Identify as inline-source dependency
        instance.isInline = 'stack' in dependency;
        this.dependencies.push(instance);
      }
    });
  }

  /**
   * Inline dependencyReferences
   */
  inlineDependencyReferences() {
    function inline(content, references) {
      let inlineContent;

      references.forEach(reference => {
        // Inline nested dependencies
        // Duplicates are allowed (not @import_once)
        inlineContent = reference.file.dependencyReferences.length ? inline(reference.file.content, reference.file.dependencyReferences) : reference.file.content;
        // Replace @import * with inlined content
        if (reference.context) content = content.replace(new RegExp(_libFilejs_regexpEscape(reference.context), 'mg'), inlineContent);
      });
      return content;
    }

    // TODO: remove comments?
    this.content = inline(this.content, this.dependencyReferences);
  }

  /**
   * Run workflow set based on 'type' and 'buildOptions'
   * @param {String} type
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   * @returns {null}
   */
  run(type, buildOptions, fn) {
    if (!this.workflows[type]) return fn();

    const workflows = this.workflows[type].map((workflow, idx) => {
      return _libFilejs_callable(this, 'runWorkflow', type, idx, buildOptions);
    });

    _libFilejs_series(workflows, err => {
      if (err) return fn(err);
      // Return all dependencies
      fn(null, this.getAllDependencies(false));
    });
  }

  /**
   * Run workflow set for 'type' and 'buildOptions' on 'dependencies'
   * @param {String} type
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Array} [dependencies]
   * @param {Function} fn(err)
   */
  runForDependencies(type, buildOptions, dependencies, fn) {
    dependencies = dependencies || this.dependencies;
    _libFilejs_parallel(dependencies.map(dependency => {
      return _libFilejs_callable(dependency, 'run', type, buildOptions);
    }), fn);
  }

  /**
   * Run workflow tasks for 'type' and 'index'
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   * @returns {null}
   */
  runWorkflow(type, index, buildOptions, fn) {
    if (this.ran & _libFilejs_WORKFLOWS[type] * (index + 1)) return fn();

    const workflow = this.parseWorkflow(type, index, buildOptions);
    const tasks = workflow.map(task => {
      return task == 'runWorkflowForDependencies' ? _libFilejs_callable(this, task, type, index, buildOptions) : _libFilejs_callable(this, task, buildOptions);
    });

    _libFilejs_series(tasks, err => {
      if (err) return fn(err);
      this.ran |= _libFilejs_WORKFLOWS[type] * (index + 1);
      fn();
    });
  }

  /**
   * Run workflow tasks for 'type' and 'index' on dependencies
   * @param {String} type
   * @param {Number} index
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  runWorkflowForDependencies(type, index, buildOptions, fn) {
    _libFilejs_parallel(this.dependencies.map(dependency => {
      return _libFilejs_callable(dependency, 'runWorkflow', type, index, buildOptions);
    }), fn);
  }

  /**
   * Read and store file contents
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  load(buildOptions, fn) {
    if (!this.fileContent) {
      const content = _libFilejs_readFile(this.filepath, this.encoding);

      this.content = this.fileContent = content;
      this.hash = _libFilejs_md5(content);

      _libFilejs_debug(`load: ${ _libFilejs_strong(this.relpath) }`, 4);
    } else {
      this.content = this.fileContent;
    }

    if (fn) fn();
  }

  /**
   * Parse file contents for dependency references [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  parse(buildOptions, fn) {
    _libFilejs_debug(`parse: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Compile file contents [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  compile(buildOptions, fn) {
    _libFilejs_debug(`compile: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Compress file contents [no-op]
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err)
   */
  compress(buildOptions, fn) {
    _libFilejs_debug(`compress: ${ _libFilejs_strong(this.relpath) }`, 4);
    fn();
  }

  /**
   * Write file contents to disk
   * @param {String} filepath
   * @param {Object} buildOptions
   *  - {Boolean} batch
   *  - {Boolean} bootstrap
   *  - {Boolean} boilerplate
   *  - {Boolean} browser
   *  - {Boolean} bundle
   *  - {Boolean} compress
   *  - {Array} ignoredFiles
   *  - {Boolean} helpers
   *  - {Boolean} watchOnly
   * @param {Function} fn(err, results)
   */
  write(filepath, buildOptions, fn) {
    this.run('writeable', buildOptions, err => {
      if (err) return fn(err);

      const relpath = _libFilejs_truncate(_libFilejs_path.relative(process.cwd(), filepath));

      _libFilejs_mkdir(filepath);
      _libFilejs_writeFile(filepath, this.content, 'utf8');

      _libFilejs_print(_libFilejs_chalk.green(`built ${ this.options.runtimeOptions.compress ? 'and compressed' : '' } ${ _libFilejs_strong(relpath) }`), 2);

      fn(null, {
        filepath,
        hash: _libFilejs_md5(this.content),
        helpers: this.getAllHelpers(),
        date: Date.now()
      });
    });
  }

  /**
   * Reset content
   * @param {Boolean} hard
   */
  reset(hard) {
    this.isCircularDependency = false;
    this.isDependency = false;
    this.isInline = false;
    this.isLocked = false;
    this.date = Date.now();
    this.dependencies = [];
    this.dependencyReferences = [];
    this.helpers = [];
    this.ran = 0;
    if (!hard) {
      this.content = this.fileContent;
    } else {
      this.content = this.fileContent = '';
    }
    _libFilejs_debug(`reset${ hard ? '(hard):' : ':' } ${ _libFilejs_strong(this.relpath) }`, 4);
  }

  /**
   * Destroy instance
   */
  destroy() {
    this.reset(true);
    this.options = null;
  }
};
/*≠≠ lib/File.js ≠≠*/

/*== lib/config/filetype.js ==*/
$m['lib/config/filetype.js'] = { exports: {} };
'use strict';

const _libconfigfiletypejs_path = require('path');

/**
 * Determine type of 'filepath'
 * @param {String} filepath
 * @param {Object} fileExtensions
 * @returns {String}
 */
$m['lib/config/filetype.js'].exports = function filetype(filepath, fileExtensions) {
  const ext = _libconfigfiletypejs_path.extname(filepath).slice(1);

  // Match input extension to type
  for (const t in fileExtensions) {
    const exts = fileExtensions[t];

    for (let i = 0, n = exts.length; i < n; i++) {
      if (ext == exts[i]) return t;
    }
  }

  return 'unknown';
};
/*≠≠ lib/config/filetype.js ≠≠*/

/*== lib/config/buildParser.js ==*/
$m['lib/config/buildParser.js'] = { exports: {} };
'use strict';

const { strong: _libconfigbuildParserjs_strong, warn: _libconfigbuildParserjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { indir: _libconfigbuildParserjs_indir, readdir: { sync: _libconfigbuildParserjs_readdir } } = $m['recur-fs/index.js#2.2.3'].exports;
const _libconfigbuildParserjs_filetype = $m['lib/config/filetype.js'].exports;
const _libconfigbuildParserjs_fs = require('fs');
const _libconfigbuildParserjs_glob = $m['glob/glob.js#7.0.6'].exports.sync;
const _libconfigbuildParserjs_match = $m['minimatch/minimatch.js#3.0.3'].exports;
const _libconfigbuildParserjs_path = require('path');
const _libconfigbuildParserjs_pluginLoader = $m['lib/config/pluginLoader.js'].exports;

const _libconfigbuildParserjs_DEPRECATED_VERSION = 'this build format is no longer compatible with newer versions of Buddy. See https://github.com/popeindustries/buddy/blob/master/docs/config.md for help';
const _libconfigbuildParserjs_RE_GLOB = /[\*\[\{]/;

let _libconfigbuildParserjs_numBuildTargets;

$m['lib/config/buildParser.js'].exports = {
  /**
   * Parse and validate build targets of 'config'
   * @param {Object} config
   */
  parse(config) {
    if (!config.build) throw Error('missing build data');
    config.build = _libconfigbuildParserjs_parseBuild(config.build, config.caches, config.fileExtensions, config.fileFactory, config.npmModulepaths, config.runtimeOptions, config.server);
  }
};

/**
 * Parse and validate build targets
 * @param {Object} build
 * @param {Object} caches
 * @param {Object} fileExtensions
 * @param {Function} fileFactory
 * @param {Array} npmModulepaths
 * @param {Object} runtimeOptions
 * @param {Object} server
 * @param {Object} [parent]
 * @returns {Array}
 */
function _libconfigbuildParserjs_parseBuild(build, caches, fileExtensions, fileFactory, npmModulepaths, runtimeOptions, server, parent) {
  if (!parent) _libconfigbuildParserjs_numBuildTargets = 0;
  // Deprecate sources
  if ('sources' in build) {
    _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('sources') } attribute is no longer supported. Use environment variable ${ _libconfigbuildParserjs_strong('NODE_PATH') } instead`, 1);
  }
  // Deprecate targets
  if ('targets' in build) {
    _libconfigbuildParserjs_warn(_libconfigbuildParserjs_DEPRECATED_VERSION);
    build = build.targets;
  }
  // Support basic mode with single build target
  if (!Array.isArray(build)) build = [build];

  return build.reduce((build, buildTarget) => {
    // Deprecate old formats
    if ('js' in buildTarget || 'css' in buildTarget || 'html' in buildTarget || 'targets' in buildTarget) {
      _libconfigbuildParserjs_warn(_libconfigbuildParserjs_DEPRECATED_VERSION);
      return build;
    }
    // Deprecate aliases
    if (buildTarget.alias) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('alias') } attribute is no longer supported. Use package.json ${ _libconfigbuildParserjs_strong('browser') } field instead`, 1);
    // Deprecate modular
    if (buildTarget.modular) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('modular') } attribute has been renamed to ${ _libconfigbuildParserjs_strong('bundle') }`, 1);
    // Deprecate sources
    if (buildTarget.sources) _libconfigbuildParserjs_warn(`${ _libconfigbuildParserjs_strong('sources') } attribute is no longer supported. Use environment variable ${ _libconfigbuildParserjs_strong('NODE_PATH') } instead`, 1);

    if (buildTarget.bootstrap == null) buildTarget.bootstrap = true;
    if (buildTarget.label == null) buildTarget.label = '';
    if (buildTarget.bundle == null || buildTarget.modular) buildTarget.bundle = true;
    buildTarget.hasChildren = false;
    buildTarget.hasParent = !!parent;
    buildTarget.index = ++_libconfigbuildParserjs_numBuildTargets;
    buildTarget.caches = caches;
    buildTarget.runtimeOptions = runtimeOptions;
    buildTarget.watchOnly = !buildTarget.output;
    if (!buildTarget.hasParent) {
      let globalAliases = {};

      if (buildTarget.resolve) {
        globalAliases = buildTarget.resolve;
        delete buildTarget.resolve;
      }

      let pluginOptions = buildTarget.options || {};

      // Generate Babel options based on 'options' and target 'version'
      // Any versions that indicate server as target will return 'false'
      buildTarget.browser = _libconfigbuildParserjs_pluginLoader.loadBuildPlugins(pluginOptions, buildTarget.version);

      let fileFactoryOptions = { caches, fileExtensions, globalAliases, npmModulepaths, pluginOptions, runtimeOptions };

      // Create fileFactory function with memoized options
      fileFactoryOptions.fileFactory = function createFile(filepath) {
        return fileFactory(filepath, fileFactoryOptions);
      };

      buildTarget.fileFactory = fileFactoryOptions.fileFactory;
    } else {
      // options/version only valid for root parent build targets
      if (buildTarget.options || buildTarget.version) _libconfigbuildParserjs_warn("child build targets inherit their root parent 'version' and 'options'");
      buildTarget.browser = parent.browser;
      buildTarget.fileFactory = parent.fileFactory;
    }
    delete buildTarget.options;
    delete buildTarget.version;

    _libconfigbuildParserjs_parseInputOutput(buildTarget, fileExtensions, runtimeOptions);
    // Ignore build targets with nulled input (no grep match)
    if ('input' in buildTarget && buildTarget.input != null) {
      // Flag as app server target
      buildTarget.isAppServer = _libconfigbuildParserjs_isAppServer(buildTarget.inputpaths, server);
      // Store hooks
      if (buildTarget.before) buildTarget.before = _libconfigbuildParserjs_defineHook(buildTarget.before);
      if (buildTarget.afterEach) buildTarget.afterEach = _libconfigbuildParserjs_defineHook(buildTarget.afterEach);
      if (buildTarget.after) buildTarget.after = _libconfigbuildParserjs_defineHook(buildTarget.after);

      // Traverse child build targets
      if (buildTarget.build) {
        buildTarget.hasChildren = true;
        buildTarget.build = _libconfigbuildParserjs_parseBuild(buildTarget.build, caches, fileExtensions, fileFactory, npmModulepaths, runtimeOptions, server, buildTarget);
        _libconfigbuildParserjs_parseChildInputpaths(buildTarget);
      }
      build.push(buildTarget);
    }

    return build;
  }, []);
}

/**
 * Parse input/output path(s) for 'buildTarget'
 * @param {Object} buildTarget
 * @param {Object} fileExtensions
 * @param {Object} runtimeOptions
 */
function _libconfigbuildParserjs_parseInputOutput(buildTarget, fileExtensions, runtimeOptions) {
  let outputs, outputIsDirectory;

  // Parse output
  if (buildTarget.output) {
    outputs = buildTarget.output;

    if (!Array.isArray(outputs)) outputs = [outputs];

    // Use compressed if specified
    if (runtimeOptions.compress && 'output_compressed' in buildTarget) {
      let outputsCompressed = buildTarget.output_compressed;

      if (!Array.isArray(outputsCompressed)) outputsCompressed = [outputsCompressed];
      if (outputsCompressed.length != outputs.length) {
        throw Error(`total number of outputs (${ _libconfigbuildParserjs_strong(buildTarget.output) }) do not match total number of compressed outputs (${ _libconfigbuildParserjs_strong(buildTarget.output_compressed) })`);
      }
      outputs = outputsCompressed;
      buildTarget.output = buildTarget.output_compressed;
    }

    outputIsDirectory = outputs.length == 1 && !_libconfigbuildParserjs_path.extname(outputs[0]).length;
  } else {
    buildTarget.outputpaths = [];
  }

  // Parse input
  if (buildTarget.input) {
    let allFileExtensions = [];
    let inputs = buildTarget.input;
    let inputsRelative = [];

    // Gather all extensions to allow for easier filtering
    for (const type in fileExtensions) {
      allFileExtensions.push(...fileExtensions[type]);
    }

    if (!Array.isArray(inputs)) inputs = [inputs];

    buildTarget.inputpaths = inputs.reduce((inputs, input) => {
      // Expand glob pattern
      if (_libconfigbuildParserjs_RE_GLOB.test(input)) {
        inputs = inputs.concat(_libconfigbuildParserjs_glob(input, { matchBase: true }));
      } else {
        inputs.push(input);
      }
      return inputs;
    }, []).reduce((inputs, input) => {
      input = _libconfigbuildParserjs_path.resolve(input);
      // Expand directory
      if (!_libconfigbuildParserjs_path.extname(input).length) {
        // Batch mode will change output behaviour if dir -> dir
        buildTarget.batch = true;
        inputs = inputs.concat(_libconfigbuildParserjs_readdir(input, (resource, stat) => {
          const isFile = stat.isFile();

          // Capture relative path for dir -> dir
          if (isFile) inputsRelative.push(_libconfigbuildParserjs_path.relative(input, resource));
          return isFile;
        }));
      } else {
        inputs.push(input);
        inputsRelative.push(_libconfigbuildParserjs_path.basename(input));
      }
      return inputs;
    }, []).filter((input, idx) => {
      const extension = _libconfigbuildParserjs_path.extname(input).slice(1);
      let include = true;

      // Include/exclude if grepping
      if (runtimeOptions.grep) {
        include = buildTarget.label == runtimeOptions.grep || _libconfigbuildParserjs_match(input, runtimeOptions.grep, { matchBase: true });
        if (runtimeOptions.invert) include = !include;
      }
      // Exclude unknown files
      if (!allFileExtensions.includes(extension)) {
        include = false;
      }

      if (!include) inputsRelative.splice(idx, 1);
      return include;
    }).map(input => {
      const inputpath = _libconfigbuildParserjs_path.resolve(input);
      if (!_libconfigbuildParserjs_fs.existsSync(inputpath)) _libconfigbuildParserjs_warn(_libconfigbuildParserjs_strong(input) + ' doesn\'t exist', 1);
      return inputpath;
    });

    if (!buildTarget.inputpaths.length) {
      buildTarget.input = null;
      buildTarget.inputpaths = null;
      return;
    }

    if (outputs) {
      if (buildTarget.inputpaths.length != outputs.length && !outputIsDirectory) {
        throw Error(`unable to resolve inputs (${ _libconfigbuildParserjs_strong(buildTarget.input) }) with outputs (${ _libconfigbuildParserjs_strong(buildTarget[runtimeOptions.compress ? 'output_compressed' : 'output']) })`);
      }

      buildTarget.outputpaths = buildTarget.inputpaths.map((inputpath, idx) => {
        let outputpath = '';

        if (outputIsDirectory) {
          // Preserve relative paths when batching
          outputpath = _libconfigbuildParserjs_path.join(_libconfigbuildParserjs_path.resolve(outputs[0]), inputsRelative[idx]);
        } else {
          outputpath = _libconfigbuildParserjs_path.resolve(outputs[idx]);
        }

        const extension = _libconfigbuildParserjs_path.extname(outputpath);
        const type = _libconfigbuildParserjs_filetype(inputpath, fileExtensions);

        // Resolve missing extension
        if (!extension) outputpath += `.${ type }`;
        if (type != 'image' && extension != `.${ type }`) outputpath = outputpath.replace(extension, `.${ type }`);

        return outputpath;
      });
    }
  }
}

/**
 * Parse nested child input paths
 * @param {Object} buildTarget
 */
function _libconfigbuildParserjs_parseChildInputpaths(buildTarget) {
  function parse(build) {
    let inputpaths = [];

    build.forEach(buildTarget => {
      inputpaths = inputpaths.concat(buildTarget.inputpaths, buildTarget.build ? parse(buildTarget.build) : []);
    });

    return inputpaths;
  }

  buildTarget.childInputpaths = parse(buildTarget.build);
}

/**
 * Determine if 'inputpaths' contain server file
 * @param {Array} inputpaths
 * @param {Object} server
 * @returns {Boolean}
 */
function _libconfigbuildParserjs_isAppServer(inputpaths, server) {
  // Test if 'p' is in 'dirs'
  function contains(dirs, p) {
    if (!Array.isArray(dirs)) dirs = [dirs];
    return dirs.some(dir => {
      return _libconfigbuildParserjs_indir(dir, p);
    });
  }

  return server != undefined && server.file != undefined && contains(inputpaths, _libconfigbuildParserjs_path.resolve(server.file));
}

/**
 * Convert hook path or expression to Function
 * @param {String} hook
 * @returns {Function}
 */
function _libconfigbuildParserjs_defineHook(hook) {
  // Load file content if filepath
  if (_libconfigbuildParserjs_path.extname(hook) && (~hook.indexOf('/') || ~hook.indexOf(_libconfigbuildParserjs_path.sep))) {
    let hookpath;

    if (_libconfigbuildParserjs_fs.existsSync(hookpath = _libconfigbuildParserjs_path.resolve(hook))) {
      hook = _libconfigbuildParserjs_fs.readFileSync(hookpath, 'utf8');
    } else {
      throw Error('hook (' + _libconfigbuildParserjs_strong(hook) + ') isn\'t a valid path');
    }
  }

  return new Function('global', 'process', 'console', 'require', 'context', 'options', 'done', hook);
}
/*≠≠ lib/config/buildParser.js ≠≠*/

/*== lib/config/index.js ==*/
$m['lib/config/index.js'] = { exports: {} };
'use strict';

const { error: _libconfigindexjs_error, print: _libconfigindexjs_print, strong: _libconfigindexjs_strong, warn: _libconfigindexjs_warn } = $m['lib/utils/cnsl.js'].exports;
const { hunt: { sync: _libconfigindexjs_hunt } } = $m['recur-fs/index.js#2.2.3'].exports;
const { identify: _libconfigindexjs_identify } = $m['lib/dependency-resolver/index.js'].exports;
const _libconfigindexjs_buildParser = $m['lib/config/buildParser.js'].exports;
const _libconfigindexjs_dependencyResolverCache = $m['lib/dependency-resolver/cache.js'].exports;
const _libconfigindexjs_File = $m['lib/File.js'].exports;
const _libconfigindexjs_fileCache = $m['lib/config/fileCache.js'].exports;
const _libconfigindexjs_fs = require('fs');
const _libconfigindexjs_merge = $m['lodash/merge.js#4.15.0'].exports;
const _libconfigindexjs_path = require('path');
const _libconfigindexjs_pluginLoader = $m['lib/config/pluginLoader.js'].exports;
const _libconfigindexjs_utils = $m['lib/utils/index.js'].exports;

const _libconfigindexjs_DEFAULT_MANIFEST = {
  js: 'buddy.js',
  json: 'buddy.json',
  pkgjson: 'package.json'
};

/**
 * Retrieve new instance of Config
 * @param {String|Object} [configpath]
 * @param {Object} [runtimeOptions]
 * @returns {Config}
 */
$m['lib/config/index.js'].exports = function configFactory(configpath, runtimeOptions) {
  return new _libconfigindexjs_Config(configpath, runtimeOptions);
};

class _libconfigindexjs_Config {
  /**
   * Constructor
   * @param {String|Object} [configpath]
   * @param {Object} [runtimeOptions]
   */
  constructor(configpath, runtimeOptions) {
    let data;

    if ('string' == typeof configpath || configpath == null) {
      this.url = _libconfigindexjs_locateConfig(configpath);
      data = require(this.url);

      // Set current directory to location of file
      process.chdir(_libconfigindexjs_path.dirname(this.url));
      _libconfigindexjs_print('loaded config ' + _libconfigindexjs_strong(this.url), 0);

      // Passed in JSON object
    } else {
      this.url = '';
      data = configpath;
    }
    // Package.json
    if (data.buddy) data = data.buddy;
    // Handle super simple mode
    if (data.input) data = { build: [data] };

    this.build = [];
    this.fileDefinitionByExtension = {};
    this.fileExtensions = {};
    this.npmModulepaths = _libconfigindexjs_parseNpmModulepaths();
    this.runtimeOptions = _libconfigindexjs_merge({
      compress: false,
      deploy: false,
      grep: false,
      invert: false,
      reload: false,
      script: false,
      serve: false,
      watch: false,
      verbose: false
    }, runtimeOptions);
    this.script = '';
    this.server = {
      directory: '.',
      port: 8080
    };
    this.caches = {
      fileInstances: _libconfigindexjs_fileCache(this.runtimeOptions.watch),
      dependencyResolver: _libconfigindexjs_dependencyResolverCache,
      clear: _libconfigindexjs_dependencyResolverCache.clear
    };
    this.fileFactory = this.fileFactory.bind(this);

    // Merge config file data
    _libconfigindexjs_merge(this, data);

    // Load default/installed plugins
    // Generates fileExtensions/types used to validate build
    _libconfigindexjs_pluginLoader.loadPluginModules(this, _libconfigindexjs_parsePlugins(this));
    // Parse build data
    _libconfigindexjs_buildParser.parse(this);
  }

  /**
   * Retrieve File instance for 'filepath'
   * @param {String} filepath
   * @param {Object} options
   *  - {Object} caches
   *  - {Object} fileExtensions
   *  - {Function} fileFactory
   *  - {Object} globalAliases
   *  - {Array} npmModulepaths
   *  - {Object} pluginOptions
   *  - {Object} runtimeOptions
   * @returns {File}
   */
  fileFactory(filepath, options) {
    const { caches, fileExtensions, globalAliases } = options;

    // Retrieve cached
    if (caches.fileInstances.hasFile(filepath)) return caches.fileInstances.getFile(filepath);

    const extension = _libconfigindexjs_path.extname(filepath).slice(1);
    const id = _libconfigindexjs_identify(filepath, { fileExtensions, globalAliases });
    const ctor = this.fileDefinitionByExtension[extension];

    if (!id) throw Error(`unable to create file for: ${ _libconfigindexjs_strong(filepath) }`);

    const file = new ctor(id, filepath, options);

    caches.fileInstances.addFile(file);
    // Warn of multiple versions
    if (caches.dependencyResolver.hasMultipleVersions(id)) {
      _libconfigindexjs_warn(`more than one version of ${ _libconfigindexjs_strong(id.split('#')[0]) } exists (${ _libconfigindexjs_strong(file.relpath) })`, 3);
    }

    return file;
  }

  /**
   * Register file 'extensions' for 'type'
   * @param {Array} extensions
   * @param {String} type
   */
  registerFileExtensionsForType(extensions, type) {
    if (!this.fileExtensions[type]) this.fileExtensions[type] = [];
    this.fileExtensions[type].push(...extensions);
  }

  /**
   * Register target 'version' for 'type'
   * @param {String} version
   * @param {Array} plugins
   * @param {String} type
   */
  registerTargetVersionForType(version, plugins, type) {
    if (type == 'js') {
      _libconfigindexjs_pluginLoader.addPreset('babel', version, plugins);
    }
  }

  /**
   * Register file definitiion and 'extensions' for 'type'
   * @param {Function} define
   * @param {Array} extensions
   * @param {String} type
   */
  registerFileDefinitionAndExtensionsForType(define, extensions, type) {
    const def = define(this.fileDefinitionByExtension[type] || _libconfigindexjs_File, _libconfigindexjs_utils);

    if (extensions) {
      this.registerFileExtensionsForType(extensions, type);
      extensions.forEach(extension => {
        this.fileDefinitionByExtension[extension] = def;
      });
    }
  }

  /**
   * Extend file definitiion for 'extensions' or 'type'
   * @param {Function} extend
   * @param {Array} extensions
   * @param {String} type
   * @returns {null}
   */
  extendFileDefinitionForExtensionsOrType(extend, extensions, type) {
    const key = extensions ? extensions[0] : this.fileExtensions[type][0];
    const def = this.fileDefinitionByExtension[key];

    if (!def) return _libconfigindexjs_error(`no File type available for extension for ${ _libconfigindexjs_strong(key) }`);

    extend(def.prototype, _libconfigindexjs_utils);
  }

  /**
   * Destroy instance
   */
  destroy() {
    this.caches.fileInstances.flush();
    this.caches.dependencyResolver.clear();
  }
}

/**
 * Locate the configuration file
 * Walks the directory tree if no file/directory specified
 * @param {String} [url]
 * @returns {String}
 */
function _libconfigindexjs_locateConfig(url) {
  let configpath = '';

  function check(dir) {
    // Support js, json, and package.json
    const urljs = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.js);
    const urljson = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.json);
    const urlpkgjson = _libconfigindexjs_path.join(dir, _libconfigindexjs_DEFAULT_MANIFEST.pkgjson);
    let urlFinal;

    if (_libconfigindexjs_fs.existsSync(urlFinal = urljs) || _libconfigindexjs_fs.existsSync(urlFinal = urljson) || _libconfigindexjs_fs.existsSync(urlFinal = urlpkgjson)) {
      return urlFinal;
    }

    return '';
  }

  if (url) {
    configpath = _libconfigindexjs_path.resolve(url);
    try {
      // Try default file name if passed directory
      if (!_libconfigindexjs_path.extname(configpath).length || _libconfigindexjs_fs.statSync(configpath).isDirectory()) {
        configpath = check(configpath);
        if (!configpath) throw Error('no default found');
      }
    } catch (err) {
      throw Error(_libconfigindexjs_strong('buddy') + ' config not found in ' + _libconfigindexjs_strong(_libconfigindexjs_path.dirname(url)));
    }

    // No url specified
  } else {
    try {
      // Find the first instance of a DEFAULT file based on the current working directory
      configpath = _libconfigindexjs_hunt(process.cwd(), (resource, stat) => {
        if (stat.isFile()) {
          const basename = _libconfigindexjs_path.basename(resource);

          return basename == _libconfigindexjs_DEFAULT_MANIFEST.js || basename == _libconfigindexjs_DEFAULT_MANIFEST.json || basename == _libconfigindexjs_DEFAULT_MANIFEST.pkgjson;
        }
      }, true);
    } catch (err) {
      if (!configpath) throw Error(_libconfigindexjs_strong('buddy') + ' config not found');
    }
  }

  return configpath;
}

/**
 * Parse plugins defined in 'config'
 * @param {Config} config
 * @returns {Array}
 */
function _libconfigindexjs_parsePlugins(config) {
  let plugins = [];

  function parse(plugins) {
    return plugins.map(plugin => {
      if ('string' == typeof plugin) plugin = _libconfigindexjs_path.resolve(plugin);
      return plugin;
    });
  }

  // Handle plugin paths defined in config file
  if (config.plugins) {
    plugins.push(...parse(config.plugins));
    delete config.plugins;
  }
  // Handle plugin paths/functions defined in runtime options
  if (config.runtimeOptions.plugins) {
    plugins.push(...parse(config.runtimeOptions.plugins));
    delete config.runtimeOptions.plugins;
  }

  return plugins;
}

/**
 * Parse all npm package paths
 * @returns {Array}
 */
function _libconfigindexjs_parseNpmModulepaths() {
  const jsonpath = _libconfigindexjs_path.resolve('package.json');

  try {
    const json = require(jsonpath);

    return ['dependencies', 'devDependencies', 'optionalDependencies'].reduce((packages, type) => {
      if (type in json) {
        for (const dependency in json[type]) {
          packages.push(_libconfigindexjs_path.resolve('node_modules', dependency));
        }
      }
      return packages;
    }, []);
  } catch (err) {
    return [];
  }
}
/*≠≠ lib/config/index.js ≠≠*/

/*== node_modules/lodash/compact.js ==*/
$m['lodash/compact.js#4.15.0'] = { exports: {} };
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function _lodashcompactjs4150_compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

$m['lodash/compact.js#4.15.0'].exports = _lodashcompactjs4150_compact;
/*≠≠ node_modules/lodash/compact.js ≠≠*/

/*== node_modules/async/waterfall.js ==*/
$m['async/waterfall.js#2.0.1'] = { exports: {} };
'use strict';

Object.defineProperty($m['async/waterfall.js#2.0.1'].exports, "__esModule", {
    value: true
});

$m['async/waterfall.js#2.0.1'].exports.default = function (tasks, callback) {
    callback = (0, _asyncwaterfalljs201__once2.default)(callback || _asyncwaterfalljs201__noop2.default);
    if (!(0, _asyncwaterfalljs201__isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        if (taskIndex === tasks.length) {
            return callback.apply(null, [null].concat(args));
        }

        var taskCallback = (0, _asyncwaterfalljs201__onlyOnce2.default)((0, _asyncwaterfalljs201__rest2.default)(function (err, args) {
            if (err) {
                return callback.apply(null, [err].concat(args));
            }
            nextTask(args);
        }));

        args.push(taskCallback);

        var task = tasks[taskIndex++];
        task.apply(null, args);
    }

    nextTask([]);
};

var _asyncwaterfalljs201__isArray = $m['lodash/isArray.js#4.15.0'].exports;

var _asyncwaterfalljs201__isArray2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__isArray);

var _asyncwaterfalljs201__noop = $m['lodash/noop.js#4.15.0'].exports;

var _asyncwaterfalljs201__noop2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__noop);

var _asyncwaterfalljs201__once = $m['async/internal/once.js#2.0.1'].exports;

var _asyncwaterfalljs201__once2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__once);

var _asyncwaterfalljs201__rest = $m['lodash/rest.js#4.15.0'].exports;

var _asyncwaterfalljs201__rest2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__rest);

var _asyncwaterfalljs201__onlyOnce = $m['async/internal/onlyOnce.js#2.0.1'].exports;

var _asyncwaterfalljs201__onlyOnce2 = _asyncwaterfalljs201__interopRequireDefault(_asyncwaterfalljs201__onlyOnce);

function _asyncwaterfalljs201__interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

$m['async/waterfall.js#2.0.1'].exports = $m['async/waterfall.js#2.0.1'].exports['default'];

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of functions to run, each function is passed
 * a `callback(err, result1, result2, ...)` it must call on completion. The
 * first argument is an error (which can be `null`) and any further arguments
 * will be passed as arguments in order to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
/*≠≠ node_modules/async/waterfall.js ≠≠*/

/*== lib/utils/unique.js ==*/
$m['lib/utils/unique.js'] = { exports: {} };
'use strict';

const { regexpEscape: _libutilsuniquejs_regexpEscape } = $m['lib/utils/string.js'].exports;
const _libutilsuniquejs_fs = require('fs');
const _libutilsuniquejs_md5 = $m['md5/md5.js#2.2.1'].exports;
const _libutilsuniquejs_path = require('path');

const _libutilsuniquejs_RE_HASH_TOKEN = /%hash%/;
const _libutilsuniquejs_RE_TOKEN = /%(?:hash|date)%/;

$m['lib/utils/unique.js'].exports = {
  /**
   * Find file matching 'pattern'
   * @param {String} pattern
   * @returns {String}
   */
  find(pattern) {
    pattern = _libutilsuniquejs_path.resolve(pattern);

    // Limit scope to containing directory
    const dir = _libutilsuniquejs_path.dirname(pattern);
    let files, reToken;

    // Matches {hash} or {date}
    if (reToken = _libutilsuniquejs_RE_TOKEN.exec(pattern)) {
      try {
        files = _libutilsuniquejs_fs.readdirSync(dir);
      } catch (err) {
        // Directory doesn't exist
        return '';
      }

      // Generate regexp with pattern as wildcard
      const re = new RegExp(_libutilsuniquejs_regexpEscape(pattern).replace(reToken[0], _libutilsuniquejs_RE_HASH_TOKEN.test(pattern) ? '[a-f0-9]{32}' : '[0-9]{13,}'));

      for (let i = 0, n = files.length; i < n; i++) {
        const filepath = _libutilsuniquejs_path.resolve(dir, files[i]);

        if (re.test(filepath)) return filepath;
      }
    }

    return '';
  },

  /**
   * Generate unique filepath from 'pattern'
   * @param {String} pattern
   * @param {String|Boolean} content
   * @returns {String}
   */
  generate(pattern, content) {
    pattern = _libutilsuniquejs_path.resolve(pattern);

    let reToken, wildcard;

    if (reToken = _libutilsuniquejs_RE_TOKEN.exec(pattern)) {
      wildcard = reToken[0];
      if (wildcard == '%hash%') {
        // Remove if content == false
        pattern = pattern.replace(wildcard, content ? _libutilsuniquejs_md5(content) : '');
      } else if (wildcard == '%date%') {
        pattern = pattern.replace(wildcard, content ? Date.now() : '');
      }
    }

    return pattern;
  },

  /**
   * Determine whether 'pattern' is supported
   * @param {String} pattern
   * @returns {Boolean}
   */
  isUniquePattern(pattern) {
    return _libutilsuniquejs_RE_TOKEN.test(pattern);
  }
};
/*≠≠ lib/utils/unique.js ≠≠*/

/*== lib/utils/pathname.js ==*/
$m['lib/utils/pathname.js'] = { exports: {} };
'use strict';

const _libutilspathnamejs_path = require('path');

/**
 * Retrieve path name (dirname/filename) of 'p'
 * @param {String} p
 * @returns {String}
 */
$m['lib/utils/pathname.js'].exports = function pathname(p) {
  p = _libutilspathnamejs_path.resolve(p);

  let dir = _libutilspathnamejs_path.resolve(p, '..');

  if (dir == process.cwd()) dir = '.';

  return `${ _libutilspathnamejs_path.basename(dir) }/${ _libutilspathnamejs_path.basename(p) }`;
};
/*≠≠ lib/utils/pathname.js ≠≠*/

/*== lib/build.js ==*/
$m['lib/build.js'] = { exports: {} };
'use strict';

const { debug: _libbuildjs_debug, print: _libbuildjs_print, start: _libbuildjs_start, stop: _libbuildjs_stop, strong: _libbuildjs_strong, warn: _libbuildjs_warn } = $m['lib/utils/cnsl.js'].exports;
const _libbuildjs_callable = $m['lib/utils/callable.js'].exports;
const _libbuildjs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libbuildjs_distinct = $m['lodash/uniq.js#4.15.0'].exports;
const _libbuildjs_env = $m['lib/utils/env.js'].exports;
const _libbuildjs_flatten = $m['lodash/flatten.js#4.15.0'].exports;
const _libbuildjs_fs = require('fs');
const _libbuildjs_merge = $m['lodash/merge.js#4.15.0'].exports;
const _libbuildjs_parallel = $m['async/parallel.js#2.0.1'].exports;
const _libbuildjs_pathname = $m['lib/utils/pathname.js'].exports;
const _libbuildjs_series = $m['async/series.js#2.0.1'].exports;
const _libbuildjs_unique = $m['lib/utils/unique.js'].exports;
const _libbuildjs_waterfall = $m['async/waterfall.js#2.0.1'].exports;

const _libbuildjs_MAX_INPUT_STRING_LENGTH = 3;

/**
 * Build instance factory
 * @param {Object} props
 *  - {Boolean} bootstrap
 *  - {Object} build
 *  - {Boolean} bundle
 *  - {Object} caches
 *  - {Array} childInputpaths
 *  - {Function} fileFactory
 *  - {Boolean} hasChildren
 *  - {Boolean} hasParent
 *  - {Number} index
 *  - {String} input
 *  - {Array} inputpaths
 *  - {Boolean} isAppServer
 *  - {String} label
 *  - {String} output
 *  - {Array} outputpaths
 *  - {Object} runtimeOptions
 *  - {Boolean} watchOnly
 *  - {Boolean} writeableFilterFlag
 * @returns {Build}
 */
$m['lib/build.js'].exports = function buildFactory(props) {
  return new _libbuildjs_Build(props);
};

class _libbuildjs_Build {
  /**
   * Constructor
   * @param {Object} props
   *  - {Boolean} bootstrap
   *  - {Boolean} browser
   *  - {Object} build
   *  - {Boolean} bundle
   *  - {Object} caches
   *  - {Array} childInputpaths
   *  - {Function} fileFactory
   *  - {Boolean} hasChildren
   *  - {Boolean} hasParent
   *  - {Number} index
   *  - {String} input
   *  - {Array} inputpaths
   *  - {Boolean} isAppServer
   *  - {String} label
   *  - {String} output
   *  - {Array} outputpaths
   *  - {Object} runtimeOptions
   *  - {Boolean} watchOnly
   *  - {Boolean} writeableFilterFlag
   */
  constructor(props) {
    _libbuildjs_merge(this, props);
    this.id = this.label || this.index != null && this.index.toString();
    this.referencedFiles = [];
    this.processFilesOptions = {
      batch: !this.bundle && this.batch,
      // TODO: should only parent include?
      boilerplate: true,
      bootstrap: this.bootstrap,
      browser: this.browser,
      bundle: this.bundle,
      compress: this.runtimeOptions.compress,
      // TODO: include in child if watching?
      helpers: !this.hasParent && this.bundle,
      ignoredFiles: this.childInputpaths,
      watchOnly: this.watchOnly
    };

    // Handle printing long input arrays
    if (this.inputpaths.length > 1) {
      this.inputString = this.inputpaths.map(input => {
        return _libbuildjs_pathname(input);
      });
      // Trim long lists
      if (this.inputString.length > _libbuildjs_MAX_INPUT_STRING_LENGTH) {
        const remainder = this.inputString.length - _libbuildjs_MAX_INPUT_STRING_LENGTH;

        this.inputString = `${ this.inputString.slice(0, _libbuildjs_MAX_INPUT_STRING_LENGTH).join(', ') } ...and ${ remainder } other${ remainder > 1 ? 's' : '' }`;
      } else {
        this.inputString = this.inputString.join(', ');
      }
    } else {
      this.inputString = _libbuildjs_pathname(this.inputpaths[0]);
    }

    _libbuildjs_debug(`created Build instance with input: ${ _libbuildjs_strong(this.inputString) } and output: ${ _libbuildjs_strong(this.output) }`, 2);
  }

  /**
   * Run build
   * @param {Function} fn(err, results)
   * @returns {null}
   */
  run(fn) {
    // Skip if watch only and not running a watch build
    if (this.watchOnly && !this.runtimeOptions.watch) return fn();

    const timerID = this.inputpaths[0];
    const type = this.watchOnly && this.runtimeOptions.watch ? 'watching' : 'building';

    this.referencedFiles = [];

    _libbuildjs_start(timerID);

    _libbuildjs_print(`${ type } ${ _libbuildjs_strong(this.inputString) } ${ this.output ? 'to ' + _libbuildjs_strong(this.output) : '' }`, 1);

    _libbuildjs_waterfall([
    // Execute 'before' hook
    _libbuildjs_callable(this, 'executeHook', 'before', [this], this.inputpaths),
    // Init file instances
    _libbuildjs_callable(this, 'initFiles' /* , filepaths */),
    // Process files
    _libbuildjs_callable(this, 'processFiles' /* , files */),
    // Print
    _libbuildjs_callable(this, 'printProgress', timerID /* , referencedFiles */),
    // Execute 'afterEach' hooks
    _libbuildjs_callable(this, 'executeHook', 'afterEach' /* , referencedFiles */),
    // Build child targets
    _libbuildjs_callable(this, 'runChildren' /* , referencedFiles */),
    // Write files
    _libbuildjs_callable(this, 'writeFiles' /* , referencedFiles, childResults */),
    // Execute 'after' hook
    _libbuildjs_callable(this, 'executeHook', 'after', [this] /* , results */),
    // Reset
    _libbuildjs_callable(this, 'reset' /* , results */)], fn);
  }

  /**
   * Parse source 'filepaths'
   * @param {Array} filepaths
   * @param {Function} fn(err, files)
   */
  initFiles(filepaths, fn) {
    fn(null, filepaths.reduce((files, filepath) => {
      const file = this.fileFactory(filepath, this.fileFactoryOptions);

      if (!file) {
        _libbuildjs_warn(`${ _libbuildjs_strong(filepath) } not found in project source`, 4);
      } else {
        files.push(file);
      }
      return files;
    }, []));
  }

  /**
   * Process 'files'
   * @param {Array} files
   * @param {Function} fn(err, files)
   */
  processFiles(files, fn) {
    _libbuildjs_env('INPUT', files, this.id);
    _libbuildjs_env('INPUT_HASH', files, this.id);
    _libbuildjs_env('INPUT_DATE', files, this.id);

    _libbuildjs_parallel(files.map(file => _libbuildjs_callable(file, 'run', 'standard', this.processFilesOptions)), (err, results) => {
      if (err) return fn(err);
      this.referencedFiles = _libbuildjs_distinct(files.concat(_libbuildjs_flatten(results)));
      fn(null, this.referencedFiles);
    });
  }

  /**
   * Print progress
   * @param {String} timerID
   * @param {Array} files
   * @param {Function} fn(err, files)
   */
  printProgress(timerID, files, fn) {
    _libbuildjs_print('[processed ' + _libbuildjs_strong(files.length) + (files.length > 1 ? ' files' : ' file') + ' in ' + _libbuildjs_chalk.cyan(_libbuildjs_stop(timerID) + 'ms') + ']', 2);
    fn(null, files);
  }

  /**
   * Run child builds
   * @param {Array} files
   * @param {Function} fn(err, files, childResults)
   * @returns {null}
   */
  runChildren(files, fn) {
    if (!this.hasChildren) return fn(null, files, []);

    // Lock files to prevent inclusion in downstream targets
    this.lock(this.referencedFiles);
    _libbuildjs_series(this.build.map(build => _libbuildjs_callable(build, 'build')), (err, results) => {
      if (err) return fn(err);

      this.unlock(this.referencedFiles);
      fn(files, _libbuildjs_flatten(results || []));
    });
  }

  /**
   * Write content for 'files'
   * @param {Array} files
   * @param {Array} childResults
   * @param {Function} fn(err, results)
   */
  writeFiles(files, childResults, fn) {
    const writeable = files.filter(file => file.isWriteable(this.processFilesOptions.batch)).reduce((writeable, file) => {
      let filepath = '';

      for (let i = 0, n = this.inputpaths.length; i < n; i++) {
        if (this.inputpaths[i] == file.filepath) {
          filepath = this.outputpaths[i];
          break;
        }
      }

      // Don't write if no output path
      if (filepath) {
        // Handle generating unique paths
        if (_libbuildjs_unique.isUniquePattern(filepath)) {
          // Remove existing
          const existing = _libbuildjs_unique.find(filepath);

          if (existing && _libbuildjs_fs.existsSync(existing)) _libbuildjs_fs.unlinkSync(existing);

          // Generate unique path
          // Disable during watch otherwise css reloading won't work
          filepath = _libbuildjs_unique.generate(filepath, !this.runtimeOptions.watch ? file.content : false);
        }

        writeable.push(_libbuildjs_callable(file, 'write', filepath, this.processFilesOptions));
      }

      return writeable;
    }, []);

    // Results are [{ filepath, hash, date, helpers }]
    _libbuildjs_parallel(writeable, (err, results) => {
      if (err) return fn(err);

      _libbuildjs_env('OUTPUT', results.map(item => item.filepath), this.id);
      _libbuildjs_env('OUTPUT_HASH', results.map(item => item.hash), this.id);
      _libbuildjs_env('OUTPUT_DATE', results.map(item => item.date), this.id);

      fn(null, results.concat(childResults));
    });
  }

  /**
   * Reset referenced files
   * @param {Array} results
   * @param {Array} fn(err, results)
   */
  reset(results, fn) {
    this.referencedFiles.forEach(file => file.reset());
    this.caches.clear();
    fn(null, results);
  }

  /**
   * Set lock flag for 'files'
   * @param {Array} files
   */
  lock(files) {
    files.forEach(file => {
      file.isLocked = true;
    });
  }

  /**
   * Unset lock flag for 'files'
   * @param {Array} files
   */
  unlock(files) {
    files.forEach(file => {
      file.isLocked = false;
    });
  }

  /**
   * Determine if 'file' is a referenced file (child targets included)
   * @param {File} file
   * @returns {Boolean}
   */
  hasFile(file) {
    if (this.referencedFiles.includes(file)) return true;

    if (this.hasChildren) {
      for (let i = 0, n = this.build.length; i < n; i++) {
        if (this.build[i].hasFile(file)) return true;
      }
    }

    return false;
  }

  /**
   * Execute the 'hook' function for 'contexts'
   * @param {String} hook
   * @param {Array} contexts
   * @param {Object} [passthrough]
   * @param {Function} fn(err)
   * @returns {null}
   */
  executeHook(hook, contexts, passthrough, fn) {
    // Handle missing passthrough value
    if (!fn && 'function' == typeof passthrough) {
      fn = passthrough;
      passthrough = contexts;
    }
    if (!this[hook]) return fn(null, passthrough);

    _libbuildjs_print('executing ' + hook + ' hook...', 2);
    _libbuildjs_parallel(contexts.map(context => {
      // Make global objects available to the function
      return _libbuildjs_callable(this, hook, global, process, console, require, context, this.runtimeOptions);
    }), err => {
      fn(err, passthrough);
    });
  }
}
/*≠≠ lib/build.js ≠≠*/

/*== lib/buddy.js ==*/
$m['lib/buddy.js'] = { exports: {} };
'use strict';

const { spawn: _libbuddyjs_spawn } = require('child_process');
const _libbuddyjs_buildFactory = $m['lib/build.js'].exports;
const _libbuddyjs_callable = $m['lib/utils/callable.js'].exports;
const _libbuddyjs_chalk = $m['chalk/index.js#1.1.3'].exports;
const _libbuddyjs_cnsl = $m['lib/utils/cnsl.js'].exports;
const _libbuddyjs_compact = $m['lodash/compact.js#4.15.0'].exports;
const _libbuddyjs_configFactory = $m['lib/config/index.js'].exports;
const _libbuddyjs_flatten = $m['lodash/flatten.js#4.15.0'].exports;
const _libbuddyjs_path = require('path');
const _libbuddyjs_series = $m['async/series.js#2.0.1'].exports;

const { BELL: _libbuddyjs_BELL, debug: _libbuddyjs_debug, error: _libbuddyjs_error, print: _libbuddyjs_print, start: _libbuddyjs_start, stop: _libbuddyjs_stop, strong: _libbuddyjs_strong } = _libbuddyjs_cnsl;
let _libbuddyjs_serverfarm = null;

/**
 * Buddy instance factory
 * @param {String|Object} configpath [file name | JSON Object]
 * @param {Object} options
 * @returns {Buddy}
 */
module.exports = function buddyFactory(configpath, options) {
  return new _libbuddyjs_Buddy(configpath, options);
};

class _libbuddyjs_Buddy {
  /**
   * Constructor
   * Initialize based on configuration located at 'configpath'
   * The directory tree will be walked if no 'configpath' specified
   * @param {String|Object} configpath [file name | JSON Object]
   * @param {Object} runtimeOptions
   */
  constructor(configpath, runtimeOptions = {}) {
    // Set console behaviour
    _libbuddyjs_cnsl.verbose = runtimeOptions.verbose;

    this.building = false;
    this.config = _libbuddyjs_configFactory(configpath, runtimeOptions);
    this.onFileCacheChange = this.onFileCacheChange.bind(this);

    // Setup watch
    if (this.config.runtimeOptions.watch) {
      this.config.caches.fileInstances.on('change', this.onFileCacheChange);
      // TODO: add error listener
    }

    // Initialize builds
    this.builds = this.initBuilds(this.config);
  }

  /**
   * Build sources based on build targets specified in config
   * @param {Function} fn
   */
  build(fn) {
    _libbuddyjs_start('build');

    // Build targets
    this.run(this.builds, (err, results) => {
      if (err) return fn ? fn(err) : _libbuddyjs_error(err, 2);
      _libbuddyjs_print(`completed build in ${ _libbuddyjs_chalk.cyan(_libbuddyjs_stop('build') / 1000 + 's') }`, 1);
      // Run script
      this.executeScript();
      if (fn) fn(null, results.map(result => result.filepath));
    });
  }

  /**
   * Build sources and watch for changes
   * @param {Function} fn
   */
  watch(fn) {
    // Build first
    this.build((err, results) => {
      if (err) return fn ? fn(err) : _libbuddyjs_error(err, 2);

      if (this.config.runtimeOptions.reload || this.config.runtimeOptions.serve) {
        // Protect against uninstalled add-on
        try {
          // Hide from buddy parsing
          _libbuddyjs_serverfarm = $m['lib/utils/index.js'].exports;
        } catch (tryError) {
          return _libbuddyjs_error('buddy-server add-on missing. Install \'buddy-server\' with npm', 2, true);
        }
        // Start servers
        _libbuddyjs_serverfarm.start(this.config.runtimeOptions.serve, this.config.runtimeOptions.reload, this.config.server, serverError => {
          if (serverError) {/* Ignore and keep watching */}
        });
      } else {
        _libbuddyjs_print('watching files for changes:', 1);
      }
    });
  }

  /**
   * Cleanup after unhandled exception
   */
  exceptionalCleanup() {
    if (_libbuddyjs_serverfarm) _libbuddyjs_serverfarm.stop();
  }

  /**
   * Reset
   */
  destroy() {
    this.exceptionalCleanup();
    this.config.destroy();

    this.config = null;
    this.builds = [];
  }

  /**
   * Recursively initialize all valid build instances specified in configuration
   * @param {Options} config
   * @returns {Array}
   */
  initBuilds(config) {
    function init(builds) {
      return builds.map(build => {
        const instance = _libbuddyjs_buildFactory(build);

        // Traverse
        if (instance.hasChildren) instance.build = init(instance.build);
        return instance;
      });
    }

    return init(config.build);
  }

  /**
   * Run all build targets
   * @param {Array} builds
   * @param {Function} fn(err, results)
   */
  run(builds, fn) {
    this.building = true;

    // Execute builds in sequence
    _libbuddyjs_series(builds.map(build => _libbuddyjs_callable(build, 'run')), (err, results) => {
      if (err) return fn(err);

      this.building = false;
      fn(null, _libbuddyjs_compact(_libbuddyjs_flatten(results)));
    });
  }

  /**
   * Run the script defined in config 'script'
   */
  executeScript() {
    let hasErrored = false;
    let args, command, script;

    if (this.config.runtimeOptions.script && (script = this.config.script)) {
      script = script.split(' ');
      command = script.shift();
      args = script;

      _libbuddyjs_print('executing script...', 1);
      _libbuddyjs_debug(`execute: ${ _libbuddyjs_strong(this.config.script) }`, 3);

      script = _libbuddyjs_spawn(command, args, { cwd: process.cwd() });

      script.stdout.on('data', data => {
        process.stdout.write(data.toString());
      });

      script.stderr.on('data', data => {
        process.stderr.write(data.toString());
        hasErrored = true;
      });

      script.on('close', code => {
        if (hasErrored) process.stderr.write(_libbuddyjs_BELL);
      });
    }
  }

  /**
   * Handle cache changes
   * @param {File} file
   */
  onFileCacheChange(file) {
    const now = new Date();
    const builds = this.builds.filter(build => build.hasFile(file));
    // Determine if any changes to app server code that needs a restart
    const servers = builds.filter(build => build.isAppServer);

    if (!this.building) {
      _libbuddyjs_print(`[${ now.toLocaleTimeString() }] ${ _libbuddyjs_chalk.yellow('changed') } ${ _libbuddyjs_strong(_libbuddyjs_path.relative(process.cwd(), file.filepath)) }`, 1);

      _libbuddyjs_start('watch');

      this.run(builds, (err, filepaths) => {
        // Don't throw
        if (err) return _libbuddyjs_error(err, 2, false);
        if (_libbuddyjs_serverfarm) {
          // Trigger partial refresh if only 1 css file, full reload if not
          const filepath = filepaths.length == 1 && _libbuddyjs_path.extname(filepaths[0]) == '.css' ? filepaths[0] : 'foo.js';

          // Refresh browser
          if (!servers.length) return _libbuddyjs_serverfarm.refresh(_libbuddyjs_path.basename(filepath));

          // Restart app server
          _libbuddyjs_serverfarm.restart(err => {
            if (err) {} /* ignore */
            // Refresh browser
            _libbuddyjs_serverfarm.refresh(_libbuddyjs_path.basename(filepath));
          });
        }
        _libbuddyjs_print(`completed build in ${ _libbuddyjs_chalk.cyan(_libbuddyjs_stop('watch') / 1000 + 's') }`, 1);
        // Run test script
        this.executeScript();
      });
    }
  }
}
/*≠≠ lib/buddy.js ≠≠*/